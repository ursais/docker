{"ast":null,"code":"import _Date$now from \"@babel/runtime-corejs3/core-js-stable/date/now\";import _Array$from from \"@babel/runtime-corejs3/core-js-stable/array/from\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";import _reduceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/reduce\";import _sliceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/slice\";import _Set from \"@babel/runtime-corejs3/core-js-stable/set\";import _Object$values from \"@babel/runtime-corejs3/core-js-stable/object/values\";import _Object$keys from \"@babel/runtime-corejs3/core-js-stable/object/keys\";import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";import _keyBy from \"lodash/keyBy\";import _isString from \"lodash/isString\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport {\nBehavior,\nCategoricalColorNamespace,\ngetChartMetadataRegistry } from\n'@superset-ui/core';\n\nimport { chart } from 'src/chart/chartReducer';\nimport { initSliceEntities } from 'src/dashboard/reducers/sliceEntities';\nimport { getInitialState as getInitialNativeFilterState } from 'src/dashboard/reducers/nativeFilters';\nimport { applyDefaultFormData } from 'src/explore/store';\nimport { buildActiveFilters } from 'src/dashboard/util/activeDashboardFilters';\nimport findPermission, {\ncanUserEditDashboard } from\n'src/dashboard/util/findPermission';\nimport {\nDASHBOARD_FILTER_SCOPE_GLOBAL,\ndashboardFilter } from\n'src/dashboard/reducers/dashboardFilters';\nimport {\nDASHBOARD_HEADER_ID,\nGRID_DEFAULT_CHART_WIDTH,\nGRID_COLUMN_COUNT,\nDASHBOARD_ROOT_ID } from\n'src/dashboard/util/constants';\nimport {\nDASHBOARD_HEADER_TYPE,\nCHART_TYPE,\nROW_TYPE } from\n'src/dashboard/util/componentTypes';\nimport findFirstParentContainerId from 'src/dashboard/util/findFirstParentContainer';\nimport getEmptyLayout from 'src/dashboard/util/getEmptyLayout';\nimport getFilterConfigsFromFormdata from 'src/dashboard/util/getFilterConfigsFromFormdata';\nimport getLocationHash from 'src/dashboard/util/getLocationHash';\nimport newComponentFactory from 'src/dashboard/util/newComponentFactory';\nimport { TIME_RANGE } from 'src/visualizations/FilterBox/FilterBox';\nimport { URL_PARAMS } from 'src/constants';\nimport { getUrlParam } from 'src/utils/urlUtils';\nimport { FeatureFlag, isFeatureEnabled } from '../../featureFlags';\nimport extractUrlParams from '../util/extractUrlParams';\n\nexport const HYDRATE_DASHBOARD = 'HYDRATE_DASHBOARD';\n\nexport const hydrateDashboard = (dashboardData, chartData, datasourcesData) => (\ndispatch,\ngetState) =>\n{var _metadata, _context2, _metadata2, _metadata3, _metadata4, _dashboardData$metada, _dashboardData$metada2, _metadata5, _metadata6, _metadata7, _metadata8;\n  const { user, common } = getState();\n  let { metadata } = dashboardData;\n  const regularUrlParams = extractUrlParams('regular');\n  const reservedUrlParams = extractUrlParams('reserved');\n  const editMode = reservedUrlParams.edit === 'true';\n\n  let preselectFilters = {};\n\n  _forEachInstanceProperty(chartData).call(chartData, chart => {\n    // eslint-disable-next-line no-param-reassign\n    chart.slice_id = chart.form_data.slice_id;\n  });\n  try {\n    // allow request parameter overwrite dashboard metadata\n    preselectFilters =\n    getUrlParam(URL_PARAMS.preselectFilters) ||\n    JSON.parse(metadata.default_filters);\n  } catch (e) {\n    //\n  }\n\n  // Priming the color palette with user's label-color mapping provided in\n  // the dashboard's JSON metadata\n  if ((_metadata = metadata) != null && _metadata.label_colors) {var _context;\n    const scheme = metadata.color_scheme;\n    const namespace = metadata.color_namespace;\n    const colorMap = _isString(metadata.label_colors) ?\n    JSON.parse(metadata.label_colors) :\n    metadata.label_colors;\n    _forEachInstanceProperty(_context = _Object$keys(colorMap)).call(_context, label => {\n      CategoricalColorNamespace.getScale(scheme, namespace).setColor(\n      label,\n      colorMap[label]);\n\n    });\n  }\n\n  // dashboard layout\n  const { position_data } = dashboardData;\n  // new dash: position_json could be {} or null\n  const layout =\n  position_data && _Object$keys(position_data).length > 0 ?\n  position_data :\n  getEmptyLayout();\n\n  // create a lookup to sync layout names with slice names\n  const chartIdToLayoutId = {};\n  _forEachInstanceProperty(_context2 = _Object$values(layout)).call(_context2, layoutComponent => {\n    if (layoutComponent.type === CHART_TYPE) {\n      chartIdToLayoutId[layoutComponent.meta.chartId] = layoutComponent.id;\n    }\n  });\n\n  // find root level chart container node for newly-added slices\n  const parentId = findFirstParentContainerId(layout);\n  const parent = layout[parentId];\n  let newSlicesContainer;\n  let newSlicesContainerWidth = 0;\n\n  const filterScopes = ((_metadata2 = metadata) == null ? void 0 : _metadata2.filter_scopes) || {};\n\n  const chartQueries = {};\n  const dashboardFilters = {};\n  const slices = {};\n  const sliceIds = new _Set();\n  _forEachInstanceProperty(chartData).call(chartData, slice => {\n    const key = slice.slice_id;\n    const form_data = {\n      ...slice.form_data,\n      url_params: {\n        ...slice.form_data.url_params,\n        ...regularUrlParams } };\n\n\n    chartQueries[key] = {\n      ...chart,\n      id: key,\n      form_data,\n      formData: applyDefaultFormData(form_data) };\n\n\n    slices[key] = {\n      slice_id: key,\n      slice_url: slice.slice_url,\n      slice_name: slice.slice_name,\n      form_data: slice.form_data,\n      viz_type: slice.form_data.viz_type,\n      datasource: slice.form_data.datasource,\n      description: slice.description,\n      description_markeddown: slice.description_markeddown,\n      owners: slice.owners,\n      modified: slice.modified,\n      changed_on: new Date(slice.changed_on).getTime() };\n\n\n    sliceIds.add(key);\n\n    // if there are newly added slices from explore view, fill slices into 1 or more rows\n    if (!chartIdToLayoutId[key] && layout[parentId]) {var _context4;\n      if (\n      newSlicesContainerWidth === 0 ||\n      newSlicesContainerWidth + GRID_DEFAULT_CHART_WIDTH > GRID_COLUMN_COUNT)\n      {var _context3;\n        newSlicesContainer = newComponentFactory(\n        ROW_TYPE,\n        _sliceInstanceProperty(_context3 = parent.parents || []).call(_context3));\n\n        layout[newSlicesContainer.id] = newSlicesContainer;\n        parent.children.push(newSlicesContainer.id);\n        newSlicesContainerWidth = 0;\n      }\n\n      const chartHolder = newComponentFactory(\n      CHART_TYPE,\n      {\n        chartId: slice.slice_id },\n\n      _sliceInstanceProperty(_context4 = newSlicesContainer.parents || []).call(_context4));\n\n\n      layout[chartHolder.id] = chartHolder;\n      newSlicesContainer.children.push(chartHolder.id);\n      chartIdToLayoutId[chartHolder.meta.chartId] = chartHolder.id;\n      newSlicesContainerWidth += GRID_DEFAULT_CHART_WIDTH;\n    }\n\n    // build DashboardFilters for interactive filter features\n    if (slice.form_data.viz_type === 'filter_box') {var _context6, _context7, _context8;\n      const configs = getFilterConfigsFromFormdata(slice.form_data);\n      let { columns } = configs;\n      const { labels } = configs;\n      if (preselectFilters[key]) {var _context5;\n        _forEachInstanceProperty(_context5 = _Object$keys(columns)).call(_context5, col => {\n          if (preselectFilters[key][col]) {\n            columns = {\n              ...columns,\n              [col]: preselectFilters[key][col] };\n\n          }\n        });\n      }\n\n      const scopesByChartId = _reduceInstanceProperty(_context6 = _Object$keys(columns)).call(_context6, (map, column) => {\n        const scopeSettings = {\n          ...filterScopes[key] };\n\n        const { scope, immune } = {\n          ...DASHBOARD_FILTER_SCOPE_GLOBAL,\n          ...scopeSettings[column] };\n\n\n        return {\n          ...map,\n          [column]: {\n            scope,\n            immune } };\n\n\n      }, {});\n\n      const componentId = chartIdToLayoutId[key];\n      const directPathToFilter = _sliceInstanceProperty(_context7 = layout[componentId].parents || []).call(_context7);\n      directPathToFilter.push(componentId);\n      dashboardFilters[key] = {\n        ...dashboardFilter,\n        chartId: key,\n        componentId,\n        datasourceId: slice.form_data.datasource,\n        filterName: slice.slice_name,\n        directPathToFilter,\n        columns,\n        labels,\n        scopes: scopesByChartId,\n        isInstantFilter: !!slice.form_data.instant_filtering,\n        isDateFilter: _includesInstanceProperty(_context8 = _Object$keys(columns)).call(_context8, TIME_RANGE) };\n\n    }\n\n    // sync layout names with current slice names in case a slice was edited\n    // in explore since the layout was updated. name updates go through layout for undo/redo\n    // functionality and python updates slice names based on layout upon dashboard save\n    const layoutId = chartIdToLayoutId[key];\n    if (layoutId && layout[layoutId]) {\n      layout[layoutId].meta.sliceName = slice.slice_name;\n    }\n  });\n  buildActiveFilters({\n    dashboardFilters,\n    components: layout });\n\n\n  // store the header as a layout component so we can undo/redo changes\n  layout[DASHBOARD_HEADER_ID] = {\n    id: DASHBOARD_HEADER_ID,\n    type: DASHBOARD_HEADER_TYPE,\n    meta: {\n      text: dashboardData.dashboard_title } };\n\n\n\n  const dashboardLayout = {\n    past: [],\n    present: layout,\n    future: [] };\n\n\n  // find direct link component and path from root\n  const directLinkComponentId = getLocationHash();\n  let directPathToChild = [];\n  if (layout[directLinkComponentId]) {var _context9;\n    directPathToChild = _sliceInstanceProperty(_context9 = layout[directLinkComponentId].parents || []).call(_context9);\n    directPathToChild.push(directLinkComponentId);\n  }\n\n  const nativeFilters = getInitialNativeFilterState({\n    filterConfig: ((_metadata3 = metadata) == null ? void 0 : _metadata3.native_filter_configuration) || [],\n    filterSetsConfig: ((_metadata4 = metadata) == null ? void 0 : _metadata4.filter_sets_configuration) || [] });\n\n\n  if (!metadata) {\n    metadata = {};\n  }\n\n  metadata.show_native_filters = (_dashboardData$metada =\n  dashboardData == null ? void 0 : (_dashboardData$metada2 = dashboardData.metadata) == null ? void 0 : _dashboardData$metada2.show_native_filters) != null ? _dashboardData$metada : true;\n\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {var _context10;\n    // If user just added cross filter to dashboard it's not saving it scope on server,\n    // so we tweak it until user will update scope and will save it in server\n    _forEachInstanceProperty(_context10 = _Object$values(dashboardLayout.present)).call(_context10, layoutItem => {var _layoutItem$meta, _behaviors, _ref, _getChartMetadataRegi, _chartQueries$chartId, _chartQueries$chartId2;\n      const chartId = (_layoutItem$meta = layoutItem.meta) == null ? void 0 : _layoutItem$meta.chartId;\n      const behaviors = (_behaviors = (_ref = (_getChartMetadataRegi =\n\n      getChartMetadataRegistry().get((_chartQueries$chartId =\n      chartQueries[chartId]) == null ? void 0 : (_chartQueries$chartId2 = _chartQueries$chartId.formData) == null ? void 0 : _chartQueries$chartId2.viz_type)) != null ? _getChartMetadataRegi :\n      {}) == null ? void 0 : _ref.\n      behaviors) != null ? _behaviors : [];\n\n      if (!metadata.chart_configuration) {\n        metadata.chart_configuration = {};\n      }\n      if (\n      _includesInstanceProperty(behaviors).call(behaviors, Behavior.INTERACTIVE_CHART) &&\n      !metadata.chart_configuration[chartId])\n      {\n        metadata.chart_configuration[chartId] = {\n          id: chartId,\n          crossFilters: {\n            scope: {\n              rootPath: [DASHBOARD_ROOT_ID],\n              excluded: [chartId] // By default it doesn't affects itself\n            } } };\n\n\n      }\n    });\n  }\n\n  const { roles } = user;\n  const canEdit = canUserEditDashboard(dashboardData, user);\n\n  return dispatch({\n    type: HYDRATE_DASHBOARD,\n    data: {\n      datasources: _keyBy(datasourcesData, 'uid'),\n      sliceEntities: { ...initSliceEntities, slices, isLoading: false },\n      charts: chartQueries,\n      // read-only data\n      dashboardInfo: {\n        ...dashboardData,\n        metadata,\n        userId: String(user.userId), // legacy, please use state.user instead\n        dash_edit_perm: canEdit,\n        dash_save_perm: findPermission('can_save_dash', 'Superset', roles),\n        dash_share_perm: findPermission(\n        'can_share_dashboard',\n        'Superset',\n        roles),\n\n        superset_can_explore: findPermission('can_explore', 'Superset', roles),\n        superset_can_share: findPermission(\n        'can_share_chart',\n        'Superset',\n        roles),\n\n        superset_can_csv: findPermission('can_csv', 'Superset', roles),\n        slice_can_edit: findPermission('can_slice', 'Superset', roles),\n        common: {\n          // legacy, please use state.common instead\n          flash_messages: common.flash_messages,\n          conf: common.conf } },\n\n\n      dashboardFilters,\n      nativeFilters,\n      dashboardState: {\n        sliceIds: _Array$from(sliceIds),\n        directPathToChild,\n        directPathLastUpdated: _Date$now(),\n        focusedFilterField: null,\n        expandedSlices: ((_metadata5 = metadata) == null ? void 0 : _metadata5.expanded_slices) || {},\n        refreshFrequency: ((_metadata6 = metadata) == null ? void 0 : _metadata6.refresh_frequency) || 0,\n        // dashboard viewers can set refresh frequency for the current visit,\n        // only persistent refreshFrequency will be saved to backend\n        shouldPersistRefreshFrequency: false,\n        css: dashboardData.css || '',\n        colorNamespace: ((_metadata7 = metadata) == null ? void 0 : _metadata7.color_namespace) || null,\n        colorScheme: ((_metadata8 = metadata) == null ? void 0 : _metadata8.color_scheme) || null,\n        editMode: canEdit && editMode,\n        isPublished: dashboardData.published,\n        hasUnsavedChanges: false,\n        maxUndoHistoryExceeded: false,\n        lastModifiedTime: dashboardData.changed_on,\n        activeTabs: [] },\n\n      dashboardLayout } });\n\n\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(HYDRATE_DASHBOARD, \"HYDRATE_DASHBOARD\", \"/app/superset-frontend/src/dashboard/actions/hydrate.js\");reactHotLoader.register(hydrateDashboard, \"hydrateDashboard\", \"/app/superset-frontend/src/dashboard/actions/hydrate.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/dashboard/actions/hydrate.js"],"names":["Behavior","CategoricalColorNamespace","getChartMetadataRegistry","chart","initSliceEntities","getInitialState","getInitialNativeFilterState","applyDefaultFormData","buildActiveFilters","findPermission","canUserEditDashboard","DASHBOARD_FILTER_SCOPE_GLOBAL","dashboardFilter","DASHBOARD_HEADER_ID","GRID_DEFAULT_CHART_WIDTH","GRID_COLUMN_COUNT","DASHBOARD_ROOT_ID","DASHBOARD_HEADER_TYPE","CHART_TYPE","ROW_TYPE","findFirstParentContainerId","getEmptyLayout","getFilterConfigsFromFormdata","getLocationHash","newComponentFactory","TIME_RANGE","URL_PARAMS","getUrlParam","FeatureFlag","isFeatureEnabled","extractUrlParams","HYDRATE_DASHBOARD","hydrateDashboard","dashboardData","chartData","datasourcesData","dispatch","getState","user","common","metadata","regularUrlParams","reservedUrlParams","editMode","edit","preselectFilters","slice_id","form_data","JSON","parse","default_filters","e","label_colors","scheme","color_scheme","namespace","color_namespace","colorMap","label","getScale","setColor","position_data","layout","length","chartIdToLayoutId","layoutComponent","type","meta","chartId","id","parentId","parent","newSlicesContainer","newSlicesContainerWidth","filterScopes","filter_scopes","chartQueries","dashboardFilters","slices","sliceIds","slice","key","url_params","formData","slice_url","slice_name","viz_type","datasource","description","description_markeddown","owners","modified","changed_on","Date","getTime","add","parents","children","push","chartHolder","configs","columns","labels","col","scopesByChartId","map","column","scopeSettings","scope","immune","componentId","directPathToFilter","datasourceId","filterName","scopes","isInstantFilter","instant_filtering","isDateFilter","layoutId","sliceName","components","text","dashboard_title","dashboardLayout","past","present","future","directLinkComponentId","directPathToChild","nativeFilters","filterConfig","native_filter_configuration","filterSetsConfig","filter_sets_configuration","show_native_filters","DASHBOARD_CROSS_FILTERS","layoutItem","behaviors","get","chart_configuration","INTERACTIVE_CHART","crossFilters","rootPath","excluded","roles","canEdit","data","datasources","sliceEntities","isLoading","charts","dashboardInfo","userId","String","dash_edit_perm","dash_save_perm","dash_share_perm","superset_can_explore","superset_can_share","superset_can_csv","slice_can_edit","flash_messages","conf","dashboardState","directPathLastUpdated","focusedFilterField","expandedSlices","expanded_slices","refreshFrequency","refresh_frequency","shouldPersistRefreshFrequency","css","colorNamespace","colorScheme","isPublished","published","hasUnsavedChanges","maxUndoHistoryExceeded","lastModifiedTime","activeTabs"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint-disable camelcase */\nimport { isString, keyBy } from 'lodash';\nimport {\n  Behavior,\n  CategoricalColorNamespace,\n  getChartMetadataRegistry,\n} from '@superset-ui/core';\n\nimport { chart } from 'src/chart/chartReducer';\nimport { initSliceEntities } from 'src/dashboard/reducers/sliceEntities';\nimport { getInitialState as getInitialNativeFilterState } from 'src/dashboard/reducers/nativeFilters';\nimport { applyDefaultFormData } from 'src/explore/store';\nimport { buildActiveFilters } from 'src/dashboard/util/activeDashboardFilters';\nimport findPermission, {\n  canUserEditDashboard,\n} from 'src/dashboard/util/findPermission';\nimport {\n  DASHBOARD_FILTER_SCOPE_GLOBAL,\n  dashboardFilter,\n} from 'src/dashboard/reducers/dashboardFilters';\nimport {\n  DASHBOARD_HEADER_ID,\n  GRID_DEFAULT_CHART_WIDTH,\n  GRID_COLUMN_COUNT,\n  DASHBOARD_ROOT_ID,\n} from 'src/dashboard/util/constants';\nimport {\n  DASHBOARD_HEADER_TYPE,\n  CHART_TYPE,\n  ROW_TYPE,\n} from 'src/dashboard/util/componentTypes';\nimport findFirstParentContainerId from 'src/dashboard/util/findFirstParentContainer';\nimport getEmptyLayout from 'src/dashboard/util/getEmptyLayout';\nimport getFilterConfigsFromFormdata from 'src/dashboard/util/getFilterConfigsFromFormdata';\nimport getLocationHash from 'src/dashboard/util/getLocationHash';\nimport newComponentFactory from 'src/dashboard/util/newComponentFactory';\nimport { TIME_RANGE } from 'src/visualizations/FilterBox/FilterBox';\nimport { URL_PARAMS } from 'src/constants';\nimport { getUrlParam } from 'src/utils/urlUtils';\nimport { FeatureFlag, isFeatureEnabled } from '../../featureFlags';\nimport extractUrlParams from '../util/extractUrlParams';\n\nexport const HYDRATE_DASHBOARD = 'HYDRATE_DASHBOARD';\n\nexport const hydrateDashboard = (dashboardData, chartData, datasourcesData) => (\n  dispatch,\n  getState,\n) => {\n  const { user, common } = getState();\n  let { metadata } = dashboardData;\n  const regularUrlParams = extractUrlParams('regular');\n  const reservedUrlParams = extractUrlParams('reserved');\n  const editMode = reservedUrlParams.edit === 'true';\n\n  let preselectFilters = {};\n\n  chartData.forEach(chart => {\n    // eslint-disable-next-line no-param-reassign\n    chart.slice_id = chart.form_data.slice_id;\n  });\n  try {\n    // allow request parameter overwrite dashboard metadata\n    preselectFilters =\n      getUrlParam(URL_PARAMS.preselectFilters) ||\n      JSON.parse(metadata.default_filters);\n  } catch (e) {\n    //\n  }\n\n  // Priming the color palette with user's label-color mapping provided in\n  // the dashboard's JSON metadata\n  if (metadata?.label_colors) {\n    const scheme = metadata.color_scheme;\n    const namespace = metadata.color_namespace;\n    const colorMap = isString(metadata.label_colors)\n      ? JSON.parse(metadata.label_colors)\n      : metadata.label_colors;\n    Object.keys(colorMap).forEach(label => {\n      CategoricalColorNamespace.getScale(scheme, namespace).setColor(\n        label,\n        colorMap[label],\n      );\n    });\n  }\n\n  // dashboard layout\n  const { position_data } = dashboardData;\n  // new dash: position_json could be {} or null\n  const layout =\n    position_data && Object.keys(position_data).length > 0\n      ? position_data\n      : getEmptyLayout();\n\n  // create a lookup to sync layout names with slice names\n  const chartIdToLayoutId = {};\n  Object.values(layout).forEach(layoutComponent => {\n    if (layoutComponent.type === CHART_TYPE) {\n      chartIdToLayoutId[layoutComponent.meta.chartId] = layoutComponent.id;\n    }\n  });\n\n  // find root level chart container node for newly-added slices\n  const parentId = findFirstParentContainerId(layout);\n  const parent = layout[parentId];\n  let newSlicesContainer;\n  let newSlicesContainerWidth = 0;\n\n  const filterScopes = metadata?.filter_scopes || {};\n\n  const chartQueries = {};\n  const dashboardFilters = {};\n  const slices = {};\n  const sliceIds = new Set();\n  chartData.forEach(slice => {\n    const key = slice.slice_id;\n    const form_data = {\n      ...slice.form_data,\n      url_params: {\n        ...slice.form_data.url_params,\n        ...regularUrlParams,\n      },\n    };\n    chartQueries[key] = {\n      ...chart,\n      id: key,\n      form_data,\n      formData: applyDefaultFormData(form_data),\n    };\n\n    slices[key] = {\n      slice_id: key,\n      slice_url: slice.slice_url,\n      slice_name: slice.slice_name,\n      form_data: slice.form_data,\n      viz_type: slice.form_data.viz_type,\n      datasource: slice.form_data.datasource,\n      description: slice.description,\n      description_markeddown: slice.description_markeddown,\n      owners: slice.owners,\n      modified: slice.modified,\n      changed_on: new Date(slice.changed_on).getTime(),\n    };\n\n    sliceIds.add(key);\n\n    // if there are newly added slices from explore view, fill slices into 1 or more rows\n    if (!chartIdToLayoutId[key] && layout[parentId]) {\n      if (\n        newSlicesContainerWidth === 0 ||\n        newSlicesContainerWidth + GRID_DEFAULT_CHART_WIDTH > GRID_COLUMN_COUNT\n      ) {\n        newSlicesContainer = newComponentFactory(\n          ROW_TYPE,\n          (parent.parents || []).slice(),\n        );\n        layout[newSlicesContainer.id] = newSlicesContainer;\n        parent.children.push(newSlicesContainer.id);\n        newSlicesContainerWidth = 0;\n      }\n\n      const chartHolder = newComponentFactory(\n        CHART_TYPE,\n        {\n          chartId: slice.slice_id,\n        },\n        (newSlicesContainer.parents || []).slice(),\n      );\n\n      layout[chartHolder.id] = chartHolder;\n      newSlicesContainer.children.push(chartHolder.id);\n      chartIdToLayoutId[chartHolder.meta.chartId] = chartHolder.id;\n      newSlicesContainerWidth += GRID_DEFAULT_CHART_WIDTH;\n    }\n\n    // build DashboardFilters for interactive filter features\n    if (slice.form_data.viz_type === 'filter_box') {\n      const configs = getFilterConfigsFromFormdata(slice.form_data);\n      let { columns } = configs;\n      const { labels } = configs;\n      if (preselectFilters[key]) {\n        Object.keys(columns).forEach(col => {\n          if (preselectFilters[key][col]) {\n            columns = {\n              ...columns,\n              [col]: preselectFilters[key][col],\n            };\n          }\n        });\n      }\n\n      const scopesByChartId = Object.keys(columns).reduce((map, column) => {\n        const scopeSettings = {\n          ...filterScopes[key],\n        };\n        const { scope, immune } = {\n          ...DASHBOARD_FILTER_SCOPE_GLOBAL,\n          ...scopeSettings[column],\n        };\n\n        return {\n          ...map,\n          [column]: {\n            scope,\n            immune,\n          },\n        };\n      }, {});\n\n      const componentId = chartIdToLayoutId[key];\n      const directPathToFilter = (layout[componentId].parents || []).slice();\n      directPathToFilter.push(componentId);\n      dashboardFilters[key] = {\n        ...dashboardFilter,\n        chartId: key,\n        componentId,\n        datasourceId: slice.form_data.datasource,\n        filterName: slice.slice_name,\n        directPathToFilter,\n        columns,\n        labels,\n        scopes: scopesByChartId,\n        isInstantFilter: !!slice.form_data.instant_filtering,\n        isDateFilter: Object.keys(columns).includes(TIME_RANGE),\n      };\n    }\n\n    // sync layout names with current slice names in case a slice was edited\n    // in explore since the layout was updated. name updates go through layout for undo/redo\n    // functionality and python updates slice names based on layout upon dashboard save\n    const layoutId = chartIdToLayoutId[key];\n    if (layoutId && layout[layoutId]) {\n      layout[layoutId].meta.sliceName = slice.slice_name;\n    }\n  });\n  buildActiveFilters({\n    dashboardFilters,\n    components: layout,\n  });\n\n  // store the header as a layout component so we can undo/redo changes\n  layout[DASHBOARD_HEADER_ID] = {\n    id: DASHBOARD_HEADER_ID,\n    type: DASHBOARD_HEADER_TYPE,\n    meta: {\n      text: dashboardData.dashboard_title,\n    },\n  };\n\n  const dashboardLayout = {\n    past: [],\n    present: layout,\n    future: [],\n  };\n\n  // find direct link component and path from root\n  const directLinkComponentId = getLocationHash();\n  let directPathToChild = [];\n  if (layout[directLinkComponentId]) {\n    directPathToChild = (layout[directLinkComponentId].parents || []).slice();\n    directPathToChild.push(directLinkComponentId);\n  }\n\n  const nativeFilters = getInitialNativeFilterState({\n    filterConfig: metadata?.native_filter_configuration || [],\n    filterSetsConfig: metadata?.filter_sets_configuration || [],\n  });\n\n  if (!metadata) {\n    metadata = {};\n  }\n\n  metadata.show_native_filters =\n    dashboardData?.metadata?.show_native_filters ?? true;\n\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n    // If user just added cross filter to dashboard it's not saving it scope on server,\n    // so we tweak it until user will update scope and will save it in server\n    Object.values(dashboardLayout.present).forEach(layoutItem => {\n      const chartId = layoutItem.meta?.chartId;\n      const behaviors =\n        (\n          getChartMetadataRegistry().get(\n            chartQueries[chartId]?.formData?.viz_type,\n          ) ?? {}\n        )?.behaviors ?? [];\n\n      if (!metadata.chart_configuration) {\n        metadata.chart_configuration = {};\n      }\n      if (\n        behaviors.includes(Behavior.INTERACTIVE_CHART) &&\n        !metadata.chart_configuration[chartId]\n      ) {\n        metadata.chart_configuration[chartId] = {\n          id: chartId,\n          crossFilters: {\n            scope: {\n              rootPath: [DASHBOARD_ROOT_ID],\n              excluded: [chartId], // By default it doesn't affects itself\n            },\n          },\n        };\n      }\n    });\n  }\n\n  const { roles } = user;\n  const canEdit = canUserEditDashboard(dashboardData, user);\n\n  return dispatch({\n    type: HYDRATE_DASHBOARD,\n    data: {\n      datasources: keyBy(datasourcesData, 'uid'),\n      sliceEntities: { ...initSliceEntities, slices, isLoading: false },\n      charts: chartQueries,\n      // read-only data\n      dashboardInfo: {\n        ...dashboardData,\n        metadata,\n        userId: String(user.userId), // legacy, please use state.user instead\n        dash_edit_perm: canEdit,\n        dash_save_perm: findPermission('can_save_dash', 'Superset', roles),\n        dash_share_perm: findPermission(\n          'can_share_dashboard',\n          'Superset',\n          roles,\n        ),\n        superset_can_explore: findPermission('can_explore', 'Superset', roles),\n        superset_can_share: findPermission(\n          'can_share_chart',\n          'Superset',\n          roles,\n        ),\n        superset_can_csv: findPermission('can_csv', 'Superset', roles),\n        slice_can_edit: findPermission('can_slice', 'Superset', roles),\n        common: {\n          // legacy, please use state.common instead\n          flash_messages: common.flash_messages,\n          conf: common.conf,\n        },\n      },\n      dashboardFilters,\n      nativeFilters,\n      dashboardState: {\n        sliceIds: Array.from(sliceIds),\n        directPathToChild,\n        directPathLastUpdated: Date.now(),\n        focusedFilterField: null,\n        expandedSlices: metadata?.expanded_slices || {},\n        refreshFrequency: metadata?.refresh_frequency || 0,\n        // dashboard viewers can set refresh frequency for the current visit,\n        // only persistent refreshFrequency will be saved to backend\n        shouldPersistRefreshFrequency: false,\n        css: dashboardData.css || '',\n        colorNamespace: metadata?.color_namespace || null,\n        colorScheme: metadata?.color_scheme || null,\n        editMode: canEdit && editMode,\n        isPublished: dashboardData.published,\n        hasUnsavedChanges: false,\n        maxUndoHistoryExceeded: false,\n        lastModifiedTime: dashboardData.changed_on,\n        activeTabs: [],\n      },\n      dashboardLayout,\n    },\n  });\n};\n"]},"metadata":{},"sourceType":"module"}