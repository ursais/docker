{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";import _findInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/find\";import _Object$entries from \"@babel/runtime-corejs3/core-js-stable/object/entries\";import _sortInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/sort\";import _Set from \"@babel/runtime-corejs3/core-js-stable/set\";import _Object$values from \"@babel/runtime-corejs3/core-js-stable/object/values\";import _filterInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/filter\";import _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import { CHART_TYPE, DASHBOARD_ROOT_TYPE, TAB_TYPE } from 'src/dashboard/util/componentTypes';\nimport { DASHBOARD_ROOT_ID } from 'src/dashboard/util/constants';\nexport const isShowTypeInTree = ({ type, meta }, charts) => {var _charts$meta$chartId, _charts$meta$chartId$;return (type === TAB_TYPE || type === CHART_TYPE || type === DASHBOARD_ROOT_TYPE) && (\n  !charts || ((_charts$meta$chartId = charts[meta == null ? void 0 : meta.chartId]) == null ? void 0 : (_charts$meta$chartId$ = _charts$meta$chartId.formData) == null ? void 0 : _charts$meta$chartId$.viz_type) !== 'filter_box');};\nexport const buildTree = (node, treeItem, layout, charts, validNodes) => {var _context;\n  let itemToPass = treeItem;\n  if (isShowTypeInTree(node, charts) &&\n  node.type !== DASHBOARD_ROOT_TYPE &&\n  _includesInstanceProperty(validNodes).call(validNodes, node.id)) {\n    const currentTreeItem = {\n      key: node.id,\n      title: node.meta.sliceNameOverride ||\n      node.meta.sliceName ||\n      node.meta.text ||\n      node.id.toString(),\n      children: [] };\n\n    treeItem.children.push(currentTreeItem);\n    itemToPass = currentTreeItem;\n  }\n  _forEachInstanceProperty(_context = node.children).call(_context, child => buildTree(layout[child], itemToPass, layout, charts, validNodes));\n};\nconst addInvisibleParents = (layout, item) => {var _layout$item, _context2, _context3;return [\n  ...(((_layout$item = layout[item]) == null ? void 0 : _layout$item.children) || []),\n  ..._mapInstanceProperty(_context2 = _filterInstanceProperty(_context3 = _Object$values(layout)).call(_context3,\n  val => val.parents &&\n  val.parents[val.parents.length - 1] === item &&\n  !isShowTypeInTree(layout[val.parents[val.parents.length - 1]]))).call(_context2,\n  ({ id }) => id)];};\n\n// Generate checked options for Ant tree from redux scope\nconst checkTreeItem = (checkedItems, layout, items, excluded) => {\n  _forEachInstanceProperty(items).call(items, item => {var _layout$item2, _layout$item3;\n    checkTreeItem(checkedItems, layout, addInvisibleParents(layout, item), excluded);\n    if (((_layout$item2 = layout[item]) == null ? void 0 : _layout$item2.type) === CHART_TYPE &&\n    !_includesInstanceProperty(excluded).call(excluded, (_layout$item3 = layout[item]) == null ? void 0 : _layout$item3.meta.chartId)) {\n      checkedItems.push(item);\n    }\n  });\n};\nexport const getTreeCheckedItems = (scope, layout) => {\n  const checkedItems = [];\n  checkTreeItem(checkedItems, layout, [...scope.rootPath], [...scope.excluded]);\n  return [...new _Set(checkedItems)];\n};\n// Looking for first common parent for selected charts/tabs/tab\nexport const findFilterScope = (checkedKeys, layout) => {var _context4, _context5;\n  if (!checkedKeys.length) {\n    return {\n      rootPath: [],\n      excluded: [] };\n\n  }\n  // Get arrays of parents for selected charts\n  const checkedItemParents = _mapInstanceProperty(_context4 = _filterInstanceProperty(checkedKeys).call(checkedKeys,\n  item => {var _layout$item4;return ((_layout$item4 = layout[item]) == null ? void 0 : _layout$item4.type) === CHART_TYPE;})).call(_context4,\n  key => {var _layout$key;\n    const parents = [DASHBOARD_ROOT_ID, ...(((_layout$key = layout[key]) == null ? void 0 : _layout$key.parents) || [])];\n    return _filterInstanceProperty(parents).call(parents, parent => isShowTypeInTree(layout[parent]));\n  });\n  // Sort arrays of parents to get first shortest array of parents,\n  // that means on it's level of parents located common parent, from this place parents start be different\n  _sortInstanceProperty(checkedItemParents).call(checkedItemParents, (p1, p2) => p1.length - p2.length);\n  const rootPath = _mapInstanceProperty(checkedItemParents).call(checkedItemParents, parents => parents[checkedItemParents[0].length - 1]);\n  const excluded = [];\n  const isExcluded = (parent, item) => _includesInstanceProperty(rootPath).call(rootPath, parent) && !_includesInstanceProperty(checkedKeys).call(checkedKeys, item);\n  // looking for charts to be excluded: iterate over all charts\n  // and looking for charts that have one of their parents in `rootPath` and not in selected items\n  _forEachInstanceProperty(_context5 = _Object$entries(layout)).call(_context5, ([key, value]) => {var _ref;\n    const parents = value.parents || [];\n    if (value.type === CHART_TYPE && (_ref =\n    [DASHBOARD_ROOT_ID, ...parents]) != null && _findInstanceProperty(_ref).call(_ref, parent => isExcluded(parent, key))) {\n      excluded.push(value.meta.chartId);\n    }\n  });\n  return {\n    rootPath: [...new _Set(rootPath)],\n    excluded };\n\n};\nexport const getDefaultScopeValue = chartId => ({\n  rootPath: [DASHBOARD_ROOT_ID],\n  excluded: chartId ? [chartId] : [] });\n\nexport const isScopingAll = (scope, chartId) => {var _context6;return !scope ||\n  scope.rootPath[0] === DASHBOARD_ROOT_ID &&\n  !_filterInstanceProperty(_context6 = scope.excluded).call(_context6, item => item !== chartId).length;};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(isShowTypeInTree, \"isShowTypeInTree\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils.ts\");reactHotLoader.register(buildTree, \"buildTree\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils.ts\");reactHotLoader.register(addInvisibleParents, \"addInvisibleParents\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils.ts\");reactHotLoader.register(checkTreeItem, \"checkTreeItem\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils.ts\");reactHotLoader.register(getTreeCheckedItems, \"getTreeCheckedItems\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils.ts\");reactHotLoader.register(findFilterScope, \"findFilterScope\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils.ts\");reactHotLoader.register(getDefaultScopeValue, \"getDefaultScopeValue\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils.ts\");reactHotLoader.register(isScopingAll, \"isScopingAll\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils.ts"],"names":[],"mappings":"kmCAmBA,SACE,UADF,EAEE,mBAFF,EAGE,QAHF,QAIO,mCAJP;AAKA,SAAS,iBAAT,QAAkC,8BAAlC;AAIA,OAAO,MAAM,gBAAgB,GAAG,CAAC,EAAE,IAAF,EAAQ,IAAR,EAAD,EAA6B,MAA7B,6DAC9B,CAAC,IAAI,KAAK,QAAT,IAAqB,IAAI,KAAK,UAA9B,IAA4C,IAAI,KAAK,mBAAtD;AACC,GAAC,MAAD,IAAW,yBAAA,MAAM,CAAC,IAAD,oBAAC,IAAI,CAAE,OAAP,CAAN,mEAAuB,QAAvB,2CAAiC,QAAjC,MAA8C,YAD1D,CAD8B,EAAzB;AAIP,OAAO,MAAM,SAAS,GAAG,CACvB,IADuB,EAEvB,QAFuB,EAGvB,MAHuB,EAIvB,MAJuB,EAKvB,UALuB,KAMrB;AACF,MAAI,UAAU,GAAa,QAA3B;AACA,MACE,gBAAgB,CAAC,IAAD,EAAO,MAAP,CAAhB;AACA,EAAA,IAAI,CAAC,IAAL,KAAc,mBADd;AAEA,4BAAA,UAAU,MAAV,CAAA,UAAU,EAAU,IAAI,CAAC,EAAf,CAHZ,EAIE;AACA,UAAM,eAAe,GAAG;AACtB,MAAA,GAAG,EAAE,IAAI,CAAC,EADY;AAEtB,MAAA,KAAK,EACH,IAAI,CAAC,IAAL,CAAU,iBAAV;AACA,MAAA,IAAI,CAAC,IAAL,CAAU,SADV;AAEA,MAAA,IAAI,CAAC,IAAL,CAAU,IAFV;AAGA,MAAA,IAAI,CAAC,EAAL,CAAQ,QAAR,EANoB;AAOtB,MAAA,QAAQ,EAAE,EAPY,EAAxB;;AASA,IAAA,QAAQ,CAAC,QAAT,CAAkB,IAAlB,CAAuB,eAAvB;AACA,IAAA,UAAU,GAAG,eAAb;AACD;AACD,sCAAA,IAAI,CAAC,QAAL,iBAAsB,KAAK,IACzB,SAAS,CAAC,MAAM,CAAC,KAAD,CAAP,EAAgB,UAAhB,EAA4B,MAA5B,EAAoC,MAApC,EAA4C,UAA5C,CADX;AAGD,CA5BM;AA8BP,MAAM,mBAAmB,GAAG,CAAC,MAAD,EAAiB,IAAjB,oDAAkC;AAC5D,MAAI,iBAAA,MAAM,CAAC,IAAD,CAAN,kCAAc,QAAd,KAA0B,EAA9B,CAD4D;AAE5D,KAAG,oFAAc,MAAd;AAEC,EAAA,GAAG,IACD,GAAG,CAAC,OAAJ;AACA,EAAA,GAAG,CAAC,OAAJ,CAAY,GAAG,CAAC,OAAJ,CAAY,MAAZ,GAAqB,CAAjC,MAAwC,IADxC;AAEA,GAAC,gBAAgB,CAAC,MAAM,CAAC,GAAG,CAAC,OAAJ,CAAY,GAAG,CAAC,OAAJ,CAAY,MAAZ,GAAqB,CAAjC,CAAD,CAAP,CALpB;AAOI,GAAC,EAAE,EAAF,EAAD,KAAY,EAPhB,CAFyD,CAAlC,EAA5B;;AAYA;AACA,MAAM,aAAa,GAAG,CACpB,YADoB,EAEpB,MAFoB,EAGpB,KAHoB,EAIpB,QAJoB,KAKlB;AACF,2BAAA,KAAK,MAAL,CAAA,KAAK,EAAS,IAAI,IAAG;AACnB,IAAA,aAAa,CACX,YADW,EAEX,MAFW,EAGX,mBAAmB,CAAC,MAAD,EAAS,IAAT,CAHR,EAIX,QAJW,CAAb;AAMA,QACE,kBAAA,MAAM,CAAC,IAAD,CAAN,mCAAc,IAAd,MAAuB,UAAvB;AACA,KAAC,0BAAA,QAAQ,MAAR,CAAA,QAAQ,mBAAU,MAAM,CAAC,IAAD,CAAhB,qBAAU,cAAc,IAAd,CAAmB,OAA7B,CAFX,EAGE;AACA,MAAA,YAAY,CAAC,IAAb,CAAkB,IAAlB;AACD;AACF,GAbI,CAAL;AAcD,CApBD;AAsBA,OAAO,MAAM,mBAAmB,GAAG,CAAC,KAAD,EAAe,MAAf,KAAiC;AAClE,QAAM,YAAY,GAAa,EAA/B;AACA,EAAA,aAAa,CAAC,YAAD,EAAe,MAAf,EAAuB,CAAC,GAAG,KAAK,CAAC,QAAV,CAAvB,EAA4C,CAAC,GAAG,KAAK,CAAC,QAAV,CAA5C,CAAb;AACA,SAAO,CAAC,GAAG,SAAQ,YAAR,CAAJ,CAAP;AACD,CAJM;AAMP;AACA,OAAO,MAAM,eAAe,GAAG,CAC7B,WAD6B,EAE7B,MAF6B,KAGpB;AACT,MAAI,CAAC,WAAW,CAAC,MAAjB,EAAyB;AACvB,WAAO;AACL,MAAA,QAAQ,EAAE,EADL;AAEL,MAAA,QAAQ,EAAE,EAFL,EAAP;;AAID;AAED;AACA,QAAM,kBAAkB,GAAG,yDAAA,WAAW,MAAX,CAAA,WAAW;AAC5B,EAAA,IAAI,8BAAI,kBAAA,MAAM,CAAC,IAAD,CAAN,mCAAc,IAAd,MAAuB,UAA3B,EADwB,CAAX;AAEpB,EAAA,GAAG,IAAG;AACT,UAAM,OAAO,GAAG,CAAC,iBAAD,EAAoB,IAAI,gBAAA,MAAM,CAAC,GAAD,CAAN,iCAAa,OAAb,KAAwB,EAA5B,CAApB,CAAhB;AACA,WAAO,wBAAA,OAAO,MAAP,CAAA,OAAO,EAAQ,MAAM,IAAI,gBAAgB,CAAC,MAAM,CAAC,MAAD,CAAP,CAAlC,CAAd;AACD,GALwB,CAA3B;AAMA;AACA;AACA,wBAAA,kBAAkB,MAAlB,CAAA,kBAAkB,EAAM,CAAC,EAAD,EAAK,EAAL,KAAY,EAAE,CAAC,MAAH,GAAY,EAAE,CAAC,MAAjC,CAAlB;AACA,QAAM,QAAQ,GAAG,qBAAA,kBAAkB,MAAlB,CAAA,kBAAkB,EACjC,OAAO,IAAI,OAAO,CAAC,kBAAkB,CAAC,CAAD,CAAlB,CAAsB,MAAtB,GAA+B,CAAhC,CADe,CAAnC;AAIA,QAAM,QAAQ,GAAa,EAA3B;AACA,QAAM,UAAU,GAAG,CAAC,MAAD,EAAiB,IAAjB,KACjB,0BAAA,QAAQ,MAAR,CAAA,QAAQ,EAAU,MAAV,CAAR,IAA6B,CAAC,0BAAA,WAAW,MAAX,CAAA,WAAW,EAAU,IAAV,CAD3C;AAEA;AACA;AACA,uDAAe,MAAf,mBAA+B,CAAC,CAAC,GAAD,EAAM,KAAN,CAAD,KAAiB;AAC9C,UAAM,OAAO,GAAG,KAAK,CAAC,OAAN,IAAiB,EAAjC;AACA,QACE,KAAK,CAAC,IAAN,KAAe,UAAf;AACA,KAAC,iBAAD,EAAoB,GAAG,OAAvB,CADA,aACA,uCAAsC,MAAM,IAAI,UAAU,CAAC,MAAD,EAAS,GAAT,CAA1D,CAFF,EAGE;AACA,MAAA,QAAQ,CAAC,IAAT,CAAc,KAAK,CAAC,IAAN,CAAW,OAAzB;AACD;AACF,GARD;AAUA,SAAO;AACL,IAAA,QAAQ,EAAE,CAAC,GAAG,SAAQ,QAAR,CAAJ,CADL;AAEL,IAAA,QAFK,EAAP;;AAID,CA5CM;AA8CP,OAAO,MAAM,oBAAoB,GAAI,OAAD,KAA8B;AAChE,EAAA,QAAQ,EAAE,CAAC,iBAAD,CADsD;AAEhE,EAAA,QAAQ,EAAE,OAAO,GAAG,CAAC,OAAD,CAAH,GAAe,EAFgC,EAA9B,CAA7B;;AAKP,OAAO,MAAM,YAAY,GAAG,CAAC,KAAD,EAAe,OAAf,2BAC1B,CAAC,KAAD;AACC,EAAA,KAAK,CAAC,QAAN,CAAe,CAAf,MAAsB,iBAAtB;AACC,GAAC,oCAAA,KAAK,CAAC,QAAN,kBAAsB,IAAI,IAAI,IAAI,KAAK,OAAvC,EAAgD,MAHzB,EAArB,C,iLA/HM,gB,yKAIA,S,kKA8BP,mB,4KAaA,a,sKAsBO,mB,4KAOA,e,wKA8CA,oB,6KAKA,Y","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { Charts, Layout, LayoutItem } from 'src/dashboard/types';\nimport {\n  CHART_TYPE,\n  DASHBOARD_ROOT_TYPE,\n  TAB_TYPE,\n} from 'src/dashboard/util/componentTypes';\nimport { DASHBOARD_ROOT_ID } from 'src/dashboard/util/constants';\nimport { TreeItem } from './types';\nimport { Scope } from '../../../types';\n\nexport const isShowTypeInTree = ({ type, meta }: LayoutItem, charts?: Charts) =>\n  (type === TAB_TYPE || type === CHART_TYPE || type === DASHBOARD_ROOT_TYPE) &&\n  (!charts || charts[meta?.chartId]?.formData?.viz_type !== 'filter_box');\n\nexport const buildTree = (\n  node: LayoutItem,\n  treeItem: TreeItem,\n  layout: Layout,\n  charts: Charts,\n  validNodes: string[],\n) => {\n  let itemToPass: TreeItem = treeItem;\n  if (\n    isShowTypeInTree(node, charts) &&\n    node.type !== DASHBOARD_ROOT_TYPE &&\n    validNodes.includes(node.id)\n  ) {\n    const currentTreeItem = {\n      key: node.id,\n      title:\n        node.meta.sliceNameOverride ||\n        node.meta.sliceName ||\n        node.meta.text ||\n        node.id.toString(),\n      children: [],\n    };\n    treeItem.children.push(currentTreeItem);\n    itemToPass = currentTreeItem;\n  }\n  node.children.forEach(child =>\n    buildTree(layout[child], itemToPass, layout, charts, validNodes),\n  );\n};\n\nconst addInvisibleParents = (layout: Layout, item: string) => [\n  ...(layout[item]?.children || []),\n  ...Object.values(layout)\n    .filter(\n      val =>\n        val.parents &&\n        val.parents[val.parents.length - 1] === item &&\n        !isShowTypeInTree(layout[val.parents[val.parents.length - 1]]),\n    )\n    .map(({ id }) => id),\n];\n\n// Generate checked options for Ant tree from redux scope\nconst checkTreeItem = (\n  checkedItems: string[],\n  layout: Layout,\n  items: string[],\n  excluded: number[],\n) => {\n  items.forEach(item => {\n    checkTreeItem(\n      checkedItems,\n      layout,\n      addInvisibleParents(layout, item),\n      excluded,\n    );\n    if (\n      layout[item]?.type === CHART_TYPE &&\n      !excluded.includes(layout[item]?.meta.chartId)\n    ) {\n      checkedItems.push(item);\n    }\n  });\n};\n\nexport const getTreeCheckedItems = (scope: Scope, layout: Layout) => {\n  const checkedItems: string[] = [];\n  checkTreeItem(checkedItems, layout, [...scope.rootPath], [...scope.excluded]);\n  return [...new Set(checkedItems)];\n};\n\n// Looking for first common parent for selected charts/tabs/tab\nexport const findFilterScope = (\n  checkedKeys: string[],\n  layout: Layout,\n): Scope => {\n  if (!checkedKeys.length) {\n    return {\n      rootPath: [],\n      excluded: [],\n    };\n  }\n\n  // Get arrays of parents for selected charts\n  const checkedItemParents = checkedKeys\n    .filter(item => layout[item]?.type === CHART_TYPE)\n    .map(key => {\n      const parents = [DASHBOARD_ROOT_ID, ...(layout[key]?.parents || [])];\n      return parents.filter(parent => isShowTypeInTree(layout[parent]));\n    });\n  // Sort arrays of parents to get first shortest array of parents,\n  // that means on it's level of parents located common parent, from this place parents start be different\n  checkedItemParents.sort((p1, p2) => p1.length - p2.length);\n  const rootPath = checkedItemParents.map(\n    parents => parents[checkedItemParents[0].length - 1],\n  );\n\n  const excluded: number[] = [];\n  const isExcluded = (parent: string, item: string) =>\n    rootPath.includes(parent) && !checkedKeys.includes(item);\n  // looking for charts to be excluded: iterate over all charts\n  // and looking for charts that have one of their parents in `rootPath` and not in selected items\n  Object.entries(layout).forEach(([key, value]) => {\n    const parents = value.parents || [];\n    if (\n      value.type === CHART_TYPE &&\n      [DASHBOARD_ROOT_ID, ...parents]?.find(parent => isExcluded(parent, key))\n    ) {\n      excluded.push(value.meta.chartId);\n    }\n  });\n\n  return {\n    rootPath: [...new Set(rootPath)],\n    excluded,\n  };\n};\n\nexport const getDefaultScopeValue = (chartId?: number): Scope => ({\n  rootPath: [DASHBOARD_ROOT_ID],\n  excluded: chartId ? [chartId] : [],\n});\n\nexport const isScopingAll = (scope: Scope, chartId?: number) =>\n  !scope ||\n  (scope.rootPath[0] === DASHBOARD_ROOT_ID &&\n    !scope.excluded.filter(item => item !== chartId).length);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}