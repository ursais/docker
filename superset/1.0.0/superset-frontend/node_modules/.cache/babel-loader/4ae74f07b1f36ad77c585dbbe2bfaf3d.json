{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";import _findInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/find\";import _Object$values from \"@babel/runtime-corejs3/core-js-stable/object/values\";import _filterInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/filter\";import _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";import _spliceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/splice\";import _indexOfInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/index-of\";import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\nDASHBOARD_ROOT_ID,\nDASHBOARD_GRID_ID,\nNEW_COMPONENTS_SOURCE_ID,\nDASHBOARD_HEADER_ID } from\n'../util/constants';\nimport componentIsResizable from '../util/componentIsResizable';\nimport findParentId from '../util/findParentId';\nimport getComponentWidthFromDrop from '../util/getComponentWidthFromDrop';\nimport updateComponentParentsList from '../util/updateComponentParentsList';\nimport newComponentFactory from '../util/newComponentFactory';\nimport newEntitiesFromDrop from '../util/newEntitiesFromDrop';\nimport reorderItem from '../util/dnd-reorder';\nimport shouldWrapChildInRow from '../util/shouldWrapChildInRow';\nimport { ROW_TYPE, TAB_TYPE, TABS_TYPE } from '../util/componentTypes';\n\nimport {\nUPDATE_COMPONENTS,\nUPDATE_COMPONENTS_PARENTS_LIST,\nDELETE_COMPONENT,\nCREATE_COMPONENT,\nMOVE_COMPONENT,\nCREATE_TOP_LEVEL_TABS,\nDELETE_TOP_LEVEL_TABS,\nDASHBOARD_TITLE_CHANGED } from\n'../actions/dashboardLayout';\n\nimport { HYDRATE_DASHBOARD } from '../actions/hydrate';\n\nconst actionHandlers = {\n  [HYDRATE_DASHBOARD](state, action) {\n    return {\n      ...action.data.dashboardLayout.present };\n\n  },\n\n  [UPDATE_COMPONENTS](state, action) {\n    const {\n      payload: { nextComponents } } =\n    action;\n    return {\n      ...state,\n      ...nextComponents };\n\n  },\n\n  [DELETE_COMPONENT](state, action) {\n    const {\n      payload: { id, parentId } } =\n    action;\n\n    if (!parentId || !id || !state[id] || !state[parentId]) return state;\n\n    const nextComponents = { ...state };\n\n    function recursivelyDeleteChildren(componentId, componentParentId) {\n      // delete child and it's children\n      const component = nextComponents[componentId];\n      delete nextComponents[componentId];\n\n      const { children = [] } = component;\n      _forEachInstanceProperty(children).call(children, childId => {\n        recursivelyDeleteChildren(childId, componentId);\n      });\n\n      const parent = nextComponents[componentParentId];\n      if (parent) {var _context;\n        // may have been deleted in another recursion\n        const componentIndex = _indexOfInstanceProperty(_context = parent.children || []).call(_context, componentId);\n        if (componentIndex > -1) {\n          const nextChildren = [...parent.children];\n          _spliceInstanceProperty(nextChildren).call(nextChildren, componentIndex, 1);\n          nextComponents[componentParentId] = {\n            ...parent,\n            children: nextChildren };\n\n        }\n      }\n    }\n\n    recursivelyDeleteChildren(id, parentId);\n    const nextParent = nextComponents[parentId];\n    if (nextParent.type === ROW_TYPE && nextParent.children.length === 0) {\n      const grandparentId = findParentId({\n        childId: parentId,\n        layout: nextComponents });\n\n      recursivelyDeleteChildren(parentId, grandparentId);\n    }\n\n    return nextComponents;\n  },\n\n  [CREATE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult } } =\n    action;\n\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n\n    return {\n      ...state,\n      ...newEntities };\n\n  },\n\n  [MOVE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult } } =\n    action;\n    const { source, destination, dragging } = dropResult;\n\n    if (!source || !destination || !dragging) return state;\n\n    const nextEntities = reorderItem({\n      entitiesMap: state,\n      source,\n      destination });\n\n\n    if (componentIsResizable(nextEntities[dragging.id])) {\n      // update component width if it changed\n      const nextWidth =\n      getComponentWidthFromDrop({\n        dropResult,\n        layout: state }) ||\n      undefined; // don't set a 0 width\n      if ((nextEntities[dragging.id].meta || {}).width !== nextWidth) {\n        nextEntities[dragging.id] = {\n          ...nextEntities[dragging.id],\n          meta: {\n            ...nextEntities[dragging.id].meta,\n            width: nextWidth } };\n\n\n      }\n    }\n\n    // wrap the dragged component in a row depending on destination type\n    const wrapInRow = shouldWrapChildInRow({\n      parentType: destination.type,\n      childType: dragging.type });\n\n\n    if (wrapInRow) {var _context2;\n      const destinationEntity = nextEntities[destination.id];\n      const destinationChildren = destinationEntity.children;\n      const newRow = newComponentFactory(ROW_TYPE);\n      newRow.children = [destinationChildren[destination.index]];\n      newRow.parents = _concatInstanceProperty(_context2 = destinationEntity.parents || []).call(_context2, destination.id);\n      destinationChildren[destination.index] = newRow.id;\n      nextEntities[newRow.id] = newRow;\n    }\n\n    return {\n      ...state,\n      ...nextEntities };\n\n  },\n\n  [CREATE_TOP_LEVEL_TABS](state, action) {\n    const {\n      payload: { dropResult } } =\n    action;\n    const { source, dragging } = dropResult;\n\n    // move children of current root to be children of the dragging tab\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelComponent = state[topLevelId];\n\n    if (source.id !== NEW_COMPONENTS_SOURCE_ID) {var _context3;\n      // component already exists\n      const draggingTabs = state[dragging.id];\n      const draggingTabId = draggingTabs.children[0];\n      const draggingTab = state[draggingTabId];\n\n      // move all children except the one that is dragging\n      const childrenToMove = _filterInstanceProperty(_context3 = [...topLevelComponent.children]).call(_context3,\n      id => id !== dragging.id);\n\n\n      return {\n        ...state,\n        [DASHBOARD_ROOT_ID]: {\n          ...rootComponent,\n          children: [dragging.id] },\n\n        [topLevelId]: {\n          ...topLevelComponent,\n          children: [] },\n\n        [draggingTabId]: {\n          ...draggingTab,\n          children: [...draggingTab.children, ...childrenToMove] } };\n\n\n    }\n\n    // create new component\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n    const newEntitiesArray = _Object$values(newEntities);\n    const tabComponent = _findInstanceProperty(newEntitiesArray).call(newEntitiesArray,\n    component => component.type === TAB_TYPE);\n\n    const tabsComponent = _findInstanceProperty(newEntitiesArray).call(newEntitiesArray,\n    component => component.type === TABS_TYPE);\n\n\n    tabComponent.children = [...topLevelComponent.children];\n    newEntities[topLevelId] = { ...topLevelComponent, children: [] };\n    newEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [tabsComponent.id] };\n\n\n    return {\n      ...state,\n      ...newEntities };\n\n  },\n\n  [DELETE_TOP_LEVEL_TABS](state) {var _context4;\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelTabs = state[topLevelId];\n\n    if (topLevelTabs.type !== TABS_TYPE) return state;\n\n    let childrenToMove = [];\n    const nextEntities = { ...state };\n\n    _forEachInstanceProperty(_context4 = topLevelTabs.children).call(_context4, tabId => {\n      const tabComponent = state[tabId];\n      childrenToMove = [...childrenToMove, ...tabComponent.children];\n      delete nextEntities[tabId];\n    });\n\n    delete nextEntities[topLevelId];\n\n    nextEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [DASHBOARD_GRID_ID] };\n\n\n    nextEntities[DASHBOARD_GRID_ID] = {\n      ...state[DASHBOARD_GRID_ID],\n      children: childrenToMove };\n\n\n    return nextEntities;\n  },\n\n  [UPDATE_COMPONENTS_PARENTS_LIST](state) {\n    const nextState = {\n      ...state };\n\n\n    updateComponentParentsList({\n      currentComponent: nextState[DASHBOARD_ROOT_ID],\n      layout: nextState });\n\n\n    return {\n      ...nextState };\n\n  },\n\n  [DASHBOARD_TITLE_CHANGED](state, action) {\n    return {\n      ...state,\n      [DASHBOARD_HEADER_ID]: {\n        ...state[DASHBOARD_HEADER_ID],\n        meta: {\n          ...state[DASHBOARD_HEADER_ID].meta,\n          text: action.text } } };\n\n\n\n  } };\n\n\nexport default function layoutReducer(state = {}, action) {\n  if (action.type in actionHandlers) {\n    const handler = actionHandlers[action.type];\n    return handler(state, action);\n  }\n\n  return state;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(actionHandlers, \"actionHandlers\", \"/app/superset-frontend/src/dashboard/reducers/dashboardLayout.js\");reactHotLoader.register(layoutReducer, \"layoutReducer\", \"/app/superset-frontend/src/dashboard/reducers/dashboardLayout.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/dashboard/reducers/dashboardLayout.js"],"names":["DASHBOARD_ROOT_ID","DASHBOARD_GRID_ID","NEW_COMPONENTS_SOURCE_ID","DASHBOARD_HEADER_ID","componentIsResizable","findParentId","getComponentWidthFromDrop","updateComponentParentsList","newComponentFactory","newEntitiesFromDrop","reorderItem","shouldWrapChildInRow","ROW_TYPE","TAB_TYPE","TABS_TYPE","UPDATE_COMPONENTS","UPDATE_COMPONENTS_PARENTS_LIST","DELETE_COMPONENT","CREATE_COMPONENT","MOVE_COMPONENT","CREATE_TOP_LEVEL_TABS","DELETE_TOP_LEVEL_TABS","DASHBOARD_TITLE_CHANGED","HYDRATE_DASHBOARD","actionHandlers","state","action","data","dashboardLayout","present","payload","nextComponents","id","parentId","recursivelyDeleteChildren","componentId","componentParentId","component","children","childId","parent","componentIndex","nextChildren","nextParent","type","length","grandparentId","layout","dropResult","newEntities","source","destination","dragging","nextEntities","entitiesMap","nextWidth","undefined","meta","width","wrapInRow","parentType","childType","destinationEntity","destinationChildren","newRow","index","parents","rootComponent","topLevelId","topLevelComponent","draggingTabs","draggingTabId","draggingTab","childrenToMove","newEntitiesArray","tabComponent","tabsComponent","topLevelTabs","tabId","nextState","currentComponent","text","layoutReducer","handler"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport {\n  DASHBOARD_ROOT_ID,\n  DASHBOARD_GRID_ID,\n  NEW_COMPONENTS_SOURCE_ID,\n  DASHBOARD_HEADER_ID,\n} from '../util/constants';\nimport componentIsResizable from '../util/componentIsResizable';\nimport findParentId from '../util/findParentId';\nimport getComponentWidthFromDrop from '../util/getComponentWidthFromDrop';\nimport updateComponentParentsList from '../util/updateComponentParentsList';\nimport newComponentFactory from '../util/newComponentFactory';\nimport newEntitiesFromDrop from '../util/newEntitiesFromDrop';\nimport reorderItem from '../util/dnd-reorder';\nimport shouldWrapChildInRow from '../util/shouldWrapChildInRow';\nimport { ROW_TYPE, TAB_TYPE, TABS_TYPE } from '../util/componentTypes';\n\nimport {\n  UPDATE_COMPONENTS,\n  UPDATE_COMPONENTS_PARENTS_LIST,\n  DELETE_COMPONENT,\n  CREATE_COMPONENT,\n  MOVE_COMPONENT,\n  CREATE_TOP_LEVEL_TABS,\n  DELETE_TOP_LEVEL_TABS,\n  DASHBOARD_TITLE_CHANGED,\n} from '../actions/dashboardLayout';\n\nimport { HYDRATE_DASHBOARD } from '../actions/hydrate';\n\nconst actionHandlers = {\n  [HYDRATE_DASHBOARD](state, action) {\n    return {\n      ...action.data.dashboardLayout.present,\n    };\n  },\n\n  [UPDATE_COMPONENTS](state, action) {\n    const {\n      payload: { nextComponents },\n    } = action;\n    return {\n      ...state,\n      ...nextComponents,\n    };\n  },\n\n  [DELETE_COMPONENT](state, action) {\n    const {\n      payload: { id, parentId },\n    } = action;\n\n    if (!parentId || !id || !state[id] || !state[parentId]) return state;\n\n    const nextComponents = { ...state };\n\n    function recursivelyDeleteChildren(componentId, componentParentId) {\n      // delete child and it's children\n      const component = nextComponents[componentId];\n      delete nextComponents[componentId];\n\n      const { children = [] } = component;\n      children.forEach(childId => {\n        recursivelyDeleteChildren(childId, componentId);\n      });\n\n      const parent = nextComponents[componentParentId];\n      if (parent) {\n        // may have been deleted in another recursion\n        const componentIndex = (parent.children || []).indexOf(componentId);\n        if (componentIndex > -1) {\n          const nextChildren = [...parent.children];\n          nextChildren.splice(componentIndex, 1);\n          nextComponents[componentParentId] = {\n            ...parent,\n            children: nextChildren,\n          };\n        }\n      }\n    }\n\n    recursivelyDeleteChildren(id, parentId);\n    const nextParent = nextComponents[parentId];\n    if (nextParent.type === ROW_TYPE && nextParent.children.length === 0) {\n      const grandparentId = findParentId({\n        childId: parentId,\n        layout: nextComponents,\n      });\n      recursivelyDeleteChildren(parentId, grandparentId);\n    }\n\n    return nextComponents;\n  },\n\n  [CREATE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult },\n    } = action;\n\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n\n    return {\n      ...state,\n      ...newEntities,\n    };\n  },\n\n  [MOVE_COMPONENT](state, action) {\n    const {\n      payload: { dropResult },\n    } = action;\n    const { source, destination, dragging } = dropResult;\n\n    if (!source || !destination || !dragging) return state;\n\n    const nextEntities = reorderItem({\n      entitiesMap: state,\n      source,\n      destination,\n    });\n\n    if (componentIsResizable(nextEntities[dragging.id])) {\n      // update component width if it changed\n      const nextWidth =\n        getComponentWidthFromDrop({\n          dropResult,\n          layout: state,\n        }) || undefined; // don't set a 0 width\n      if ((nextEntities[dragging.id].meta || {}).width !== nextWidth) {\n        nextEntities[dragging.id] = {\n          ...nextEntities[dragging.id],\n          meta: {\n            ...nextEntities[dragging.id].meta,\n            width: nextWidth,\n          },\n        };\n      }\n    }\n\n    // wrap the dragged component in a row depending on destination type\n    const wrapInRow = shouldWrapChildInRow({\n      parentType: destination.type,\n      childType: dragging.type,\n    });\n\n    if (wrapInRow) {\n      const destinationEntity = nextEntities[destination.id];\n      const destinationChildren = destinationEntity.children;\n      const newRow = newComponentFactory(ROW_TYPE);\n      newRow.children = [destinationChildren[destination.index]];\n      newRow.parents = (destinationEntity.parents || []).concat(destination.id);\n      destinationChildren[destination.index] = newRow.id;\n      nextEntities[newRow.id] = newRow;\n    }\n\n    return {\n      ...state,\n      ...nextEntities,\n    };\n  },\n\n  [CREATE_TOP_LEVEL_TABS](state, action) {\n    const {\n      payload: { dropResult },\n    } = action;\n    const { source, dragging } = dropResult;\n\n    // move children of current root to be children of the dragging tab\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelComponent = state[topLevelId];\n\n    if (source.id !== NEW_COMPONENTS_SOURCE_ID) {\n      // component already exists\n      const draggingTabs = state[dragging.id];\n      const draggingTabId = draggingTabs.children[0];\n      const draggingTab = state[draggingTabId];\n\n      // move all children except the one that is dragging\n      const childrenToMove = [...topLevelComponent.children].filter(\n        id => id !== dragging.id,\n      );\n\n      return {\n        ...state,\n        [DASHBOARD_ROOT_ID]: {\n          ...rootComponent,\n          children: [dragging.id],\n        },\n        [topLevelId]: {\n          ...topLevelComponent,\n          children: [],\n        },\n        [draggingTabId]: {\n          ...draggingTab,\n          children: [...draggingTab.children, ...childrenToMove],\n        },\n      };\n    }\n\n    // create new component\n    const newEntities = newEntitiesFromDrop({ dropResult, layout: state });\n    const newEntitiesArray = Object.values(newEntities);\n    const tabComponent = newEntitiesArray.find(\n      component => component.type === TAB_TYPE,\n    );\n    const tabsComponent = newEntitiesArray.find(\n      component => component.type === TABS_TYPE,\n    );\n\n    tabComponent.children = [...topLevelComponent.children];\n    newEntities[topLevelId] = { ...topLevelComponent, children: [] };\n    newEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [tabsComponent.id],\n    };\n\n    return {\n      ...state,\n      ...newEntities,\n    };\n  },\n\n  [DELETE_TOP_LEVEL_TABS](state) {\n    const rootComponent = state[DASHBOARD_ROOT_ID];\n    const topLevelId = rootComponent.children[0];\n    const topLevelTabs = state[topLevelId];\n\n    if (topLevelTabs.type !== TABS_TYPE) return state;\n\n    let childrenToMove = [];\n    const nextEntities = { ...state };\n\n    topLevelTabs.children.forEach(tabId => {\n      const tabComponent = state[tabId];\n      childrenToMove = [...childrenToMove, ...tabComponent.children];\n      delete nextEntities[tabId];\n    });\n\n    delete nextEntities[topLevelId];\n\n    nextEntities[DASHBOARD_ROOT_ID] = {\n      ...rootComponent,\n      children: [DASHBOARD_GRID_ID],\n    };\n\n    nextEntities[DASHBOARD_GRID_ID] = {\n      ...state[DASHBOARD_GRID_ID],\n      children: childrenToMove,\n    };\n\n    return nextEntities;\n  },\n\n  [UPDATE_COMPONENTS_PARENTS_LIST](state) {\n    const nextState = {\n      ...state,\n    };\n\n    updateComponentParentsList({\n      currentComponent: nextState[DASHBOARD_ROOT_ID],\n      layout: nextState,\n    });\n\n    return {\n      ...nextState,\n    };\n  },\n\n  [DASHBOARD_TITLE_CHANGED](state, action) {\n    return {\n      ...state,\n      [DASHBOARD_HEADER_ID]: {\n        ...state[DASHBOARD_HEADER_ID],\n        meta: {\n          ...state[DASHBOARD_HEADER_ID].meta,\n          text: action.text,\n        },\n      },\n    };\n  },\n};\n\nexport default function layoutReducer(state = {}, action) {\n  if (action.type in actionHandlers) {\n    const handler = actionHandlers[action.type];\n    return handler(state, action);\n  }\n\n  return state;\n}\n"]},"metadata":{},"sourceType":"module"}