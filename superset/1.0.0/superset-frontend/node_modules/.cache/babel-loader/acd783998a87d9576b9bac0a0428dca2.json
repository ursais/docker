{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { makeApi } from '@superset-ui/core';\nimport { useEffect, useMemo, useRef, useState } from 'react';\nexport var ResourceStatus;\n(function (ResourceStatus) {\n  ResourceStatus[\"LOADING\"] = \"loading\";\n  ResourceStatus[\"COMPLETE\"] = \"complete\";\n  ResourceStatus[\"ERROR\"] = \"error\";\n})(ResourceStatus || (ResourceStatus = {}));\nconst initialState = {\n  status: ResourceStatus.LOADING,\n  result: null,\n  error: null };\n\n/**\n * A general-purpose hook to fetch the response from an endpoint.\n * Returns the full response body from the API, including metadata.\n *\n * Note: You likely want {useApiV1Resource} instead of this!\n *\n * TODO Store the state in redux or something, share state between hook instances.\n *\n * TODO Include a function in the returned resource object to refresh the data.\n *\n * A core design decision here is composition > configuration,\n * and every hook should only have one job.\n * Please address new needs with new hooks if possible,\n * rather than adding config options to this hook.\n *\n * @param endpoint The url where the resource is located.\n */\nexport function useApiResourceFullBody(endpoint) {\n  const [resource, setResource] = useState(initialState);\n  const cancelRef = useRef(() => {});\n  useEffect(() => {\n    // If refresh is implemented, this will need to change.\n    // The previous values should stay during refresh.\n    setResource(initialState);\n    // when this effect runs, the endpoint has changed.\n    // cancel any current calls so that state doesn't get messed up.\n    cancelRef.current();\n    let cancelled = false;\n    cancelRef.current = () => {\n      cancelled = true;\n    };\n    const fetchResource = makeApi({\n      method: 'GET',\n      endpoint });\n\n    fetchResource({}).\n    then(result => {\n      if (!cancelled) {\n        setResource({\n          status: ResourceStatus.COMPLETE,\n          result,\n          error: null });\n\n      }\n    }).\n    catch(error => {\n      if (!cancelled) {\n        setResource({\n          status: ResourceStatus.ERROR,\n          result: null,\n          error });\n\n      }\n    });\n    // Cancel the request when the component un-mounts\n    return () => {\n      cancelled = true;\n    };\n  }, [endpoint]);\n  return resource;\n}\n/**\n * For when you want to transform the result of an api resource hook before using it.\n *\n * @param resource the Resource object returned from useApiV1Resource\n * @param transformFn a callback that transforms the result object into the shape you want.\n * Make sure to use a persistent function for this so it doesn't constantly recalculate!\n */__signature__(useApiResourceFullBody, \"useState{[resource, setResource](initialState)}\\nuseRef{cancelRef}\\nuseEffect{}\");\nexport function useTransformedResource(resource, transformFn) {\n  return useMemo(() => {\n    if (resource.status !== ResourceStatus.COMPLETE) {\n      // While incomplete, there is no result - no need to transform.\n      return resource;\n    }\n    return {\n      ...resource,\n      result: transformFn(resource.result) };\n\n  }, [resource, transformFn]);\n}\n// returns the \"result\" field from a fetched API v1 endpoint\n__signature__(useTransformedResource, \"useMemo{}\");const extractInnerResult = responseBody => responseBody.result;\n/**\n * A general-purpose hook to fetch a Superset resource from a v1 API endpoint.\n * Handles request lifecycle and async logic so you don't have to.\n *\n * This returns the data under the \"result\" field in the API response body.\n * If you need the full response body, use {useFullApiResource} instead.\n *\n * @param endpoint The url where the resource is located.\n */\nexport function useApiV1Resource(endpoint) {\n  return useTransformedResource(useApiResourceFullBody(endpoint), extractInnerResult);\n}__signature__(useApiV1Resource, \"useTransformedResource{}\\nuseApiResourceFullBody{}\", () => [useTransformedResource, useApiResourceFullBody]);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(ResourceStatus, \"ResourceStatus\", \"/app/superset-frontend/src/common/hooks/apiResources/apiResources.ts\");reactHotLoader.register(initialState, \"initialState\", \"/app/superset-frontend/src/common/hooks/apiResources/apiResources.ts\");reactHotLoader.register(useApiResourceFullBody, \"useApiResourceFullBody\", \"/app/superset-frontend/src/common/hooks/apiResources/apiResources.ts\");reactHotLoader.register(useTransformedResource, \"useTransformedResource\", \"/app/superset-frontend/src/common/hooks/apiResources/apiResources.ts\");reactHotLoader.register(extractInnerResult, \"extractInnerResult\", \"/app/superset-frontend/src/common/hooks/apiResources/apiResources.ts\");reactHotLoader.register(useApiV1Resource, \"useApiV1Resource\", \"/app/superset-frontend/src/common/hooks/apiResources/apiResources.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/common/hooks/apiResources/apiResources.ts"],"names":[],"mappings":"iWAAA;;;;;;;;;;;;;;;;;AAiBG;AAEH,SAAS,OAAT,QAAwB,mBAAxB;AACA,SAAS,SAAT,EAAoB,OAApB,EAA6B,MAA7B,EAAqC,QAArC,QAAqD,OAArD;AAEA,OAAA,IAAY,cAAZ;AAAA,CAAA,UAAY,cAAZ,EAA0B;AACxB,EAAA,cAAA,CAAA,SAAA,CAAA,GAAA,SAAA;AACA,EAAA,cAAA,CAAA,UAAA,CAAA,GAAA,UAAA;AACA,EAAA,cAAA,CAAA,OAAA,CAAA,GAAA,OAAA;AACD,CAJD,EAAY,cAAc,KAAd,cAAc,GAAA,EAAA,CAA1B;AAyCA,MAAM,YAAY,GAAiB;AACjC,EAAA,MAAM,EAAE,cAAc,CAAC,OADU;AAEjC,EAAA,MAAM,EAAE,IAFyB;AAGjC,EAAA,KAAK,EAAE,IAH0B,EAAnC;;AAMA;;;;;;;;;;;;;;;;AAgBG;AACH,OAAM,SAAU,sBAAV,CACJ,QADI,EACY;AAEhB,QAAM,CAAC,QAAD,EAAW,WAAX,IAA0B,QAAQ,CAAmB,YAAnB,CAAxC;AACA,QAAM,SAAS,GAAG,MAAM,CAAa,MAAK,CAAG,CAArB,CAAxB;AAEA,EAAA,SAAS,CAAC,MAAK;AACb;AACA;AACA,IAAA,WAAW,CAAC,YAAD,CAAX;AAEA;AACA;AACA,IAAA,SAAS,CAAC,OAAV;AACA,QAAI,SAAS,GAAG,KAAhB;AACA,IAAA,SAAS,CAAC,OAAV,GAAoB,MAAK;AACvB,MAAA,SAAS,GAAG,IAAZ;AACD,KAFD;AAIA,UAAM,aAAa,GAAG,OAAO,CAAa;AACxC,MAAA,MAAM,EAAE,KADgC;AAExC,MAAA,QAFwC,EAAb,CAA7B;;AAKA,IAAA,aAAa,CAAC,EAAD,CAAb;AACG,IAAA,IADH,CACQ,MAAM,IAAG;AACb,UAAI,CAAC,SAAL,EAAgB;AACd,QAAA,WAAW,CAAC;AACV,UAAA,MAAM,EAAE,cAAc,CAAC,QADb;AAEV,UAAA,MAFU;AAGV,UAAA,KAAK,EAAE,IAHG,EAAD,CAAX;;AAKD;AACF,KATH;AAUG,IAAA,KAVH,CAUS,KAAK,IAAG;AACb,UAAI,CAAC,SAAL,EAAgB;AACd,QAAA,WAAW,CAAC;AACV,UAAA,MAAM,EAAE,cAAc,CAAC,KADb;AAEV,UAAA,MAAM,EAAE,IAFE;AAGV,UAAA,KAHU,EAAD,CAAX;;AAKD;AACF,KAlBH;AAoBA;AACA,WAAO,MAAK;AACV,MAAA,SAAS,GAAG,IAAZ;AACD,KAFD;AAGD,GA1CQ,EA0CN,CAAC,QAAD,CA1CM,CAAT;AA4CA,SAAO,QAAP;AACD;AAED;;;;;;AAMG,G,cA3Da,sB;AA4DhB,OAAM,SAAU,sBAAV,CACJ,QADI,EAEJ,WAFI,EAE4B;AAEhC,SAAO,OAAO,CAAC,MAAK;AAClB,QAAI,QAAQ,CAAC,MAAT,KAAoB,cAAc,CAAC,QAAvC,EAAiD;AAC/C;AACA,aAAO,QAAP;AACD;AACD,WAAO;AACL,SAAG,QADE;AAEL,MAAA,MAAM,EAAE,WAAW,CAAC,QAAQ,CAAC,MAAV,CAFd,EAAP;;AAID,GATa,EASX,CAAC,QAAD,EAAW,WAAX,CATW,CAAd;AAUD;AAED;cAhBgB,sB,eAiBhB,MAAM,kBAAkB,GAAO,YAAJ,IACzB,YAAY,CAAC,MADf;AAGA;;;;;;;;AAQG;AACH,OAAM,SAAU,gBAAV,CAAmC,QAAnC,EAAmD;AACvD,SAAO,sBAAsB,CAC3B,sBAAsB,CAAqB,QAArB,CADK,EAE3B,kBAF2B,CAA7B;AAID,C,cALe,gB,+DACP,sB,EACL,sB,oLA3JQ,c,oHAyCN,Y,kHAuBU,sB,4HA4DA,sB,4HAiBV,kB,wHAYU,gB","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport { makeApi } from '@superset-ui/core';\nimport { useEffect, useMemo, useRef, useState } from 'react';\n\nexport enum ResourceStatus {\n  LOADING = 'loading',\n  COMPLETE = 'complete',\n  ERROR = 'error',\n}\n\n/**\n * An object containing the data fetched from the API,\n * as well as loading and error info\n */\nexport type Resource<T> = LoadingState | CompleteState<T> | ErrorState;\n\n// Trying out something a little different: a separate type per status.\n// This should let Typescript know whether a Resource has a result or error.\n// It's possible that I'm expecting too much from Typescript here.\n// If this ends up causing problems, we can change the type to:\n//\n// export type Resource<T> = {\n//   status: ResourceStatus;\n//   result: null | T;\n//   error: null | Error;\n// }\n\ntype LoadingState = {\n  status: ResourceStatus.LOADING;\n  result: null;\n  error: null;\n};\n\ntype CompleteState<T> = {\n  status: ResourceStatus.COMPLETE;\n  result: T;\n  error: null;\n};\n\ntype ErrorState = {\n  status: ResourceStatus.ERROR;\n  result: null;\n  error: Error;\n};\n\nconst initialState: LoadingState = {\n  status: ResourceStatus.LOADING,\n  result: null,\n  error: null,\n};\n\n/**\n * A general-purpose hook to fetch the response from an endpoint.\n * Returns the full response body from the API, including metadata.\n *\n * Note: You likely want {useApiV1Resource} instead of this!\n *\n * TODO Store the state in redux or something, share state between hook instances.\n *\n * TODO Include a function in the returned resource object to refresh the data.\n *\n * A core design decision here is composition > configuration,\n * and every hook should only have one job.\n * Please address new needs with new hooks if possible,\n * rather than adding config options to this hook.\n *\n * @param endpoint The url where the resource is located.\n */\nexport function useApiResourceFullBody<RESULT>(\n  endpoint: string,\n): Resource<RESULT> {\n  const [resource, setResource] = useState<Resource<RESULT>>(initialState);\n  const cancelRef = useRef<() => void>(() => {});\n\n  useEffect(() => {\n    // If refresh is implemented, this will need to change.\n    // The previous values should stay during refresh.\n    setResource(initialState);\n\n    // when this effect runs, the endpoint has changed.\n    // cancel any current calls so that state doesn't get messed up.\n    cancelRef.current();\n    let cancelled = false;\n    cancelRef.current = () => {\n      cancelled = true;\n    };\n\n    const fetchResource = makeApi<{}, RESULT>({\n      method: 'GET',\n      endpoint,\n    });\n\n    fetchResource({})\n      .then(result => {\n        if (!cancelled) {\n          setResource({\n            status: ResourceStatus.COMPLETE,\n            result,\n            error: null,\n          });\n        }\n      })\n      .catch(error => {\n        if (!cancelled) {\n          setResource({\n            status: ResourceStatus.ERROR,\n            result: null,\n            error,\n          });\n        }\n      });\n\n    // Cancel the request when the component un-mounts\n    return () => {\n      cancelled = true;\n    };\n  }, [endpoint]);\n\n  return resource;\n}\n\n/**\n * For when you want to transform the result of an api resource hook before using it.\n *\n * @param resource the Resource object returned from useApiV1Resource\n * @param transformFn a callback that transforms the result object into the shape you want.\n * Make sure to use a persistent function for this so it doesn't constantly recalculate!\n */\nexport function useTransformedResource<IN, OUT>(\n  resource: Resource<IN>,\n  transformFn: (result: IN) => OUT,\n): Resource<OUT> {\n  return useMemo(() => {\n    if (resource.status !== ResourceStatus.COMPLETE) {\n      // While incomplete, there is no result - no need to transform.\n      return resource;\n    }\n    return {\n      ...resource,\n      result: transformFn(resource.result),\n    };\n  }, [resource, transformFn]);\n}\n\n// returns the \"result\" field from a fetched API v1 endpoint\nconst extractInnerResult = <T>(responseBody: { result: T }) =>\n  responseBody.result;\n\n/**\n * A general-purpose hook to fetch a Superset resource from a v1 API endpoint.\n * Handles request lifecycle and async logic so you don't have to.\n *\n * This returns the data under the \"result\" field in the API response body.\n * If you need the full response body, use {useFullApiResource} instead.\n *\n * @param endpoint The url where the resource is located.\n */\nexport function useApiV1Resource<RESULT>(endpoint: string): Resource<RESULT> {\n  return useTransformedResource(\n    useApiResourceFullBody<{ result: RESULT }>(endpoint),\n    extractInnerResult,\n  );\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}