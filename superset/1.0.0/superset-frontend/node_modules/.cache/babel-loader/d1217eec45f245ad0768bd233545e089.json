{"ast":null,"code":"import _lastIndexOfInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/last-index-of\";import _indexOfInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/index-of\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { sqlaAutoGeneratedMetricRegex } from 'src/explore/constants';\n\nexport const EXPRESSION_TYPES = {\n  SIMPLE: 'SIMPLE',\n  SQL: 'SQL' };\n\n\nfunction inferSqlExpressionColumn(adhocMetric) {\n  if (\n  adhocMetric.sqlExpression &&\n  sqlaAutoGeneratedMetricRegex.test(adhocMetric.sqlExpression))\n  {var _context, _context2;\n    const indexFirstCloseParen = _indexOfInstanceProperty(_context = adhocMetric.sqlExpression).call(_context, ')');\n    const indexPairedOpenParen = _lastIndexOfInstanceProperty(_context2 = adhocMetric.sqlExpression.\n    substring(0, indexFirstCloseParen)).call(_context2,\n    '(');\n    if (indexFirstCloseParen > 0 && indexPairedOpenParen > 0) {\n      return adhocMetric.sqlExpression.substring(\n      indexPairedOpenParen + 1,\n      indexFirstCloseParen);\n\n    }\n  }\n  return null;\n}\n\nfunction inferSqlExpressionAggregate(adhocMetric) {\n  if (\n  adhocMetric.sqlExpression &&\n  sqlaAutoGeneratedMetricRegex.test(adhocMetric.sqlExpression))\n  {var _context3;\n    const indexFirstOpenParen = _indexOfInstanceProperty(_context3 = adhocMetric.sqlExpression).call(_context3, '(');\n    if (indexFirstOpenParen > 0) {\n      return adhocMetric.sqlExpression.substring(0, indexFirstOpenParen);\n    }\n  }\n  return null;\n}\n\nexport default class AdhocMetric {\n  constructor(adhocMetric) {\n    this.expressionType = adhocMetric.expressionType || EXPRESSION_TYPES.SIMPLE;\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      // try to be clever in the case of transitioning from Sql expression back to simple expression\n      const inferredColumn = inferSqlExpressionColumn(adhocMetric);\n      this.column =\n      adhocMetric.column ||\n      inferredColumn && { column_name: inferredColumn };\n      this.aggregate =\n      adhocMetric.aggregate || inferSqlExpressionAggregate(adhocMetric);\n      this.sqlExpression = null;\n    } else if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      this.sqlExpression = adhocMetric.sqlExpression;\n      this.column = null;\n      this.aggregate = null;\n    }\n    this.isNew = !!adhocMetric.isNew;\n    this.hasCustomLabel = !!(adhocMetric.hasCustomLabel && adhocMetric.label);\n    this.label = this.hasCustomLabel ?\n    adhocMetric.label :\n    this.getDefaultLabel();\n\n    this.optionName =\n    adhocMetric.optionName ||\n    `metric_${Math.random().\n    toString(36).\n    substring(2, 15)}_${Math.random().toString(36).substring(2, 15)}`;\n  }\n\n  getDefaultLabel() {\n    const label = this.translateToSql();\n    return label.length < 43 ? label : `${label.substring(0, 40)}...`;\n  }\n\n  translateToSql() {\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {var _this$column;\n      const aggregate = this.aggregate || '';\n      // eslint-disable-next-line camelcase\n      const column = (_this$column = this.column) != null && _this$column.column_name ?\n      `(${this.column.column_name})` :\n      '';\n      return aggregate + column;\n    }\n    if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return this.sqlExpression;\n    }\n    return '';\n  }\n\n  duplicateWith(nextFields) {\n    return new AdhocMetric({\n      ...this,\n      // all duplicate metrics are not considered new by default\n      isNew: false,\n      // but still overriddable by nextFields\n      ...nextFields });\n\n  }\n\n  equals(adhocMetric) {\n    return (\n      adhocMetric.label === this.label &&\n      adhocMetric.expressionType === this.expressionType &&\n      adhocMetric.sqlExpression === this.sqlExpression &&\n      adhocMetric.aggregate === this.aggregate &&\n      (adhocMetric.column && adhocMetric.column.column_name) === (\n      this.column && this.column.column_name));\n\n  }\n\n  isValid() {\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      return !!(this.column && this.aggregate);\n    }\n    if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return !!this.sqlExpression;\n    }\n    return false;\n  }\n\n  inferSqlExpressionAggregate() {\n    return inferSqlExpressionAggregate(this);\n  }\n\n  inferSqlExpressionColumn() {\n    return inferSqlExpressionColumn(this);\n  } // @ts-ignore\n  __reactstandin__regenerateByEval(key, code) {// @ts-ignore\n    this[key] = eval(code);}};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(EXPRESSION_TYPES, \"EXPRESSION_TYPES\", \"/app/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");reactHotLoader.register(inferSqlExpressionColumn, \"inferSqlExpressionColumn\", \"/app/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");reactHotLoader.register(inferSqlExpressionAggregate, \"inferSqlExpressionAggregate\", \"/app/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");reactHotLoader.register(AdhocMetric, \"AdhocMetric\", \"/app/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/explore/components/controls/MetricControl/AdhocMetric.js"],"names":["sqlaAutoGeneratedMetricRegex","EXPRESSION_TYPES","SIMPLE","SQL","inferSqlExpressionColumn","adhocMetric","sqlExpression","test","indexFirstCloseParen","indexPairedOpenParen","substring","inferSqlExpressionAggregate","indexFirstOpenParen","AdhocMetric","constructor","expressionType","inferredColumn","column","column_name","aggregate","isNew","hasCustomLabel","label","getDefaultLabel","optionName","Math","random","toString","translateToSql","length","duplicateWith","nextFields","equals","isValid"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { sqlaAutoGeneratedMetricRegex } from 'src/explore/constants';\n\nexport const EXPRESSION_TYPES = {\n  SIMPLE: 'SIMPLE',\n  SQL: 'SQL',\n};\n\nfunction inferSqlExpressionColumn(adhocMetric) {\n  if (\n    adhocMetric.sqlExpression &&\n    sqlaAutoGeneratedMetricRegex.test(adhocMetric.sqlExpression)\n  ) {\n    const indexFirstCloseParen = adhocMetric.sqlExpression.indexOf(')');\n    const indexPairedOpenParen = adhocMetric.sqlExpression\n      .substring(0, indexFirstCloseParen)\n      .lastIndexOf('(');\n    if (indexFirstCloseParen > 0 && indexPairedOpenParen > 0) {\n      return adhocMetric.sqlExpression.substring(\n        indexPairedOpenParen + 1,\n        indexFirstCloseParen,\n      );\n    }\n  }\n  return null;\n}\n\nfunction inferSqlExpressionAggregate(adhocMetric) {\n  if (\n    adhocMetric.sqlExpression &&\n    sqlaAutoGeneratedMetricRegex.test(adhocMetric.sqlExpression)\n  ) {\n    const indexFirstOpenParen = adhocMetric.sqlExpression.indexOf('(');\n    if (indexFirstOpenParen > 0) {\n      return adhocMetric.sqlExpression.substring(0, indexFirstOpenParen);\n    }\n  }\n  return null;\n}\n\nexport default class AdhocMetric {\n  constructor(adhocMetric) {\n    this.expressionType = adhocMetric.expressionType || EXPRESSION_TYPES.SIMPLE;\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      // try to be clever in the case of transitioning from Sql expression back to simple expression\n      const inferredColumn = inferSqlExpressionColumn(adhocMetric);\n      this.column =\n        adhocMetric.column ||\n        (inferredColumn && { column_name: inferredColumn });\n      this.aggregate =\n        adhocMetric.aggregate || inferSqlExpressionAggregate(adhocMetric);\n      this.sqlExpression = null;\n    } else if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      this.sqlExpression = adhocMetric.sqlExpression;\n      this.column = null;\n      this.aggregate = null;\n    }\n    this.isNew = !!adhocMetric.isNew;\n    this.hasCustomLabel = !!(adhocMetric.hasCustomLabel && adhocMetric.label);\n    this.label = this.hasCustomLabel\n      ? adhocMetric.label\n      : this.getDefaultLabel();\n\n    this.optionName =\n      adhocMetric.optionName ||\n      `metric_${Math.random()\n        .toString(36)\n        .substring(2, 15)}_${Math.random().toString(36).substring(2, 15)}`;\n  }\n\n  getDefaultLabel() {\n    const label = this.translateToSql();\n    return label.length < 43 ? label : `${label.substring(0, 40)}...`;\n  }\n\n  translateToSql() {\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      const aggregate = this.aggregate || '';\n      // eslint-disable-next-line camelcase\n      const column = this.column?.column_name\n        ? `(${this.column.column_name})`\n        : '';\n      return aggregate + column;\n    }\n    if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return this.sqlExpression;\n    }\n    return '';\n  }\n\n  duplicateWith(nextFields) {\n    return new AdhocMetric({\n      ...this,\n      // all duplicate metrics are not considered new by default\n      isNew: false,\n      // but still overriddable by nextFields\n      ...nextFields,\n    });\n  }\n\n  equals(adhocMetric) {\n    return (\n      adhocMetric.label === this.label &&\n      adhocMetric.expressionType === this.expressionType &&\n      adhocMetric.sqlExpression === this.sqlExpression &&\n      adhocMetric.aggregate === this.aggregate &&\n      (adhocMetric.column && adhocMetric.column.column_name) ===\n        (this.column && this.column.column_name)\n    );\n  }\n\n  isValid() {\n    if (this.expressionType === EXPRESSION_TYPES.SIMPLE) {\n      return !!(this.column && this.aggregate);\n    }\n    if (this.expressionType === EXPRESSION_TYPES.SQL) {\n      return !!this.sqlExpression;\n    }\n    return false;\n  }\n\n  inferSqlExpressionAggregate() {\n    return inferSqlExpressionAggregate(this);\n  }\n\n  inferSqlExpressionColumn() {\n    return inferSqlExpressionColumn(this);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}