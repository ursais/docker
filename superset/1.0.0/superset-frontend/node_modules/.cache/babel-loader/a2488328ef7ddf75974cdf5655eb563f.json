{"ast":null,"code":"(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint max-len: 0 */\n/**\n * When determining if a component is a valid child of another component we must consider both\n *   - parent + child component types\n *   - component depth, or depth of nesting of container components\n *\n * We consider types because some components aren't containers (e.g. a heading) and we consider\n * depth to prevent infinite nesting of container components.\n *\n * The following example container nestings should be valid, which means that some containers\n * don't increase the (depth) of their children, namely tabs and tab:\n *   (a) root (0) > grid (1) >                         row (2) > column (3) > row (4) > non-container (5)\n *   (b) root (0) > grid (1) >    tabs (2) > tab (2) > row (2) > column (3) > row (4) > non-container (5)\n *   (c) root (0) > top-tab (1) >                      row (2) > column (3) > row (4) > non-container (5)\n *   (d) root (0) > top-tab (1) > tabs (2) > tab (2) > row (2) > column (3) > row (4) > non-container (5)\n */\nimport { CHART_TYPE, COLUMN_TYPE, DASHBOARD_GRID_TYPE, DASHBOARD_ROOT_TYPE, DIVIDER_TYPE, HEADER_TYPE, MARKDOWN_TYPE, ROW_TYPE, TABS_TYPE, TAB_TYPE } from './componentTypes';\nimport { DASHBOARD_ROOT_DEPTH as rootDepth } from './constants';\nconst depthOne = rootDepth + 1;\nconst depthTwo = rootDepth + 2;\nconst depthThree = rootDepth + 3;\nconst depthFour = rootDepth + 4;\nconst depthFive = rootDepth + 5;\n// when moving components around the depth of child is irrelevant, note these are parent depths\nconst parentMaxDepthLookup = {\n  [DASHBOARD_ROOT_TYPE]: {\n    [TABS_TYPE]: rootDepth,\n    [DASHBOARD_GRID_TYPE]: rootDepth },\n\n  [DASHBOARD_GRID_TYPE]: {\n    [CHART_TYPE]: depthOne,\n    [MARKDOWN_TYPE]: depthOne,\n    [COLUMN_TYPE]: depthOne,\n    [DIVIDER_TYPE]: depthOne,\n    [HEADER_TYPE]: depthOne,\n    [ROW_TYPE]: depthOne,\n    [TABS_TYPE]: depthOne },\n\n  [ROW_TYPE]: {\n    [CHART_TYPE]: depthFour,\n    [MARKDOWN_TYPE]: depthFour,\n    [COLUMN_TYPE]: depthFour },\n\n  [TABS_TYPE]: {\n    [TAB_TYPE]: depthTwo },\n\n  [TAB_TYPE]: {\n    [CHART_TYPE]: depthTwo,\n    [MARKDOWN_TYPE]: depthTwo,\n    [COLUMN_TYPE]: depthTwo,\n    [DIVIDER_TYPE]: depthTwo,\n    [HEADER_TYPE]: depthTwo,\n    [ROW_TYPE]: depthTwo,\n    [TABS_TYPE]: depthTwo },\n\n  [COLUMN_TYPE]: {\n    [CHART_TYPE]: depthFive,\n    [HEADER_TYPE]: depthFive,\n    [MARKDOWN_TYPE]: depthFive,\n    [ROW_TYPE]: depthThree,\n    [DIVIDER_TYPE]: depthThree },\n\n  // these have no valid children\n  [CHART_TYPE]: {},\n  [DIVIDER_TYPE]: {},\n  [HEADER_TYPE]: {},\n  [MARKDOWN_TYPE]: {} };\n\nexport default function isValidChild(child) {\n  const { parentType, childType, parentDepth } = child;\n  if (!parentType || !childType || typeof parentDepth !== 'number') {\n    return false;\n  }\n  const maxParentDepth = (parentMaxDepthLookup[parentType] || {})[childType];\n  return typeof maxParentDepth === 'number' && parentDepth <= maxParentDepth;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(depthOne, \"depthOne\", \"/app/superset-frontend/src/dashboard/util/isValidChild.ts\");reactHotLoader.register(depthTwo, \"depthTwo\", \"/app/superset-frontend/src/dashboard/util/isValidChild.ts\");reactHotLoader.register(depthThree, \"depthThree\", \"/app/superset-frontend/src/dashboard/util/isValidChild.ts\");reactHotLoader.register(depthFour, \"depthFour\", \"/app/superset-frontend/src/dashboard/util/isValidChild.ts\");reactHotLoader.register(depthFive, \"depthFive\", \"/app/superset-frontend/src/dashboard/util/isValidChild.ts\");reactHotLoader.register(parentMaxDepthLookup, \"parentMaxDepthLookup\", \"/app/superset-frontend/src/dashboard/util/isValidChild.ts\");reactHotLoader.register(isValidChild, \"isValidChild\", \"/app/superset-frontend/src/dashboard/util/isValidChild.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/dashboard/util/isValidChild.ts"],"names":[],"mappings":"wSAAA;;;;;;;;;;;;;;;;;AAiBG;AACH;AACA;;;;;;;;;;;;;;AAcG;AACH,SACE,UADF,EAEE,WAFF,EAGE,mBAHF,EAIE,mBAJF,EAKE,YALF,EAME,WANF,EAOE,aAPF,EAQE,QARF,EASE,SATF,EAUE,QAVF,QAWO,kBAXP;AAaA,SAAS,oBAAoB,IAAI,SAAjC,QAAkD,aAAlD;AAEA,MAAM,QAAQ,GAAG,SAAS,GAAG,CAA7B;AACA,MAAM,QAAQ,GAAG,SAAS,GAAG,CAA7B;AACA,MAAM,UAAU,GAAG,SAAS,GAAG,CAA/B;AACA,MAAM,SAAS,GAAG,SAAS,GAAG,CAA9B;AACA,MAAM,SAAS,GAAG,SAAS,GAAG,CAA9B;AAEA;AACA,MAAM,oBAAoB,GAAG;AAC3B,GAAC,mBAAD,GAAuB;AACrB,KAAC,SAAD,GAAa,SADQ;AAErB,KAAC,mBAAD,GAAuB,SAFF,EADI;;AAM3B,GAAC,mBAAD,GAAuB;AACrB,KAAC,UAAD,GAAc,QADO;AAErB,KAAC,aAAD,GAAiB,QAFI;AAGrB,KAAC,WAAD,GAAe,QAHM;AAIrB,KAAC,YAAD,GAAgB,QAJK;AAKrB,KAAC,WAAD,GAAe,QALM;AAMrB,KAAC,QAAD,GAAY,QANS;AAOrB,KAAC,SAAD,GAAa,QAPQ,EANI;;AAgB3B,GAAC,QAAD,GAAY;AACV,KAAC,UAAD,GAAc,SADJ;AAEV,KAAC,aAAD,GAAiB,SAFP;AAGV,KAAC,WAAD,GAAe,SAHL,EAhBe;;AAsB3B,GAAC,SAAD,GAAa;AACX,KAAC,QAAD,GAAY,QADD,EAtBc;;AA0B3B,GAAC,QAAD,GAAY;AACV,KAAC,UAAD,GAAc,QADJ;AAEV,KAAC,aAAD,GAAiB,QAFP;AAGV,KAAC,WAAD,GAAe,QAHL;AAIV,KAAC,YAAD,GAAgB,QAJN;AAKV,KAAC,WAAD,GAAe,QALL;AAMV,KAAC,QAAD,GAAY,QANF;AAOV,KAAC,SAAD,GAAa,QAPH,EA1Be;;AAoC3B,GAAC,WAAD,GAAe;AACb,KAAC,UAAD,GAAc,SADD;AAEb,KAAC,WAAD,GAAe,SAFF;AAGb,KAAC,aAAD,GAAiB,SAHJ;AAIb,KAAC,QAAD,GAAY,UAJC;AAKb,KAAC,YAAD,GAAgB,UALH,EApCY;;AA4C3B;AACA,GAAC,UAAD,GAAc,EA7Ca;AA8C3B,GAAC,YAAD,GAAgB,EA9CW;AA+C3B,GAAC,WAAD,GAAe,EA/CY;AAgD3B,GAAC,aAAD,GAAiB,EAhDU,EAA7B;;AAyDA,eAAc,SAAU,YAAV,CAAuB,KAAvB,EAA+C;AAC3D,QAAM,EAAE,UAAF,EAAc,SAAd,EAAyB,WAAzB,KAAyC,KAA/C;AACA,MAAI,CAAC,UAAD,IAAe,CAAC,SAAhB,IAA6B,OAAO,WAAP,KAAuB,QAAxD,EAAkE;AAChE,WAAO,KAAP;AACD;AAED,QAAM,cAAc,GAAuB,CAAC,oBAAoB,CAC9D,UAD8D,CAApB,IAEvC,EAFsC,EAElC,SAFkC,CAA3C;AAIA,SAAO,OAAO,cAAP,KAA0B,QAA1B,IAAsC,WAAW,IAAI,cAA5D;AACD,C,iLA3EK,Q,mGACA,Q,mGACA,U,qGACA,S,oGACA,S,oGAGA,oB,+GAyDkB,Y","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint max-len: 0 */\n/**\n * When determining if a component is a valid child of another component we must consider both\n *   - parent + child component types\n *   - component depth, or depth of nesting of container components\n *\n * We consider types because some components aren't containers (e.g. a heading) and we consider\n * depth to prevent infinite nesting of container components.\n *\n * The following example container nestings should be valid, which means that some containers\n * don't increase the (depth) of their children, namely tabs and tab:\n *   (a) root (0) > grid (1) >                         row (2) > column (3) > row (4) > non-container (5)\n *   (b) root (0) > grid (1) >    tabs (2) > tab (2) > row (2) > column (3) > row (4) > non-container (5)\n *   (c) root (0) > top-tab (1) >                      row (2) > column (3) > row (4) > non-container (5)\n *   (d) root (0) > top-tab (1) > tabs (2) > tab (2) > row (2) > column (3) > row (4) > non-container (5)\n */\nimport {\n  CHART_TYPE,\n  COLUMN_TYPE,\n  DASHBOARD_GRID_TYPE,\n  DASHBOARD_ROOT_TYPE,\n  DIVIDER_TYPE,\n  HEADER_TYPE,\n  MARKDOWN_TYPE,\n  ROW_TYPE,\n  TABS_TYPE,\n  TAB_TYPE,\n} from './componentTypes';\n\nimport { DASHBOARD_ROOT_DEPTH as rootDepth } from './constants';\n\nconst depthOne = rootDepth + 1;\nconst depthTwo = rootDepth + 2;\nconst depthThree = rootDepth + 3;\nconst depthFour = rootDepth + 4;\nconst depthFive = rootDepth + 5;\n\n// when moving components around the depth of child is irrelevant, note these are parent depths\nconst parentMaxDepthLookup = {\n  [DASHBOARD_ROOT_TYPE]: {\n    [TABS_TYPE]: rootDepth,\n    [DASHBOARD_GRID_TYPE]: rootDepth,\n  },\n\n  [DASHBOARD_GRID_TYPE]: {\n    [CHART_TYPE]: depthOne,\n    [MARKDOWN_TYPE]: depthOne,\n    [COLUMN_TYPE]: depthOne,\n    [DIVIDER_TYPE]: depthOne,\n    [HEADER_TYPE]: depthOne,\n    [ROW_TYPE]: depthOne,\n    [TABS_TYPE]: depthOne,\n  },\n\n  [ROW_TYPE]: {\n    [CHART_TYPE]: depthFour,\n    [MARKDOWN_TYPE]: depthFour,\n    [COLUMN_TYPE]: depthFour,\n  },\n\n  [TABS_TYPE]: {\n    [TAB_TYPE]: depthTwo,\n  },\n\n  [TAB_TYPE]: {\n    [CHART_TYPE]: depthTwo,\n    [MARKDOWN_TYPE]: depthTwo,\n    [COLUMN_TYPE]: depthTwo,\n    [DIVIDER_TYPE]: depthTwo,\n    [HEADER_TYPE]: depthTwo,\n    [ROW_TYPE]: depthTwo,\n    [TABS_TYPE]: depthTwo,\n  },\n\n  [COLUMN_TYPE]: {\n    [CHART_TYPE]: depthFive,\n    [HEADER_TYPE]: depthFive,\n    [MARKDOWN_TYPE]: depthFive,\n    [ROW_TYPE]: depthThree,\n    [DIVIDER_TYPE]: depthThree,\n  },\n\n  // these have no valid children\n  [CHART_TYPE]: {},\n  [DIVIDER_TYPE]: {},\n  [HEADER_TYPE]: {},\n  [MARKDOWN_TYPE]: {},\n};\n\ninterface IsValidChildProps {\n  parentType?: string;\n  childType?: string;\n  parentDepth?: unknown;\n}\n\nexport default function isValidChild(child: IsValidChildProps): boolean {\n  const { parentType, childType, parentDepth } = child;\n  if (!parentType || !childType || typeof parentDepth !== 'number') {\n    return false;\n  }\n\n  const maxParentDepth: number | undefined = (parentMaxDepthLookup[\n    parentType\n  ] || {})[childType];\n\n  return typeof maxParentDepth === 'number' && parentDepth <= maxParentDepth;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}