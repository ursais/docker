{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";import _Array$isArray from \"@babel/runtime-corejs3/core-js-stable/array/is-array\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";import _filterInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/filter\";import _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import { ensureIsArray } from '@superset-ui/core';\nimport { getSectionsToRender } from './getSectionsToRender';\nimport { getControlConfig } from './getControlConfig';\nfunction execControlValidator(control, processedState) {\n  const validators = control.validators;\n  const { externalValidationErrors = [] } = control;\n  const errors = [];\n  if (validators && validators.length > 0) {\n    _forEachInstanceProperty(validators).call(validators, validator => {\n      const error = validator.call(control, control.value, processedState);\n      if (error) {\n        errors.push(error);\n      }\n    });\n  }\n  const validationErrors = [...errors, ...externalValidationErrors];\n  // always reset validation errors even when there is no validator\n  return { ...control, validationErrors };\n}\n/**\n * Clear control values that are no longer in the `choices` list.\n */\nfunction handleMissingChoice(control) {\n  // If the value is not valid anymore based on choices, clear it\n  if (control.type === 'SelectControl' &&\n  !control.freeForm &&\n  control.choices &&\n  control.value) {\n    const alteredControl = { ...control };\n    const choices = control.choices;\n    const value = ensureIsArray(control.value);\n    const choiceValues = _mapInstanceProperty(choices).call(choices, c => c[0]);\n    if (control.multi && value.length > 0) {\n      alteredControl.value = _filterInstanceProperty(value).call(value, el => _includesInstanceProperty(choiceValues).call(choiceValues, el));\n      return alteredControl;\n    }\n    if (!control.multi && !_includesInstanceProperty(choiceValues).call(choiceValues, value[0])) {\n      alteredControl.value = null;\n      return alteredControl;\n    }\n  }\n  return control;\n}\nexport function applyMapStateToPropsToControl(controlState, controlPanelState) {\n  const { mapStateToProps } = controlState;\n  let state = { ...controlState };\n  let { value } = state; // value is current user-input value\n  if (mapStateToProps && controlPanelState) {\n    state = {\n      ...controlState,\n      ...mapStateToProps.call(controlState, controlPanelState, controlState) };\n\n    // `mapStateToProps` may also provide a value\n    value = value || state.value;\n  }\n  // If default is a function, evaluate it\n  if (typeof state.default === 'function') {\n    state.default = state.default(state, controlPanelState);\n    // if default is still a function, discard\n    if (typeof state.default === 'function') {\n      delete state.default;\n    }\n  }\n  // If no current value, set it as default\n  if (state.default && value === undefined) {\n    value = state.default;\n  }\n  // If a choice control went from multi=false to true, wrap value in array\n  if (value && state.multi && !_Array$isArray(value)) {\n    value = [value];\n  }\n  state.value = value;\n  return execControlValidator(handleMissingChoice(state), state);\n}\nexport function getControlStateFromControlConfig(controlConfig, controlPanelState, value) {\n  // skip invalid config values\n  if (!controlConfig) {\n    return null;\n  }\n  const controlState = { ...controlConfig, value };\n  // only apply mapStateToProps when control states have been initialized\n  // or when explicitly didn't provide control panel state (mostly for testing)\n  if (controlPanelState && controlPanelState.controls ||\n  controlPanelState === null) {\n    return applyMapStateToPropsToControl(controlState, controlPanelState);\n  }\n  return controlState;\n}\nexport function getControlState(controlKey, vizType, state, value) {\n  return getControlStateFromControlConfig(getControlConfig(controlKey, vizType), state, value);\n}\nexport function getAllControlsState(vizType, datasourceType, state, formData) {var _context;\n  const controlsState = {};\n  _forEachInstanceProperty(_context = getSectionsToRender(vizType, datasourceType)).call(_context, section => {var _context2;return _forEachInstanceProperty(_context2 = section.controlSetRows).call(_context2, fieldsetRow => _forEachInstanceProperty(fieldsetRow).call(fieldsetRow, field => {\n      if (field && 'config' in field && field.config && field.name) {\n        const { config, name } = field;\n        controlsState[name] = getControlStateFromControlConfig(config, state, formData[name]);\n      }\n    }));});\n  return controlsState;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(execControlValidator, \"execControlValidator\", \"/app/superset-frontend/src/explore/controlUtils/getControlState.ts\");reactHotLoader.register(handleMissingChoice, \"handleMissingChoice\", \"/app/superset-frontend/src/explore/controlUtils/getControlState.ts\");reactHotLoader.register(applyMapStateToPropsToControl, \"applyMapStateToPropsToControl\", \"/app/superset-frontend/src/explore/controlUtils/getControlState.ts\");reactHotLoader.register(getControlStateFromControlConfig, \"getControlStateFromControlConfig\", \"/app/superset-frontend/src/explore/controlUtils/getControlState.ts\");reactHotLoader.register(getControlState, \"getControlState\", \"/app/superset-frontend/src/explore/controlUtils/getControlState.ts\");reactHotLoader.register(getAllControlsState, \"getAllControlsState\", \"/app/superset-frontend/src/explore/controlUtils/getControlState.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/explore/controlUtils/getControlState.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { ReactNode } from 'react';\nimport {\n  DatasourceType,\n  ensureIsArray,\n  JsonValue,\n  QueryFormData,\n} from '@superset-ui/core';\nimport {\n  ControlConfig,\n  ControlPanelState,\n  ControlState,\n  ControlType,\n  ControlValueValidator,\n} from '@superset-ui/chart-controls';\nimport { getSectionsToRender } from './getSectionsToRender';\nimport { getControlConfig } from './getControlConfig';\n\ntype ValidationError = JsonValue;\n\nfunction execControlValidator<T = ControlType>(\n  control: ControlState<T>,\n  processedState: ControlState<T>,\n) {\n  const validators = control.validators as ControlValueValidator[] | undefined;\n  const { externalValidationErrors = [] } = control;\n  const errors: ValidationError[] = [];\n  if (validators && validators.length > 0) {\n    validators.forEach(validator => {\n      const error = validator.call(control, control.value, processedState);\n      if (error) {\n        errors.push(error);\n      }\n    });\n  }\n  const validationErrors = [...errors, ...externalValidationErrors];\n  // always reset validation errors even when there is no validator\n  return { ...control, validationErrors };\n}\n\n/**\n * Clear control values that are no longer in the `choices` list.\n */\nfunction handleMissingChoice<T = ControlType>(control: ControlState<T>) {\n  // If the value is not valid anymore based on choices, clear it\n  if (\n    control.type === 'SelectControl' &&\n    !control.freeForm &&\n    control.choices &&\n    control.value\n  ) {\n    const alteredControl = { ...control };\n    const choices = control.choices as [JsonValue, ReactNode][];\n    const value = ensureIsArray(control.value);\n    const choiceValues = choices.map(c => c[0]);\n    if (control.multi && value.length > 0) {\n      alteredControl.value = value.filter(el => choiceValues.includes(el));\n      return alteredControl;\n    }\n    if (!control.multi && !choiceValues.includes(value[0])) {\n      alteredControl.value = null;\n      return alteredControl;\n    }\n  }\n  return control;\n}\n\nexport function applyMapStateToPropsToControl<T = ControlType>(\n  controlState: ControlState<T>,\n  controlPanelState: Partial<ControlPanelState>,\n) {\n  const { mapStateToProps } = controlState;\n  let state = { ...controlState };\n  let { value } = state; // value is current user-input value\n  if (mapStateToProps && controlPanelState) {\n    state = {\n      ...controlState,\n      ...mapStateToProps.call(controlState, controlPanelState, controlState),\n    };\n    // `mapStateToProps` may also provide a value\n    value = value || state.value;\n  }\n  // If default is a function, evaluate it\n  if (typeof state.default === 'function') {\n    state.default = state.default(state, controlPanelState);\n    // if default is still a function, discard\n    if (typeof state.default === 'function') {\n      delete state.default;\n    }\n  }\n  // If no current value, set it as default\n  if (state.default && value === undefined) {\n    value = state.default;\n  }\n  // If a choice control went from multi=false to true, wrap value in array\n  if (value && state.multi && !Array.isArray(value)) {\n    value = [value];\n  }\n  state.value = value;\n  return execControlValidator(handleMissingChoice(state), state);\n}\n\nexport function getControlStateFromControlConfig<T = ControlType>(\n  controlConfig: ControlConfig<T> | null,\n  controlPanelState: Partial<ControlPanelState>,\n  value?: JsonValue,\n) {\n  // skip invalid config values\n  if (!controlConfig) {\n    return null;\n  }\n  const controlState = { ...controlConfig, value } as ControlState<T>;\n  // only apply mapStateToProps when control states have been initialized\n  // or when explicitly didn't provide control panel state (mostly for testing)\n  if (\n    (controlPanelState && controlPanelState.controls) ||\n    controlPanelState === null\n  ) {\n    return applyMapStateToPropsToControl(controlState, controlPanelState);\n  }\n  return controlState;\n}\n\nexport function getControlState(\n  controlKey: string,\n  vizType: string,\n  state: Partial<ControlPanelState>,\n  value?: JsonValue,\n) {\n  return getControlStateFromControlConfig(\n    getControlConfig(controlKey, vizType),\n    state,\n    value,\n  );\n}\n\nexport function getAllControlsState(\n  vizType: string,\n  datasourceType: DatasourceType,\n  state: ControlPanelState,\n  formData: QueryFormData,\n) {\n  const controlsState = {};\n  getSectionsToRender(vizType, datasourceType).forEach(section =>\n    section.controlSetRows.forEach(fieldsetRow =>\n      fieldsetRow.forEach(field => {\n        if (field && 'config' in field && field.config && field.name) {\n          const { config, name } = field;\n          controlsState[name] = getControlStateFromControlConfig(\n            config,\n            state,\n            formData[name],\n          );\n        }\n      }),\n    ),\n  );\n  return controlsState;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}