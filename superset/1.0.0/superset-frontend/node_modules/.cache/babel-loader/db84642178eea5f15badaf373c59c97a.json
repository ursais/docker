{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";import _findInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/find\";import _someInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/some\";import _sortInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/sort\";import _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";import _Object$keys from \"@babel/runtime-corejs3/core-js-stable/object/keys\";import _filterInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/filter\";import _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";import _reduceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/reduce\";import _Array$isArray from \"@babel/runtime-corejs3/core-js-stable/array/is-array\";import _Object$values from \"@babel/runtime-corejs3/core-js-stable/object/values\";import _Set from \"@babel/runtime-corejs3/core-js-stable/set\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { NO_TIME_RANGE, TIME_FILTER_MAP } from 'src/explore/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/activeDashboardFilters';\nimport { DataMaskType } from 'src/dataMask/types';\nimport { FeatureFlag, isFeatureEnabled } from '@superset-ui/core';\nimport { getTreeCheckedItems } from '../nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils';\nexport var IndicatorStatus;\n(function (IndicatorStatus) {\n  IndicatorStatus[\"Unset\"] = \"UNSET\";\n  IndicatorStatus[\"Applied\"] = \"APPLIED\";\n  IndicatorStatus[\"Incompatible\"] = \"INCOMPATIBLE\";\n  IndicatorStatus[\"CrossFilterApplied\"] = \"CROSS_FILTER_APPLIED\";\n})(IndicatorStatus || (IndicatorStatus = {}));\nconst TIME_GRANULARITY_FIELDS = new _Set(_Object$values(TIME_FILTER_MAP));\nconst selectIndicatorValue = (columnKey, filter, datasource) => {\n  const values = filter.columns[columnKey];\n  const arrValues = _Array$isArray(values) ? values : [values];\n  if (values == null ||\n  filter.isDateFilter && values === NO_TIME_RANGE ||\n  arrValues.length === 0) {\n    return [];\n  }\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {var _context;\n    const timeGranularityMap = _reduceInstanceProperty(_context = (columnKey === TIME_FILTER_MAP.time_grain_sqla ?\n    datasource.time_grain_sqla :\n    datasource.granularity) || []).call(_context, (map, [key, value]) => ({\n      ...map,\n      [key]: value }),\n    {});\n    return _mapInstanceProperty(arrValues).call(arrValues, value => timeGranularityMap[value] || value);\n  }\n  return arrValues;\n};\nconst selectIndicatorsForChartFromFilter = (chartId, filter, filterDataSource, appliedColumns, rejectedColumns) => {var _context2, _context3;\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = (column, filter) => {\n    if (appliedColumns.has(column) && filter.columns[column])\n    return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column))\n    return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n  return _mapInstanceProperty(_context2 = _filterInstanceProperty(_context3 = _Object$keys(filter.columns)).call(_context3,\n  column => {var _context4;return _includesInstanceProperty(_context4 = getChartIdsInFilterScope({\n      filterScope: filter.scopes[column] })).call(_context4,\n    chartId);})).call(_context2,\n  column => ({\n    column,\n    name: filter.labels[column] || column,\n    value: selectIndicatorValue(column, filter, filterDataSource),\n    status: getStatus(column, filter),\n    path: filter.directPathToFilter }));\n\n};\nconst getAppliedColumns = chart => {var _context5, _chart$queriesRespons, _chart$queriesRespons2;return new _Set(_mapInstanceProperty(_context5 = (chart == null ? void 0 : (_chart$queriesRespons = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons2 = _chart$queriesRespons[0]) == null ? void 0 : _chart$queriesRespons2.applied_filters) || []).call(_context5, filter => filter.column));};\nconst getRejectedColumns = chart => {var _context6, _chart$queriesRespons3, _chart$queriesRespons4;return new _Set(_mapInstanceProperty(_context6 = (chart == null ? void 0 : (_chart$queriesRespons3 = chart.queriesResponse) == null ? void 0 : (_chart$queriesRespons4 = _chart$queriesRespons3[0]) == null ? void 0 : _chart$queriesRespons4.rejected_filters) || []).call(_context6, filter => filter.column));};\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (chartId, filters, datasources, charts) => {var _context7, _context8;\n  const chart = charts[chartId];\n  // no indicators if chart is loading\n  if (chart.chartStatus === 'loading')\n  return [];\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const indicators = _reduceInstanceProperty(_context7 = _filterInstanceProperty(_context8 = _Object$values(filters)).call(_context8,\n  filter => filter.chartId !== chartId)).call(_context7,\n  (acc, filter) => _concatInstanceProperty(acc).call(acc, selectIndicatorsForChartFromFilter(chartId, filter, datasources[filter.datasourceId] || {}, appliedColumns, rejectedColumns)), []);\n  _sortInstanceProperty(indicators).call(indicators, (a, b) => a.name.localeCompare(b.name));\n  return indicators;\n};\nexport const selectNativeIndicatorsForChart = (nativeFilters, dataMask, chartId, charts, dashboardLayout, chartConfiguration = {}) => {\n  const chart = charts[chartId];\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n  const getStatus = ({ value, column, type = DataMaskType.NativeFilters }) => {\n    // a filter is only considered unset if it's value is null\n    const hasValue = value !== null;\n    if (type === DataMaskType.CrossFilters && hasValue) {\n      return IndicatorStatus.CrossFilterApplied;\n    }\n    if (!column && hasValue) {\n      // Filter without datasource\n      return IndicatorStatus.Applied;\n    }\n    if (column && rejectedColumns.has(column))\n    return IndicatorStatus.Incompatible;\n    if (column && appliedColumns.has(column) && hasValue) {\n      return IndicatorStatus.Applied;\n    }\n    return IndicatorStatus.Unset;\n  };\n  let nativeFilterIndicators = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS)) {var _context9, _context10;\n    nativeFilterIndicators = _mapInstanceProperty(_context9 = _filterInstanceProperty(_context10 = _Object$values(nativeFilters.filters)).call(_context10,\n    nativeFilter => {var _context11;return _someInstanceProperty(_context11 = getTreeCheckedItems(nativeFilter.scope, dashboardLayout)).call(_context11, layoutItem => {var _dashboardLayout$layo, _dashboardLayout$layo2;return ((_dashboardLayout$layo = dashboardLayout[layoutItem]) == null ? void 0 : (_dashboardLayout$layo2 = _dashboardLayout$layo.meta) == null ? void 0 : _dashboardLayout$layo2.chartId) === chartId;});})).call(_context9,\n    nativeFilter => {var _nativeFilter$targets, _nativeFilter$targets2, _ref, _dataMask$nativeFilte, _dataMask$nativeFilte2, _dataMask$nativeFilte3, _dataMask$nativeFilte4, _dataMask$nativeFilte5;\n      const column = (_nativeFilter$targets = nativeFilter.targets[0]) == null ? void 0 : (_nativeFilter$targets2 = _nativeFilter$targets.column) == null ? void 0 : _nativeFilter$targets2.name;\n      let value = (_ref = (_dataMask$nativeFilte = (_dataMask$nativeFilte2 = dataMask[nativeFilter.id]) == null ? void 0 : (_dataMask$nativeFilte3 = _dataMask$nativeFilte2.filterState) == null ? void 0 : _dataMask$nativeFilte3.label) != null ? _dataMask$nativeFilte : (_dataMask$nativeFilte4 =\n      dataMask[nativeFilter.id]) == null ? void 0 : (_dataMask$nativeFilte5 = _dataMask$nativeFilte4.filterState) == null ? void 0 : _dataMask$nativeFilte5.value) != null ? _ref :\n      null;\n      if (!_Array$isArray(value) && value !== null) {\n        value = [value];\n      }\n      return {\n        column,\n        name: nativeFilter.name,\n        path: [nativeFilter.id],\n        status: getStatus({ value, column }),\n        value };\n\n    });\n  }\n  let crossFilterIndicators = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {var _context12, _context13, _context14;\n    crossFilterIndicators = _filterInstanceProperty(_context12 = _mapInstanceProperty(_context13 = _filterInstanceProperty(_context14 = _Object$values(chartConfiguration)).call(_context14,\n    chartConfig => {var _context15, _chartConfig$crossFil;return _someInstanceProperty(_context15 = getTreeCheckedItems(chartConfig == null ? void 0 : (_chartConfig$crossFil = chartConfig.crossFilters) == null ? void 0 : _chartConfig$crossFil.scope, dashboardLayout)).call(_context15, layoutItem => {var _dashboardLayout$layo3, _dashboardLayout$layo4;return ((_dashboardLayout$layo3 = dashboardLayout[layoutItem]) == null ? void 0 : (_dashboardLayout$layo4 = _dashboardLayout$layo3.meta) == null ? void 0 : _dashboardLayout$layo4.chartId) === chartId;});})).call(_context13,\n    chartConfig => {var _ref2, _dataMask$chartConfig, _dataMask$chartConfig2, _dataMask$chartConfig3, _dataMask$chartConfig4, _dataMask$chartConfig5, _Object$values$find, _Object$values$find$m, _context16;\n      let value = (_ref2 = (_dataMask$chartConfig = (_dataMask$chartConfig2 = dataMask[chartConfig.id]) == null ? void 0 : (_dataMask$chartConfig3 = _dataMask$chartConfig2.filterState) == null ? void 0 : _dataMask$chartConfig3.label) != null ? _dataMask$chartConfig : (_dataMask$chartConfig4 =\n      dataMask[chartConfig.id]) == null ? void 0 : (_dataMask$chartConfig5 = _dataMask$chartConfig4.filterState) == null ? void 0 : _dataMask$chartConfig5.value) != null ? _ref2 :\n      null;\n      if (!_Array$isArray(value) && value !== null) {\n        value = [value];\n      }\n      return {\n        name: (_Object$values$find = _findInstanceProperty(_context16 = _Object$values(dashboardLayout)).call(_context16, layoutItem => {var _layoutItem$meta;return (layoutItem == null ? void 0 : (_layoutItem$meta = layoutItem.meta) == null ? void 0 : _layoutItem$meta.chartId) === chartConfig.id;})) == null ? void 0 : (_Object$values$find$m = _Object$values$find.meta) == null ? void 0 : _Object$values$find$m.sliceName,\n        path: [`${chartConfig.id}`],\n        status: getStatus({\n          value,\n          type: DataMaskType.CrossFilters }),\n\n        value };\n\n    })).call(_context12,\n    filter => filter.status === IndicatorStatus.CrossFilterApplied);\n  }\n  return _concatInstanceProperty(crossFilterIndicators).call(crossFilterIndicators, nativeFilterIndicators);\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(IndicatorStatus, \"IndicatorStatus\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(TIME_GRANULARITY_FIELDS, \"TIME_GRANULARITY_FIELDS\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(selectIndicatorValue, \"selectIndicatorValue\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(selectIndicatorsForChartFromFilter, \"selectIndicatorsForChartFromFilter\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(getAppliedColumns, \"getAppliedColumns\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(getRejectedColumns, \"getRejectedColumns\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(selectIndicatorsForChart, \"selectIndicatorsForChart\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");reactHotLoader.register(selectNativeIndicatorsForChart, \"selectNativeIndicatorsForChart\", \"/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/dashboard/components/FiltersBadge/selectors.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { NO_TIME_RANGE, TIME_FILTER_MAP } from 'src/explore/constants';\nimport { getChartIdsInFilterScope } from 'src/dashboard/util/activeDashboardFilters';\nimport {\n  ChartConfiguration,\n  NativeFiltersState,\n} from 'src/dashboard/reducers/types';\nimport { DataMaskStateWithId, DataMaskType } from 'src/dataMask/types';\nimport { FeatureFlag, isFeatureEnabled } from '@superset-ui/core';\nimport { Layout } from '../../types';\nimport { getTreeCheckedItems } from '../nativeFilters/FiltersConfigModal/FiltersConfigForm/FilterScope/utils';\n\nexport enum IndicatorStatus {\n  Unset = 'UNSET',\n  Applied = 'APPLIED',\n  Incompatible = 'INCOMPATIBLE',\n  CrossFilterApplied = 'CROSS_FILTER_APPLIED',\n}\n\nconst TIME_GRANULARITY_FIELDS = new Set(Object.values(TIME_FILTER_MAP));\n\n// As of 2020-09-28, the DatasourceMeta type in superset-ui is incorrect.\n// Should patch it here until the DatasourceMeta type is updated.\ntype Datasource = {\n  time_grain_sqla?: [string, string][];\n  granularity?: [string, string][];\n};\n\ntype Filter = {\n  chartId: number;\n  columns: { [key: string]: string | string[] };\n  scopes: { [key: string]: any };\n  labels: { [key: string]: string };\n  isDateFilter: boolean;\n  directPathToFilter: string[];\n  datasourceId: string;\n};\n\nconst selectIndicatorValue = (\n  columnKey: string,\n  filter: Filter,\n  datasource: Datasource,\n): any => {\n  const values = filter.columns[columnKey];\n  const arrValues = Array.isArray(values) ? values : [values];\n\n  if (\n    values == null ||\n    (filter.isDateFilter && values === NO_TIME_RANGE) ||\n    arrValues.length === 0\n  ) {\n    return [];\n  }\n\n  if (filter.isDateFilter && TIME_GRANULARITY_FIELDS.has(columnKey)) {\n    const timeGranularityMap = (\n      (columnKey === TIME_FILTER_MAP.time_grain_sqla\n        ? datasource.time_grain_sqla\n        : datasource.granularity) || []\n    ).reduce(\n      (map, [key, value]) => ({\n        ...map,\n        [key]: value,\n      }),\n      {},\n    );\n\n    return arrValues.map(value => timeGranularityMap[value] || value);\n  }\n\n  return arrValues;\n};\n\nconst selectIndicatorsForChartFromFilter = (\n  chartId: number,\n  filter: Filter,\n  filterDataSource: Datasource,\n  appliedColumns: Set<string>,\n  rejectedColumns: Set<string>,\n): Indicator[] => {\n  // filters can be applied (if the filter is compatible with the datasource)\n  // or rejected (if the filter is incompatible)\n  // or the status can be unknown (if the filter has calculated parameters that we can't analyze)\n  const getStatus = (column: string, filter: Filter) => {\n    if (appliedColumns.has(column) && filter.columns[column])\n      return IndicatorStatus.Applied;\n    if (rejectedColumns.has(column)) return IndicatorStatus.Incompatible;\n    return IndicatorStatus.Unset;\n  };\n\n  return Object.keys(filter.columns)\n    .filter(column =>\n      getChartIdsInFilterScope({\n        filterScope: filter.scopes[column],\n      }).includes(chartId),\n    )\n    .map(column => ({\n      column,\n      name: filter.labels[column] || column,\n      value: selectIndicatorValue(column, filter, filterDataSource),\n      status: getStatus(column, filter),\n      path: filter.directPathToFilter,\n    }));\n};\n\nconst getAppliedColumns = (chart: any): Set<string> =>\n  new Set(\n    (chart?.queriesResponse?.[0]?.applied_filters || []).map(\n      (filter: any) => filter.column,\n    ),\n  );\n\nconst getRejectedColumns = (chart: any): Set<string> =>\n  new Set(\n    (chart?.queriesResponse?.[0]?.rejected_filters || []).map(\n      (filter: any) => filter.column,\n    ),\n  );\n\nexport type Indicator = {\n  column?: string;\n  name: string;\n  value?: any;\n  status?: IndicatorStatus;\n  path?: string[];\n};\n\n// inspects redux state to find what the filter indicators should be shown for a given chart\nexport const selectIndicatorsForChart = (\n  chartId: number,\n  filters: { [key: number]: Filter },\n  datasources: { [key: string]: Datasource },\n  charts: any,\n): Indicator[] => {\n  const chart = charts[chartId];\n  // no indicators if chart is loading\n  if (chart.chartStatus === 'loading') return [];\n\n  // for now we only need to know which columns are compatible/incompatible,\n  // so grab the columns from the applied/rejected filters\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n\n  const indicators = Object.values(filters)\n    .filter(filter => filter.chartId !== chartId)\n    .reduce(\n      (acc, filter) =>\n        acc.concat(\n          selectIndicatorsForChartFromFilter(\n            chartId,\n            filter,\n            datasources[filter.datasourceId] || {},\n            appliedColumns,\n            rejectedColumns,\n          ),\n        ),\n      [] as Indicator[],\n    );\n  indicators.sort((a, b) => a.name.localeCompare(b.name));\n  return indicators;\n};\n\nexport const selectNativeIndicatorsForChart = (\n  nativeFilters: NativeFiltersState,\n  dataMask: DataMaskStateWithId,\n  chartId: number,\n  charts: any,\n  dashboardLayout: Layout,\n  chartConfiguration: ChartConfiguration = {},\n): Indicator[] => {\n  const chart = charts[chartId];\n\n  const appliedColumns = getAppliedColumns(chart);\n  const rejectedColumns = getRejectedColumns(chart);\n\n  const getStatus = ({\n    value,\n    column,\n    type = DataMaskType.NativeFilters,\n  }: {\n    value: any;\n    column?: string;\n    type?: DataMaskType;\n  }): IndicatorStatus => {\n    // a filter is only considered unset if it's value is null\n    const hasValue = value !== null;\n    if (type === DataMaskType.CrossFilters && hasValue) {\n      return IndicatorStatus.CrossFilterApplied;\n    }\n    if (!column && hasValue) {\n      // Filter without datasource\n      return IndicatorStatus.Applied;\n    }\n    if (column && rejectedColumns.has(column))\n      return IndicatorStatus.Incompatible;\n    if (column && appliedColumns.has(column) && hasValue) {\n      return IndicatorStatus.Applied;\n    }\n    return IndicatorStatus.Unset;\n  };\n\n  let nativeFilterIndicators: any = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_NATIVE_FILTERS)) {\n    nativeFilterIndicators = Object.values(nativeFilters.filters)\n      .filter(nativeFilter =>\n        getTreeCheckedItems(nativeFilter.scope, dashboardLayout).some(\n          layoutItem => dashboardLayout[layoutItem]?.meta?.chartId === chartId,\n        ),\n      )\n      .map(nativeFilter => {\n        const column = nativeFilter.targets[0]?.column?.name;\n        let value =\n          dataMask[nativeFilter.id]?.filterState?.label ??\n          dataMask[nativeFilter.id]?.filterState?.value ??\n          null;\n        if (!Array.isArray(value) && value !== null) {\n          value = [value];\n        }\n        return {\n          column,\n          name: nativeFilter.name,\n          path: [nativeFilter.id],\n          status: getStatus({ value, column }),\n          value,\n        };\n      });\n  }\n\n  let crossFilterIndicators: any = [];\n  if (isFeatureEnabled(FeatureFlag.DASHBOARD_CROSS_FILTERS)) {\n    crossFilterIndicators = Object.values(chartConfiguration)\n      .filter(chartConfig =>\n        getTreeCheckedItems(\n          chartConfig?.crossFilters?.scope,\n          dashboardLayout,\n        ).some(\n          layoutItem => dashboardLayout[layoutItem]?.meta?.chartId === chartId,\n        ),\n      )\n      .map(chartConfig => {\n        let value =\n          dataMask[chartConfig.id]?.filterState?.label ??\n          dataMask[chartConfig.id]?.filterState?.value ??\n          null;\n        if (!Array.isArray(value) && value !== null) {\n          value = [value];\n        }\n        return {\n          name: Object.values(dashboardLayout).find(\n            layoutItem => layoutItem?.meta?.chartId === chartConfig.id,\n          )?.meta?.sliceName as string,\n          path: [`${chartConfig.id}`],\n          status: getStatus({\n            value,\n            type: DataMaskType.CrossFilters,\n          }),\n          value,\n        };\n      })\n      .filter(filter => filter.status === IndicatorStatus.CrossFilterApplied);\n  }\n  return crossFilterIndicators.concat(nativeFilterIndicators);\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}