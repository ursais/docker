{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";import _sliceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/slice\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";import _Array$isArray from \"@babel/runtime-corejs3/core-js-stable/array/is-array\";import _Object$entries from \"@babel/runtime-corejs3/core-js-stable/object/entries\";import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;}; /**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport { DYNAMIC_PLUGIN_CONTROLS_READY } from 'src/chart/chartAction';\nimport { DEFAULT_TIME_RANGE } from 'src/explore/constants';\nimport { getControlsState } from 'src/explore/store';\nimport {\ngetControlConfig,\ngetFormDataFromControls,\ngetControlStateFromControlConfig } from\n'src/explore/controlUtils';\nimport * as actions from 'src/explore/actions/exploreActions';\n\nexport default function exploreReducer(state = {}, action) {\n  const actionHandlers = {\n    [DYNAMIC_PLUGIN_CONTROLS_READY]() {\n      return {\n        ...state,\n        controls: action.controlsState };\n\n    },\n    [actions.TOGGLE_FAVE_STAR]() {\n      return {\n        ...state,\n        isStarred: action.isStarred };\n\n    },\n    [actions.POST_DATASOURCE_STARTED]() {\n      return {\n        ...state,\n        isDatasourceMetaLoading: true };\n\n    },\n    [actions.SET_DATASOURCE]() {\n      const newFormData = { ...state.form_data };\n      if (action.datasource.type !== state.datasource.type) {\n        if (action.datasource.type === 'table') {\n          newFormData.granularity_sqla = action.datasource.granularity_sqla;\n          newFormData.time_grain_sqla = action.datasource.time_grain_sqla;\n          delete newFormData.druid_time_origin;\n          delete newFormData.granularity;\n        } else {\n          newFormData.druid_time_origin = action.datasource.druid_time_origin;\n          newFormData.granularity = action.datasource.granularity;\n          delete newFormData.granularity_sqla;\n          delete newFormData.time_grain_sqla;\n        }\n      }\n\n      const controls = { ...state.controls };\n      if (\n      action.datasource.id !== state.datasource.id ||\n      action.datasource.type !== state.datasource.type)\n      {var _context;\n        // reset time range filter to default\n        newFormData.time_range = DEFAULT_TIME_RANGE;\n\n        // reset control values for column/metric related controls\n        _forEachInstanceProperty(_context = _Object$entries(controls)).call(_context, ([controlName, controlState]) => {\n          if (\n          // for direct column select controls\n          controlState.valueKey === 'column_name' ||\n          // for all other controls\n          'columns' in controlState)\n          {\n            // if a control use datasource columns, reset its value to `undefined`,\n            // then `getControlsState` will pick up the default.\n            // TODO: filter out only invalid columns and keep others\n            controls[controlName] = {\n              ...controlState,\n              value: undefined };\n\n            newFormData[controlName] = undefined;\n          }\n        });\n      }\n\n      const newState = {\n        ...state,\n        controls,\n        datasource: action.datasource,\n        datasource_id: action.datasource.id,\n        datasource_type: action.datasource.type };\n\n      return {\n        ...newState,\n        form_data: newFormData,\n        controls: getControlsState(newState, newFormData) };\n\n    },\n    [actions.FETCH_DATASOURCES_STARTED]() {\n      return {\n        ...state,\n        isDatasourcesLoading: true };\n\n    },\n    [actions.SET_DATASOURCES]() {\n      return {\n        ...state,\n        datasources: action.datasources };\n\n    },\n    [actions.SET_FIELD_VALUE]() {var _context3;\n      const new_form_data = state.form_data;\n      const { controlName, value, validationErrors } = action;\n      new_form_data[controlName] = value;\n\n      const vizType = new_form_data.viz_type;\n\n      // Use the processed control config (with overrides and everything)\n      // if `controlName` does not existing in current controls,\n      const controlConfig =\n      state.controls[action.controlName] ||\n      getControlConfig(action.controlName, vizType) ||\n      {};\n\n      // will call validators again\n      const control = {\n        ...getControlStateFromControlConfig(controlConfig, state, action.value) };\n\n\n      const newState = {\n        ...state,\n        controls: { ...state.controls, [action.controlName]: control } };\n\n\n      const rerenderedControls = {};\n      if (_Array$isArray(control.rerender)) {var _context2;\n        _forEachInstanceProperty(_context2 = control.rerender).call(_context2, controlName => {\n          rerenderedControls[controlName] = {\n            ...getControlStateFromControlConfig(\n            newState.controls[controlName],\n            newState,\n            newState.controls[controlName].value) };\n\n\n        });\n      }\n\n      // combine newly detected errors with errors from `onChange` event of\n      // each control component (passed via reducer action).\n      const errors = control.validationErrors || [];\n      _forEachInstanceProperty(_context3 = validationErrors || []).call(_context3, err => {\n        // skip duplicated errors\n        if (!_includesInstanceProperty(errors).call(errors, err)) {\n          errors.push(err);\n        }\n      });\n      const hasErrors = errors && errors.length > 0;\n\n      const currentControlsState =\n      action.controlName === 'viz_type' &&\n      action.value !== state.controls.viz_type.value ?\n      // rebuild the full control state if switching viz type\n      getControlsState(\n      state,\n      getFormDataFromControls({\n        ...state.controls,\n        viz_type: control })) :\n\n\n      state.controls;\n\n      return {\n        ...state,\n        form_data: new_form_data,\n        triggerRender: control.renderTrigger && !hasErrors,\n        controls: {\n          ...currentControlsState,\n          [action.controlName]: {\n            ...control,\n            validationErrors: errors },\n\n          ...rerenderedControls } };\n\n\n    },\n    [actions.SET_EXPLORE_CONTROLS]() {\n      return {\n        ...state,\n        controls: getControlsState(state, action.formData) };\n\n    },\n    [actions.UPDATE_CHART_TITLE]() {\n      return {\n        ...state,\n        sliceName: action.sliceName };\n\n    },\n    [actions.CREATE_NEW_SLICE]() {\n      return {\n        ...state,\n        slice: _sliceInstanceProperty(action),\n        controls: getControlsState(state, action.form_data),\n        can_add: action.can_add,\n        can_download: action.can_download,\n        can_overwrite: action.can_overwrite };\n\n    },\n    [actions.SLICE_UPDATED]() {var _action$slice$slice_n;\n      return {\n        ...state,\n        slice: {\n          ..._sliceInstanceProperty(state),\n          ..._sliceInstanceProperty(action) },\n\n        sliceName: (_action$slice$slice_n = _sliceInstanceProperty(action).slice_name) != null ? _action$slice$slice_n : state.sliceName };\n\n    } };\n\n  if (action.type in actionHandlers) {\n    return actionHandlers[action.type]();\n  }\n  return state;\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(exploreReducer, \"exploreReducer\", \"/app/superset-frontend/src/explore/reducers/exploreReducer.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/explore/reducers/exploreReducer.js"],"names":["DYNAMIC_PLUGIN_CONTROLS_READY","DEFAULT_TIME_RANGE","getControlsState","getControlConfig","getFormDataFromControls","getControlStateFromControlConfig","actions","exploreReducer","state","action","actionHandlers","controls","controlsState","TOGGLE_FAVE_STAR","isStarred","POST_DATASOURCE_STARTED","isDatasourceMetaLoading","SET_DATASOURCE","newFormData","form_data","datasource","type","granularity_sqla","time_grain_sqla","druid_time_origin","granularity","id","time_range","controlName","controlState","valueKey","value","undefined","newState","datasource_id","datasource_type","FETCH_DATASOURCES_STARTED","isDatasourcesLoading","SET_DATASOURCES","datasources","SET_FIELD_VALUE","new_form_data","validationErrors","vizType","viz_type","controlConfig","control","rerenderedControls","rerender","errors","err","push","hasErrors","length","currentControlsState","triggerRender","renderTrigger","SET_EXPLORE_CONTROLS","formData","UPDATE_CHART_TITLE","sliceName","CREATE_NEW_SLICE","slice","can_add","can_download","can_overwrite","SLICE_UPDATED","slice_name"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n/* eslint camelcase: 0 */\nimport { DYNAMIC_PLUGIN_CONTROLS_READY } from 'src/chart/chartAction';\nimport { DEFAULT_TIME_RANGE } from 'src/explore/constants';\nimport { getControlsState } from 'src/explore/store';\nimport {\n  getControlConfig,\n  getFormDataFromControls,\n  getControlStateFromControlConfig,\n} from 'src/explore/controlUtils';\nimport * as actions from 'src/explore/actions/exploreActions';\n\nexport default function exploreReducer(state = {}, action) {\n  const actionHandlers = {\n    [DYNAMIC_PLUGIN_CONTROLS_READY]() {\n      return {\n        ...state,\n        controls: action.controlsState,\n      };\n    },\n    [actions.TOGGLE_FAVE_STAR]() {\n      return {\n        ...state,\n        isStarred: action.isStarred,\n      };\n    },\n    [actions.POST_DATASOURCE_STARTED]() {\n      return {\n        ...state,\n        isDatasourceMetaLoading: true,\n      };\n    },\n    [actions.SET_DATASOURCE]() {\n      const newFormData = { ...state.form_data };\n      if (action.datasource.type !== state.datasource.type) {\n        if (action.datasource.type === 'table') {\n          newFormData.granularity_sqla = action.datasource.granularity_sqla;\n          newFormData.time_grain_sqla = action.datasource.time_grain_sqla;\n          delete newFormData.druid_time_origin;\n          delete newFormData.granularity;\n        } else {\n          newFormData.druid_time_origin = action.datasource.druid_time_origin;\n          newFormData.granularity = action.datasource.granularity;\n          delete newFormData.granularity_sqla;\n          delete newFormData.time_grain_sqla;\n        }\n      }\n\n      const controls = { ...state.controls };\n      if (\n        action.datasource.id !== state.datasource.id ||\n        action.datasource.type !== state.datasource.type\n      ) {\n        // reset time range filter to default\n        newFormData.time_range = DEFAULT_TIME_RANGE;\n\n        // reset control values for column/metric related controls\n        Object.entries(controls).forEach(([controlName, controlState]) => {\n          if (\n            // for direct column select controls\n            controlState.valueKey === 'column_name' ||\n            // for all other controls\n            'columns' in controlState\n          ) {\n            // if a control use datasource columns, reset its value to `undefined`,\n            // then `getControlsState` will pick up the default.\n            // TODO: filter out only invalid columns and keep others\n            controls[controlName] = {\n              ...controlState,\n              value: undefined,\n            };\n            newFormData[controlName] = undefined;\n          }\n        });\n      }\n\n      const newState = {\n        ...state,\n        controls,\n        datasource: action.datasource,\n        datasource_id: action.datasource.id,\n        datasource_type: action.datasource.type,\n      };\n      return {\n        ...newState,\n        form_data: newFormData,\n        controls: getControlsState(newState, newFormData),\n      };\n    },\n    [actions.FETCH_DATASOURCES_STARTED]() {\n      return {\n        ...state,\n        isDatasourcesLoading: true,\n      };\n    },\n    [actions.SET_DATASOURCES]() {\n      return {\n        ...state,\n        datasources: action.datasources,\n      };\n    },\n    [actions.SET_FIELD_VALUE]() {\n      const new_form_data = state.form_data;\n      const { controlName, value, validationErrors } = action;\n      new_form_data[controlName] = value;\n\n      const vizType = new_form_data.viz_type;\n\n      // Use the processed control config (with overrides and everything)\n      // if `controlName` does not existing in current controls,\n      const controlConfig =\n        state.controls[action.controlName] ||\n        getControlConfig(action.controlName, vizType) ||\n        {};\n\n      // will call validators again\n      const control = {\n        ...getControlStateFromControlConfig(controlConfig, state, action.value),\n      };\n\n      const newState = {\n        ...state,\n        controls: { ...state.controls, [action.controlName]: control },\n      };\n\n      const rerenderedControls = {};\n      if (Array.isArray(control.rerender)) {\n        control.rerender.forEach(controlName => {\n          rerenderedControls[controlName] = {\n            ...getControlStateFromControlConfig(\n              newState.controls[controlName],\n              newState,\n              newState.controls[controlName].value,\n            ),\n          };\n        });\n      }\n\n      // combine newly detected errors with errors from `onChange` event of\n      // each control component (passed via reducer action).\n      const errors = control.validationErrors || [];\n      (validationErrors || []).forEach(err => {\n        // skip duplicated errors\n        if (!errors.includes(err)) {\n          errors.push(err);\n        }\n      });\n      const hasErrors = errors && errors.length > 0;\n\n      const currentControlsState =\n        action.controlName === 'viz_type' &&\n        action.value !== state.controls.viz_type.value\n          ? // rebuild the full control state if switching viz type\n            getControlsState(\n              state,\n              getFormDataFromControls({\n                ...state.controls,\n                viz_type: control,\n              }),\n            )\n          : state.controls;\n\n      return {\n        ...state,\n        form_data: new_form_data,\n        triggerRender: control.renderTrigger && !hasErrors,\n        controls: {\n          ...currentControlsState,\n          [action.controlName]: {\n            ...control,\n            validationErrors: errors,\n          },\n          ...rerenderedControls,\n        },\n      };\n    },\n    [actions.SET_EXPLORE_CONTROLS]() {\n      return {\n        ...state,\n        controls: getControlsState(state, action.formData),\n      };\n    },\n    [actions.UPDATE_CHART_TITLE]() {\n      return {\n        ...state,\n        sliceName: action.sliceName,\n      };\n    },\n    [actions.CREATE_NEW_SLICE]() {\n      return {\n        ...state,\n        slice: action.slice,\n        controls: getControlsState(state, action.form_data),\n        can_add: action.can_add,\n        can_download: action.can_download,\n        can_overwrite: action.can_overwrite,\n      };\n    },\n    [actions.SLICE_UPDATED]() {\n      return {\n        ...state,\n        slice: {\n          ...state.slice,\n          ...action.slice,\n        },\n        sliceName: action.slice.slice_name ?? state.sliceName,\n      };\n    },\n  };\n  if (action.type in actionHandlers) {\n    return actionHandlers[action.type]();\n  }\n  return state;\n}\n"]},"metadata":{},"sourceType":"module"}