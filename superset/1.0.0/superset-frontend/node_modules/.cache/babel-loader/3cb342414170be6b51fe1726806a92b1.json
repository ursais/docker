{"ast":null,"code":"import _Object$values from \"@babel/runtime-corejs3/core-js-stable/object/values\";import _filterInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/filter\";import _reduceInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/reduce\";import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import { CHART_TYPE } from './componentTypes';\nimport { DASHBOARD_ROOT_ID } from './constants';\n// Looking for affected chart scopes and values\nexport const findAffectedCharts = ({ child, layout, scope, activeFilters, filterId, extraFormData }) => {var _layout$child, _layout$child$meta, _context2;\n  const chartId = (_layout$child = layout[child]) == null ? void 0 : (_layout$child$meta = _layout$child.meta) == null ? void 0 : _layout$child$meta.chartId;\n  if (layout[child].type === CHART_TYPE) {var _context;\n    // Ignore excluded charts\n    if (_includesInstanceProperty(_context = scope.excluded).call(_context, chartId)) {\n      return;\n    }\n    if (!activeFilters[filterId]) {\n      // Small mutation but simplify logic\n      // eslint-disable-next-line no-param-reassign\n      activeFilters[filterId] = {\n        scope: [],\n        values: extraFormData };\n\n    }\n    // Add not excluded chart scopes(to know what charts refresh) and values(refresh only if its value changed)\n    activeFilters[filterId].scope.push(chartId);\n    return;\n  }\n  // If child is not chart, recursive iterate over its children\n  _forEachInstanceProperty(_context2 = layout[child].children).call(_context2, child => findAffectedCharts({\n    child,\n    layout,\n    scope,\n    activeFilters,\n    filterId,\n    extraFormData }));\n\n};\nexport const getRelevantDataMask = (dataMask, prop) => {var _context3, _context4;return _reduceInstanceProperty(_context3 = _filterInstanceProperty(_context4 = _Object$values(dataMask)).call(_context4,\n  item => item[prop])).call(_context3,\n  (prev, next) => ({ ...prev, [next.id]: prop ? next[prop] : next }), {});};\nexport const getAllActiveFilters = ({ chartConfiguration, nativeFilters, dataMask, layout }) => {var _context5;\n  const activeFilters = {};\n  // Combine native filters with cross filters, because they have similar logic\n  _forEachInstanceProperty(_context5 = _Object$values(dataMask)).call(_context5, ({ id: filterId, extraFormData }) => {var _ref, _nativeFilters$filter, _nativeFilters$filter2, _chartConfiguration$f, _chartConfiguration$f2, _context6;\n    const scope = (_ref = (_nativeFilters$filter = nativeFilters == null ? void 0 : (_nativeFilters$filter2 = nativeFilters[filterId]) == null ? void 0 : _nativeFilters$filter2.scope) != null ? _nativeFilters$filter :\n    chartConfiguration == null ? void 0 : (_chartConfiguration$f = chartConfiguration[filterId]) == null ? void 0 : (_chartConfiguration$f2 = _chartConfiguration$f.crossFilters) == null ? void 0 : _chartConfiguration$f2.scope) != null ? _ref : {\n      rootPath: [DASHBOARD_ROOT_ID],\n      excluded: [filterId] };\n\n    // Iterate over all roots to find all affected charts\n    _forEachInstanceProperty(_context6 = scope.rootPath).call(_context6, layoutItemId => {var _context7;\n      _forEachInstanceProperty(_context7 = layout[layoutItemId].children).call(_context7, child => {\n        // Need exclude from affected charts, charts that located in scope `excluded`\n        findAffectedCharts({\n          child,\n          layout,\n          scope,\n          activeFilters,\n          filterId,\n          extraFormData });\n\n      });\n    });\n  });\n  return activeFilters;\n};;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(findAffectedCharts, \"findAffectedCharts\", \"/app/superset-frontend/src/dashboard/util/activeAllDashboardFilters.ts\");reactHotLoader.register(getRelevantDataMask, \"getRelevantDataMask\", \"/app/superset-frontend/src/dashboard/util/activeAllDashboardFilters.ts\");reactHotLoader.register(getAllActiveFilters, \"getAllActiveFilters\", \"/app/superset-frontend/src/dashboard/util/activeAllDashboardFilters.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/dashboard/util/activeAllDashboardFilters.ts"],"names":[],"mappings":"+uBAoBA,SAAS,UAAT,QAA2B,kBAA3B;AAIA,SAAS,iBAAT,QAAkC,aAAlC;AAEA;AACA,OAAO,MAAM,kBAAkB,GAAG,CAAC,EACjC,KADiC,EAEjC,MAFiC,EAGjC,KAHiC,EAIjC,aAJiC,EAKjC,QALiC,EAMjC,aANiC,EAAD,KAc7B;AACH,QAAM,OAAO,oBAAG,MAAM,CAAC,KAAD,CAAT,2CAAG,cAAe,IAAlB,qBAAG,mBAAqB,OAArC;AACA,MAAI,MAAM,CAAC,KAAD,CAAN,CAAc,IAAd,KAAuB,UAA3B,EAAuC;AACrC;AACA,QAAI,qCAAA,KAAK,CAAC,QAAN,iBAAwB,OAAxB,CAAJ,EAAsC;AACpC;AACD;AACD,QAAI,CAAC,aAAa,CAAC,QAAD,CAAlB,EAA8B;AAC5B;AACA;AACA,MAAA,aAAa,CAAC,QAAD,CAAb,GAA0B;AACxB,QAAA,KAAK,EAAE,EADiB;AAExB,QAAA,MAAM,EAAE,aAFgB,EAA1B;;AAID;AACD;AACA,IAAA,aAAa,CAAC,QAAD,CAAb,CAAwB,KAAxB,CAA8B,IAA9B,CAAmC,OAAnC;AACA;AACD;AACD;AACA,uCAAA,MAAM,CAAC,KAAD,CAAN,CAAc,QAAd,kBAAgC,KAAD,IAC7B,kBAAkB,CAAC;AACjB,IAAA,KADiB;AAEjB,IAAA,MAFiB;AAGjB,IAAA,KAHiB;AAIjB,IAAA,aAJiB;AAKjB,IAAA,QALiB;AAMjB,IAAA,aANiB,EAAD,CADpB;;AAUD,CA5CM;AA8CP,OAAO,MAAM,mBAAmB,GAAG,CACjC,QADiC,EAEjC,IAFiC,sCAIjC,uFAAc,QAAd;AACU,EAAA,IAAI,IAAI,IAAI,CAAC,IAAD,CADtB;AAGI,GAAC,IAAD,EAAO,IAAP,MAAiB,EAAE,GAAG,IAAL,EAAW,CAAC,IAAI,CAAC,EAAN,GAAW,IAAI,GAAG,IAAI,CAAC,IAAD,CAAP,GAAgB,IAA1C,EAAjB,CAHJ,EAII,EAJJ,CAJiC,EAA5B;AAWP,OAAO,MAAM,mBAAmB,GAAG,CAAC,EAClC,kBADkC,EAElC,aAFkC,EAGlC,QAHkC,EAIlC,MAJkC,EAAD,KAUf;AAClB,QAAM,aAAa,GAAG,EAAtB;AAEA;AACA,sDAAc,QAAd,mBAAgC,CAAC,EAAE,EAAE,EAAE,QAAN,EAAgB,aAAhB,EAAD,KAAoC;AAClE,UAAM,KAAK,oCAAG,aAAH,8CAAG,aAAa,CAAG,QAAH,CAAhB,qBAAG,uBAA2B,KAA9B;AACT,IAAA,kBADS,6CACT,kBAAkB,CAAG,QAAH,CADT,+CACT,sBAAgC,YADvB,qBACT,uBAA8C,KADrC,mBAC8C;AACrD,MAAA,QAAQ,EAAE,CAAC,iBAAD,CAD2C;AAErD,MAAA,QAAQ,EAAE,CAAC,QAAD,CAF2C,EADzD;;AAKA;AACA,yCAAA,KAAK,CAAC,QAAN,kBAAwB,YAAD,IAAkC;AACvD,2CAAA,MAAM,CAAC,YAAD,CAAN,CAAqB,QAArB,kBAAuC,KAAD,IAAkB;AACtD;AACA,QAAA,kBAAkB,CAAC;AACjB,UAAA,KADiB;AAEjB,UAAA,MAFiB;AAGjB,UAAA,KAHiB;AAIjB,UAAA,aAJiB;AAKjB,UAAA,QALiB;AAMjB,UAAA,aANiB,EAAD,CAAlB;;AAQD,OAVD;AAWD,KAZD;AAaD,GApBD;AAqBA,SAAO,aAAP;AACD,CApCM,C,iLAzDM,kB,0HA8CA,mB,2HAWA,mB","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { DataMaskStateWithId } from 'src/dataMask/types';\nimport { JsonObject } from '@superset-ui/core';\nimport { CHART_TYPE } from './componentTypes';\nimport { Scope } from '../components/nativeFilters/types';\nimport { ActiveFilters, Layout, LayoutItem } from '../types';\nimport { ChartConfiguration, Filters } from '../reducers/types';\nimport { DASHBOARD_ROOT_ID } from './constants';\n\n// Looking for affected chart scopes and values\nexport const findAffectedCharts = ({\n  child,\n  layout,\n  scope,\n  activeFilters,\n  filterId,\n  extraFormData,\n}: {\n  child: string;\n  layout: { [key: string]: LayoutItem };\n  scope: Scope;\n  activeFilters: ActiveFilters;\n  filterId: string;\n  extraFormData: any;\n}) => {\n  const chartId = layout[child]?.meta?.chartId;\n  if (layout[child].type === CHART_TYPE) {\n    // Ignore excluded charts\n    if (scope.excluded.includes(chartId)) {\n      return;\n    }\n    if (!activeFilters[filterId]) {\n      // Small mutation but simplify logic\n      // eslint-disable-next-line no-param-reassign\n      activeFilters[filterId] = {\n        scope: [],\n        values: extraFormData,\n      };\n    }\n    // Add not excluded chart scopes(to know what charts refresh) and values(refresh only if its value changed)\n    activeFilters[filterId].scope.push(chartId);\n    return;\n  }\n  // If child is not chart, recursive iterate over its children\n  layout[child].children.forEach((child: string) =>\n    findAffectedCharts({\n      child,\n      layout,\n      scope,\n      activeFilters,\n      filterId,\n      extraFormData,\n    }),\n  );\n};\n\nexport const getRelevantDataMask = (\n  dataMask: DataMaskStateWithId,\n  prop: string,\n): JsonObject | DataMaskStateWithId =>\n  Object.values(dataMask)\n    .filter(item => item[prop])\n    .reduce(\n      (prev, next) => ({ ...prev, [next.id]: prop ? next[prop] : next }),\n      {},\n    );\n\nexport const getAllActiveFilters = ({\n  chartConfiguration,\n  nativeFilters,\n  dataMask,\n  layout,\n}: {\n  chartConfiguration: ChartConfiguration;\n  dataMask: DataMaskStateWithId;\n  nativeFilters: Filters;\n  layout: Layout;\n}): ActiveFilters => {\n  const activeFilters = {};\n\n  // Combine native filters with cross filters, because they have similar logic\n  Object.values(dataMask).forEach(({ id: filterId, extraFormData }) => {\n    const scope = nativeFilters?.[filterId]?.scope ??\n      chartConfiguration?.[filterId]?.crossFilters?.scope ?? {\n        rootPath: [DASHBOARD_ROOT_ID],\n        excluded: [filterId],\n      };\n    // Iterate over all roots to find all affected charts\n    scope.rootPath.forEach((layoutItemId: string | number) => {\n      layout[layoutItemId].children.forEach((child: string) => {\n        // Need exclude from affected charts, charts that located in scope `excluded`\n        findAffectedCharts({\n          child,\n          layout,\n          scope,\n          activeFilters,\n          filterId,\n          extraFormData,\n        });\n      });\n    });\n  });\n  return activeFilters;\n};\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}