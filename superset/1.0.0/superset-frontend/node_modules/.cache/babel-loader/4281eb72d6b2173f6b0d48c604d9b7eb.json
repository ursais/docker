{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";import _someInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/some\";import _concatInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/concat\";import _Set from \"@babel/runtime-corejs3/core-js-stable/set\";import _Object$values from \"@babel/runtime-corejs3/core-js-stable/object/values\";import _Object$entries from \"@babel/runtime-corejs3/core-js-stable/object/entries\";import _everyInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/every\";import _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";import _filterInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/filter\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";import _isEmpty from \"lodash/isEmpty\";import _flatMap from \"lodash/flatMap\";import _mapValues from \"lodash/fp/mapValues\";import _keyBy from \"lodash/fp/keyBy\";import _flow from \"lodash/fp/flow\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { CHART_TYPE, TAB_TYPE } from './componentTypes';\nimport { getChartIdAndColumnFromFilterKey } from './getDashboardFilterKey';\n\nfunction getImmuneChartIdsFromTabsNotInScope({ tabs = [], tabsInScope = [] }) {\n  const chartsNotInScope = [];\n  _forEachInstanceProperty(tabs).call(tabs, ({ value: tab, children: tabChildren }) => {\n    if (tabChildren && !_includesInstanceProperty(tabsInScope).call(tabsInScope, tab)) {\n      _forEachInstanceProperty(tabChildren).call(tabChildren, ({ value: subTab, children: subTabChildren }) => {\n        if (subTabChildren && !_includesInstanceProperty(tabsInScope).call(tabsInScope, subTab)) {\n          chartsNotInScope.push(\n          ..._filterInstanceProperty(subTabChildren).call(subTabChildren, ({ type }) => type === CHART_TYPE));\n\n        }\n      });\n    }\n  });\n\n  // return chartId only\n  return _mapInstanceProperty(chartsNotInScope).call(chartsNotInScope, ({ value }) => value);\n}\nfunction getTabChildrenScope({\n  tabScopes,\n  parentNodeValue,\n  forceAggregate = false,\n  hasChartSiblings = false,\n  tabChildren = [],\n  immuneChartSiblings = [] })\n{var _context, _context2, _context3;\n  // if all sub-tabs are in scope, or forceAggregate =  true\n  // aggregate scope to parentNodeValue\n  if (\n  forceAggregate ||\n  !hasChartSiblings &&\n  _everyInstanceProperty(_context = _Object$entries(tabScopes)).call(_context,\n  ([key, { scope }]) => scope && scope.length && key === scope[0]))\n\n  {\n    // get all charts from tabChildren that is not in scope\n    const immuneChartIdsFromTabsNotInScope = getImmuneChartIdsFromTabsNotInScope(\n    {\n      tabs: tabChildren,\n      tabsInScope: _flatMap(tabScopes, ({ scope }) => scope) });\n\n\n    const immuneChartIdsFromTabsInScope = _flatMap(\n    _Object$values(tabScopes),\n    ({ immune }) => immune);\n\n    const immuneCharts = [\n    ...new _Set([\n    ...immuneChartIdsFromTabsNotInScope,\n    ...immuneChartIdsFromTabsInScope])];\n\n\n    return {\n      scope: [parentNodeValue],\n      immune: immuneCharts };\n\n  }\n\n  const componentsInScope = _filterInstanceProperty(_context2 = _Object$values(tabScopes)).call(_context2,\n  ({ scope }) => scope && scope.length);\n\n  return {\n    scope: _flatMap(componentsInScope, ({ scope }) => scope),\n    immune: componentsInScope.length ?\n    _flatMap(componentsInScope, ({ immune }) => immune) :\n    _concatInstanceProperty(_context3 = _flatMap(_Object$values(tabScopes), ({ immune }) => immune)).call(_context3,\n    immuneChartSiblings) };\n\n\n}\n\nfunction traverse({ currentNode = {}, filterId, checkedChartIds = [] }) {var _context4;\n  if (!currentNode) {\n    return {};\n  }\n\n  const { value: currentValue, children } = currentNode;\n  const chartChildren = _filterInstanceProperty(children).call(children, ({ type }) => type === CHART_TYPE);\n  const tabChildren = _filterInstanceProperty(children).call(children, ({ type }) => type === TAB_TYPE);\n\n  const chartsImmune = _mapInstanceProperty(_context4 = _filterInstanceProperty(chartChildren).call(chartChildren,\n\n  ({ value }) => filterId !== value && !_includesInstanceProperty(checkedChartIds).call(checkedChartIds, value))).call(_context4,\n\n  ({ value }) => value);\n  const tabScopes = _flow(\n  _keyBy(child => child.value),\n  _mapValues((child) =>\n  traverse({\n    currentNode: child,\n    filterId,\n    checkedChartIds })))(\n\n\n  tabChildren);\n\n  // if any chart type child is in scope,\n  // no matter has tab children or not, current node should be scope\n  if (\n  !_isEmpty(chartChildren) &&\n  _someInstanceProperty(chartChildren).call(chartChildren, ({ value }) => _includesInstanceProperty(checkedChartIds).call(checkedChartIds, value)))\n  {\n    if (_isEmpty(tabChildren)) {\n      return { scope: [currentValue], immune: chartsImmune };\n    }\n\n    const { scope, immune } = getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      forceAggregate: true,\n      tabChildren });\n\n    return {\n      scope,\n      immune: _concatInstanceProperty(chartsImmune).call(chartsImmune, immune) };\n\n  }\n\n  // has tab children but only some sub-tab in scope\n  if (tabChildren.length) {\n    return getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      hasChartSiblings: !_isEmpty(chartChildren),\n      tabChildren,\n      immuneChartSiblings: chartsImmune });\n\n  }\n\n  // no tab children and no chart children in scope\n  return {\n    scope: [],\n    immune: chartsImmune };\n\n}\n\nexport default function getFilterScopeFromNodesTree({\n  filterKey,\n  nodes = [],\n  checkedChartIds = [] })\n{\n  if (nodes.length) {\n    const { chartId } = getChartIdAndColumnFromFilterKey(filterKey);\n    return traverse({\n      currentNode: nodes[0],\n      filterId: chartId,\n      checkedChartIds });\n\n  }\n\n  return {};\n};(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(getImmuneChartIdsFromTabsNotInScope, \"getImmuneChartIdsFromTabsNotInScope\", \"/app/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(getTabChildrenScope, \"getTabChildrenScope\", \"/app/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(traverse, \"traverse\", \"/app/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");reactHotLoader.register(getFilterScopeFromNodesTree, \"getFilterScopeFromNodesTree\", \"/app/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/dashboard/util/getFilterScopeFromNodesTree.js"],"names":["CHART_TYPE","TAB_TYPE","getChartIdAndColumnFromFilterKey","getImmuneChartIdsFromTabsNotInScope","tabs","tabsInScope","chartsNotInScope","value","tab","children","tabChildren","subTab","subTabChildren","push","type","getTabChildrenScope","tabScopes","parentNodeValue","forceAggregate","hasChartSiblings","immuneChartSiblings","key","scope","length","immuneChartIdsFromTabsNotInScope","immuneChartIdsFromTabsInScope","immune","immuneCharts","componentsInScope","traverse","currentNode","filterId","checkedChartIds","currentValue","chartChildren","chartsImmune","child","getFilterScopeFromNodesTree","filterKey","nodes","chartId"],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { flow, keyBy, mapValues } from 'lodash/fp';\nimport { flatMap, isEmpty } from 'lodash';\n\nimport { CHART_TYPE, TAB_TYPE } from './componentTypes';\nimport { getChartIdAndColumnFromFilterKey } from './getDashboardFilterKey';\n\nfunction getImmuneChartIdsFromTabsNotInScope({ tabs = [], tabsInScope = [] }) {\n  const chartsNotInScope = [];\n  tabs.forEach(({ value: tab, children: tabChildren }) => {\n    if (tabChildren && !tabsInScope.includes(tab)) {\n      tabChildren.forEach(({ value: subTab, children: subTabChildren }) => {\n        if (subTabChildren && !tabsInScope.includes(subTab)) {\n          chartsNotInScope.push(\n            ...subTabChildren.filter(({ type }) => type === CHART_TYPE),\n          );\n        }\n      });\n    }\n  });\n\n  // return chartId only\n  return chartsNotInScope.map(({ value }) => value);\n}\nfunction getTabChildrenScope({\n  tabScopes,\n  parentNodeValue,\n  forceAggregate = false,\n  hasChartSiblings = false,\n  tabChildren = [],\n  immuneChartSiblings = [],\n}) {\n  // if all sub-tabs are in scope, or forceAggregate =  true\n  // aggregate scope to parentNodeValue\n  if (\n    forceAggregate ||\n    (!hasChartSiblings &&\n      Object.entries(tabScopes).every(\n        ([key, { scope }]) => scope && scope.length && key === scope[0],\n      ))\n  ) {\n    // get all charts from tabChildren that is not in scope\n    const immuneChartIdsFromTabsNotInScope = getImmuneChartIdsFromTabsNotInScope(\n      {\n        tabs: tabChildren,\n        tabsInScope: flatMap(tabScopes, ({ scope }) => scope),\n      },\n    );\n    const immuneChartIdsFromTabsInScope = flatMap(\n      Object.values(tabScopes),\n      ({ immune }) => immune,\n    );\n    const immuneCharts = [\n      ...new Set([\n        ...immuneChartIdsFromTabsNotInScope,\n        ...immuneChartIdsFromTabsInScope,\n      ]),\n    ];\n    return {\n      scope: [parentNodeValue],\n      immune: immuneCharts,\n    };\n  }\n\n  const componentsInScope = Object.values(tabScopes).filter(\n    ({ scope }) => scope && scope.length,\n  );\n  return {\n    scope: flatMap(componentsInScope, ({ scope }) => scope),\n    immune: componentsInScope.length\n      ? flatMap(componentsInScope, ({ immune }) => immune)\n      : flatMap(Object.values(tabScopes), ({ immune }) => immune).concat(\n          immuneChartSiblings,\n        ),\n  };\n}\n\nfunction traverse({ currentNode = {}, filterId, checkedChartIds = [] }) {\n  if (!currentNode) {\n    return {};\n  }\n\n  const { value: currentValue, children } = currentNode;\n  const chartChildren = children.filter(({ type }) => type === CHART_TYPE);\n  const tabChildren = children.filter(({ type }) => type === TAB_TYPE);\n\n  const chartsImmune = chartChildren\n    .filter(\n      ({ value }) => filterId !== value && !checkedChartIds.includes(value),\n    )\n    .map(({ value }) => value);\n  const tabScopes = flow(\n    keyBy(child => child.value),\n    mapValues(child =>\n      traverse({\n        currentNode: child,\n        filterId,\n        checkedChartIds,\n      }),\n    ),\n  )(tabChildren);\n\n  // if any chart type child is in scope,\n  // no matter has tab children or not, current node should be scope\n  if (\n    !isEmpty(chartChildren) &&\n    chartChildren.some(({ value }) => checkedChartIds.includes(value))\n  ) {\n    if (isEmpty(tabChildren)) {\n      return { scope: [currentValue], immune: chartsImmune };\n    }\n\n    const { scope, immune } = getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      forceAggregate: true,\n      tabChildren,\n    });\n    return {\n      scope,\n      immune: chartsImmune.concat(immune),\n    };\n  }\n\n  // has tab children but only some sub-tab in scope\n  if (tabChildren.length) {\n    return getTabChildrenScope({\n      tabScopes,\n      parentNodeValue: currentValue,\n      hasChartSiblings: !isEmpty(chartChildren),\n      tabChildren,\n      immuneChartSiblings: chartsImmune,\n    });\n  }\n\n  // no tab children and no chart children in scope\n  return {\n    scope: [],\n    immune: chartsImmune,\n  };\n}\n\nexport default function getFilterScopeFromNodesTree({\n  filterKey,\n  nodes = [],\n  checkedChartIds = [],\n}) {\n  if (nodes.length) {\n    const { chartId } = getChartIdAndColumnFromFilterKey(filterKey);\n    return traverse({\n      currentNode: nodes[0],\n      filterId: chartId,\n      checkedChartIds,\n    });\n  }\n\n  return {};\n}\n"]},"metadata":{},"sourceType":"module"}