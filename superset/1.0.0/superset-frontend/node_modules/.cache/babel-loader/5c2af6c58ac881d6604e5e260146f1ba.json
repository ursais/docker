{"ast":null,"code":"import \"core-js/modules/web.dom-collections.iterator.js\";import _Object$values from \"@babel/runtime-corejs3/core-js-stable/object/values\";import _mapInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/map\";import _findInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/find\";import _someInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/some\";import _filterInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/filter\";import _forEachInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/for-each\";import _includesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/includes\";import _valuesInstanceProperty from \"@babel/runtime-corejs3/core-js-stable/instance/values\";(function () {var enterModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.enterModule : undefined;enterModule && enterModule(module);})();var __signature__ = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default.signature : function (a) {return a;};import shortid from 'shortid';\nimport { getInitialDataMask } from 'src/dataMask/reducer';\nexport const REMOVAL_DELAY_SECS = 5;\nexport const validateForm = async (form, currentFilterId, filterConfigMap, filterIds, removedFilters, setCurrentFilterId) => {\n  const addValidationError = (filterId, field, error) => {\n    const fieldError = {\n      name: ['filters', filterId, field],\n      errors: [error] };\n\n    form.setFields([fieldError]);\n  };\n  try {var _context;\n    let formValues;\n    try {\n      formValues = await form.validateFields();\n    }\n    catch (error) {var _error$errorFields;\n      // In Jest tests in chain of tests, Ant generate `outOfDate` error so need to catch it here\n      if (!(error != null && (_error$errorFields = error.errorFields) != null && _error$errorFields.length) && error != null && error.outOfDate) {\n        formValues = _valuesInstanceProperty(error);\n      } else\n      {\n        throw error;\n      }\n    }\n    const validateInstant = filterId => {var _filterConfigMap$filt;\n      const isInstant = formValues.filters[filterId] ?\n      formValues.filters[filterId].isInstant : (_filterConfigMap$filt =\n      filterConfigMap[filterId]) == null ? void 0 : _filterConfigMap$filt.isInstant;\n      if (!isInstant) {\n        addValidationError(filterId, 'isInstant', 'For hierarchical filters changes must be applied instantly');\n      }\n    };\n    const validateCycles = (filterId, trace = []) => {var _formValues$filters$f, _filterConfigMap$filt2, _filterConfigMap$filt3;\n      if (_includesInstanceProperty(trace).call(trace, filterId)) {\n        addValidationError(filterId, 'parentFilter', 'Cannot create cyclic hierarchy');\n      }\n      const parentId = formValues.filters[filterId] ? (_formValues$filters$f =\n      formValues.filters[filterId].parentFilter) == null ? void 0 : _formValues$filters$f.value : (_filterConfigMap$filt2 =\n      filterConfigMap[filterId]) == null ? void 0 : (_filterConfigMap$filt3 = _filterConfigMap$filt2.cascadeParentIds) == null ? void 0 : _filterConfigMap$filt3[0];\n      if (parentId) {\n        validateInstant(parentId);\n        validateCycles(parentId, [...trace, filterId]);\n      }\n    };\n    _forEachInstanceProperty(_context = _filterInstanceProperty(filterIds).call(filterIds,\n    id => !removedFilters[id])).call(_context,\n    filterId => validateCycles(filterId));\n    return formValues;\n  }\n  catch (error) {\n    console.warn('Filter configuration failed:', error);\n    if (!error.errorFields || !error.errorFields.length)\n    return null; // not a validation error\n    const errorFields = error.errorFields;\n    // filter id is the second item in the field name\n    if (!_someInstanceProperty(errorFields).call(errorFields, field => field.name[1] === currentFilterId)) {\n      // switch to the first tab that had a validation error\n      const filterError = _findInstanceProperty(errorFields).call(errorFields, field => field.name[0] === 'filters');\n      if (filterError) {\n        setCurrentFilterId(filterError.name[1]);\n      }\n    }\n    return null;\n  }\n};\nexport const createHandleSave = (filterConfigMap, filterIds, removedFilters, resetForm, saveForm, values) => async () => {var _context2;\n  const newFilterConfig = _mapInstanceProperty(_context2 = _filterInstanceProperty(filterIds).call(filterIds,\n  id => !removedFilters[id])).call(_context2,\n  id => {var _formInputs$controlVa, _context3, _formInputs$requiredF, _formInputs$defaultDa;\n    // create a filter config object from the form inputs\n    const formInputs = values.filters[id];\n    // if user didn't open a filter, return the original config\n    if (!formInputs)\n    return filterConfigMap[id];\n    const target = {};\n    if (formInputs.dataset) {\n      target.datasetId = formInputs.dataset.value;\n    }\n    if (formInputs.dataset && formInputs.column) {\n      target.column = { name: formInputs.column };\n    }\n    return {\n      id,\n      adhoc_filters: formInputs.adhoc_filters,\n      time_range: formInputs.time_range,\n      controlValues: (_formInputs$controlVa = formInputs.controlValues) != null ? _formInputs$controlVa : {},\n      requiredFirst: _findInstanceProperty(_context3 = _Object$values((_formInputs$requiredF = formInputs.requiredFirst) != null ? _formInputs$requiredF : {})).call(_context3, rf => rf),\n      name: formInputs.name,\n      filterType: formInputs.filterType,\n      // for now there will only ever be one target\n      targets: [target],\n      defaultDataMask: (_formInputs$defaultDa = formInputs.defaultDataMask) != null ? _formInputs$defaultDa : getInitialDataMask(),\n      cascadeParentIds: formInputs.parentFilter ?\n      [formInputs.parentFilter.value] :\n      [],\n      scope: formInputs.scope,\n      isInstant: formInputs.isInstant,\n      sortMetric: formInputs.sortMetric };\n\n  });\n  await saveForm(newFilterConfig);\n  resetForm();\n};\nexport const createHandleTabEdit = (setRemovedFilters, setSaveAlertVisible, addFilter) => (filterId, action) => {\n  const completeFilterRemoval = filterId => {\n    // the filter state will actually stick around in the form,\n    // and the filterConfig/newFilterIds, but we use removedFilters\n    // to mark it as removed.\n    setRemovedFilters(removedFilters => ({\n      ...removedFilters,\n      [filterId]: { isPending: false } }));\n\n  };\n  if (action === 'remove') {\n    // first set up the timer to completely remove it\n    const timerId = window.setTimeout(() => completeFilterRemoval(filterId), REMOVAL_DELAY_SECS * 1000);\n    // mark the filter state as \"removal in progress\"\n    setRemovedFilters(removedFilters => ({\n      ...removedFilters,\n      [filterId]: { isPending: true, timerId } }));\n\n    setSaveAlertVisible(false);\n  } else\n  if (action === 'add') {\n    addFilter();\n  }\n};\nexport const NATIVE_FILTER_PREFIX = 'NATIVE_FILTER-';\nexport const generateFilterId = () => `${NATIVE_FILTER_PREFIX}${shortid.generate()}`;\nexport const getFilterIds = config => _mapInstanceProperty(config).call(config, filter => filter.id);;(function () {var reactHotLoader = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.default : undefined;if (!reactHotLoader) {return;}reactHotLoader.register(REMOVAL_DELAY_SECS, \"REMOVAL_DELAY_SECS\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(validateForm, \"validateForm\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(createHandleSave, \"createHandleSave\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(createHandleTabEdit, \"createHandleTabEdit\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(NATIVE_FILTER_PREFIX, \"NATIVE_FILTER_PREFIX\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(generateFilterId, \"generateFilterId\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");reactHotLoader.register(getFilterIds, \"getFilterIds\", \"/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts\");})();;(function () {var leaveModule = typeof reactHotLoaderGlobal !== 'undefined' ? reactHotLoaderGlobal.leaveModule : undefined;leaveModule && leaveModule(module);})();","map":{"version":3,"sources":["/app/superset-frontend/src/dashboard/components/nativeFilters/FiltersConfigModal/utils.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\nimport { FormInstance } from 'antd/lib/form';\nimport shortid from 'shortid';\nimport { getInitialDataMask } from 'src/dataMask/reducer';\nimport { FilterRemoval, NativeFiltersForm } from './types';\nimport { Filter, FilterConfiguration, Target } from '../types';\n\nexport const REMOVAL_DELAY_SECS = 5;\n\nexport const validateForm = async (\n  form: FormInstance<NativeFiltersForm>,\n  currentFilterId: string,\n  filterConfigMap: Record<string, Filter>,\n  filterIds: string[],\n  removedFilters: Record<string, FilterRemoval>,\n  setCurrentFilterId: Function,\n) => {\n  const addValidationError = (\n    filterId: string,\n    field: string,\n    error: string,\n  ) => {\n    const fieldError = {\n      name: ['filters', filterId, field],\n      errors: [error],\n    };\n    form.setFields([fieldError]);\n  };\n\n  try {\n    let formValues: NativeFiltersForm;\n    try {\n      formValues = (await form.validateFields()) as NativeFiltersForm;\n    } catch (error) {\n      // In Jest tests in chain of tests, Ant generate `outOfDate` error so need to catch it here\n      if (!error?.errorFields?.length && error?.outOfDate) {\n        formValues = error.values;\n      } else {\n        throw error;\n      }\n    }\n    const validateInstant = (filterId: string) => {\n      const isInstant = formValues.filters[filterId]\n        ? formValues.filters[filterId].isInstant\n        : filterConfigMap[filterId]?.isInstant;\n      if (!isInstant) {\n        addValidationError(\n          filterId,\n          'isInstant',\n          'For hierarchical filters changes must be applied instantly',\n        );\n      }\n    };\n\n    const validateCycles = (filterId: string, trace: string[] = []) => {\n      if (trace.includes(filterId)) {\n        addValidationError(\n          filterId,\n          'parentFilter',\n          'Cannot create cyclic hierarchy',\n        );\n      }\n      const parentId = formValues.filters[filterId]\n        ? formValues.filters[filterId].parentFilter?.value\n        : filterConfigMap[filterId]?.cascadeParentIds?.[0];\n      if (parentId) {\n        validateInstant(parentId);\n        validateCycles(parentId, [...trace, filterId]);\n      }\n    };\n\n    filterIds\n      .filter(id => !removedFilters[id])\n      .forEach(filterId => validateCycles(filterId));\n\n    return formValues;\n  } catch (error) {\n    console.warn('Filter configuration failed:', error);\n\n    if (!error.errorFields || !error.errorFields.length) return null; // not a validation error\n\n    // the name is in array format since the fields are nested\n    type ErrorFields = { name: ['filters', string, string] }[];\n    const errorFields = error.errorFields as ErrorFields;\n    // filter id is the second item in the field name\n    if (!errorFields.some(field => field.name[1] === currentFilterId)) {\n      // switch to the first tab that had a validation error\n      const filterError = errorFields.find(\n        field => field.name[0] === 'filters',\n      );\n      if (filterError) {\n        setCurrentFilterId(filterError.name[1]);\n      }\n    }\n    return null;\n  }\n};\n\nexport const createHandleSave = (\n  filterConfigMap: Record<string, Filter>,\n  filterIds: string[],\n  removedFilters: Record<string, FilterRemoval>,\n  resetForm: Function,\n  saveForm: Function,\n  values: NativeFiltersForm,\n) => async () => {\n  const newFilterConfig: FilterConfiguration = filterIds\n    .filter(id => !removedFilters[id])\n    .map(id => {\n      // create a filter config object from the form inputs\n      const formInputs = values.filters[id];\n      // if user didn't open a filter, return the original config\n      if (!formInputs) return filterConfigMap[id];\n      const target: Partial<Target> = {};\n      if (formInputs.dataset) {\n        target.datasetId = formInputs.dataset.value;\n      }\n      if (formInputs.dataset && formInputs.column) {\n        target.column = { name: formInputs.column };\n      }\n      return {\n        id,\n        adhoc_filters: formInputs.adhoc_filters,\n        time_range: formInputs.time_range,\n        controlValues: formInputs.controlValues ?? {},\n        requiredFirst: Object.values(formInputs.requiredFirst ?? {}).find(\n          rf => rf,\n        ),\n        name: formInputs.name,\n        filterType: formInputs.filterType,\n        // for now there will only ever be one target\n        targets: [target],\n        defaultDataMask: formInputs.defaultDataMask ?? getInitialDataMask(),\n        cascadeParentIds: formInputs.parentFilter\n          ? [formInputs.parentFilter.value]\n          : [],\n        scope: formInputs.scope,\n        isInstant: formInputs.isInstant,\n        sortMetric: formInputs.sortMetric,\n      };\n    });\n\n  await saveForm(newFilterConfig);\n  resetForm();\n};\n\nexport const createHandleTabEdit = (\n  setRemovedFilters: (\n    value:\n      | ((\n          prevState: Record<string, FilterRemoval>,\n        ) => Record<string, FilterRemoval>)\n      | Record<string, FilterRemoval>,\n  ) => void,\n  setSaveAlertVisible: Function,\n  addFilter: Function,\n) => (filterId: string, action: 'add' | 'remove') => {\n  const completeFilterRemoval = (filterId: string) => {\n    // the filter state will actually stick around in the form,\n    // and the filterConfig/newFilterIds, but we use removedFilters\n    // to mark it as removed.\n    setRemovedFilters(removedFilters => ({\n      ...removedFilters,\n      [filterId]: { isPending: false },\n    }));\n  };\n\n  if (action === 'remove') {\n    // first set up the timer to completely remove it\n    const timerId = window.setTimeout(\n      () => completeFilterRemoval(filterId),\n      REMOVAL_DELAY_SECS * 1000,\n    );\n    // mark the filter state as \"removal in progress\"\n    setRemovedFilters(removedFilters => ({\n      ...removedFilters,\n      [filterId]: { isPending: true, timerId },\n    }));\n    setSaveAlertVisible(false);\n  } else if (action === 'add') {\n    addFilter();\n  }\n};\n\nexport const NATIVE_FILTER_PREFIX = 'NATIVE_FILTER-';\nexport const generateFilterId = () =>\n  `${NATIVE_FILTER_PREFIX}${shortid.generate()}`;\n\nexport const getFilterIds = (config: FilterConfiguration) =>\n  config.map(filter => filter.id);\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}