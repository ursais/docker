{"version":3,"sources":["../../../src/worker-utils/worker-utils.js"],"names":["assert","getTransferList","object","recursive","transfers","ArrayBuffer","push","buffer","key","workerURLCache","Map","getWorkerURL","workerSource","startsWith","endsWith","match","workerURL","get","blob","Blob","type","URL","createObjectURL","set"],"mappings":";AACA,OAAOA,MAAP,MAAmB,iBAAnB;AAEA,OAAO,SAASC,eAAT,CAAyBC,MAAzB,EAAmE;AAAA,MAAlCC,SAAkC,uEAAtB,IAAsB;AAAA,MAAhBC,SAAgB,uEAAJ,EAAI;;AACxE,MAAI,CAACF,MAAL,EAAa,CAEZ,CAFD,MAEO,IAAIA,MAAM,YAAYG,WAAtB,EAAmC;AACxCD,IAAAA,SAAS,CAACE,IAAV,CAAeJ,MAAf;AACD,GAFM,MAEA,IAAIA,MAAM,CAACK,MAAP,IAAiBL,MAAM,CAACK,MAAP,YAAyBF,WAA9C,EAA2D;AAEhED,IAAAA,SAAS,CAACE,IAAV,CAAeJ,MAAM,CAACK,MAAtB;AACD,GAHM,MAGA,IAAIJ,SAAS,IAAI,QAAOD,MAAP,MAAkB,QAAnC,EAA6C;AAClD,SAAK,IAAMM,GAAX,IAAkBN,MAAlB,EAA0B;AAExBD,MAAAA,eAAe,CAACC,MAAM,CAACM,GAAD,CAAP,EAAcL,SAAd,EAAyBC,SAAzB,CAAf;AACD;AACF;;AACD,SAAOA,SAAP;AACD;AAED,IAAMK,cAAc,GAAG,IAAIC,GAAJ,EAAvB;AAIA,OAAO,SAASC,YAAT,CAAsBC,YAAtB,EAAoC;AACzCZ,EAAAA,MAAM,CAAC,OAAOY,YAAP,KAAwB,QAAzB,EAAmC,eAAnC,CAAN;;AAKA,MAAIA,YAAY,CAACC,UAAb,CAAwB,MAAxB,KAAmCD,YAAY,CAACE,QAAb,CAAsB,GAAtB,CAAvC,EAAmE;AACjE,WAAOF,YAAY,CAACG,KAAb,CAAmB,eAAnB,EAAoC,CAApC,CAAP;AACD;;AAED,MAAIC,SAAS,GAAGP,cAAc,CAACQ,GAAf,CAAmBL,YAAnB,CAAhB;;AAEA,MAAI,CAACI,SAAL,EAAgB;AACd,QAAME,IAAI,GAAG,IAAIC,IAAJ,CAAS,CAACP,YAAD,CAAT,EAAyB;AAACQ,MAAAA,IAAI,EAAE;AAAP,KAAzB,CAAb;AAEAJ,IAAAA,SAAS,GAAGK,GAAG,CAACC,eAAJ,CAAoBJ,IAApB,CAAZ;AACAT,IAAAA,cAAc,CAACc,GAAf,CAAmBX,YAAnB,EAAiCI,SAAjC;AACD;;AAED,SAAOA,SAAP;AACD","sourcesContent":["/* global URL, Blob */\nimport assert from '../utils/assert';\n\nexport function getTransferList(object, recursive = true, transfers = []) {\n  if (!object) {\n    // ignore\n  } else if (object instanceof ArrayBuffer) {\n    transfers.push(object);\n  } else if (object.buffer && object.buffer instanceof ArrayBuffer) {\n    // Typed array\n    transfers.push(object.buffer);\n  } else if (recursive && typeof object === 'object') {\n    for (const key in object) {\n      // Avoid perf hit - only go one level deep\n      getTransferList(object[key], recursive, transfers);\n    }\n  }\n  return transfers;\n}\n\nconst workerURLCache = new Map();\n\n// Creates a URL from worker source that can be used to create `Worker` instances\n// Packages (and then caches) the result of `webworkify` as an \"Object URL\"\nexport function getWorkerURL(workerSource) {\n  assert(typeof workerSource === 'string', 'worker source');\n\n  // url(./worker.js)\n  // This pattern is used to differentiate worker urls from worker source code\n  // Load from url is needed for testing, when using Webpack & webworker target\n  if (workerSource.startsWith('url(') && workerSource.endsWith(')')) {\n    return workerSource.match(/^url\\((.*)\\)$/)[1];\n  }\n\n  let workerURL = workerURLCache.get(workerSource);\n\n  if (!workerURL) {\n    const blob = new Blob([workerSource], {type: 'application/javascript'});\n    // const blob = webworkify(workerSource, {bare: true});\n    workerURL = URL.createObjectURL(blob);\n    workerURLCache.set(workerSource, workerURL);\n  }\n\n  return workerURL;\n}\n"],"file":"worker-utils.js"}