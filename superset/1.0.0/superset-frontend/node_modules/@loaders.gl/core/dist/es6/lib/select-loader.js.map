{"version":3,"sources":["../../../src/lib/select-loader.js"],"names":["getRegisteredLoaders","normalizeLoader","EXT_PATTERN","DATA_URL_PATTERN","selectLoader","loaders","url","data","nothrow","Array","isArray","loader","normalizeLoaders","replace","findLoaderByUrl","findLoaderByExamingInitialData","Error","match","mimeType","findLoaderByMimeType","extension","findLoaderByExtension","mimeTypes","includes","toLowerCase","loaderExtension","extensions","testText","ArrayBuffer","isView","testBinary","buffer","byteOffset","type","test","tests","some","magic","getMagicString","length","arrayBuffer","byteLength","dataView","DataView","i","String","fromCharCode","getUint8"],"mappings":"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","sourcesContent":["import {getRegisteredLoaders} from './register-loaders';\nimport {normalizeLoader} from './loader-utils/normalize-loader';\n\nconst EXT_PATTERN = /\\.([^.]+)$/;\nconst DATA_URL_PATTERN = /^data:(.*?)(;|,)/;\n\n// Find a loader that matches file extension and/or initial file content\n// Search the loaders array argument for a loader that matches url extension or initial data\n// Returns: a normalized loader\n\n// TODO - Need a variant that peeks at streams for parseInBatches\n// TODO - Detect multiple matching loaders? Use heuristics to grade matches?\n// TODO - Allow apps to pass context to disambiguate between multiple matches (e.g. multiple .json formats)?\n\nexport function selectLoader(loaders, url = '', data = null, {nothrow = false} = {}) {\n  url = url || '';\n\n  // if only a single loader was provided (not as array), force its use\n  // TODO - Should this behaviour be kept and documented?\n  if (loaders && !Array.isArray(loaders)) {\n    const loader = loaders;\n    normalizeLoader(loader);\n    return loader;\n  }\n\n  // If no loaders provided, get the registered loaders\n  loaders = loaders || getRegisteredLoaders();\n  normalizeLoaders(loaders);\n\n  url = url.replace(/\\?.*/, '');\n  let loader = null;\n  loader = loader || findLoaderByUrl(loaders, url);\n  loader = loader || findLoaderByExamingInitialData(loaders, data);\n\n  // no loader available\n  if (!loader) {\n    if (nothrow) {\n      return null;\n    }\n    throw new Error(`No valid loader found for ${url}`);\n  }\n\n  return loader;\n}\n\nfunction normalizeLoaders(loaders) {\n  for (const loader of loaders) {\n    normalizeLoader(loader);\n  }\n}\n\n// TODO - Would be nice to support http://example.com/file.glb?parameter=1\n// E.g: x = new URL('http://example.com/file.glb?load=1'; x.pathname\nfunction findLoaderByUrl(loaders, url) {\n  // Check for data url\n  let match = url.match(DATA_URL_PATTERN);\n  const mimeType = match && match[1];\n  if (mimeType) {\n    return findLoaderByMimeType(loaders, mimeType);\n  }\n  // Get extension\n  match = url.match(EXT_PATTERN);\n  const extension = match && match[1];\n  const loader = extension && findLoaderByExtension(loaders, extension);\n  return loader;\n}\n\nfunction findLoaderByMimeType(loaders, mimeType) {\n  for (const loader of loaders) {\n    if (loader.mimeTypes && loader.mimeTypes.includes(mimeType)) {\n      return loader;\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByExtension(loaders, extension) {\n  extension = extension.toLowerCase();\n\n  for (const loader of loaders) {\n    for (const loaderExtension of loader.extensions) {\n      if (loaderExtension.toLowerCase() === extension) {\n        return loader;\n      }\n    }\n  }\n  return null;\n}\n\nfunction findLoaderByExamingInitialData(loaders, data) {\n  if (!data) {\n    return null;\n  }\n\n  for (const loader of loaders) {\n    if (typeof data === 'string') {\n      if (testText(data, loader)) {\n        return loader;\n      }\n    } else if (ArrayBuffer.isView(data)) {\n      // Typed Arrays can have offsets into underlying buffer\n      if (testBinary(data.buffer, data.byteOffset, loader)) {\n        return loader;\n      }\n    } else if (data instanceof ArrayBuffer) {\n      const byteOffset = 0;\n      if (testBinary(data, byteOffset, loader)) {\n        return loader;\n      }\n    }\n    // TODO Handle streaming case (requires creating a new AsyncIterator)\n  }\n  return null;\n}\n\nfunction testText(data, loader) {\n  return loader.testText && loader.testText(data);\n}\n\nfunction testBinary(data, byteOffset, loader) {\n  const type = Array.isArray(loader.test) ? 'array' : typeof loader.test;\n  switch (type) {\n    case 'function':\n      return loader.test(data, loader);\n\n    case 'string':\n    case 'array':\n      // Magic bytes check: If `loader.test` is a string or array of strings,\n      // check if binary data starts with one of those strings\n      const tests = Array.isArray(loader.test) ? loader.test : [loader.test];\n      return tests.some(test => {\n        const magic = getMagicString(data, byteOffset, test.length);\n        return test === magic;\n      });\n\n    default:\n      return false;\n  }\n}\n\nfunction getMagicString(arrayBuffer, byteOffset, length) {\n  if (arrayBuffer.byteLength <= byteOffset + length) {\n    return '';\n  }\n  const dataView = new DataView(arrayBuffer);\n  let magic = '';\n  for (let i = 0; i < length; i++) {\n    magic += String.fromCharCode(dataView.getUint8(byteOffset + i));\n  }\n  return magic;\n}\n"],"file":"select-loader.js"}