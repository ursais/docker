{"version":3,"sources":["../../../src/javascript-utils/stream-utils.js"],"names":["isBrowser","nodeVersion","getStreamIterator","stream","Symbol","asyncIterator","getIterator","makeBrowserStreamIterator","makeNodeStreamIterator","reader","getReader","done","value","read","error","releaseLock","data","_readableState","ended","onceReadable","Promise","resolve","once"],"mappings":";;AAAA,SAAQA,SAAR,EAAmBC,WAAnB,QAAqC,kBAArC;AAEA,OAAO,SAASC,iBAAT,CAA2BC,MAA3B,EAAmC;AAExC,MAAIH,SAAS,IAAIC,WAAW,IAAI,EAAhC,EAAoC;AAElC,QAAI,OAAOE,MAAM,CAACC,MAAM,CAACC,aAAR,CAAb,KAAwC,UAA5C,EAAwD;AACtD,aAAOF,MAAP;AACD;;AAGD,QAAI,OAAOA,MAAM,CAACG,WAAd,KAA8B,UAAlC,EAA8C;AAC5C,aAAOH,MAAM,CAACG,WAAP,EAAP;AACD;AACF;;AAED,SAAON,SAAS,GAAGO,yBAAyB,CAACJ,MAAD,CAA5B,GAAuCK,sBAAsB,CAACL,MAAD,CAA7E;AACD;;SAKeI,yB;;;;;mDAAhB,WAA0CJ,MAA1C,EAAkD;AAEhD,UAAMM,MAAM,GAAGN,MAAM,CAACO,SAAP,EAAf;;AAEA,QAAI;AAEF,aAAO,IAAP,EAAa;AAEX,cAAM;AAACC,UAAAA,IAAD;AAAOC,UAAAA;AAAP,uCAAsBH,MAAM,CAACI,IAAP,EAAtB,CAAN;;AAEA,YAAIF,IAAJ,EAAU;AACR;AACD;;AAED,cAAMC,KAAN;AACD;AACF,KAZD,CAYE,OAAOE,KAAP,EAAc;AAGdL,MAAAA,MAAM,CAACM,WAAP;AACD;AACF,G;;;;SAKeP,sB;;;;;gDAAhB,WAAuCL,MAAvC,EAA+C;AAE7CA,IAAAA,MAAM,8BAASA,MAAT,CAAN;;AAGA,WAAO,IAAP,EAAa;AACX,YAAMa,IAAI,GAAGb,MAAM,CAACU,IAAP,EAAb;;AACA,UAAIG,IAAI,KAAK,IAAb,EAAmB;AACjB,cAAMA,IAAN;AAEA;AACD;;AACD,UAAIb,MAAM,CAACc,cAAP,CAAsBC,KAA1B,EAAiC;AAC/B;AACD;;AACD,iCAAMC,YAAY,CAAChB,MAAD,CAAlB;AACD;AACF,G;;;;AAED,eAAegB,YAAf,CAA4BhB,MAA5B,EAAoC;AAClC,SAAO,IAAIiB,OAAJ,CAAYC,OAAO,IAAI;AAC5BlB,IAAAA,MAAM,CAACmB,IAAP,CAAY,UAAZ,EAAwBD,OAAxB;AACD,GAFM,CAAP;AAGD","sourcesContent":["import {isBrowser, nodeVersion} from '../utils/globals';\n\nexport function getStreamIterator(stream) {\n  // Hacky test for node version to ensure we don't call bad polyfills\n  if (isBrowser || nodeVersion >= 10) {\n    // NODE 10+: stream is an asyncIterator\n    if (typeof stream[Symbol.asyncIterator] === 'function') {\n      return stream;\n    }\n\n    // WhatWG: stream is supposed to have a `getIterator` method\n    if (typeof stream.getIterator === 'function') {\n      return stream.getIterator();\n    }\n  }\n\n  return isBrowser ? makeBrowserStreamIterator(stream) : makeNodeStreamIterator(stream);\n}\n\n// BROWSER IMPLEMENTATION\n// See https://jakearchibald.com/2017/async-iterators-and-generators/#making-streams-iterate\n\nasync function* makeBrowserStreamIterator(stream) {\n  // In the brower, we first need to get a lock on the stream\n  const reader = stream.getReader();\n\n  try {\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      // Read from the stream\n      const {done, value} = await reader.read();\n      // Exit if we're done\n      if (done) {\n        return;\n      }\n      // Else yield the chunk\n      yield value;\n    }\n  } catch (error) {\n    // TODO - examples makes it look like this should always be called,\n    // but that generates exceptions so only call it if we do not reach the end\n    reader.releaseLock();\n  }\n}\n\n// NODE <10 IMPLEMENTATION\n// See https://github.com/bustle/streaming-iterables, MIT license\n\nasync function* makeNodeStreamIterator(stream) {\n  // Node createStream will return promises to handle http requests\n  stream = await stream;\n\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const data = stream.read();\n    if (data !== null) {\n      yield data;\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n    if (stream._readableState.ended) {\n      return;\n    }\n    await onceReadable(stream);\n  }\n}\n\nasync function onceReadable(stream) {\n  return new Promise(resolve => {\n    stream.once('readable', resolve);\n  });\n}\n\n// TODO - we could add our own polyfill\n// const {Readable} = require('stream');\n// if (typeof Readable !== 'undefined' && !Readable.prototype[Symbol.asyncIterator]) {\n//   Readable.prototype[Symbol.asyncIterator] = function () {\n//     return makeNodeStreamIterator(this);\n//   }\n// }\n"],"file":"stream-utils.js"}