{"version":3,"sources":["../../../src/lib/parse-sync.js"],"names":["parseSync","data","loaders","options","url","Array","isArray","loader","context","parseWithLoaderSync","parseTextSync","Error","name"],"mappings":";;;;;;;AAAA;;AACA;;AACA;;AACA;;AACA;;AAEO,SAASA,SAAT,CAAmBC,IAAnB,EAAyBC,OAAzB,EAAkCC,OAAlC,EAA2CC,GAA3C,EAAgD;AAGrD,MAAI,CAACC,KAAK,CAACC,OAAN,CAAcJ,OAAd,CAAD,IAA2B,CAAC,qCAAeA,OAAf,CAAhC,EAAyD;AACvDE,IAAAA,GAAG,GAAGD,OAAN;AACAA,IAAAA,OAAO,GAAGD,OAAV;AACAA,IAAAA,OAAO,GAAG,IAAV;AACD;;AAGD,MAAMK,MAAM,GAAG,gCAAaL,OAAb,EAAsBE,GAAtB,EAA2BH,IAA3B,CAAf;;AAEA,MAAI,CAACM,MAAL,EAAa;AACX,WAAO,IAAP;AACD;;AAGDJ,EAAAA,OAAO,GAAG,iDAA0BA,OAA1B,EAAmCI,MAAnC,CAAV;AAEA,MAAMC,OAAO,GAAG,wCAAiB;AAACJ,IAAAA,GAAG,EAAHA,GAAD;AAAMJ,IAAAA,SAAS,EAATA;AAAN,GAAjB,EAAmCG,OAAnC,CAAhB;AAEA,SAAOM,mBAAmB,CAACF,MAAD,EAASN,IAAT,EAAeE,OAAf,EAAwBK,OAAxB,CAA1B;AACD;;AAGD,SAASC,mBAAT,CAA6BF,MAA7B,EAAqCN,IAArC,EAA2CE,OAA3C,EAAoDK,OAApD,EAA6D;AAC3DP,EAAAA,IAAI,GAAG,iDAAmCA,IAAnC,EAAyCM,MAAzC,CAAP;;AAEA,MAAIA,MAAM,CAACG,aAAP,IAAwB,OAAOT,IAAP,KAAgB,QAA5C,EAAsD;AACpD,WAAOM,MAAM,CAACG,aAAP,CAAqBT,IAArB,EAA2BE,OAA3B,EAAoCK,OAApC,EAA6CD,MAA7C,CAAP;AACD;;AAED,MAAIA,MAAM,CAACP,SAAX,EAAsB;AACpB,WAAOO,MAAM,CAACP,SAAP,CAAiBC,IAAjB,EAAuBE,OAAvB,EAAgCK,OAAhC,EAAyCD,MAAzC,CAAP;AACD;;AAGD,QAAM,IAAII,KAAJ,2BAA6BH,OAAO,CAACJ,GAAR,IAAe,MAA5C,oBAA4DG,MAAM,CAACK,IAAnE,aAAN;AACD","sourcesContent":["import {selectLoader} from './select-loader';\nimport {isLoaderObject} from './loader-utils/normalize-loader';\nimport {mergeLoaderAndUserOptions} from './loader-utils/normalize-options';\nimport {getArrayBufferOrStringFromDataSync} from './loader-utils/get-data';\nimport {getLoaderContext} from './loader-utils/get-loader-context';\n\nexport function parseSync(data, loaders, options, url) {\n  // Signature: parseSync(data, options, url)\n  // Uses registered loaders\n  if (!Array.isArray(loaders) && !isLoaderObject(loaders)) {\n    url = options;\n    options = loaders;\n    loaders = null;\n  }\n\n  // Chooses a loader and normalize it\n  const loader = selectLoader(loaders, url, data);\n  // Note: if nothrow option was set, it is possible that no loader was found, if so just return null\n  if (!loader) {\n    return null;\n  }\n\n  // Normalize options\n  options = mergeLoaderAndUserOptions(options, loader);\n\n  const context = getLoaderContext({url, parseSync}, options);\n\n  return parseWithLoaderSync(loader, data, options, context);\n}\n\n// TODO - should accept loader.parseSync/parse and generate 1 chunk asyncIterator\nfunction parseWithLoaderSync(loader, data, options, context) {\n  data = getArrayBufferOrStringFromDataSync(data, loader);\n\n  if (loader.parseTextSync && typeof data === 'string') {\n    return loader.parseTextSync(data, options, context, loader);\n  }\n\n  if (loader.parseSync) {\n    return loader.parseSync(data, options, context, loader);\n  }\n\n  // TBD - If synchronous parser not available, return null\n  throw new Error(`Could not parse ${context.url || 'data'} using ${loader.name} loader`);\n}\n"],"file":"parse-sync.js"}