{"version":3,"sources":["../../../src/worker-utils/worker-pool.js"],"names":["WorkerPool","source","name","maxConcurrency","onMessage","onDebug","jobQueue","idleQueue","count","isDestroyed","forEach","worker","destroy","data","jobName","Promise","resolve","reject","push","_startQueuedJob","length","_getAvailableWorker","job","shift","message","backlog","process","then","result","error","_onWorkerDone","toLowerCase","WorkerThread"],"mappings":"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","sourcesContent":["import WorkerThread from './worker-thread';\n\n/**\n * Process multiple data messages with small pool of identical workers\n */\nexport default class WorkerPool {\n  /**\n   * @param processor {function | string} - worker function\n   * @param maxConcurrency {number} - max count of workers\n   */\n  constructor({source, name = 'unnamed', maxConcurrency = 1, onMessage, onDebug = () => {}}) {\n    this.source = source;\n    this.name = name;\n    this.maxConcurrency = maxConcurrency;\n    this.onMessage = onMessage;\n    this.onDebug = onDebug;\n\n    this.jobQueue = [];\n    this.idleQueue = [];\n    this.count = 0;\n    this.isDestroyed = false;\n  }\n\n  destroy() {\n    // Destroy idle workers, active Workers will be destroyed on completion\n    this.idleQueue.forEach(worker => worker.destroy());\n    this.isDestroyed = true;\n  }\n\n  /**\n   * Process binary data in a worker\n   * @param data {data containing binary typed arrays} - data to be transferred to worker\n   * @returns a Promise with data containing typed arrays transferred back from work\n   */\n  async process(data, jobName) {\n    return new Promise((resolve, reject) => {\n      this.jobQueue.push({data, jobName, resolve, reject});\n      this._startQueuedJob();\n    });\n  }\n\n  // PRIVATE\n\n  _startQueuedJob() {\n    if (!this.jobQueue.length) {\n      return;\n    }\n    const worker = this._getAvailableWorker();\n    if (!worker) {\n      return;\n    }\n\n    // We have a worker, dequeue and start the job\n    const job = this.jobQueue.shift();\n\n    this.onDebug({\n      message: 'processing',\n      worker: worker.name,\n      job: job.jobName,\n      backlog: this.jobQueue.length\n    });\n\n    worker\n      .process(job.data)\n      .then(result => job.resolve(result))\n      .catch(error => job.reject(error))\n      .then(() => this._onWorkerDone(worker));\n  }\n\n  _onWorkerDone(worker) {\n    if (this.isDestroyed) {\n      worker.destroy();\n    } else {\n      this.idleQueue.push(worker);\n      this._startQueuedJob();\n    }\n  }\n\n  _getAvailableWorker() {\n    // If a worker has completed and returned to the queue, it can be used\n    if (this.idleQueue.length > 0) {\n      return this.idleQueue.shift();\n    }\n\n    // Create fresh worker if we haven't yet created the max amount of worker threads for this worker source\n    if (this.count < this.maxConcurrency) {\n      this.count++;\n      const name = `${this.name.toLowerCase()}-worker-${this.count}-of-${this.maxConcurrency}`;\n      return new WorkerThread({source: this.source, onMessage: this.onMessage, name});\n    }\n\n    // No worker available, have to wait\n    return null;\n  }\n}\n"],"file":"worker-pool.js"}