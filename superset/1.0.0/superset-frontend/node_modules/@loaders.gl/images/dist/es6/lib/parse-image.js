import { global } from '../utils/globals';
import { getImageMetadata } from './get-image-metadata';
export const canParseImage = global._parseImageNode || typeof ImageBitmap !== 'undefined';
export function parseImage(arrayBuffer, options) {
  if (global._parseImageNode) {
    const {
      mimeType
    } = getImageMetadata(arrayBuffer);
    return global._parseImageNode(arrayBuffer, mimeType, options);
  }

  return parseToImageBitmap(arrayBuffer, options);
}
export async function loadImage(url, options = {}) {
  if (typeof Image === 'undefined') {
    const response = await fetch(url, options);
    const arrayBuffer = await response.arrayBuffer();
    return parseImage(arrayBuffer, options);
  }

  return await loadToHTMLImage(url, options);
}
export function parseToImageBitmap(arrayBuffer, options) {
  if (typeof createImageBitmap === 'undefined') {
    throw new Error('parseImage');
  }

  const blob = new Blob([new Uint8Array(arrayBuffer)]);
  return createImageBitmap(blob);
}
export async function loadToHTMLImage(url, options) {
  let src;

  if (/\.svg((\?|#).*)?$/.test(url)) {
    const response = await fetch(url, options);
    const xml = await response.text();
    src = "data:image/svg+xml;base64,".concat(btoa(xml));
  } else {
    src = await url;
  }

  return await new Promise((resolve, reject) => {
    try {
      const image = new Image();

      image.onload = () => resolve(image);

      image.onerror = err => reject(new Error("Could not load image ".concat(url, ": ").concat(err)));

      image.crossOrigin = options && options.crossOrigin || 'anonymous';
      image.src = src;
    } catch (error) {
      reject(error);
    }
  });
}
//# sourceMappingURL=parse-image.js.map