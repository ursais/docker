{"version":3,"sources":["../../../src/lib/parse-image.js"],"names":["global","getImageMetadata","canParseImage","_parseImageNode","ImageBitmap","parseImage","arrayBuffer","options","mimeType","parseToImageBitmap","loadImage","url","Image","fetch","response","loadToHTMLImage","createImageBitmap","Error","blob","Blob","Uint8Array","test","text","xml","src","btoa","Promise","resolve","reject","image","onload","onerror","err","crossOrigin","error"],"mappings":"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","sourcesContent":["/* global Image, Blob, createImageBitmap, btoa, fetch */\nimport {global} from '../utils/globals';\nimport {getImageMetadata} from './get-image-metadata';\n\nexport const canParseImage = global._parseImageNode || typeof ImageBitmap !== 'undefined';\n\n// Parse to platform defined type (ndarray on node, ImageBitmap on browser)\nexport function parseImage(arrayBuffer, options) {\n  if (global._parseImageNode) {\n    const {mimeType} = getImageMetadata(arrayBuffer);\n    return global._parseImageNode(arrayBuffer, mimeType, options);\n  }\n\n  return parseToImageBitmap(arrayBuffer, options);\n}\n\n// Fallback for older browsers\n// TODO - investigate Image.decode()\n// https://medium.com/dailyjs/image-loading-with-image-decode-b03652e7d2d2\nexport async function loadImage(url, options = {}) {\n  if (typeof Image === 'undefined') {\n    const response = await fetch(url, options);\n    const arrayBuffer = await response.arrayBuffer();\n    return parseImage(arrayBuffer, options);\n  }\n  return await loadToHTMLImage(url, options);\n}\n\n// Asynchronously parses an array buffer into an ImageBitmap - this contains the decoded data\n// Supported on worker threads\n// Not supported on Edge and Safari\n// https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap#Browser_compatibility\nexport function parseToImageBitmap(arrayBuffer, options) {\n  if (typeof createImageBitmap === 'undefined') {\n    throw new Error('parseImage');\n  }\n\n  const blob = new Blob([new Uint8Array(arrayBuffer)]);\n  return createImageBitmap(blob);\n}\n\n//\nexport async function loadToHTMLImage(url, options) {\n  let src;\n  if (/\\.svg((\\?|#).*)?$/.test(url)) {\n    // is SVG\n    const response = await fetch(url, options);\n    const xml = await response.text();\n    // base64 encoding is safer. utf-8 fails in some browsers\n    src = `data:image/svg+xml;base64,${btoa(xml)}`;\n  } else {\n    src = await url;\n  }\n\n  return await new Promise((resolve, reject) => {\n    try {\n      const image = new Image();\n      image.onload = () => resolve(image);\n      image.onerror = err => reject(new Error(`Could not load image ${url}: ${err}`));\n      image.crossOrigin = (options && options.crossOrigin) || 'anonymous';\n      image.src = src;\n    } catch (error) {\n      reject(error);\n    }\n  });\n}\n"],"file":"parse-image.js"}