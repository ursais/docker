{"version":3,"sources":["../../../src/lib/attribute-transition-utils.js"],"names":["ATTRIBUTE_MAPPING","getShaders","transitions","varyings","attributeDeclarations","uniformsDeclarations","varyingDeclarations","calculations","attributeName","transition","attributeType","attribute","size","bufferIndex","length","push","vs","join","fs","getBuffers","sourceBuffers","feedbackBuffers","fromState","toState","buffer","Buffer","divisor","padBuffer","fromLength","toLength","fromBufferLayout","toBufferLayout","getData","x","hasBufferLayout","data","Float32Array","fromData","constant","toData","getValue","getBuffer","getMissingData","i","chunk","subarray","source","target","sourceLayout","targetLayout","setData"],"mappings":"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","sourcesContent":["import {Buffer} from '@luma.gl/core';\nimport {padArray} from '../utils/array-utils';\n\nconst ATTRIBUTE_MAPPING = {\n  1: 'float',\n  2: 'vec2',\n  3: 'vec3',\n  4: 'vec4'\n};\n\nexport function getShaders(transitions) {\n  // Build shaders\n  const varyings = [];\n  const attributeDeclarations = [];\n  const uniformsDeclarations = [];\n  const varyingDeclarations = [];\n  const calculations = [];\n\n  for (const attributeName in transitions) {\n    const transition = transitions[attributeName];\n    const attributeType = ATTRIBUTE_MAPPING[transition.attribute.size];\n\n    if (attributeType) {\n      transition.bufferIndex = varyings.length;\n      varyings.push(attributeName);\n\n      attributeDeclarations.push(`attribute ${attributeType} ${attributeName}From;`);\n      attributeDeclarations.push(`attribute ${attributeType} ${attributeName}To;`);\n      uniformsDeclarations.push(`uniform float ${attributeName}Time;`);\n      varyingDeclarations.push(`varying ${attributeType} ${attributeName};`);\n      calculations.push(`${attributeName} = mix(${attributeName}From, ${attributeName}To,\n        ${attributeName}Time);`);\n    }\n  }\n\n  const vs = `\n#define SHADER_NAME feedback-vertex-shader\n${attributeDeclarations.join('\\n')}\n${uniformsDeclarations.join('\\n')}\n${varyingDeclarations.join('\\n')}\n\nvoid main(void) {\n  ${calculations.join('\\n')}\n  gl_Position = vec4(0.0);\n}\n`;\n\n  const fs = `\\\n#define SHADER_NAME feedback-fragment-shader\n\nprecision highp float;\n\n${varyingDeclarations.join('\\n')}\n\nvoid main(void) {\n  gl_FragColor = vec4(0.0);\n}\n`;\n  return {vs, fs, varyings};\n}\n\nexport function getBuffers(transitions) {\n  const sourceBuffers = {};\n  const feedbackBuffers = {};\n  for (const attributeName in transitions) {\n    const {fromState, toState, buffer} = transitions[attributeName];\n    sourceBuffers[`${attributeName}From`] =\n      fromState instanceof Buffer ? [fromState, {divisor: 0}] : fromState;\n    sourceBuffers[`${attributeName}To`] = toState;\n    feedbackBuffers[`${attributeName}`] = buffer;\n  }\n  return {sourceBuffers, feedbackBuffers};\n}\n\nexport function padBuffer({\n  fromState,\n  toState,\n  fromLength,\n  toLength,\n  fromBufferLayout,\n  toBufferLayout,\n  getData = x => x\n}) {\n  const hasBufferLayout = fromBufferLayout && toBufferLayout;\n\n  // check if buffer needs to be padded\n  if ((!hasBufferLayout && fromLength >= toLength) || !(fromState instanceof Buffer)) {\n    return;\n  }\n\n  const data = new Float32Array(toLength);\n  const fromData = fromState.getData({});\n\n  const {size, constant} = toState;\n  const toData = constant ? toState.getValue() : toState.getBuffer().getData({});\n\n  const getMissingData = constant\n    ? (i, chunk) => getData(toData, chunk)\n    : (i, chunk) => getData(toData.subarray(i, i + size), chunk);\n\n  padArray({\n    source: fromData,\n    target: data,\n    sourceLayout: fromBufferLayout,\n    targetLayout: toBufferLayout,\n    size: toState.size,\n    getData: getMissingData\n  });\n\n  fromState.setData({data});\n}\n"],"file":"attribute-transition-utils.js"}