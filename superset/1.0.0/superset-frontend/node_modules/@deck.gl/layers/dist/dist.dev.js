(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("deck"), require("luma"));
	else if(typeof define === 'function' && define.amd)
		define(["deck", "luma"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("deck"), require("luma")) : factory(root["deck"], root["luma"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function(__WEBPACK_EXTERNAL_MODULE__deck_gl_core__, __WEBPACK_EXTERNAL_MODULE__luma_gl_constants__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./bundle.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js":
/*!************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!
  \************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayWithHoles; });
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!**************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _asyncToGenerator; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js":
/*!******************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _iterableToArrayLimit; });
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js":
/*!*************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!
  \*************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _nonIterableRest; });
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js":
/*!***********************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _slicedToArray; });
/* harmony import */ var _arrayWithHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithHoles */ "../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js");
/* harmony import */ var _iterableToArrayLimit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArrayLimit */ "../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js");
/* harmony import */ var _nonIterableRest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nonIterableRest */ "../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js");



function _slicedToArray(arr, i) {
  return Object(_arrayWithHoles__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || Object(_iterableToArrayLimit__WEBPACK_IMPORTED_MODULE_1__["default"])(arr, i) || Object(_nonIterableRest__WEBPACK_IMPORTED_MODULE_2__["default"])();
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/regenerator/index.js":
/*!***************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@babel/runtime/regenerator/index.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "../../node_modules/regenerator-runtime/runtime-module.js");


/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/categories/mesh/mesh-utils.js":
/*!***********************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/categories/mesh/mesh-utils.js ***!
  \***********************************************************************************************************/
/*! exports provided: getMeshSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMeshSize", function() { return getMeshSize; });
function getMeshSize(attributes) {
  var size = 0;

  for (var attributeName in attributes) {
    var attribute = attributes[attributeName];

    if (ArrayBuffer.isView(attribute)) {
      size += attribute.length * attribute.BYTES_PER_ELEMENT;
    }
  }

  return size;
}
//# sourceMappingURL=mesh-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/index.js":
/*!**************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/index.js ***!
  \**************************************************************************************/
/*! exports provided: setPathPrefix, getPathPrefix, resolvePath, fetchFile, readFileSync, writeFile, writeFileSync, registerLoaders, parse, parseSync, parseInBatches, parseInBatchesSync, load, loadInBatches, encode, encodeSync, encodeInBatches, save, saveSync, isPromise, isIterable, isAsyncIterable, isIterator, isFetchResponse, isReadableStream, isWritableStream, isArrayBuffer, isBlob, toArrayBuffer, blobToArrayBuffer, toDataView, padTo4Bytes, copyToArray, copyArrayBuffer, flattenToTypedArray, TextDecoder, TextEncoder, getStreamIterator, forEach, concatenateAsyncIterator, lineAsyncIterator, textDecoderAsyncIterator, numberedLineAsyncIterator, createWorker, isBrowser, self, window, global, document, assert, _getMeshSize, createReadStream, parseFile, parseFileSync, loadFile */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseFile", function() { return parseFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseFileSync", function() { return parseFileSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFile", function() { return loadFile; });
/* harmony import */ var _lib_fetch_file_aliases_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/fetch/file-aliases.js */ "../../node_modules/@loaders.gl/core/dist/esm/lib/fetch/file-aliases.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return _lib_fetch_file_aliases_js__WEBPACK_IMPORTED_MODULE_0__["setPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return _lib_fetch_file_aliases_js__WEBPACK_IMPORTED_MODULE_0__["getPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return _lib_fetch_file_aliases_js__WEBPACK_IMPORTED_MODULE_0__["resolvePath"]; });

/* harmony import */ var _lib_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/fetch/fetch-file */ "../../node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchFile", function() { return _lib_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_1__["fetchFile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readFileSync", function() { return _lib_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_1__["readFileSync"]; });

/* harmony import */ var _lib_fetch_write_file__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/fetch/write-file */ "../../node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "writeFile", function() { return _lib_fetch_write_file__WEBPACK_IMPORTED_MODULE_2__["writeFile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "writeFileSync", function() { return _lib_fetch_write_file__WEBPACK_IMPORTED_MODULE_2__["writeFileSync"]; });

/* harmony import */ var _lib_register_loaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/register-loaders */ "../../node_modules/@loaders.gl/core/dist/esm/lib/register-loaders.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerLoaders", function() { return _lib_register_loaders__WEBPACK_IMPORTED_MODULE_3__["registerLoaders"]; });

/* harmony import */ var _lib_parse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/parse */ "../../node_modules/@loaders.gl/core/dist/esm/lib/parse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return _lib_parse__WEBPACK_IMPORTED_MODULE_4__["parse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseSync", function() { return _lib_parse__WEBPACK_IMPORTED_MODULE_4__["parseSync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseInBatches", function() { return _lib_parse__WEBPACK_IMPORTED_MODULE_4__["parseInBatches"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseInBatchesSync", function() { return _lib_parse__WEBPACK_IMPORTED_MODULE_4__["parseInBatchesSync"]; });

/* harmony import */ var _lib_load__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/load */ "../../node_modules/@loaders.gl/core/dist/esm/lib/load.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "load", function() { return _lib_load__WEBPACK_IMPORTED_MODULE_5__["load"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadInBatches", function() { return _lib_load__WEBPACK_IMPORTED_MODULE_5__["loadInBatches"]; });

/* harmony import */ var _lib_encode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/encode */ "../../node_modules/@loaders.gl/core/dist/esm/lib/encode.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return _lib_encode__WEBPACK_IMPORTED_MODULE_6__["encode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encodeSync", function() { return _lib_encode__WEBPACK_IMPORTED_MODULE_6__["encodeSync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encodeInBatches", function() { return _lib_encode__WEBPACK_IMPORTED_MODULE_6__["encodeInBatches"]; });

/* harmony import */ var _lib_save__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/save */ "../../node_modules/@loaders.gl/core/dist/esm/lib/save.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "save", function() { return _lib_save__WEBPACK_IMPORTED_MODULE_7__["save"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "saveSync", function() { return _lib_save__WEBPACK_IMPORTED_MODULE_7__["saveSync"]; });

/* harmony import */ var _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./javascript-utils/is-type */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isPromise", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__["isPromise"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isIterable", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__["isIterable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isAsyncIterable", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__["isAsyncIterable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isIterator", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__["isIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isFetchResponse", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__["isFetchResponse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isReadableStream", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__["isReadableStream"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWritableStream", function() { return _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_8__["isWritableStream"]; });

/* harmony import */ var _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./javascript-utils/binary-utils */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/binary-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArrayBuffer", function() { return _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_9__["isArrayBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBlob", function() { return _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_9__["isBlob"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toArrayBuffer", function() { return _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_9__["toArrayBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "blobToArrayBuffer", function() { return _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_9__["blobToArrayBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toDataView", function() { return _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_9__["toDataView"]; });

/* harmony import */ var _javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./javascript-utils/memory-copy-utils */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/memory-copy-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "padTo4Bytes", function() { return _javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_10__["padTo4Bytes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return _javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_10__["copyToArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return _javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_10__["copyArrayBuffer"]; });

/* harmony import */ var _javascript_utils_flatten_to_typed_array__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./javascript-utils/flatten-to-typed-array */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/flatten-to-typed-array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flattenToTypedArray", function() { return _javascript_utils_flatten_to_typed_array__WEBPACK_IMPORTED_MODULE_11__["flattenToTypedArray"]; });

/* harmony import */ var _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./javascript-utils/text-encoding */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/text-encoding.js");
/* harmony import */ var _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(_javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_12__);
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextDecoder", function() { return _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_12__["TextDecoder"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextEncoder", function() { return _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_12__["TextEncoder"]; });

/* harmony import */ var _javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./javascript-utils/stream-utils */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/stream-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStreamIterator", function() { return _javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_13__["getStreamIterator"]; });

/* harmony import */ var _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./javascript-utils/async-iterator-utils */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/async-iterator-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_14__["forEach"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concatenateAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_14__["concatenateAsyncIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lineAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_14__["lineAsyncIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "textDecoderAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_14__["textDecoderAsyncIterator"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "numberedLineAsyncIterator", function() { return _javascript_utils_async_iterator_utils__WEBPACK_IMPORTED_MODULE_14__["numberedLineAsyncIterator"]; });

/* harmony import */ var _worker_utils_create_worker__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./worker-utils/create-worker */ "../../node_modules/@loaders.gl/core/dist/esm/worker-utils/create-worker.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createWorker", function() { return _worker_utils_create_worker__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils/globals */ "../../node_modules/@loaders.gl/core/dist/esm/utils/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_16__["isBrowser"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_16__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_16__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_16__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_16__["document"]; });

/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./utils/assert */ "../../node_modules/@loaders.gl/core/dist/esm/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _utils_assert__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./categories/mesh/mesh-utils */ "../../node_modules/@loaders.gl/core/dist/esm/categories/mesh/mesh-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_getMeshSize", function() { return _categories_mesh_mesh_utils__WEBPACK_IMPORTED_MODULE_18__["getMeshSize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createReadStream", function() { return _lib_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_1__["createReadStream"]; });























function parseFile() {
  console.warn('parse() deprecated, use parse()');
  return _lib_parse__WEBPACK_IMPORTED_MODULE_4__["parse"].apply(void 0, arguments);
}
function parseFileSync() {
  console.warn('parseSync() deprecated, use parseSync()');
  return _lib_parse__WEBPACK_IMPORTED_MODULE_4__["parseSync"].apply(void 0, arguments);
}
function loadFile() {
  console.warn('loadFile() deprecated, use load()');
  return _lib_load__WEBPACK_IMPORTED_MODULE_5__["load"].apply(void 0, arguments);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/async-iterator-utils.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/javascript-utils/async-iterator-utils.js ***!
  \**********************************************************************************************************************/
/*! exports provided: forEach, concatenateAsyncIterator, textDecoderAsyncIterator, textEncoderAsyncIterator, lineAsyncIterator, numberedLineAsyncIterator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateAsyncIterator", function() { return concatenateAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textDecoderAsyncIterator", function() { return textDecoderAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "textEncoderAsyncIterator", function() { return textEncoderAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lineAsyncIterator", function() { return lineAsyncIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "numberedLineAsyncIterator", function() { return numberedLineAsyncIterator; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/asyncToGenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/awaitAsyncGenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js");
/* harmony import */ var _babel_runtime_helpers_esm_wrapAsyncGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/wrapAsyncGenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js");
/* harmony import */ var _babel_runtime_helpers_esm_asyncIterator__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/asyncIterator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/asyncIterator.js");
/* harmony import */ var _javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../javascript-utils/memory-copy-utils */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/memory-copy-utils.js");
/* harmony import */ var _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../javascript-utils/text-encoding */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/text-encoding.js");
/* harmony import */ var _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_6__);







function forEach(_x7, _x8) {
  return _forEach.apply(this, arguments);
}

function _forEach() {
  _forEach = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee5(iterator, visitor) {
    var _ref, done, value, cancel;

    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (false) {}

            _context5.next = 3;
            return iterator.next();

          case 3:
            _ref = _context5.sent;
            done = _ref.done;
            value = _ref.value;

            if (!done) {
              _context5.next = 9;
              break;
            }

            iterator["return"]();
            return _context5.abrupt("return");

          case 9:
            cancel = visitor(value);

            if (!cancel) {
              _context5.next = 12;
              break;
            }

            return _context5.abrupt("return");

          case 12:
            _context5.next = 0;
            break;

          case 14:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _forEach.apply(this, arguments);
}

function concatenateAsyncIterator(_x9) {
  return _concatenateAsyncIterator.apply(this, arguments);
}

function _concatenateAsyncIterator() {
  _concatenateAsyncIterator = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee6(asyncIterator) {
    var arrayBuffer, string, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk;

    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            arrayBuffer = new ArrayBuffer();
            string = '';
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _context6.prev = 4;
            _iterator = Object(_babel_runtime_helpers_esm_asyncIterator__WEBPACK_IMPORTED_MODULE_4__["default"])(asyncIterator);

          case 6:
            _context6.next = 8;
            return _iterator.next();

          case 8:
            _step = _context6.sent;
            _iteratorNormalCompletion = _step.done;
            _context6.next = 12;
            return _step.value;

          case 12:
            _value = _context6.sent;

            if (_iteratorNormalCompletion) {
              _context6.next = 19;
              break;
            }

            chunk = _value;

            if (typeof chunk === 'string') {
              string += chunk;
            } else {
              arrayBuffer = Object(_javascript_utils_memory_copy_utils__WEBPACK_IMPORTED_MODULE_5__["concatenateArrayBuffers"])(arrayBuffer, chunk);
            }

          case 16:
            _iteratorNormalCompletion = true;
            _context6.next = 6;
            break;

          case 19:
            _context6.next = 25;
            break;

          case 21:
            _context6.prev = 21;
            _context6.t0 = _context6["catch"](4);
            _didIteratorError = true;
            _iteratorError = _context6.t0;

          case 25:
            _context6.prev = 25;
            _context6.prev = 26;

            if (!(!_iteratorNormalCompletion && _iterator["return"] != null)) {
              _context6.next = 30;
              break;
            }

            _context6.next = 30;
            return _iterator["return"]();

          case 30:
            _context6.prev = 30;

            if (!_didIteratorError) {
              _context6.next = 33;
              break;
            }

            throw _iteratorError;

          case 33:
            return _context6.finish(30);

          case 34:
            return _context6.finish(25);

          case 35:
            return _context6.abrupt("return", arrayBuffer || string);

          case 36:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, null, [[4, 21, 25, 35], [26,, 30, 34]]);
  }));
  return _concatenateAsyncIterator.apply(this, arguments);
}

function textDecoderAsyncIterator(_x, _x2) {
  return _textDecoderAsyncIterator.apply(this, arguments);
}

function _textDecoderAsyncIterator() {
  _textDecoderAsyncIterator = Object(_babel_runtime_helpers_esm_wrapAsyncGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(arrayBufferIterator, options) {
    var textDecoder, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, _value2, arrayBuffer;

    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            textDecoder = new _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_6__["TextDecoder"](options);
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _context.prev = 3;
            _iterator2 = Object(_babel_runtime_helpers_esm_asyncIterator__WEBPACK_IMPORTED_MODULE_4__["default"])(arrayBufferIterator);

          case 5:
            _context.next = 7;
            return Object(_babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_iterator2.next());

          case 7:
            _step2 = _context.sent;
            _iteratorNormalCompletion2 = _step2.done;
            _context.next = 11;
            return Object(_babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_step2.value);

          case 11:
            _value2 = _context.sent;

            if (_iteratorNormalCompletion2) {
              _context.next = 19;
              break;
            }

            arrayBuffer = _value2;
            _context.next = 16;
            return typeof arrayBuffer === 'string' ? arrayBuffer : textDecoder.decode(arrayBuffer, {
              stream: true
            });

          case 16:
            _iteratorNormalCompletion2 = true;
            _context.next = 5;
            break;

          case 19:
            _context.next = 25;
            break;

          case 21:
            _context.prev = 21;
            _context.t0 = _context["catch"](3);
            _didIteratorError2 = true;
            _iteratorError2 = _context.t0;

          case 25:
            _context.prev = 25;
            _context.prev = 26;

            if (!(!_iteratorNormalCompletion2 && _iterator2["return"] != null)) {
              _context.next = 30;
              break;
            }

            _context.next = 30;
            return Object(_babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_iterator2["return"]());

          case 30:
            _context.prev = 30;

            if (!_didIteratorError2) {
              _context.next = 33;
              break;
            }

            throw _iteratorError2;

          case 33:
            return _context.finish(30);

          case 34:
            return _context.finish(25);

          case 35:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[3, 21, 25, 35], [26,, 30, 34]]);
  }));
  return _textDecoderAsyncIterator.apply(this, arguments);
}

function textEncoderAsyncIterator(_x3, _x4) {
  return _textEncoderAsyncIterator.apply(this, arguments);
}

function _textEncoderAsyncIterator() {
  _textEncoderAsyncIterator = Object(_babel_runtime_helpers_esm_wrapAsyncGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2(textIterator, options) {
    var textEncoder, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, _value3, text;

    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            textEncoder = new _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_6__["TextEncoder"]();
            _iteratorNormalCompletion3 = true;
            _didIteratorError3 = false;
            _context2.prev = 3;
            _iterator3 = Object(_babel_runtime_helpers_esm_asyncIterator__WEBPACK_IMPORTED_MODULE_4__["default"])(textIterator);

          case 5:
            _context2.next = 7;
            return Object(_babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_iterator3.next());

          case 7:
            _step3 = _context2.sent;
            _iteratorNormalCompletion3 = _step3.done;
            _context2.next = 11;
            return Object(_babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_step3.value);

          case 11:
            _value3 = _context2.sent;

            if (_iteratorNormalCompletion3) {
              _context2.next = 19;
              break;
            }

            text = _value3;
            _context2.next = 16;
            return typeof text === 'string' ? textEncoder.encode(text) : text;

          case 16:
            _iteratorNormalCompletion3 = true;
            _context2.next = 5;
            break;

          case 19:
            _context2.next = 25;
            break;

          case 21:
            _context2.prev = 21;
            _context2.t0 = _context2["catch"](3);
            _didIteratorError3 = true;
            _iteratorError3 = _context2.t0;

          case 25:
            _context2.prev = 25;
            _context2.prev = 26;

            if (!(!_iteratorNormalCompletion3 && _iterator3["return"] != null)) {
              _context2.next = 30;
              break;
            }

            _context2.next = 30;
            return Object(_babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_iterator3["return"]());

          case 30:
            _context2.prev = 30;

            if (!_didIteratorError3) {
              _context2.next = 33;
              break;
            }

            throw _iteratorError3;

          case 33:
            return _context2.finish(30);

          case 34:
            return _context2.finish(25);

          case 35:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[3, 21, 25, 35], [26,, 30, 34]]);
  }));
  return _textEncoderAsyncIterator.apply(this, arguments);
}

function lineAsyncIterator(_x5) {
  return _lineAsyncIterator.apply(this, arguments);
}

function _lineAsyncIterator() {
  _lineAsyncIterator = Object(_babel_runtime_helpers_esm_wrapAsyncGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee3(textIterator) {
    var previous, _iteratorNormalCompletion4, _didIteratorError4, _iteratorError4, _iterator4, _step4, _value4, textChunk, eolIndex, line;

    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            previous = '';
            _iteratorNormalCompletion4 = true;
            _didIteratorError4 = false;
            _context3.prev = 3;
            _iterator4 = Object(_babel_runtime_helpers_esm_asyncIterator__WEBPACK_IMPORTED_MODULE_4__["default"])(textIterator);

          case 5:
            _context3.next = 7;
            return Object(_babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_iterator4.next());

          case 7:
            _step4 = _context3.sent;
            _iteratorNormalCompletion4 = _step4.done;
            _context3.next = 11;
            return Object(_babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_step4.value);

          case 11:
            _value4 = _context3.sent;

            if (_iteratorNormalCompletion4) {
              _context3.next = 26;
              break;
            }

            textChunk = _value4;
            previous += textChunk;
            eolIndex = void 0;

          case 16:
            if (!((eolIndex = previous.indexOf('\n')) >= 0)) {
              _context3.next = 23;
              break;
            }

            line = previous.slice(0, eolIndex + 1);
            previous = previous.slice(eolIndex + 1);
            _context3.next = 21;
            return line;

          case 21:
            _context3.next = 16;
            break;

          case 23:
            _iteratorNormalCompletion4 = true;
            _context3.next = 5;
            break;

          case 26:
            _context3.next = 32;
            break;

          case 28:
            _context3.prev = 28;
            _context3.t0 = _context3["catch"](3);
            _didIteratorError4 = true;
            _iteratorError4 = _context3.t0;

          case 32:
            _context3.prev = 32;
            _context3.prev = 33;

            if (!(!_iteratorNormalCompletion4 && _iterator4["return"] != null)) {
              _context3.next = 37;
              break;
            }

            _context3.next = 37;
            return Object(_babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_iterator4["return"]());

          case 37:
            _context3.prev = 37;

            if (!_didIteratorError4) {
              _context3.next = 40;
              break;
            }

            throw _iteratorError4;

          case 40:
            return _context3.finish(37);

          case 41:
            return _context3.finish(32);

          case 42:
            if (!(previous.length > 0)) {
              _context3.next = 45;
              break;
            }

            _context3.next = 45;
            return previous;

          case 45:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[3, 28, 32, 42], [33,, 37, 41]]);
  }));
  return _lineAsyncIterator.apply(this, arguments);
}

function numberedLineAsyncIterator(_x6) {
  return _numberedLineAsyncIterator.apply(this, arguments);
}

function _numberedLineAsyncIterator() {
  _numberedLineAsyncIterator = Object(_babel_runtime_helpers_esm_wrapAsyncGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee4(lineIterator) {
    var counter, _iteratorNormalCompletion5, _didIteratorError5, _iteratorError5, _iterator5, _step5, _value5, line;

    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            counter = 1;
            _iteratorNormalCompletion5 = true;
            _didIteratorError5 = false;
            _context4.prev = 3;
            _iterator5 = Object(_babel_runtime_helpers_esm_asyncIterator__WEBPACK_IMPORTED_MODULE_4__["default"])(lineIterator);

          case 5:
            _context4.next = 7;
            return Object(_babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_iterator5.next());

          case 7:
            _step5 = _context4.sent;
            _iteratorNormalCompletion5 = _step5.done;
            _context4.next = 11;
            return Object(_babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_step5.value);

          case 11:
            _value5 = _context4.sent;

            if (_iteratorNormalCompletion5) {
              _context4.next = 20;
              break;
            }

            line = _value5;
            _context4.next = 16;
            return {
              counter: counter,
              line: line
            };

          case 16:
            counter++;

          case 17:
            _iteratorNormalCompletion5 = true;
            _context4.next = 5;
            break;

          case 20:
            _context4.next = 26;
            break;

          case 22:
            _context4.prev = 22;
            _context4.t0 = _context4["catch"](3);
            _didIteratorError5 = true;
            _iteratorError5 = _context4.t0;

          case 26:
            _context4.prev = 26;
            _context4.prev = 27;

            if (!(!_iteratorNormalCompletion5 && _iterator5["return"] != null)) {
              _context4.next = 31;
              break;
            }

            _context4.next = 31;
            return Object(_babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_iterator5["return"]());

          case 31:
            _context4.prev = 31;

            if (!_didIteratorError5) {
              _context4.next = 34;
              break;
            }

            throw _iteratorError5;

          case 34:
            return _context4.finish(31);

          case 35:
            return _context4.finish(26);

          case 36:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[3, 22, 26, 36], [27,, 31, 35]]);
  }));
  return _numberedLineAsyncIterator.apply(this, arguments);
}
//# sourceMappingURL=async-iterator-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/binary-utils.js":
/*!**************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/javascript-utils/binary-utils.js ***!
  \**************************************************************************************************************/
/*! exports provided: isArrayBuffer, isBlob, isBuffer, toArrayBuffer, blobToArrayBuffer, toDataView */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArrayBuffer", function() { return isArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBlob", function() { return isBlob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBuffer", function() { return isBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArrayBuffer", function() { return toArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blobToArrayBuffer", function() { return blobToArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toDataView", function() { return toDataView; });
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@loaders.gl/core/dist/esm/utils/assert.js");
/* harmony import */ var _text_encoding__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./text-encoding */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/text-encoding.js");
/* harmony import */ var _text_encoding__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_text_encoding__WEBPACK_IMPORTED_MODULE_1__);


var isArrayBuffer = function isArrayBuffer(x) {
  return x && x instanceof ArrayBuffer;
};
var isBlob = function isBlob(x) {
  return x && typeof Blob !== 'undefined' && x instanceof Blob;
};
var isBuffer = function isBuffer(x) {
  return x && x instanceof Buffer;
};
function toArrayBuffer(data) {
  if (isArrayBuffer(data)) {
    return data;
  }

  if (isBuffer(data)) {
    var typedArray = new Uint8Array(data);
    return typedArray.buffer;
  }

  if (ArrayBuffer.isView(data)) {
    return data.buffer;
  }

  if (typeof data === 'string') {
    var text = data;
    var uint8Array = new _text_encoding__WEBPACK_IMPORTED_MODULE_1__["TextEncoder"]().encode(text);
    return uint8Array.buffer;
  }

  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(false);
}
function blobToArrayBuffer(blob) {
  return new Promise(function (resolve, reject) {
    var arrayBuffer;
    var fileReader = new FileReader();

    fileReader.onload = function (event) {
      arrayBuffer = event.target.result;
    };

    fileReader.onloadend = function (event) {
      return resolve(arrayBuffer);
    };

    fileReader.onerror = reject;
    fileReader.readAsArrayBuffer(blob);
  });
}
function toDataView(buffer) {
  return new DataView(toArrayBuffer(buffer));
}
//# sourceMappingURL=binary-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/flatten-to-typed-array.js":
/*!************************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/javascript-utils/flatten-to-typed-array.js ***!
  \************************************************************************************************************************/
/*! exports provided: flattenToTypedArray, flatten, countVertices, flattenVertices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flattenToTypedArray", function() { return flattenToTypedArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flatten", function() { return flatten; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "countVertices", function() { return countVertices; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flattenVertices", function() { return flattenVertices; });
function flattenToTypedArray(nestedArray) {
  var ArrayType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Float32Array;

  if (nestedArray.length === 0) {
    return new Float32Array(0);
  }

  if (!checkVertices(nestedArray)) {
    return null;
  }

  var count = countVertices(nestedArray);
  var typedArray = new ArrayType(count);
  flattenVerticesInPlace(nestedArray, typedArray);
  return typedArray;
}
function flatten(array) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$filter = _ref.filter,
      filter = _ref$filter === void 0 ? function () {
    return true;
  } : _ref$filter,
      _ref$map = _ref.map,
      map = _ref$map === void 0 ? function (x) {
    return x;
  } : _ref$map,
      _ref$result = _ref.result,
      result = _ref$result === void 0 ? [] : _ref$result;

  if (!Array.isArray(array)) {
    return filter(array) ? [map(array)] : [];
  }

  return flattenArray(array, filter, map, result);
}

function flattenArray(array, filter, map, result) {
  var index = -1;

  while (++index < array.length) {
    var value = array[index];

    if (Array.isArray(value)) {
      flattenArray(value, filter, map, result);
    } else if (filter(value)) {
      result.push(map(value));
    }
  }

  return result;
}

function countVertices(nestedArray) {
  var dimensions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
  var nestedCount = 0;
  var localCount = 0;
  var index = -1;

  while (++index < nestedArray.length) {
    var value = nestedArray[index];

    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      nestedCount += countVertices(value);
    } else {
      localCount++;
    }
  }

  return nestedCount + (nestedCount === 0 && localCount < dimensions ? dimensions : localCount);
}
function flattenVertices(nestedArray) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$result = _ref2.result,
      result = _ref2$result === void 0 ? [] : _ref2$result,
      _ref2$dimensions = _ref2.dimensions,
      dimensions = _ref2$dimensions === void 0 ? 3 : _ref2$dimensions;

  var index = -1;
  var vertexLength = 0;

  while (++index < nestedArray.length) {
    var value = nestedArray[index];

    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      flattenVertices(value, {
        result: result,
        dimensions: dimensions
      });
    } else {
      if (vertexLength < dimensions) {
        result.push(value);
        vertexLength++;
      }
    }
  }

  if (vertexLength > 0 && vertexLength < dimensions) {
    result.push(0);
  }

  return result;
}

function checkVertices(nestedArray) {
  var predicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.isFinite;
  var index = -1;

  while (++index < nestedArray.length) {
    var value = nestedArray[index];

    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      if (!checkVertices(value, predicate)) {
        return false;
      }
    } else if (!predicate(value)) {
      return false;
    }
  }

  return true;
}

function flattenVerticesInPlace(nestedArray, result) {
  var dimensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;
  flattenVerticesInPlaceRecursive(nestedArray, result, dimensions, 0);
  return result;
}

function flattenVerticesInPlaceRecursive(nestedArray, result, dimensions, insert) {
  var index = -1;
  var vertexLength = 0;

  while (++index < nestedArray.length) {
    var value = nestedArray[index];

    if (Array.isArray(value) || ArrayBuffer.isView(value)) {
      insert = flattenVerticesInPlaceRecursive(value, result, dimensions, insert);
    } else {
      if (vertexLength < dimensions) {
        result[insert++] = value;
        vertexLength++;
      }
    }
  }

  if (vertexLength > 0 && vertexLength < dimensions) {
    result[insert++] = 0;
  }

  return insert;
}
//# sourceMappingURL=flatten-to-typed-array.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js ***!
  \*********************************************************************************************************/
/*! exports provided: isPromise, isIterable, isAsyncIterable, isIterator, isFetchResponse, isWritableDOMStream, isReadableDOMStream, isWritableNodeStream, isReadableNodeStream, isReadableStream, isWritableStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPromise", function() { return isPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIterable", function() { return isIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAsyncIterable", function() { return isAsyncIterable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIterator", function() { return isIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFetchResponse", function() { return isFetchResponse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWritableDOMStream", function() { return isWritableDOMStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReadableDOMStream", function() { return isReadableDOMStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWritableNodeStream", function() { return isWritableNodeStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReadableNodeStream", function() { return isReadableNodeStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isReadableStream", function() { return isReadableStream; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWritableStream", function() { return isWritableStream; });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/typeof.js");


var isBoolean = function isBoolean(x) {
  return typeof x === 'boolean';
};

var isFunction = function isFunction(x) {
  return typeof x === 'function';
};

var isObject = function isObject(x) {
  return x !== null && Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(x) === 'object';
};

var isPromise = function isPromise(x) {
  return isObject(x) && isFunction(x.then);
};
var isIterable = function isIterable(x) {
  return x && typeof x[Symbol.iterator] === 'function';
};
var isAsyncIterable = function isAsyncIterable(x) {
  return x && typeof x[Symbol.asyncIterator] === 'function';
};
var isIterator = function isIterator(x) {
  return isObject(x) && 'done' in x && 'value' in x;
};
var isFetchResponse = function isFetchResponse(x) {
  return typeof window !== 'undefined' && x instanceof window.Response || x.arrayBuffer && x.json && x.body;
};
var isWritableDOMStream = function isWritableDOMStream(x) {
  return isObject(x) && isFunction(x.abort) && isFunction(x.getWriter);
};
var isReadableDOMStream = function isReadableDOMStream(x) {
  return isObject(x) && isFunction(x.tee) && isFunction(x.cancel) && isFunction(x.pipeTo) && isFunction(x.getReader);
};
var isWritableNodeStream = function isWritableNodeStream(x) {
  return isObject(x) && isFunction(x.end) && isFunction(x.write) && isBoolean(x.writable);
};
var isReadableNodeStream = function isReadableNodeStream(x) {
  return isObject(x) && isFunction(x.read) && isFunction(x.pipe) && isBoolean(x.readable);
};
var isReadableStream = function isReadableStream(x) {
  return isReadableDOMStream(x) || isReadableNodeStream(x);
};
var isWritableStream = function isWritableStream(x) {
  return isWritableDOMStream(x) || isWritableNodeStream(x);
};
//# sourceMappingURL=is-type.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/memory-copy-utils.js":
/*!*******************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/javascript-utils/memory-copy-utils.js ***!
  \*******************************************************************************************************************/
/*! exports provided: padTo4Bytes, copyArrayBuffer, copyToArray, concatenateArrayBuffers */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "padTo4Bytes", function() { return padTo4Bytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyArrayBuffer", function() { return copyArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyToArray", function() { return copyToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateArrayBuffers", function() { return concatenateArrayBuffers; });
function padTo4Bytes(byteLength) {
  return byteLength + 3 & ~3;
}
function copyArrayBuffer(targetBuffer, sourceBuffer, byteOffset) {
  var byteLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : sourceBuffer.byteLength;
  var targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  var sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}
function copyToArray(source, target, targetOffset) {
  var sourceArray;

  if (source instanceof ArrayBuffer) {
    sourceArray = new Uint8Array(source);
  } else {
    var srcByteOffset = source.byteOffset;
    var srcByteLength = source.byteLength;
    sourceArray = new Uint8Array(source.buffer, srcByteOffset, srcByteLength);
  }

  target.set(sourceArray, targetOffset);
  return targetOffset + padTo4Bytes(sourceArray.byteLength);
}
function concatenateArrayBuffers(source1, source2) {
  var sourceArray1 = source1 instanceof ArrayBuffer ? new Uint8Array(source1) : source1;
  var sourceArray2 = source2 instanceof ArrayBuffer ? new Uint8Array(source2) : source2;
  var temp = new Uint8Array(sourceArray1.byteLength + sourceArray2.byteLength);
  temp.set(sourceArray1, 0);
  temp.set(sourceArray2, sourceArray1.byteLength);
  return temp;
}
//# sourceMappingURL=memory-copy-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/stream-utils.js":
/*!**************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/javascript-utils/stream-utils.js ***!
  \**************************************************************************************************************/
/*! exports provided: getStreamIterator, concatenateReadStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStreamIterator", function() { return getStreamIterator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concatenateReadStream", function() { return concatenateReadStream; });
/* harmony import */ var _babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/asyncToGenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/regenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/awaitAsyncGenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js");
/* harmony import */ var _babel_runtime_helpers_esm_wrapAsyncGenerator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/wrapAsyncGenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/globals */ "../../node_modules/@loaders.gl/core/dist/esm/utils/globals.js");
/* harmony import */ var _memory_copy_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./memory-copy-utils */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/memory-copy-utils.js");






function getStreamIterator(stream) {
  if (typeof stream[Symbol.asyncIterator] === 'function') {
    return stream;
  }

  if (typeof stream.getIterator === 'function') {
    return stream.getIterator();
  }

  return _utils_globals__WEBPACK_IMPORTED_MODULE_4__["isBrowser"] ? makeBrowserStreamIterator(stream) : makeNodeStreamIterator(stream);
}

function makeBrowserStreamIterator(_x) {
  return _makeBrowserStreamIterator.apply(this, arguments);
}

function _makeBrowserStreamIterator() {
  _makeBrowserStreamIterator = Object(_babel_runtime_helpers_esm_wrapAsyncGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee(stream) {
    var reader, _ref, done, value;

    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            reader = stream.getReader();
            _context.prev = 1;

          case 2:
            if (false) {}

            _context.next = 5;
            return Object(_babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(reader.read());

          case 5:
            _ref = _context.sent;
            done = _ref.done;
            value = _ref.value;

            if (!done) {
              _context.next = 10;
              break;
            }

            return _context.abrupt("return");

          case 10:
            _context.next = 12;
            return value;

          case 12:
            _context.next = 2;
            break;

          case 14:
            _context.prev = 14;
            reader.releaseLock();
            return _context.finish(14);

          case 17:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1,, 14, 17]]);
  }));
  return _makeBrowserStreamIterator.apply(this, arguments);
}

function makeNodeStreamIterator(_x2) {
  return _makeNodeStreamIterator.apply(this, arguments);
}

function _makeNodeStreamIterator() {
  _makeNodeStreamIterator = Object(_babel_runtime_helpers_esm_wrapAsyncGenerator__WEBPACK_IMPORTED_MODULE_3__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee2(stream) {
    var data;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.next = 2;
            return Object(_babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(stream);

          case 2:
            stream = _context2.sent;

          case 3:
            if (false) {}

            data = stream.read();

            if (!(data !== null)) {
              _context2.next = 9;
              break;
            }

            _context2.next = 8;
            return data;

          case 8:
            return _context2.abrupt("continue", 3);

          case 9:
            if (!stream._readableState.ended) {
              _context2.next = 11;
              break;
            }

            return _context2.abrupt("return");

          case 11:
            _context2.next = 13;
            return Object(_babel_runtime_helpers_esm_awaitAsyncGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(onceReadable(stream));

          case 13:
            _context2.next = 3;
            break;

          case 15:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _makeNodeStreamIterator.apply(this, arguments);
}

function onceReadable(_x3) {
  return _onceReadable.apply(this, arguments);
}

function _onceReadable() {
  _onceReadable = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_0__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee3(stream) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            return _context3.abrupt("return", new Promise(function (resolve) {
              stream.once('readable', resolve);
            }));

          case 1:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _onceReadable.apply(this, arguments);
}

function concatenateReadStream(readStream) {
  var arrayBuffer = new ArrayBuffer();
  var string = '';
  return new Promise(function (resolve, reject) {
    readStream.data(function (chunk) {
      if (typeof chunk === 'string') {
        string += chunk;
      } else {
        arrayBuffer = Object(_memory_copy_utils__WEBPACK_IMPORTED_MODULE_5__["concatenateArrayBuffers"])(arrayBuffer, chunk);
      }
    });
    readStream.on('error', function (error) {
      return reject(error);
    });
    readStream.on('end', function () {
      if (readStream.complete) {
        resolve(arrayBuffer || string);
      } else {
        reject('The connection was terminated while the message was still being sent');
      }
    });
  });
}
//# sourceMappingURL=stream-utils.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/text-encoding.js":
/*!***************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/javascript-utils/text-encoding.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof TextDecoder === 'undefined') {
  module.exports = {};
} else {
  module.exports = {
    TextEncoder: TextEncoder,
    TextDecoder: TextDecoder
  };
}
//# sourceMappingURL=text-encoding.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/lib/encode.js":
/*!*******************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/lib/encode.js ***!
  \*******************************************************************************************/
/*! exports provided: encode, encodeSync, encodeInBatches */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeSync", function() { return encodeSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeInBatches", function() { return encodeInBatches; });
function encode(data, writer, options, url) {
  if (writer.encode) {
    return writer.encode(data, options);
  }

  if (writer.encodeSync) {
    return Promise.resolve(writer.encodeSync(data, options));
  }

  throw new Error('Writer could not encode data');
}
function encodeSync(data, writer, options, url) {
  if (writer.encodeSync) {
    return writer.encodeSync(data, options);
  }

  throw new Error('Writer could not synchronously encode data');
}
function encodeInBatches(data, writer, options, url) {
  if (writer.encodeInBatches) {
    return writer.encodeInBatches(data, options);
  }

  throw new Error('Writer could not encode data in batches');
}
//# sourceMappingURL=encode.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file-browser.js":
/*!*************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file-browser.js ***!
  \*************************************************************************************************************/
/*! exports provided: fetchFile, readFileSync, createReadStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchFile", function() { return fetchFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readFileSync", function() { return readFileSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createReadStream", function() { return createReadStream; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/asyncToGenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/assert */ "../../node_modules/@loaders.gl/core/dist/esm/utils/assert.js");



var DEFAULT_OPTIONS = {
  dataType: 'arrayBuffer',
  nothrow: true
};

var isDataURL = function isDataURL(url) {
  return url.startsWith('data:');
};

function fetchFile(_x, _x2) {
  return _fetchFile.apply(this, arguments);
}

function _fetchFile() {
  _fetchFile = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(url, options) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return fetch(url, options);

          case 2:
            return _context.abrupt("return", _context.sent);

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fetchFile.apply(this, arguments);
}

function readFileSync(uri) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  options = getReadFileOptions(options);

  if (isDataURL(uri)) {}

  if (!options.nothrow) {
    Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(false);
  }

  return null;
}
function createReadStream(_x3, _x4) {
  return _createReadStream.apply(this, arguments);
}

function _createReadStream() {
  _createReadStream = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2(url, options) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            return _context2.abrupt("return", fetch(url, options).then(function (res) {
              return res.body;
            }));

          case 1:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _createReadStream.apply(this, arguments);
}

function getReadFileOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  options = Object.assign({}, DEFAULT_OPTIONS, options);
  options.responseType = options.responseType || options.dataType;
  return options;
}
//# sourceMappingURL=fetch-file-browser.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js":
/*!*****************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js ***!
  \*****************************************************************************************************/
/*! exports provided: fetchFile, readFileSync, createReadStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchFile", function() { return fetchFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readFileSync", function() { return readFileSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createReadStream", function() { return createReadStream; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/asyncToGenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/globals */ "../../node_modules/@loaders.gl/core/dist/esm/utils/globals.js");
/* harmony import */ var _node_fetch_fetch_file_node__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../node/fetch/fetch-file-node */ "../../node_modules/@loaders.gl/core/dist/esm/node/fetch/fetch-file-node.js");
/* harmony import */ var _fetch_file_browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fetch-file-browser */ "../../node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file-browser.js");
/* harmony import */ var _file_aliases__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./file-aliases */ "../../node_modules/@loaders.gl/core/dist/esm/lib/fetch/file-aliases.js");






function fetchFile(_x, _x2) {
  return _fetchFile.apply(this, arguments);
}

function _fetchFile() {
  _fetchFile = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(url, options) {
    var func;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            url = Object(_file_aliases__WEBPACK_IMPORTED_MODULE_5__["resolvePath"])(url);
            func = _utils_globals__WEBPACK_IMPORTED_MODULE_2__["isBrowser"] ? _fetch_file_browser__WEBPACK_IMPORTED_MODULE_4__["fetchFile"] : _node_fetch_fetch_file_node__WEBPACK_IMPORTED_MODULE_3__["fetchFile"];
            return _context.abrupt("return", func(url, options));

          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _fetchFile.apply(this, arguments);
}

function readFileSync(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  url = Object(_file_aliases__WEBPACK_IMPORTED_MODULE_5__["resolvePath"])(url);
  var func = _utils_globals__WEBPACK_IMPORTED_MODULE_2__["isBrowser"] ? _fetch_file_browser__WEBPACK_IMPORTED_MODULE_4__["readFileSync"] : _node_fetch_fetch_file_node__WEBPACK_IMPORTED_MODULE_3__["readFileSync"];
  return func(url, options);
}
function createReadStream(_x3, _x4) {
  return _createReadStream.apply(this, arguments);
}

function _createReadStream() {
  _createReadStream = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2(url, options) {
    var func;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            url = Object(_file_aliases__WEBPACK_IMPORTED_MODULE_5__["resolvePath"])(url);
            func = _utils_globals__WEBPACK_IMPORTED_MODULE_2__["isBrowser"] ? _fetch_file_browser__WEBPACK_IMPORTED_MODULE_4__["createReadStream"] : _node_fetch_fetch_file_node__WEBPACK_IMPORTED_MODULE_3__["createReadStream"];
            return _context2.abrupt("return", func(url, options));

          case 3:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _createReadStream.apply(this, arguments);
}
//# sourceMappingURL=fetch-file.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/lib/fetch/file-aliases.js":
/*!*******************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/lib/fetch/file-aliases.js ***!
  \*******************************************************************************************************/
/*! exports provided: setPathPrefix, getPathPrefix, addAliases, resolvePath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return setPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPathPrefix", function() { return getPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addAliases", function() { return addAliases; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolvePath", function() { return resolvePath; });
var pathPrefix = '';
var fileAliases = {};
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}
function getPathPrefix() {
  return pathPrefix;
}
function addAliases(aliases) {
  Object.assign(fileAliases, aliases);
}
function resolvePath(filename) {
  for (var alias in fileAliases) {
    if (filename.startsWith(alias)) {
      var replacement = fileAliases[alias];
      return filename.replace(alias, replacement);
    }
  }

  filename += pathPrefix;
  return filename;
}
//# sourceMappingURL=file-aliases.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js":
/*!*****************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js ***!
  \*****************************************************************************************************/
/*! exports provided: writeFile, writeFileSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeFile", function() { return writeFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeFileSync", function() { return writeFileSync; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/globals */ "../../node_modules/@loaders.gl/core/dist/esm/utils/globals.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/assert */ "../../node_modules/@loaders.gl/core/dist/esm/utils/assert.js");
/* harmony import */ var _node_fetch_write_file_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../node/fetch/write-file-node */ "../../node_modules/@loaders.gl/core/dist/esm/node/fetch/write-file-node.js");



function writeFile(filePath, arrayBufferOrString, options) {
  if (!_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return _node_fetch_write_file_node__WEBPACK_IMPORTED_MODULE_2__["writeFile"](filePath, arrayBufferOrString, options);
  }

  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
}
function writeFileSync(filePath, arrayBufferOrString, options) {
  if (!_utils_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"]) {
    return _node_fetch_write_file_node__WEBPACK_IMPORTED_MODULE_2__["writeFileSync"](filePath, arrayBufferOrString, options);
  }

  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
}
//# sourceMappingURL=write-file.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/lib/load.js":
/*!*****************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/lib/load.js ***!
  \*****************************************************************************************/
/*! exports provided: loadInBatches, load */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadInBatches", function() { return loadInBatches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "load", function() { return load; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/asyncToGenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _fetch_fetch_file__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fetch/fetch-file */ "../../node_modules/@loaders.gl/core/dist/esm/lib/fetch/fetch-file.js");
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_auto_detect_loader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loader-utils/auto-detect-loader */ "../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/auto-detect-loader.js");
/* harmony import */ var _parse__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parse */ "../../node_modules/@loaders.gl/core/dist/esm/lib/parse.js");
/* harmony import */ var _register_loaders__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./register-loaders */ "../../node_modules/@loaders.gl/core/dist/esm/lib/register-loaders.js");







function loadInBatches(_x, _x2, _x3) {
  return _loadInBatches.apply(this, arguments);
}

function _loadInBatches() {
  _loadInBatches = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(url, loaders, options) {
    var response;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return Object(_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_2__["fetchFile"])(url, options);

          case 2:
            response = _context.sent;
            return _context.abrupt("return", Object(_parse__WEBPACK_IMPORTED_MODULE_5__["parseInBatches"])(response, loaders, options, url));

          case 4:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadInBatches.apply(this, arguments);
}

function load(_x4, _x5, _x6) {
  return _load.apply(this, arguments);
}

function _load() {
  _load = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2(url, loaders, options) {
    var loader, response;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_3__["isLoaderObject"])(loaders)) {
              options = loaders;
              loaders = null;
            }

            loaders = loaders || Object(_register_loaders__WEBPACK_IMPORTED_MODULE_6__["getRegisteredLoaders"])();
            loader = Array.isArray(loaders) ? Object(_loader_utils_auto_detect_loader__WEBPACK_IMPORTED_MODULE_4__["autoDetectLoader"])(url, null, loaders) : loaders;

            if (!(loader && loader.loadAndParse)) {
              _context2.next = 7;
              break;
            }

            _context2.next = 6;
            return loader.loadAndParse(url, options);

          case 6:
            return _context2.abrupt("return", _context2.sent);

          case 7:
            _context2.next = 9;
            return Object(_fetch_fetch_file__WEBPACK_IMPORTED_MODULE_2__["fetchFile"])(url, options);

          case 9:
            response = _context2.sent;
            return _context2.abrupt("return", Object(_parse__WEBPACK_IMPORTED_MODULE_5__["parse"])(response, loaders, options, url));

          case 11:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _load.apply(this, arguments);
}
//# sourceMappingURL=load.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/auto-detect-loader.js":
/*!********************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/auto-detect-loader.js ***!
  \********************************************************************************************************************/
/*! exports provided: autoDetectLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "autoDetectLoader", function() { return autoDetectLoader; });
/* harmony import */ var _normalize_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./normalize-loader */ "../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js");

var EXT_PATTERN = /[^\.]+$/;
function autoDetectLoader() {
  var url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var text = arguments.length > 1 ? arguments[1] : undefined;
  var loaders = arguments.length > 2 ? arguments[2] : undefined;
  var match = url.match(EXT_PATTERN);

  if (match && match[0]) {
    var extension = match[0];

    var _loader = findLoaderByExtension(loaders, extension);

    if (_loader) {
      return _loader;
    }
  }

  var loader = findLoaderByExamingInitialData(loaders, text);

  if (loader) {
    return loader;
  }

  return null;
}

function findLoaderByExtension(loaders, extension) {
  extension = extension.toLowerCase();
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = loaders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var loader = _step.value;
      Object(_normalize_loader__WEBPACK_IMPORTED_MODULE_0__["normalizeLoader"])(loader);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = loader.extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var loaderExtension = _step2.value;

          if (loaderExtension.toLowerCase() === extension) {
            return loader;
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return null;
}

function findLoaderByExamingInitialData(loaders, text) {
  var _iteratorNormalCompletion3 = true;
  var _didIteratorError3 = false;
  var _iteratorError3 = undefined;

  try {
    for (var _iterator3 = loaders[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
      var loader = _step3.value;

      if (loader.testText && loader.testText(text)) {
        return loader;
      }
    }
  } catch (err) {
    _didIteratorError3 = true;
    _iteratorError3 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion3 && _iterator3["return"] != null) {
        _iterator3["return"]();
      }
    } finally {
      if (_didIteratorError3) {
        throw _iteratorError3;
      }
    }
  }

  return null;
}
//# sourceMappingURL=auto-detect-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js":
/*!**********************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js ***!
  \**********************************************************************************************************/
/*! exports provided: getUrlFromData, getSizeFromData, getArrayBufferOrStringFromDataSync, getArrayBufferOrStringFromData, getAsyncIteratorFromData, getIteratorFromData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUrlFromData", function() { return getUrlFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSizeFromData", function() { return getSizeFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrayBufferOrStringFromDataSync", function() { return getArrayBufferOrStringFromDataSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getArrayBufferOrStringFromData", function() { return getArrayBufferOrStringFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAsyncIteratorFromData", function() { return getAsyncIteratorFromData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIteratorFromData", function() { return getIteratorFromData; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/asyncToGenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../javascript-utils/is-type */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/is-type.js");
/* harmony import */ var _javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../javascript-utils/stream-utils */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/stream-utils.js");
/* harmony import */ var _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../javascript-utils/text-encoding */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/text-encoding.js");
/* harmony import */ var _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_4__);





var ERR_DATA = 'Cannot convert supplied data type';
function getUrlFromData(data) {
  return Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_2__["isFetchResponse"])(data) ? data.url : null;
}
function getSizeFromData(data) {
  return Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_2__["isFetchResponse"])(data) ? data.headers.get('Content-Length') : null;
}
function getArrayBufferOrStringFromDataSync(data, loader) {
  if (loader.text && typeof data === 'string') {
    return data;
  }

  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    var arrayBuffer = data.buffer || data;

    if (loader.text && !loader.binary) {
      var textDecoder = new _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_4__["TextDecoder"]('utf8');
      return textDecoder.decode(arrayBuffer);
    }

    return arrayBuffer;
  }

  throw new Error(ERR_DATA);
}
function getArrayBufferOrStringFromData(_x, _x2) {
  return _getArrayBufferOrStringFromData.apply(this, arguments);
}

function _getArrayBufferOrStringFromData() {
  _getArrayBufferOrStringFromData = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(data, loader) {
    var isArrayBuffer;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return data;

          case 2:
            data = _context.sent;
            isArrayBuffer = data instanceof ArrayBuffer || ArrayBuffer.isView(data);

            if (!(typeof data === 'string' || isArrayBuffer)) {
              _context.next = 6;
              break;
            }

            return _context.abrupt("return", getArrayBufferOrStringFromDataSync(data, loader));

          case 6:
            if (!Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_2__["isFetchResponse"])(data)) {
              _context.next = 15;
              break;
            }

            if (!loader.binary) {
              _context.next = 13;
              break;
            }

            _context.next = 10;
            return data.arrayBuffer();

          case 10:
            _context.t0 = _context.sent;
            _context.next = 14;
            break;

          case 13:
            _context.t0 = data.text();

          case 14:
            return _context.abrupt("return", _context.t0);

          case 15:
            throw new Error(ERR_DATA);

          case 16:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _getArrayBufferOrStringFromData.apply(this, arguments);
}

function getAsyncIteratorFromData(_x3, _x4) {
  return _getAsyncIteratorFromData.apply(this, arguments);
}

function _getAsyncIteratorFromData() {
  _getAsyncIteratorFromData = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2(data, loader) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_2__["isIterator"])(data)) {
              _context2.next = 2;
              break;
            }

            return _context2.abrupt("return", data);

          case 2:
            if (!Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_2__["isFetchResponse"])(data)) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt("return", Object(_javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_3__["getStreamIterator"])(data.body));

          case 4:
            if (!Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_2__["isReadableStream"])(data)) {
              _context2.next = 6;
              break;
            }

            return _context2.abrupt("return", Object(_javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_3__["getStreamIterator"])(data));

          case 6:
            if (!Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_2__["isAsyncIterable"])(data)) {
              _context2.next = 8;
              break;
            }

            return _context2.abrupt("return", data[Symbol.asyncIterator]());

          case 8:
            return _context2.abrupt("return", getIteratorFromData(data, loader));

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _getAsyncIteratorFromData.apply(this, arguments);
}

function getIteratorFromData(_x5, _x6) {
  return _getIteratorFromData.apply(this, arguments);
}

function _getIteratorFromData() {
  _getIteratorFromData = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee3(data, loader) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee3$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            if (!(data instanceof ArrayBuffer || ArrayBuffer.isView(data))) {
              _context4.next = 2;
              break;
            }

            return _context4.abrupt("return", _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function oneChunk() {
              return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function oneChunk$(_context3) {
                while (1) {
                  switch (_context3.prev = _context3.next) {
                    case 0:
                      _context3.next = 2;
                      return data.buffer || data;

                    case 2:
                    case "end":
                      return _context3.stop();
                  }
                }
              }, oneChunk);
            })());

          case 2:
            if (!Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_2__["isIterator"])(data)) {
              _context4.next = 4;
              break;
            }

            return _context4.abrupt("return", data);

          case 4:
            if (!Object(_javascript_utils_is_type__WEBPACK_IMPORTED_MODULE_2__["isIterable"])(data)) {
              _context4.next = 6;
              break;
            }

            return _context4.abrupt("return", data[Symbol.iterator]());

          case 6:
            throw new Error(ERR_DATA);

          case 7:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee3);
  }));
  return _getIteratorFromData.apply(this, arguments);
}
//# sourceMappingURL=get-data.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js":
/*!******************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js ***!
  \******************************************************************************************************************/
/*! exports provided: isLoaderObject, normalizeLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLoaderObject", function() { return isLoaderObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeLoader", function() { return normalizeLoader; });
/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/objectSpread.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/assert */ "../../node_modules/@loaders.gl/core/dist/esm/utils/assert.js");


function isLoaderObject(loader) {
  if (!loader) {
    return false;
  }

  if (Array.isArray(loader)) {
    loader = loader[0];
  }

  var hasParser = loader.parseTextSync || loader.parseSync || loader.parse || loader.loadAndParse || loader.parseStream || loader.parseInBatches || loader.worker;
  return hasParser;
}
function normalizeLoader(loader) {
  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(isLoaderObject(loader));
  var options;

  if (Array.isArray(loader)) {
    loader = loader[0];
    options = loader[1];
    loader = Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__["default"])({}, loader, {
      options: Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__["default"])({}, loader.options, {
        options: options
      })
    });
  }

  if (loader.extension) {
    loader.extensions = loader.extensions || [loader.extension];
    delete loader.extension;
  }

  if (!Array.isArray(loader.extensions)) {
    loader.extensions = [loader.extensions];
  }

  Object(_utils_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(loader.extensions && loader.extensions.length > 0 && loader.extensions[0]);

  if (loader.parseTextSync) {
    loader.text = true;
  }

  if (!loader.text) {
    loader.binary = true;
  }

  return loader;
}
//# sourceMappingURL=normalize-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/null-log.js":
/*!**********************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/null-log.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return NullLog; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/createClass.js");



var NullLog = function () {
  function NullLog() {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, NullLog);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(NullLog, [{
    key: "log",
    value: function log() {}
  }, {
    key: "info",
    value: function info() {}
  }, {
    key: "warn",
    value: function warn() {}
  }, {
    key: "error",
    value: function error() {}
  }]);

  return NullLog;
}();


//# sourceMappingURL=null-log.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/lib/parse-with-loader.js":
/*!******************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/lib/parse-with-loader.js ***!
  \******************************************************************************************************/
/*! exports provided: parseWithLoader, parseWithLoaderSync, parseWithLoaderInBatches, parseWithLoaderInBatchesSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseWithLoader", function() { return parseWithLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseWithLoaderSync", function() { return parseWithLoaderSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseWithLoaderInBatches", function() { return parseWithLoaderInBatches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseWithLoaderInBatchesSync", function() { return parseWithLoaderInBatchesSync; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/asyncToGenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/@loaders.gl/core/dist/esm/utils/assert.js");
/* harmony import */ var _parse_with_worker__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./parse-with-worker */ "../../node_modules/@loaders.gl/core/dist/esm/lib/parse-with-worker.js");
/* harmony import */ var _loader_utils_get_data__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loader-utils/get-data */ "../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/get-data.js");





function parseWithLoader(_x, _x2) {
  return _parseWithLoader.apply(this, arguments);
}

function _parseWithLoader() {
  _parseWithLoader = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(data, loader) {
    var options,
        url,
        _args = arguments;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
            url = _args.length > 3 ? _args[3] : undefined;
            url = url || Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_4__["getUrlFromData"])(data);
            _context.next = 5;
            return Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_4__["getArrayBufferOrStringFromData"])(data, loader);

          case 5:
            data = _context.sent;

            if (!(loader.parseTextSync && typeof data === 'string')) {
              _context.next = 9;
              break;
            }

            options.dataType = 'text';
            return _context.abrupt("return", loader.parseTextSync(data, options, url, loader));

          case 9:
            if (!loader.parseSync) {
              _context.next = 11;
              break;
            }

            return _context.abrupt("return", loader.parseSync(data, options, url, loader));

          case 11:
            if (!loader.parse) {
              _context.next = 15;
              break;
            }

            _context.next = 14;
            return loader.parse(data, options, url, loader);

          case 14:
            return _context.abrupt("return", _context.sent);

          case 15:
            if (!loader.worker) {
              _context.next = 19;
              break;
            }

            _context.next = 18;
            return Object(_parse_with_worker__WEBPACK_IMPORTED_MODULE_3__["default"])(loader.worker, data, options);

          case 18:
            return _context.abrupt("return", _context.sent);

          case 19:
            return _context.abrupt("return", Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(false));

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseWithLoader.apply(this, arguments);
}

function parseWithLoaderSync(data, loader) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var url = arguments.length > 3 ? arguments[3] : undefined;
  data = Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_4__["getArrayBufferOrStringFromDataSync"])(data, loader);

  if (loader.parseTextSync && typeof data === 'string') {
    return loader.parseTextSync(data, options, url, loader);
  }

  if (loader.parseSync) {
    return loader.parseSync(data, options, url, loader);
  }

  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(false);
}
function parseWithLoaderInBatches(_x3, _x4) {
  return _parseWithLoaderInBatches.apply(this, arguments);
}

function _parseWithLoaderInBatches() {
  _parseWithLoaderInBatches = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2(data, loader) {
    var options,
        url,
        inputIterator,
        outputIterator,
        _args2 = arguments;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            options = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : {};
            url = _args2.length > 3 ? _args2[3] : undefined;

            if (!loader.parseInBatches) {
              _context2.next = 8;
              break;
            }

            _context2.next = 5;
            return Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_4__["getAsyncIteratorFromData"])(data);

          case 5:
            inputIterator = _context2.sent;
            outputIterator = loader.parseInBatches(inputIterator, options, url, loader);
            return _context2.abrupt("return", outputIterator);

          case 8:
            return _context2.abrupt("return", null);

          case 9:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseWithLoaderInBatches.apply(this, arguments);
}

function parseWithLoaderInBatchesSync(_x5, _x6) {
  return _parseWithLoaderInBatchesSync.apply(this, arguments);
}

function _parseWithLoaderInBatchesSync() {
  _parseWithLoaderInBatchesSync = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee3(data, loader) {
    var options,
        url,
        inputIterator,
        outputIterator,
        _args3 = arguments;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            options = _args3.length > 2 && _args3[2] !== undefined ? _args3[2] : {};
            url = _args3.length > 3 ? _args3[3] : undefined;

            if (!loader.parseInBatchesSync) {
              _context3.next = 6;
              break;
            }

            inputIterator = Object(_loader_utils_get_data__WEBPACK_IMPORTED_MODULE_4__["getIteratorFromData"])(data);
            outputIterator = loader.parseInBatchesSync(inputIterator, options, url, loader, url);
            return _context3.abrupt("return", outputIterator);

          case 6:
            return _context3.abrupt("return", Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(false));

          case 7:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _parseWithLoaderInBatchesSync.apply(this, arguments);
}
//# sourceMappingURL=parse-with-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/lib/parse-with-worker.js":
/*!******************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/lib/parse-with-worker.js ***!
  \******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return parseWithWorker; });
/* harmony import */ var _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../javascript-utils/binary-utils */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/binary-utils.js");

var workerCache = new Map();

function getWorker(workerSource) {
  var workerURL = workerCache.get(workerSource);

  if (!workerURL) {
    var blob = new Blob([workerSource], {
      type: 'application/javascript'
    });
    workerURL = URL.createObjectURL(blob);
    workerCache.set(workerSource, workerURL);
  }

  return new Worker(workerURL);
}

function parseWithWorker(workerSource, data, options) {
  var worker = getWorker(workerSource);
  options = removeNontransferableOptions(options);

  var parse = function parse(rawData, opts) {
    return new Promise(function (resolve, reject) {
      worker.onmessage = function (evt) {
        switch (evt.data.type) {
          case 'done':
            resolve(evt.data.result);
            worker.terminate();
            break;

          case 'error':
            reject(new Error(evt.data.message));
            break;

          default:
        }
      };

      var arraybuffer = Object(_javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_0__["toArrayBuffer"])(rawData);
      worker.postMessage({
        arraybuffer: arraybuffer,
        opts: opts
      }, [arraybuffer]);
    });
  };

  return data ? parse(data, options) : parse;
}

function removeNontransferableOptions(options) {
  options = Object.assign({}, options);

  if (options.log !== null) {
    delete options.log;
  }

  return options;
}
//# sourceMappingURL=parse-with-worker.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/lib/parse.js":
/*!******************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/lib/parse.js ***!
  \******************************************************************************************/
/*! exports provided: parse, parseSync, parseInBatches, parseInBatchesSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseSync", function() { return parseSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseInBatches", function() { return parseInBatches; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseInBatchesSync", function() { return parseInBatchesSync; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/asyncToGenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _loader_utils_auto_detect_loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader-utils/auto-detect-loader */ "../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/auto-detect-loader.js");
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js");
/* harmony import */ var _loader_utils_null_log__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./loader-utils/null-log */ "../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/null-log.js");
/* harmony import */ var _register_loaders__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./register-loaders */ "../../node_modules/@loaders.gl/core/dist/esm/lib/register-loaders.js");
/* harmony import */ var _parse_with_loader__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parse-with-loader */ "../../node_modules/@loaders.gl/core/dist/esm/lib/parse-with-loader.js");







function parse(_x, _x2, _x3, _x4) {
  return _parse.apply(this, arguments);
}

function _parse() {
  _parse = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(data, loaders, options, url) {
    var loader;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_3__["isLoaderObject"])(loaders)) {
              url = options;
              options = loaders;
              loaders = null;
            }

            loaders = loaders || Object(_register_loaders__WEBPACK_IMPORTED_MODULE_5__["getRegisteredLoaders"])();
            loader = Array.isArray(loaders) ? Object(_loader_utils_auto_detect_loader__WEBPACK_IMPORTED_MODULE_2__["autoDetectLoader"])(url, data, loaders) : loaders;

            if (loader) {
              _context.next = 5;
              break;
            }

            return _context.abrupt("return", null);

          case 5:
            Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_3__["normalizeLoader"])(loader);
            options = mergeLoaderAndUserOptions(options, loader);
            _context.next = 9;
            return Object(_parse_with_loader__WEBPACK_IMPORTED_MODULE_6__["parseWithLoader"])(data, loader, options, url);

          case 9:
            return _context.abrupt("return", _context.sent);

          case 10:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parse.apply(this, arguments);
}

function parseSync(data, loaders, options, url) {
  if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_3__["isLoaderObject"])(loaders)) {
    url = options;
    options = loaders;
    loaders = null;
  }

  loaders = loaders || Object(_register_loaders__WEBPACK_IMPORTED_MODULE_5__["getRegisteredLoaders"])();
  var loader = Array.isArray(loaders) ? Object(_loader_utils_auto_detect_loader__WEBPACK_IMPORTED_MODULE_2__["autoDetectLoader"])(url, data, loaders) : loaders;
  Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_3__["normalizeLoader"])(loader);
  options = mergeLoaderAndUserOptions(options, loader);
  return Object(_parse_with_loader__WEBPACK_IMPORTED_MODULE_6__["parseWithLoaderSync"])(data, loader, options, url);
}
function parseInBatches(_x5, _x6, _x7, _x8) {
  return _parseInBatches.apply(this, arguments);
}

function _parseInBatches() {
  _parseInBatches = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2(data, loaders, options, url) {
    var loader;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_3__["isLoaderObject"])(loaders)) {
              url = options;
              options = loaders;
              loaders = null;
            }

            loaders = loaders || Object(_register_loaders__WEBPACK_IMPORTED_MODULE_5__["getRegisteredLoaders"])();
            loader = Array.isArray(loaders) ? Object(_loader_utils_auto_detect_loader__WEBPACK_IMPORTED_MODULE_2__["autoDetectLoader"])(url, null, loaders) : loaders;
            Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_3__["normalizeLoader"])(loader);
            options = mergeLoaderAndUserOptions(options, loader);
            return _context2.abrupt("return", Object(_parse_with_loader__WEBPACK_IMPORTED_MODULE_6__["parseWithLoaderInBatches"])(data, loader, options, url));

          case 6:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _parseInBatches.apply(this, arguments);
}

function parseInBatchesSync(_x9, _x10, _x11, _x12) {
  return _parseInBatchesSync.apply(this, arguments);
}

function _parseInBatchesSync() {
  _parseInBatchesSync = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee3(data, loaders, options, url) {
    var loader;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (!Array.isArray(loaders) && !Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_3__["isLoaderObject"])(loaders)) {
              url = options;
              options = loaders;
              loaders = null;
            }

            loaders = loaders || Object(_register_loaders__WEBPACK_IMPORTED_MODULE_5__["getRegisteredLoaders"])();
            loader = Array.isArray(loaders) ? Object(_loader_utils_auto_detect_loader__WEBPACK_IMPORTED_MODULE_2__["autoDetectLoader"])(url, null, loaders) : loaders;
            Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_3__["normalizeLoader"])(loader);
            options = mergeLoaderAndUserOptions(options, loader);
            return _context3.abrupt("return", Object(_parse_with_loader__WEBPACK_IMPORTED_MODULE_6__["parseWithLoaderInBatches"])(data, loader, options, url));

          case 6:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));
  return _parseInBatchesSync.apply(this, arguments);
}

function mergeLoaderAndUserOptions(options, loader) {
  options = Object.assign({}, loader.DEFAULT_OPTIONS, loader.options, options, {
    dataType: 'arraybuffer'
  });

  if (options.log === null) {
    options.log = new _loader_utils_null_log__WEBPACK_IMPORTED_MODULE_4__["default"]();
  }

  if (!('log' in options)) {
    options.log = console;
  }

  return options;
}
//# sourceMappingURL=parse.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/lib/register-loaders.js":
/*!*****************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/lib/register-loaders.js ***!
  \*****************************************************************************************************/
/*! exports provided: registerLoaders, getRegisteredLoaders */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerLoaders", function() { return registerLoaders; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRegisteredLoaders", function() { return getRegisteredLoaders; });
/* harmony import */ var _loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./loader-utils/normalize-loader */ "../../node_modules/@loaders.gl/core/dist/esm/lib/loader-utils/normalize-loader.js");

var registeredLoaders = {};
function registerLoaders(loaders) {
  loaders = Array.isArray(loaders) ? loaders : [loaders];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = loaders[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var loader = _step.value;
      Object(_loader_utils_normalize_loader__WEBPACK_IMPORTED_MODULE_0__["normalizeLoader"])(loader);
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = loader.extensions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var extension = _step2.value;
          registeredLoaders[extension] = loader;
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2["return"] != null) {
            _iterator2["return"]();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}
function getRegisteredLoaders() {
  return Object.values(registeredLoaders);
}
//# sourceMappingURL=register-loaders.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/lib/save.js":
/*!*****************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/lib/save.js ***!
  \*****************************************************************************************/
/*! exports provided: save, saveSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "save", function() { return save; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "saveSync", function() { return saveSync; });
/* harmony import */ var _encode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./encode */ "../../node_modules/@loaders.gl/core/dist/esm/lib/encode.js");
/* harmony import */ var _fetch_write_file__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fetch/write-file */ "../../node_modules/@loaders.gl/core/dist/esm/lib/fetch/write-file.js");


function save(data, url, writer) {
  var encodedData = Object(_encode__WEBPACK_IMPORTED_MODULE_0__["encode"])(data, writer, url);
  return Object(_fetch_write_file__WEBPACK_IMPORTED_MODULE_1__["writeFile"])(url, encodedData);
}
function saveSync(data, url, writer) {
  var encodedData = Object(_encode__WEBPACK_IMPORTED_MODULE_0__["encodeSync"])(data, writer, url);
  return Object(_fetch_write_file__WEBPACK_IMPORTED_MODULE_1__["writeFileSync"])(url, encodedData);
}
//# sourceMappingURL=save.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/node/fetch/decode-data-uri.js":
/*!***********************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/node/fetch/decode-data-uri.js ***!
  \***********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return decodeDataUri; });
function decodeDataUri(uri) {
  var dataIndex = uri.indexOf(',');
  var buffer;
  var mimeType;

  if (uri.slice(dataIndex - 7, dataIndex) === ';base64') {
    buffer = new Buffer(uri.slice(dataIndex + 1), 'base64');
    mimeType = uri.slice(5, dataIndex - 7).trim();
  } else {
    buffer = new Buffer(decodeURIComponent(uri.slice(dataIndex + 1)));
    mimeType = uri.slice(5, dataIndex).trim();
  }

  if (!mimeType) {
    mimeType = 'text/plain;charset=US-ASCII';
  } else if (mimeType[0] === ';') {
    mimeType = "text/plain".concat(mimeType);
  }

  return {
    buffer: buffer,
    mimeType: mimeType
  };
}
//# sourceMappingURL=decode-data-uri.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/node/fetch/fetch-file-node.js":
/*!***********************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/node/fetch/fetch-file-node.js ***!
  \***********************************************************************************************************/
/*! exports provided: fetchFile, readFileSync, createReadStream */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchFile", function() { return fetchFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readFileSync", function() { return readFileSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createReadStream", function() { return createReadStream; });
/* harmony import */ var _babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectSpread */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/objectSpread.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/regenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/asyncToGenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! fs */ 2);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! http */ 3);
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! https */ 4);
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_7__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! util */ 5);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var _javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../../javascript-utils/binary-utils */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/binary-utils.js");
/* harmony import */ var _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../../javascript-utils/text-encoding */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/text-encoding.js");
/* harmony import */ var _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(_javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_10__);
/* harmony import */ var _javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../../javascript-utils/stream-utils */ "../../node_modules/@loaders.gl/core/dist/esm/javascript-utils/stream-utils.js");
/* harmony import */ var _decode_data_uri__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./decode-data-uri */ "../../node_modules/@loaders.gl/core/dist/esm/node/fetch/decode-data-uri.js");













var DEFAULT_OPTIONS = {
  dataType: 'arrayBuffer'
};
var isNode = Boolean(fs__WEBPACK_IMPORTED_MODULE_5___default.a && fs__WEBPACK_IMPORTED_MODULE_5___default.a.readFile);

var isDataURL = function isDataURL(url) {
  return url.startsWith('data:');
};

var isRequestURL = function isRequestURL(url) {
  return url.startsWith('http:') || url.startsWith('https:');
};

var NodeHeaders = function () {
  function NodeHeaders(response) {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__["default"])(this, NodeHeaders);

    this.reponse = response;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(NodeHeaders, [{
    key: "get",
    value: function get(header) {
      if (this.response.httpResponse) {
        return this.response.httpResponse.getHeaders()[header];
      }

      switch (header) {
        case 'Content-Length':
          return this._getContentLength();

        default:
      }

      return undefined;
    }
  }, {
    key: "_getContentLength",
    value: function _getContentLength() {
      return this._contentLength;
    }
  }]);

  return NodeHeaders;
}();

var NodeFetchResponse = function () {
  function NodeFetchResponse(url, options) {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__["default"])(this, NodeFetchResponse);

    this.url = url;
    this.options = options;
    this.bodyUsed = false;
    this._headers = null;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(NodeFetchResponse, [{
    key: "arrayBuffer",
    value: function () {
      var _arrayBuffer = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee() {
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                this.bodyUsed = true;
                return _context.abrupt("return", readFile(this.url, this.options));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function arrayBuffer() {
        return _arrayBuffer.apply(this, arguments);
      }

      return arrayBuffer;
    }()
  }, {
    key: "text",
    value: function () {
      var _text = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee2() {
        var arrayBuffer, textDecoder;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.arrayBuffer();

              case 2:
                arrayBuffer = _context2.sent;
                textDecoder = new _javascript_utils_text_encoding__WEBPACK_IMPORTED_MODULE_10__["TextDecoder"]();
                return _context2.abrupt("return", textDecoder.decode(arrayBuffer));

              case 5:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function text() {
        return _text.apply(this, arguments);
      }

      return text;
    }()
  }, {
    key: "json",
    value: function () {
      var _json = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee3() {
        var text;
        return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.text();

              case 2:
                text = _context3.sent;
                return _context3.abrupt("return", JSON.parse(text));

              case 4:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function json() {
        return _json.apply(this, arguments);
      }

      return json;
    }()
  }, {
    key: "_getHeaders",
    value: function _getHeaders() {
      if (isRequestURL(this.url)) {
        return new NodeHeaders(this);
      }

      if (isDataURL(this.url)) {
        return {
          'Content-Length': this.url.length
        };
      }

      if (isRequestURL(this.repsonse.url)) {
        return {};
      }

      var stats = fs__WEBPACK_IMPORTED_MODULE_5___default.a.statSync(this.response.url);
      return {
        'Content-Length': stats.size
      };
    }
  }, {
    key: "headers",
    get: function get() {
      this._headers = this._headers || this._getHeaders();
    }
  }, {
    key: "body",
    get: function get() {
      var url = this.url,
          options = this.options;
      this.bodyUsed = true;
      return createReadStream(url, options);
    }
  }]);

  return NodeFetchResponse;
}();

function fetchFile(_x, _x2) {
  return _fetchFile.apply(this, arguments);
}

function _fetchFile() {
  _fetchFile = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee4(url, options) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            return _context4.abrupt("return", new NodeFetchResponse(url, options));

          case 1:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));
  return _fetchFile.apply(this, arguments);
}

function readFileSync(url) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  options = getReadFileOptions(options);

  if (isDataURL(url)) {
    return Object(_decode_data_uri__WEBPACK_IMPORTED_MODULE_12__["default"])(url);
  }

  if (!isNode) {
    return null;
  }

  var buffer = fs__WEBPACK_IMPORTED_MODULE_5___default.a.readFileSync(url, options, function () {});
  return buffer instanceof Buffer ? Object(_javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_9__["toArrayBuffer"])(buffer) : buffer;
}

function readFile(_x3) {
  return _readFile.apply(this, arguments);
}

function _readFile() {
  _readFile = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee5(url) {
    var options,
        readFileAsync,
        buffer,
        _args5 = arguments;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            options = _args5.length > 1 && _args5[1] !== undefined ? _args5[1] : {};
            options = getReadFileOptions(options);

            if (!isDataURL(url)) {
              _context5.next = 4;
              break;
            }

            return _context5.abrupt("return", Promise.resolve(Object(_decode_data_uri__WEBPACK_IMPORTED_MODULE_12__["default"])(url)));

          case 4:
            if (!isRequestURL(url)) {
              _context5.next = 6;
              break;
            }

            return _context5.abrupt("return", new Promise(function (resolve, reject) {
              options = Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__["default"])({}, new URL(url), options);
              var request = url.startsWith('https:') ? https__WEBPACK_IMPORTED_MODULE_7___default.a.request : http__WEBPACK_IMPORTED_MODULE_6___default.a.request;
              request(url, function (response) {
                return Object(_javascript_utils_stream_utils__WEBPACK_IMPORTED_MODULE_11__["concatenateReadStream"])(response).then(resolve, reject);
              });
            }));

          case 6:
            readFileAsync = util__WEBPACK_IMPORTED_MODULE_8___default.a.promisify(fs__WEBPACK_IMPORTED_MODULE_5___default.a.readFile);
            _context5.next = 9;
            return readFileAsync(url, options);

          case 9:
            buffer = _context5.sent;
            return _context5.abrupt("return", buffer instanceof Buffer ? Object(_javascript_utils_binary_utils__WEBPACK_IMPORTED_MODULE_9__["toArrayBuffer"])(buffer) : buffer);

          case 11:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5);
  }));
  return _readFile.apply(this, arguments);
}

function createReadStream(_x4, _x5) {
  return _createReadStream.apply(this, arguments);
}

function _createReadStream() {
  _createReadStream = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.mark(function _callee6(url, options) {
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_1___default.a.wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (!isDataURL(url)) {
              _context6.next = 2;
              break;
            }

            return _context6.abrupt("return", Object(_decode_data_uri__WEBPACK_IMPORTED_MODULE_12__["default"])(url));

          case 2:
            if (isRequestURL(url)) {
              _context6.next = 4;
              break;
            }

            return _context6.abrupt("return", fs__WEBPACK_IMPORTED_MODULE_5___default.a.createReadStream(url, options));

          case 4:
            return _context6.abrupt("return", new Promise(function (resolve, reject) {
              options = Object(_babel_runtime_helpers_esm_objectSpread__WEBPACK_IMPORTED_MODULE_0__["default"])({}, new URL(url), options);
              var request = url.startsWith('https:') ? https__WEBPACK_IMPORTED_MODULE_7___default.a.request : http__WEBPACK_IMPORTED_MODULE_6___default.a.request;
              request(url, function (response) {
                return resolve(response);
              });
            }));

          case 5:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6);
  }));
  return _createReadStream.apply(this, arguments);
}

function getReadFileOptions() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  options = Object.assign({}, DEFAULT_OPTIONS, options);
  options.responseType = options.responseType || options.dataType;

  if (fs__WEBPACK_IMPORTED_MODULE_5___default.a) {
    options.encoding = options.encoding || (options.dataType === 'text' ? 'utf8' : null);
  }

  return options;
}
//# sourceMappingURL=fetch-file-node.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/node/fetch/write-file-node.js":
/*!***********************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/node/fetch/write-file-node.js ***!
  \***********************************************************************************************************/
/*! exports provided: writeFile, writeFileSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeFile", function() { return writeFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "writeFileSync", function() { return writeFileSync; });
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ 2);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! util */ 5);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/assert */ "../../node_modules/@loaders.gl/core/dist/esm/utils/assert.js");



function writeFile(filePath, arrayBufferOrString) {
  return Object(util__WEBPACK_IMPORTED_MODULE_1__["promisify"])(fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFile)("".concat(filePath), toBuffer(arrayBufferOrString), {
    flag: 'w'
  });
}
function writeFileSync(filePath, arrayBufferOrString) {
  return fs__WEBPACK_IMPORTED_MODULE_0___default.a.writeFileSync("".concat(filePath), toBuffer(arrayBufferOrString), {
    flag: 'w'
  });
}

function toBuffer(binaryData) {
  if (ArrayBuffer.isView(binaryData)) {
    binaryData = binaryData.buffer;
  }

  if (typeof Buffer !== 'undefined' && binaryData instanceof ArrayBuffer) {
    var buffer = new Buffer(binaryData.byteLength);
    var view = new Uint8Array(binaryData);

    for (var i = 0; i < buffer.length; ++i) {
      buffer[i] = view[i];
    }

    return buffer;
  }

  return Object(_utils_assert__WEBPACK_IMPORTED_MODULE_2__["default"])(false);
}
//# sourceMappingURL=write-file-node.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/utils/assert.js":
/*!*********************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/utils/assert.js ***!
  \*********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'loader assertion failed.');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/utils/globals.js":
/*!**********************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/utils/globals.js ***!
  \**********************************************************************************************/
/*! exports provided: isBrowser, self, window, global, document */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process, global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/typeof.js");

var isBrowser = (typeof process === "undefined" ? "undefined" : Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(process)) !== 'object' || String(process) !== '[object process]' || process.browser;
var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};
var self_ = globals.self || globals.window || globals.global;
var window_ = globals.window || globals.self || globals.global;
var global_ = globals.global || globals.self || globals.window;
var document_ = globals.document || {};

//# sourceMappingURL=globals.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../process/browser.js */ "../../node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../../webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/worker-utils/create-worker.js":
/*!***********************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/worker-utils/create-worker.js ***!
  \***********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return createWorker; });
/* harmony import */ var _get_transfer_list__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-transfer-list */ "../../node_modules/@loaders.gl/core/dist/esm/worker-utils/get-transfer-list.js");

function createWorker(loader) {
  if (typeof self === 'undefined') {
    return;
  }

  self.onmessage = function (evt) {
    var _evt$data = evt.data,
        arraybuffer = _evt$data.arraybuffer,
        opts = _evt$data.opts;

    try {
      var data;
      var parser;

      if (loader.parseSync) {
        data = arraybuffer;
        parser = loader.parseSync;
      } else if (loader.parseTextSync) {
        var textDecoder = new TextDecoder();
        data = textDecoder.decode(arraybuffer);
        parser = loader.parseTextSync;
      } else {
        throw new Error("Could not load data with ".concat(loader.name, " loader"));
      }

      var result = parser(data, opts);
      var transferList = Object(_get_transfer_list__WEBPACK_IMPORTED_MODULE_0__["default"])(result);
      self.postMessage({
        type: 'done',
        result: result
      }, transferList);
    } catch (error) {
      self.postMessage({
        type: 'error',
        message: error.message
      });
    }
  };
}
//# sourceMappingURL=create-worker.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/dist/esm/worker-utils/get-transfer-list.js":
/*!***************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/dist/esm/worker-utils/get-transfer-list.js ***!
  \***************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getTransferList; });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/typeof.js");

function getTransferList(object) {
  var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  var transfers = arguments.length > 2 ? arguments[2] : undefined;
  var transfersSet = transfers || new Set();

  if (!object) {} else if (object instanceof ArrayBuffer) {
    transfersSet.add(object);
  } else if (object.buffer && object.buffer instanceof ArrayBuffer) {
    transfersSet.add(object.buffer);
  } else if (recursive && Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(object) === 'object') {
    for (var key in object) {
      getTransferList(object[key], recursive, transfersSet);
    }
  }

  return transfers === undefined ? Array.from(transfersSet) : null;
}
//# sourceMappingURL=get-transfer-list.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/AsyncGenerator.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/AsyncGenerator.js ***!
  \******************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AsyncGenerator; });
/* harmony import */ var _AwaitValue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AwaitValue */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/AwaitValue.js");

function AsyncGenerator(gen) {
  var front, back;

  function send(key, arg) {
    return new Promise(function (resolve, reject) {
      var request = {
        key: key,
        arg: arg,
        resolve: resolve,
        reject: reject,
        next: null
      };

      if (back) {
        back = back.next = request;
      } else {
        front = back = request;
        resume(key, arg);
      }
    });
  }

  function resume(key, arg) {
    try {
      var result = gen[key](arg);
      var value = result.value;
      var wrappedAwait = value instanceof _AwaitValue__WEBPACK_IMPORTED_MODULE_0__["default"];
      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {
        if (wrappedAwait) {
          resume("next", arg);
          return;
        }

        settle(result.done ? "return" : "normal", arg);
      }, function (err) {
        resume("throw", err);
      });
    } catch (err) {
      settle("throw", err);
    }
  }

  function settle(type, value) {
    switch (type) {
      case "return":
        front.resolve({
          value: value,
          done: true
        });
        break;

      case "throw":
        front.reject(value);
        break;

      default:
        front.resolve({
          value: value,
          done: false
        });
        break;
    }

    front = front.next;

    if (front) {
      resume(front.key, front.arg);
    } else {
      back = null;
    }
  }

  this._invoke = send;

  if (typeof gen["return"] !== "function") {
    this["return"] = undefined;
  }
}

if (typeof Symbol === "function" && Symbol.asyncIterator) {
  AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
    return this;
  };
}

AsyncGenerator.prototype.next = function (arg) {
  return this._invoke("next", arg);
};

AsyncGenerator.prototype["throw"] = function (arg) {
  return this._invoke("throw", arg);
};

AsyncGenerator.prototype["return"] = function (arg) {
  return this._invoke("return", arg);
};

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/AwaitValue.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/AwaitValue.js ***!
  \**************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _AwaitValue; });
function _AwaitValue(value) {
  this.wrapped = value;
}

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/asyncIterator.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/asyncIterator.js ***!
  \*****************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _asyncIterator; });
function _asyncIterator(iterable) {
  var method;

  if (typeof Symbol === "function") {
    if (Symbol.asyncIterator) {
      method = iterable[Symbol.asyncIterator];
      if (method != null) return method.call(iterable);
    }

    if (Symbol.iterator) {
      method = iterable[Symbol.iterator];
      if (method != null) return method.call(iterable);
    }
  }

  throw new TypeError("Object is not async iterable");
}

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!********************************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _asyncToGenerator; });
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js":
/*!***********************************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js ***!
  \***********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _awaitAsyncGenerator; });
/* harmony import */ var _AwaitValue__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AwaitValue */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/AwaitValue.js");

function _awaitAsyncGenerator(value) {
  return new _AwaitValue__WEBPACK_IMPORTED_MODULE_0__["default"](value);
}

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \******************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _classCallCheck; });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \***************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _createClass; });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!******************************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \******************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _defineProperty; });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/objectSpread.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/objectSpread.js ***!
  \****************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _objectSpread; });
/* harmony import */ var _defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./defineProperty */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/defineProperty.js");

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    var ownKeys = Object.keys(source);

    if (typeof Object.getOwnPropertySymbols === 'function') {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }

    ownKeys.forEach(function (key) {
      Object(_defineProperty__WEBPACK_IMPORTED_MODULE_0__["default"])(target, key, source[key]);
    });
  }

  return target;
}

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \**********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _typeof; });
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js":
/*!**********************************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js ***!
  \**********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _wrapAsyncGenerator; });
/* harmony import */ var _AsyncGenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AsyncGenerator */ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/helpers/esm/AsyncGenerator.js");

function _wrapAsyncGenerator(fn) {
  return function () {
    return new _AsyncGenerator__WEBPACK_IMPORTED_MODULE_0__["default"](fn.apply(this, arguments));
  };
}

/***/ }),

/***/ "../../node_modules/@loaders.gl/core/node_modules/@babel/runtime/regenerator/index.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/node_modules/@babel/runtime/regenerator/index.js ***!
  \*********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! regenerator-runtime */ "../../node_modules/@loaders.gl/core/node_modules/regenerator-runtime/runtime.js");


/***/ }),

/***/ "../../node_modules/@loaders.gl/core/node_modules/regenerator-runtime/runtime.js":
/*!****************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/core/node_modules/regenerator-runtime/runtime.js ***!
  \****************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/image-loader.js":
/*!***********************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/images/dist/esm/image-loader.js ***!
  \***********************************************************************************************/
/*! exports provided: default, ImageBitmapLoader, HTMLImageLoader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return ImageBitmapLoader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTMLImageLoader", function() { return HTMLImageLoader; });
/* harmony import */ var _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/parse-image */ "../../node_modules/@loaders.gl/images/dist/esm/lib/parse-image.js");

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'Images',
  extension: [],
  parse: _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["canParseImage"] && _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["parseImage"],
  loadAndParse: !_lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["canParseImage"] && _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["loadImage"]
});
var ImageBitmapLoader = {
  parse: _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["parseToImageBitmap"]
};
var HTMLImageLoader = {
  loadAndParse: _lib_parse_image__WEBPACK_IMPORTED_MODULE_0__["loadToHTMLImage"]
};
//# sourceMappingURL=image-loader.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/image-writer.js":
/*!***********************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/images/dist/esm/image-writer.js ***!
  \***********************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lib_encode_image__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/encode-image */ "../../node_modules/@loaders.gl/images/dist/esm/lib/encode-image.js");

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'Images',
  extensions: ['jpeg'],
  encode: _lib_encode_image__WEBPACK_IMPORTED_MODULE_0__["encodeImage"],
  DEFAULT_OPTIONS: {
    type: 'png'
  }
});
//# sourceMappingURL=image-writer.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/index.js":
/*!****************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/images/dist/esm/index.js ***!
  \****************************************************************************************/
/*! exports provided: ImageLoader, HTMLImageLoader, ImageBitmapLoader, ImageWriter, loadImage, isImage, getImageMetadata, decodeImage, getImageSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _image_loader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./image-loader */ "../../node_modules/@loaders.gl/images/dist/esm/image-loader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return _image_loader__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HTMLImageLoader", function() { return _image_loader__WEBPACK_IMPORTED_MODULE_0__["HTMLImageLoader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return _image_loader__WEBPACK_IMPORTED_MODULE_0__["ImageBitmapLoader"]; });

/* harmony import */ var _image_writer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./image-writer */ "../../node_modules/@loaders.gl/images/dist/esm/image-writer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ImageWriter", function() { return _image_writer__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _lib_parse_image__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/parse-image */ "../../node_modules/@loaders.gl/images/dist/esm/lib/parse-image.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return _lib_parse_image__WEBPACK_IMPORTED_MODULE_2__["loadImage"]; });

/* harmony import */ var _lib_get_image_metadata__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/get-image-metadata */ "../../node_modules/@loaders.gl/images/dist/esm/lib/get-image-metadata.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isImage", function() { return _lib_get_image_metadata__WEBPACK_IMPORTED_MODULE_3__["isImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageMetadata", function() { return _lib_get_image_metadata__WEBPACK_IMPORTED_MODULE_3__["getImageMetadata"]; });

/* harmony import */ var _lib_image_utils_browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/image-utils-browser */ "../../node_modules/@loaders.gl/images/dist/esm/lib/image-utils-browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "decodeImage", function() { return _lib_image_utils_browser__WEBPACK_IMPORTED_MODULE_4__["decodeImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getImageSize", function() { return _lib_get_image_metadata__WEBPACK_IMPORTED_MODULE_3__["getImageSize"]; });







//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/encode-image.js":
/*!***************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/encode-image.js ***!
  \***************************************************************************************************/
/*! exports provided: encodeImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeImage", function() { return encodeImage; });
/* harmony import */ var _loaders_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @loaders.gl/core */ "../../node_modules/@loaders.gl/core/dist/esm/index.js");
/* harmony import */ var _node_encode_image_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node/encode-image-node */ "../../node_modules/@loaders.gl/images/dist/esm/node/encode-image-node.js");


function encodeImage(image, type) {
  if (_node_encode_image_node__WEBPACK_IMPORTED_MODULE_1__["encodeImageNode"]) {
    return Object(_node_encode_image_node__WEBPACK_IMPORTED_MODULE_1__["encodeImageNode"])(image, type);
  }

  if (image instanceof HTMLCanvasElement) {
    var _canvas = image;
    return _canvas.toDataURL(type);
  }

  Object(_loaders_gl_core__WEBPACK_IMPORTED_MODULE_0__["assert"])(image instanceof Image, 'getImageData accepts image or canvas');
  var canvas = document.createElement('canvas');
  canvas.width = image.width;
  canvas.height = image.height;
  canvas.getContext('2d').drawImage(image, 0, 0);
  var data = canvas.toDataURL(type || 'png').replace(/^data:image\/(png|jpg);base64,/, '');
  return Promise.resolve(data);
}
//# sourceMappingURL=encode-image.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/get-image-metadata.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/get-image-metadata.js ***!
  \*********************************************************************************************************/
/*! exports provided: isImage, getImageMetadata, getImageSize */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isImage", function() { return isImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageMetadata", function() { return getImageMetadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImageSize", function() { return getImageSize; });
/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ "../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _node_buffer_to_array_buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node/buffer-to-array-buffer */ "../../node_modules/@loaders.gl/images/dist/esm/node/buffer-to-array-buffer.js");


var BIG_ENDIAN = false;
var LITTLE_ENDIAN = true;
var mimeTypeMap = new Map([['image/png', getPngSize], ['image/jpeg', getJpegSize], ['image/gif', getGifSize], ['image/bmp', getBmpSize]]);
var ERR_INVALID_TYPE = "Invalid MIME type. Supported MIME types are: ".concat(Array.from(mimeTypeMap.keys()).join(', '));
function isImage(arrayBuffer) {
  var result = guessImageMetadata(arrayBuffer);
  return result ? result.mimeType : false;
}
function getImageMetadata(arrayBuffer) {
  var mimeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  if (mimeType) {
    var handler = mimeTypeMap.get(mimeType);

    if (!handler) {
      throw new Error(ERR_INVALID_TYPE);
    }

    var _result = handler(arrayBuffer);

    if (!_result) {
      throw new Error("invalid image data for type: ".concat(mimeType));
    }

    return _result;
  }

  var result = guessImageMetadata(arrayBuffer, mimeType);

  if (!result) {
    throw new Error(ERR_INVALID_TYPE);
  }

  return result;
}

function guessImageMetadata(arrayBuffer, mimeType) {
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = mimeTypeMap.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var _step$value = Object(_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_step.value, 2),
          supportedMimeType = _step$value[0],
          handler = _step$value[1];

      var result = handler(arrayBuffer);

      if (result) {
        result.mimeType = supportedMimeType;
        return result;
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return null;
}

function getPngSize(arrayBuffer) {
  var dataView = toDataView(arrayBuffer);

  if (dataView.byteLength < 24 || dataView.getUint32(0, BIG_ENDIAN) !== 0x89504e47) {
    return null;
  }

  return {
    width: dataView.getUint32(16, BIG_ENDIAN),
    height: dataView.getUint32(20, BIG_ENDIAN)
  };
}

function getGifSize(arrayBuffer) {
  var dataView = toDataView(arrayBuffer);

  if (dataView.byteLength < 10 || dataView.getUint32(0, BIG_ENDIAN) !== 0x47494638) {
    return null;
  }

  return {
    width: dataView.getUint16(6, LITTLE_ENDIAN),
    height: dataView.getUint16(8, LITTLE_ENDIAN)
  };
}

function getBmpSize(arrayBuffer) {
  var dataView = toDataView(arrayBuffer);

  if (dataView.getUint16(0, BIG_ENDIAN) !== 0x424d) {
    return null;
  }

  return {
    width: dataView.getUint32(18, LITTLE_ENDIAN),
    height: dataView.getUint32(22, LITTLE_ENDIAN)
  };
}

function getJpegSize(arrayBuffer) {
  var dataView = toDataView(arrayBuffer);

  if (dataView.byteLength < 2 || dataView.getUint16(0, BIG_ENDIAN) !== 0xffd8) {
    return null;
  }

  var _getJpegMarkers = getJpegMarkers(),
      tableMarkers = _getJpegMarkers.tableMarkers,
      sofMarkers = _getJpegMarkers.sofMarkers;

  var i = 2;

  while (i < dataView.byteLength) {
    var marker = dataView.getUint16(i, BIG_ENDIAN);

    if (sofMarkers.has(marker)) {
      return {
        height: dataView.getUint16(i + 5, BIG_ENDIAN),
        width: dataView.getUint16(i + 7, BIG_ENDIAN)
      };
    }

    if (!tableMarkers.has(marker)) {
      return null;
    }

    i += 2;
    i += dataView.getUint16(i, BIG_ENDIAN);
  }

  return null;
}

function getJpegMarkers() {
  var tableMarkers = new Set([0xffdb, 0xffc4, 0xffcc, 0xffdd, 0xfffe]);

  for (var i = 0xffe0; i < 0xfff0; ++i) {
    tableMarkers.add(i);
  }

  var sofMarkers = new Set([0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc9, 0xffca, 0xffcb, 0xffcd, 0xffce, 0xffcf, 0xffde]);
  return {
    tableMarkers: tableMarkers,
    sofMarkers: sofMarkers
  };
}

function toDataView(data) {
  if (_node_buffer_to_array_buffer__WEBPACK_IMPORTED_MODULE_1__["bufferToArrayBuffer"]) {
    data = Object(_node_buffer_to_array_buffer__WEBPACK_IMPORTED_MODULE_1__["bufferToArrayBuffer"])(data);
  }

  if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
    return new DataView(data.buffer || data);
  }

  throw new Error('toDataView');
}

function getImageSize(arrayBuffer) {
  var mimeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  return getImageMetadata(arrayBuffer);
}
//# sourceMappingURL=get-image-metadata.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/image-utils-browser.js":
/*!**********************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/image-utils-browser.js ***!
  \**********************************************************************************************************/
/*! exports provided: decodeImage, getImagePixelData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeImage", function() { return decodeImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getImagePixelData", function() { return getImagePixelData; });
function decodeImage(arrayBufferOrView, _ref) {
  var _ref$mimeType = _ref.mimeType,
      mimeType = _ref$mimeType === void 0 ? 'image/jpeg' : _ref$mimeType;
  var blob = new Blob([arrayBufferOrView], {
    type: mimeType
  });
  var urlCreator = window.URL || window.webkitURL;
  var imageUrl = urlCreator.createObjectURL(blob);
  return new Promise(function (resolve, reject) {
    var image = new Image();

    image.onload = function () {
      return resolve(image);
    };

    image.onerror = reject;
    image.src = imageUrl;
    return image;
  });
}
function getImagePixelData(image) {
  var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  width = width || image.width;
  height = height || image.height;
  var canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  var ctx = canvas.getContext('2d');
  ctx.drawImage(image, 0, 0, width, height);
  return ctx.getImageData(0, 0, width, height);
}
//# sourceMappingURL=image-utils-browser.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/lib/parse-image.js":
/*!**************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/images/dist/esm/lib/parse-image.js ***!
  \**************************************************************************************************/
/*! exports provided: canParseImage, parseImage, loadImage, parseToImageBitmap, loadToHTMLImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canParseImage", function() { return canParseImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseImage", function() { return parseImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return loadImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseToImageBitmap", function() { return parseToImageBitmap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadToHTMLImage", function() { return loadToHTMLImage; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "../../node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/asyncToGenerator */ "../../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var _node_parse_image_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../node/parse-image-node */ "../../node_modules/@loaders.gl/images/dist/esm/node/parse-image-node.js");



var canParseImage = _node_parse_image_node__WEBPACK_IMPORTED_MODULE_2__["parseImageNode"] || typeof ImageBitmap !== 'undefined';
function parseImage(arrayBuffer, options) {
  if (_node_parse_image_node__WEBPACK_IMPORTED_MODULE_2__["parseImageNode"]) {
    return Object(_node_parse_image_node__WEBPACK_IMPORTED_MODULE_2__["parseImageNode"])(arrayBuffer, options);
  }

  return parseToImageBitmap(arrayBuffer);
}
function loadImage(_x, _x2) {
  return _loadImage.apply(this, arguments);
}

function _loadImage() {
  _loadImage = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(url, options) {
    var response, arrayBuffer;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (!(typeof Image === 'undefined')) {
              _context.next = 8;
              break;
            }

            _context.next = 3;
            return fetch(url, options);

          case 3:
            response = _context.sent;
            _context.next = 6;
            return response.arrayBuffer();

          case 6:
            arrayBuffer = _context.sent;
            return _context.abrupt("return", parseImage(arrayBuffer));

          case 8:
            _context.next = 10;
            return loadToHTMLImage(url, options);

          case 10:
            return _context.abrupt("return", _context.sent);

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _loadImage.apply(this, arguments);
}

function parseToImageBitmap(arrayBuffer) {
  if (typeof createImageBitmap === 'undefined') {
    throw new Error('parseImage');
  }

  var blob = new Blob([new Uint8Array(arrayBuffer)]);
  return createImageBitmap(blob);
}
function loadToHTMLImage(_x3, _x4) {
  return _loadToHTMLImage.apply(this, arguments);
}

function _loadToHTMLImage() {
  _loadToHTMLImage = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee2(url, options) {
    var src, response, xml;
    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (!/\.svg((\?|#).*)?$/.test(url)) {
              _context2.next = 10;
              break;
            }

            _context2.next = 3;
            return fetch(url, options);

          case 3:
            response = _context2.sent;
            _context2.next = 6;
            return response.text();

          case 6:
            xml = _context2.sent;
            src = "data:image/svg+xml;base64,".concat(btoa(xml));
            _context2.next = 13;
            break;

          case 10:
            _context2.next = 12;
            return url;

          case 12:
            src = _context2.sent;

          case 13:
            _context2.next = 15;
            return new Promise(function (resolve, reject) {
              try {
                var image = new Image();

                image.onload = function () {
                  return resolve(image);
                };

                image.onerror = function (err) {
                  return reject(new Error("Could not load image ".concat(url, ": ").concat(err)));
                };

                image.crossOrigin = options && options.crossOrigin || 'anonymous';
                image.src = src;
              } catch (error) {
                reject(error);
              }
            });

          case 15:
            return _context2.abrupt("return", _context2.sent);

          case 16:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));
  return _loadToHTMLImage.apply(this, arguments);
}
//# sourceMappingURL=parse-image.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/node/buffer-to-array-buffer.js":
/*!**************************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/images/dist/esm/node/buffer-to-array-buffer.js ***!
  \**************************************************************************************************************/
/*! exports provided: bufferToArrayBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bufferToArrayBuffer", function() { return bufferToArrayBuffer; });
function bufferToArrayBuffer(buffer) {
  if (Buffer.isBuffer(buffer)) {
    var typedArray = new Uint8Array(buffer);
    return typedArray.buffer;
  }

  return buffer;
}
//# sourceMappingURL=buffer-to-array-buffer.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/node/encode-image-node.js":
/*!*********************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/images/dist/esm/node/encode-image-node.js ***!
  \*********************************************************************************************************/
/*! exports provided: encodeImageToStreamNode, encodeImageNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeImageToStreamNode", function() { return encodeImageToStreamNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodeImageNode", function() { return encodeImageNode; });
/* harmony import */ var save_pixels__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! save-pixels */ 6);
/* harmony import */ var save_pixels__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(save_pixels__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ndarray */ 7);
/* harmony import */ var ndarray__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(ndarray__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _buffer_to_array_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buffer-to-array-buffer */ "../../node_modules/@loaders.gl/images/dist/esm/node/buffer-to-array-buffer.js");



function encodeImageToStreamNode(image, options) {
  var type = options.type ? options.type.replace('image/', '') : 'jpeg';
  var pixels = ndarray__WEBPACK_IMPORTED_MODULE_1___default()(image.data, [image.width, image.height, 4], [4, image.width * 4, 1], 0);
  return save_pixels__WEBPACK_IMPORTED_MODULE_0___default()(pixels, type, options);
}
function encodeImageNode(image, options) {
  var imageStream = encodeImageToStreamNode(image, options);
  return new Promise(function (resolve) {
    var buffers = [];
    imageStream.on('data', function (buffer) {
      return buffers.push(buffer);
    });
    imageStream.on('end', function () {
      var buffer = Buffer.concat(buffers);
      resolve(Object(_buffer_to_array_buffer__WEBPACK_IMPORTED_MODULE_2__["bufferToArrayBuffer"])(buffer));
    });
  });
}
//# sourceMappingURL=encode-image-node.js.map

/***/ }),

/***/ "../../node_modules/@loaders.gl/images/dist/esm/node/parse-image-node.js":
/*!********************************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@loaders.gl/images/dist/esm/node/parse-image-node.js ***!
  \********************************************************************************************************/
/*! exports provided: parseImageNode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseImageNode", function() { return parseImageNode; });
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/regenerator */ "../../node_modules/@babel/runtime/regenerator/index.js");
/* harmony import */ var _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/asyncToGenerator */ "../../node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js");
/* harmony import */ var get_pixels__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! get-pixels */ 0);
/* harmony import */ var get_pixels__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(get_pixels__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ 1);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _lib_get_image_metadata__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../lib/get-image-metadata */ "../../node_modules/@loaders.gl/images/dist/esm/lib/get-image-metadata.js");





function parseImageNode(_x, _x2) {
  return _parseImageNode.apply(this, arguments);
}

function _parseImageNode() {
  _parseImageNode = Object(_babel_runtime_helpers_esm_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(_babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.mark(function _callee(arrayBuffer, options) {
    var getPixelsAsync, _getImageMetadata, mimeType, buffer, ndarray;

    return _babel_runtime_regenerator__WEBPACK_IMPORTED_MODULE_0___default.a.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            getPixelsAsync = util__WEBPACK_IMPORTED_MODULE_3___default.a.promisify(get_pixels__WEBPACK_IMPORTED_MODULE_2___default.a);
            _getImageMetadata = Object(_lib_get_image_metadata__WEBPACK_IMPORTED_MODULE_4__["getImageMetadata"])(arrayBuffer), mimeType = _getImageMetadata.mimeType;
            buffer = arrayBuffer instanceof Buffer ? arrayBuffer : Buffer.from(arrayBuffer);
            _context.next = 5;
            return getPixelsAsync(buffer, mimeType);

          case 5:
            ndarray = _context.sent;
            return _context.abrupt("return", {
              width: ndarray.shape[0],
              height: ndarray.shape[1],
              data: ndarray.data
            });

          case 7:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));
  return _parseImageNode.apply(this, arguments);
}
//# sourceMappingURL=parse-image-node.js.map

/***/ }),

/***/ "../../node_modules/@mapbox/tiny-sdf/index.js":
/*!*****************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/@mapbox/tiny-sdf/index.js ***!
  \*****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = TinySDF;

var INF = 1e20;

function TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight) {
    this.fontSize = fontSize || 24;
    this.buffer = buffer === undefined ? 3 : buffer;
    this.cutoff = cutoff || 0.25;
    this.fontFamily = fontFamily || 'sans-serif';
    this.fontWeight = fontWeight || 'normal';
    this.radius = radius || 8;
    var size = this.size = this.fontSize + this.buffer * 2;

    this.canvas = document.createElement('canvas');
    this.canvas.width = this.canvas.height = size;

    this.ctx = this.canvas.getContext('2d');
    this.ctx.font = this.fontWeight + ' ' + this.fontSize + 'px ' + this.fontFamily;
    this.ctx.textBaseline = 'middle';
    this.ctx.fillStyle = 'black';

    // temporary arrays for the distance transform
    this.gridOuter = new Float64Array(size * size);
    this.gridInner = new Float64Array(size * size);
    this.f = new Float64Array(size);
    this.d = new Float64Array(size);
    this.z = new Float64Array(size + 1);
    this.v = new Int16Array(size);

    // hack around https://bugzilla.mozilla.org/show_bug.cgi?id=737852
    this.middle = Math.round((size / 2) * (navigator.userAgent.indexOf('Gecko/') >= 0 ? 1.2 : 1));
}

TinySDF.prototype.draw = function (char) {
    this.ctx.clearRect(0, 0, this.size, this.size);
    this.ctx.fillText(char, this.buffer, this.middle);

    var imgData = this.ctx.getImageData(0, 0, this.size, this.size);
    var alphaChannel = new Uint8ClampedArray(this.size * this.size);

    for (var i = 0; i < this.size * this.size; i++) {
        var a = imgData.data[i * 4 + 3] / 255; // alpha value
        this.gridOuter[i] = a === 1 ? 0 : a === 0 ? INF : Math.pow(Math.max(0, 0.5 - a), 2);
        this.gridInner[i] = a === 1 ? INF : a === 0 ? 0 : Math.pow(Math.max(0, a - 0.5), 2);
    }

    edt(this.gridOuter, this.size, this.size, this.f, this.d, this.v, this.z);
    edt(this.gridInner, this.size, this.size, this.f, this.d, this.v, this.z);

    for (i = 0; i < this.size * this.size; i++) {
        var d = this.gridOuter[i] - this.gridInner[i];
        alphaChannel[i] = Math.max(0, Math.min(255, Math.round(255 - 255 * (d / this.radius + this.cutoff))));
    }

    return alphaChannel;
};

// 2D Euclidean distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/dt/
function edt(data, width, height, f, d, v, z) {
    for (var x = 0; x < width; x++) {
        for (var y = 0; y < height; y++) {
            f[y] = data[y * width + x];
        }
        edt1d(f, d, v, z, height);
        for (y = 0; y < height; y++) {
            data[y * width + x] = d[y];
        }
    }
    for (y = 0; y < height; y++) {
        for (x = 0; x < width; x++) {
            f[x] = data[y * width + x];
        }
        edt1d(f, d, v, z, width);
        for (x = 0; x < width; x++) {
            data[y * width + x] = Math.sqrt(d[x]);
        }
    }
}

// 1D squared distance transform
function edt1d(f, d, v, z, n) {
    v[0] = 0;
    z[0] = -INF;
    z[1] = +INF;

    for (var q = 1, k = 0; q < n; q++) {
        var s = ((f[q] + q * q) - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
        while (s <= z[k]) {
            k--;
            s = ((f[q] + q * q) - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k]);
        }
        k++;
        v[k] = q;
        z[k] = s;
        z[k + 1] = +INF;
    }

    for (q = 0, k = 0; q < n; q++) {
        while (z[k + 1] < q) k++;
        d[q] = (q - v[k]) * (q - v[k]) + f[v[k]];
    }
}


/***/ }),

/***/ "../../node_modules/earcut/src/earcut.js":
/*!************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/earcut/src/earcut.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertice leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertice index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertice nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ "../../node_modules/process/browser.js":
/*!**********************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/process/browser.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../node_modules/regenerator-runtime/runtime-module.js":
/*!*****************************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/regenerator-runtime/runtime-module.js ***!
  \*****************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

// This method of obtaining a reference to the global object needs to be
// kept identical to the way it is obtained in runtime.js
var g = (function() {
  return this || (typeof self === "object" && self);
})() || Function("return this")();

// Use `getOwnPropertyNames` because not all browsers support calling
// `hasOwnProperty` on the global `self` object in a worker. See #183.
var hadRuntime = g.regeneratorRuntime &&
  Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0;

// Save the old regeneratorRuntime in case it needs to be restored later.
var oldRuntime = hadRuntime && g.regeneratorRuntime;

// Force reevalutation of runtime.js.
g.regeneratorRuntime = undefined;

module.exports = __webpack_require__(/*! ./runtime */ "../../node_modules/regenerator-runtime/runtime.js");

if (hadRuntime) {
  // Restore the original runtime.
  g.regeneratorRuntime = oldRuntime;
} else {
  // Remove the global property added by runtime.js.
  try {
    delete g.regeneratorRuntime;
  } catch(e) {
    g.regeneratorRuntime = undefined;
  }
}


/***/ }),

/***/ "../../node_modules/regenerator-runtime/runtime.js":
/*!**********************************************************************************!*\
  !*** /Users/missx/Documents/deck.gl/node_modules/regenerator-runtime/runtime.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

!(function(global) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  var inModule = typeof module === "object";
  var runtime = global.regeneratorRuntime;
  if (runtime) {
    if (inModule) {
      // If regeneratorRuntime is defined globally and we're in a module,
      // make the exports object identical to regeneratorRuntime.
      module.exports = runtime;
    }
    // Don't bother evaluating the rest of this file if the runtime was
    // already defined globally.
    return;
  }

  // Define the runtime globally (as expected by generated code) as either
  // module.exports (if we're in a module) or a new, empty object.
  runtime = global.regeneratorRuntime = inModule ? module.exports : {};

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  runtime.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  runtime.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  runtime.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  runtime.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  runtime.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  runtime.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return runtime.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        if (delegate.iterator.return) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  runtime.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  runtime.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };
})(
  // In sloppy mode, unbound `this` refers to the global object, fallback to
  // Function constructor if we're in global strict mode. That is sadly a form
  // of indirect eval which violates Content Security Policy.
  (function() {
    return this || (typeof self === "object" && self);
  })() || Function("return this")()
);


/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./bundle.js":
/*!*******************!*\
  !*** ./bundle.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {const deckGLLayers = __webpack_require__(/*! ./src */ "./src/index.js");

/* global window, global */
const _global = typeof window === 'undefined' ? global : window;
const deck = _global.deck || {};

// Check if peer dependencies are included
if (!deck.Layer) {
  throw new Error('@deck.gl/core is not found');
}

module.exports = Object.assign(deck, deckGLLayers);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/arc-layer/arc-layer-fragment.glsl.js":
/*!**************************************************!*\
  !*** ./src/arc-layer/arc-layer-fragment.glsl.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME arc-layer-fragment-shader

precision highp float;

varying vec4 vColor;

void main(void) {
  gl_FragColor = vColor;

  // use highlight color if this fragment belongs to the selected object.
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);

  // use picking color if rendering to picking FBO.
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
}
`);


/***/ }),

/***/ "./src/arc-layer/arc-layer-vertex-64.glsl.js":
/*!***************************************************!*\
  !*** ./src/arc-layer/arc-layer-vertex-64.glsl.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME arc-layer-vertex-shader-64

attribute vec3 positions;
attribute vec4 instanceSourceColors;
attribute vec4 instanceTargetColors;

attribute vec4 instancePositions;
attribute vec4 instancePositions64Low;

attribute vec3 instancePickingColors;
attribute float instanceWidths;

uniform float numSegments;
uniform float opacity;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;

varying vec4 vColor;

vec2 paraboloid_fp64(vec2 source[2], vec2 target[2], float ratio) {

  vec2 x[2];
  vec2_mix_fp64(source, target, ratio, x);
  vec2 center[2];
  vec2_mix_fp64(source, target, 0.5, center);

  vec2 dSourceCenter = vec2_distance_fp64(source, center);
  vec2 dXCenter = vec2_distance_fp64(x, center);
  return mul_fp64(sum_fp64(dSourceCenter, dXCenter), sub_fp64(dSourceCenter, dXCenter));
}

// offset vector by strokeWidth pixels
// offset_direction is -1 (left) or 1 (right)
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
  // normalized direction of the line
  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);
  // rotate by 90 degrees
  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);

  vec2 offset_screenspace = dir_screenspace * offset_direction * width / 2.0;
  vec2 offset_clipspace = project_pixel_size_to_clipspace(offset_screenspace);

  return offset_clipspace;
}

float getSegmentRatio(float index) {
  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));
}

void get_pos_fp64(vec2 source[2], vec2 target[2], float segmentRatio, out vec2 position[4]) {

  vec2 vertex_height = paraboloid_fp64(source, target, segmentRatio);

  vec2 position_temp[2];

  vec2_mix_fp64(source, target, segmentRatio, position_temp);

  position[0] = position_temp[0];
  position[1] = position_temp[1];

  if (vertex_height.x < 0.0 || (vertex_height.x == 0.0 && vertex_height.y <= 0.0)) {
    vertex_height = vec2(0.0, 0.0);
  }

  position[2] = sqrt_fp64(vertex_height);
  position[3] = vec2(1.0, 0.0);
}

void main(void) {
  vec2 projected_source_coord[2];
  vec2 projected_target_coord[2];

  project_position_fp64(instancePositions.xy, instancePositions64Low.xy, projected_source_coord);
  project_position_fp64(instancePositions.zw, instancePositions64Low.zw, projected_target_coord);

  float segmentIndex = positions.x;
  float segmentRatio = getSegmentRatio(segmentIndex);

  // if it's the first point, use next - current as direction
  // otherwise use current - prev
  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));
  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);

  vec2 curr_pos_modelspace[4];

  get_pos_fp64(projected_source_coord, projected_target_coord, segmentRatio,
    curr_pos_modelspace);

  vec2 next_pos_modelspace[4];

  get_pos_fp64(projected_source_coord, projected_target_coord, nextSegmentRatio,
    next_pos_modelspace);

  vec4 curr_pos_clipspace = project_common_position_to_clipspace_fp64(curr_pos_modelspace);
  vec4 next_pos_clipspace = project_common_position_to_clipspace_fp64(next_pos_modelspace);

  // Multiply out width and clamp to limits
  // mercator pixels are interpreted as screen pixels
  float widthPixels = clamp(
    project_size_to_pixel(instanceWidths * widthScale),
    widthMinPixels, widthMaxPixels
  );

  vec2 offset = getExtrusionOffset(next_pos_clipspace.xy - curr_pos_clipspace.xy, positions.y, widthPixels);

  gl_Position = curr_pos_clipspace + vec4(offset, 0.0, 0.0);

  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;
  vColor = vec4(color.rgb, color.a * opacity);

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);
}
`);


/***/ }),

/***/ "./src/arc-layer/arc-layer-vertex.glsl.js":
/*!************************************************!*\
  !*** ./src/arc-layer/arc-layer-vertex.glsl.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME arc-layer-vertex-shader

attribute vec3 positions;
attribute vec4 instanceSourceColors;
attribute vec4 instanceTargetColors;
attribute vec4 instancePositions;
attribute vec4 instancePositions64Low;
attribute vec3 instancePickingColors;
attribute float instanceWidths;
attribute float instanceHeights;
attribute float instanceTilts;

uniform float numSegments;
uniform float opacity;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;

varying vec4 vColor;

float paraboloid(vec2 source, vec2 target, float ratio) {

  vec2 x = mix(source, target, ratio);
  vec2 center = mix(source, target, 0.5);

  float dSourceCenter = distance(source, center);
  float dXCenter = distance(x, center);
  return (dSourceCenter + dXCenter) * (dSourceCenter - dXCenter);
}

// offset vector by strokeWidth pixels
// offset_direction is -1 (left) or 1 (right)
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
  // normalized direction of the line
  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);
  // rotate by 90 degrees
  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);

  vec2 offset_screenspace = dir_screenspace * offset_direction * width / 2.0;
  vec2 offset_clipspace = project_pixel_size_to_clipspace(offset_screenspace);

  return offset_clipspace;
}

float getSegmentRatio(float index) {
  return smoothstep(0.0, 1.0, index / (numSegments - 1.0));
}

vec3 getPos(vec2 source, vec2 target, float segmentRatio) {
  float vertexHeight = sqrt(max(0.0, paraboloid(source, target, segmentRatio))) * instanceHeights;

  float tiltAngle = radians(instanceTilts);
  vec2 tiltDirection = normalize(target - source);
  vec2 tilt = vec2(-tiltDirection.y, tiltDirection.x) * vertexHeight * sin(tiltAngle);

  return vec3(
    mix(source, target, segmentRatio) + tilt,
    vertexHeight * cos(tiltAngle)
  );
}

void main(void) {
  vec2 source = project_position(vec3(instancePositions.xy, 0.0), instancePositions64Low.xy).xy;
  vec2 target = project_position(vec3(instancePositions.zw, 0.0), instancePositions64Low.zw).xy;

  float segmentIndex = positions.x;
  float segmentRatio = getSegmentRatio(segmentIndex);
  // if it's the first point, use next - current as direction
  // otherwise use current - prev
  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));
  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);

  vec3 currPos = getPos(source, target, segmentRatio);
  vec3 nextPos = getPos(source, target, nextSegmentRatio);
  vec4 curr = project_common_position_to_clipspace(vec4(currPos, 1.0));
  vec4 next = project_common_position_to_clipspace(vec4(nextPos, 1.0));

  // Multiply out width and clamp to limits
  // mercator pixels are interpreted as screen pixels
  float widthPixels = clamp(
    project_size_to_pixel(instanceWidths * widthScale),
    widthMinPixels, widthMaxPixels
  );

  // extrude
  vec2 offset = getExtrusionOffset((next.xy - curr.xy) * indexDir, positions.y, widthPixels);
  gl_Position = curr + vec4(offset, 0.0, 0.0);

  vec4 color = mix(instanceSourceColors, instanceTargetColors, segmentRatio) / 255.;
  vColor = vec4(color.rgb, color.a * opacity);

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);
}
`);


/***/ }),

/***/ "./src/arc-layer/arc-layer.js":
/*!************************************!*\
  !*** ./src/arc-layer/arc-layer.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ArcLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _arc_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./arc-layer-vertex.glsl */ "./src/arc-layer/arc-layer-vertex.glsl.js");
/* harmony import */ var _arc_layer_vertex_64_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./arc-layer-vertex-64.glsl */ "./src/arc-layer/arc-layer-vertex-64.glsl.js");
/* harmony import */ var _arc_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./arc-layer-fragment.glsl */ "./src/arc-layer/arc-layer-fragment.glsl.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.





const {fp64LowPart} = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["fp64"];





const DEFAULT_COLOR = [0, 0, 0, 255];

const defaultProps = {
  fp64: false,

  getSourcePosition: {type: 'accessor', value: x => x.sourcePosition},
  getTargetPosition: {type: 'accessor', value: x => x.targetPosition},
  getSourceColor: {type: 'accessor', value: DEFAULT_COLOR},
  getTargetColor: {type: 'accessor', value: DEFAULT_COLOR},
  getWidth: {type: 'accessor', value: 1},
  getHeight: {type: 'accessor', value: 1},
  getTilt: {type: 'accessor', value: 0},

  widthUnits: 'pixels',
  widthScale: {type: 'number', value: 1, min: 0},
  widthMinPixels: {type: 'number', value: 0, min: 0},
  widthMaxPixels: {type: 'number', value: Number.MAX_SAFE_INTEGER, min: 0},

  // Deprecated, remove in v8
  getStrokeWidth: {deprecatedFor: 'getWidth'}
};

class ArcLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["Layer"] {
  getShaders() {
    return this.use64bitProjection()
      ? {vs: _arc_layer_vertex_64_glsl__WEBPACK_IMPORTED_MODULE_3__["default"], fs: _arc_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_4__["default"], modules: ['project64', 'picking']}
      : {vs: _arc_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__["default"], fs: _arc_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_4__["default"], modules: ['picking']}; // 'project' module added by default.
  }

  initializeState() {
    const attributeManager = this.getAttributeManager();

    /* eslint-disable max-len */
    attributeManager.addInstanced({
      instancePositions: {
        size: 4,
        transition: true,
        accessor: ['getSourcePosition', 'getTargetPosition'],
        update: this.calculateInstancePositions
      },
      instancePositions64Low: {
        size: 4,
        accessor: ['getSourcePosition', 'getTargetPosition'],
        update: this.calculateInstancePositions64Low
      },
      instanceSourceColors: {
        size: 4,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        transition: true,
        accessor: 'getSourceColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceTargetColors: {
        size: 4,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        transition: true,
        accessor: 'getTargetColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: 'getWidth',
        defaultValue: 1
      },
      instanceHeights: {
        size: 1,
        transition: true,
        accessor: 'getHeight',
        defaultValue: 1
      },
      instanceTilts: {
        size: 1,
        transition: true,
        accessor: 'getTilt',
        defaultValue: 0
      }
    });
    /* eslint-enable max-len */
  }

  updateState({props, oldProps, changeFlags}) {
    super.updateState({props, oldProps, changeFlags});
    // Re-generate model if geometry changed
    if (props.fp64 !== oldProps.fp64) {
      const {gl} = this.context;
      if (this.state.model) {
        this.state.model.delete();
      }
      this.setState({model: this._getModel(gl)});
      this.getAttributeManager().invalidateAll();
    }
  }

  draw({uniforms}) {
    const {viewport} = this.context;
    const {widthUnits, widthScale, widthMinPixels, widthMaxPixels} = this.props;

    const widthMultiplier = widthUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1;

    this.state.model
      .setUniforms(
        Object.assign({}, uniforms, {
          widthScale: widthScale * widthMultiplier,
          widthMinPixels,
          widthMaxPixels
        })
      )
      .draw();
  }

  _getModel(gl) {
    let positions = [];
    const NUM_SEGMENTS = 50;
    /*
     *  (0, -1)-------------_(1, -1)
     *       |          _,-"  |
     *       o      _,-"      o
     *       |  _,-"          |
     *   (0, 1)"-------------(1, 1)
     */
    for (let i = 0; i < NUM_SEGMENTS; i++) {
      positions = positions.concat([i, -1, 0, i, 1, 0]);
    }

    const model = new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Model"](
      gl,
      Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Geometry"]({
          drawMode: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.TRIANGLE_STRIP,
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      })
    );

    model.setUniforms({numSegments: NUM_SEGMENTS});

    return model;
  }

  calculateInstancePositions(attribute, {startRow, endRow}) {
    const {data, getSourcePosition, getTargetPosition} = this.props;
    const {value, size} = attribute;
    let i = startRow * size;
    const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["createIterable"])(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      const sourcePosition = getSourcePosition(object, objectInfo);
      value[i++] = sourcePosition[0];
      value[i++] = sourcePosition[1];
      // Call `getTargetPosition` after `sourcePosition` is used in case both accessors write into
      // the same temp array
      const targetPosition = getTargetPosition(object, objectInfo);
      value[i++] = targetPosition[0];
      value[i++] = targetPosition[1];
    }
  }

  calculateInstancePositions64Low(attribute, {startRow, endRow}) {
    const isFP64 = this.use64bitPositions();
    attribute.constant = !isFP64;

    if (!isFP64) {
      attribute.value = new Float32Array(4);
      return;
    }

    const {data, getSourcePosition, getTargetPosition} = this.props;
    const {value, size} = attribute;
    let i = startRow * size;
    const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["createIterable"])(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      const sourcePosition = getSourcePosition(object, objectInfo);
      value[i++] = fp64LowPart(sourcePosition[0]);
      value[i++] = fp64LowPart(sourcePosition[1]);
      // Call `getTargetPosition` after `sourcePosition` is used in case both accessors write into
      // the same temp array
      const targetPosition = getTargetPosition(object, objectInfo);
      value[i++] = fp64LowPart(targetPosition[0]);
      value[i++] = fp64LowPart(targetPosition[1]);
    }
  }
}

ArcLayer.layerName = 'ArcLayer';
ArcLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/bitmap-layer/bitmap-layer-fragment.js":
/*!***************************************************!*\
  !*** ./src/bitmap-layer/bitmap-layer-fragment.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`
#define SHADER_NAME bitmap-layer-fragment-shader

#ifdef GL_ES
precision highp float;
#endif

uniform sampler2D bitmapTexture;

varying vec2 vTexCoord;

uniform float desaturate;
uniform vec4 transparentColor;
uniform vec3 tintColor;
uniform float opacity;

// apply desaturation
vec3 color_desaturate(vec3 color) {
  float luminance = (color.r + color.g + color.b) * 0.333333333;
  return mix(color, vec3(luminance), desaturate);
}

// apply tint
vec3 color_tint(vec3 color) {
  return color * tintColor / 255.0;
}

// blend with background color
vec4 apply_opacity(vec3 color, float alpha) {
  return mix(transparentColor / 255.0, vec4(color, 1.0), alpha);
}

void main(void) {
  vec4 bitmapColor = texture2D(bitmapTexture, vTexCoord);

  gl_FragColor = apply_opacity(color_tint(color_desaturate(bitmapColor.rgb)), bitmapColor.a * opacity);

  // use highlight color if this fragment belongs to the selected object.
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);

  // use picking color if rendering to picking FBO.
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
}
`);


/***/ }),

/***/ "./src/bitmap-layer/bitmap-layer-vertex.js":
/*!*************************************************!*\
  !*** ./src/bitmap-layer/bitmap-layer-vertex.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`
#define SHADER_NAME bitmap-layer-vertex-shader

attribute vec2 texCoords;
attribute vec3 positions;
attribute vec2 positions64xyLow;
attribute vec3 instancePickingColors;

varying vec2 vTexCoord;

void main(void) {
  gl_Position = project_position_to_clipspace(positions, positions64xyLow, vec3(0.0));
 
  vTexCoord = texCoords;
 
  picking_setPickingColor(instancePickingColors);
}
`);


/***/ }),

/***/ "./src/bitmap-layer/bitmap-layer.js":
/*!******************************************!*\
  !*** ./src/bitmap-layer/bitmap-layer.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BitmapLayer; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _loaders_gl_images__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @loaders.gl/images */ "../../node_modules/@loaders.gl/images/dist/esm/index.js");
/* harmony import */ var _bitmap_layer_vertex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bitmap-layer-vertex */ "./src/bitmap-layer/bitmap-layer-vertex.js");
/* harmony import */ var _bitmap_layer_fragment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./bitmap-layer-fragment */ "./src/bitmap-layer/bitmap-layer-fragment.js");
// Copyright (c) 2015 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* global Image, HTMLCanvasElement */





const {fp64LowPart} = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["fp64"];




const DEFAULT_TEXTURE_PARAMETERS = {
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MIN_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINEAR_MIPMAP_LINEAR,
  // GL.LINEAR is the default value but explicitly set it here
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MAG_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINEAR,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_WRAP_S]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CLAMP_TO_EDGE,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_WRAP_T]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CLAMP_TO_EDGE
};

const defaultProps = {
  image: null,
  bounds: {type: 'array', value: [1, 0, 0, 1], compare: true},
  fp64: false,

  desaturate: {type: 'number', min: 0, max: 1, value: 0},
  // More context: because of the blending mode we're using for ground imagery,
  // alpha is not effective when blending the bitmap layers with the base map.
  // Instead we need to manually dim/blend rgb values with a background color.
  transparentColor: {type: 'color', value: [0, 0, 0, 0]},
  tintColor: {type: 'color', value: [255, 255, 255]}
};

/*
 * @class
 * @param {object} props
 * @param {number} props.transparentColor - color to interpret transparency to
 * @param {number} props.tintColor - color bias
 */
class BitmapLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__["Layer"] {
  getShaders() {
    const projectModule = this.use64bitProjection() ? 'project64' : 'project32';
    return {vs: _bitmap_layer_vertex__WEBPACK_IMPORTED_MODULE_3__["default"], fs: _bitmap_layer_fragment__WEBPACK_IMPORTED_MODULE_4__["default"], modules: [projectModule, 'picking']};
  }

  initializeState() {
    const attributeManager = this.getAttributeManager();

    attributeManager.add({
      positions: {
        size: 3,
        update: this.calculatePositions,
        value: new Float32Array(12)
      },
      positions64xyLow: {
        size: 3,
        update: this.calculatePositions64xyLow,
        value: new Float32Array(12)
      }
    });

    this.setState({numInstances: 4}); // 4 corners
  }

  updateState({props, oldProps, changeFlags}) {
    // setup model first
    if (props.fp64 !== oldProps.fp64) {
      const {gl} = this.context;
      if (this.state.model) {
        this.state.model.delete();
      }
      this.setState({model: this._getModel(gl)});
      this.getAttributeManager().invalidateAll();
    }

    if (props.image !== oldProps.image) {
      this.loadTexture(props.image);
    }

    const attributeManager = this.getAttributeManager();

    if (props.bounds !== oldProps.bounds) {
      this.setState({
        positions: this._getPositionsFromBounds(props.bounds)
      });
      attributeManager.invalidate('positions');
      attributeManager.invalidate('positions64xyLow');
    }
  }

  finalizeState() {
    super.finalizeState();

    if (this.state.bitmapTexture) {
      this.state.bitmapTexture.delete();
    }
  }

  _getPositionsFromBounds(bounds) {
    const positions = new Array(12);
    // bounds as [minX, minY, maxX, maxY]
    if (Number.isFinite(bounds[0])) {
      /*
        (minX0, maxY3) ---- (maxX2, maxY3)
               |                  |
               |                  |
               |                  |
        (minX0, minY1) ---- (maxX2, minY1)
     */
      positions[0] = bounds[0];
      positions[1] = bounds[1];
      positions[2] = 0;

      positions[3] = bounds[0];
      positions[4] = bounds[3];
      positions[5] = 0;

      positions[6] = bounds[2];
      positions[7] = bounds[3];
      positions[8] = 0;

      positions[9] = bounds[2];
      positions[10] = bounds[1];
      positions[11] = 0;
    } else {
      // [[minX, minY], [minX, maxY], [maxX, maxY], [maxX, minY]]
      for (let i = 0; i < bounds.length; i++) {
        positions[i * 3 + 0] = bounds[i][0];
        positions[i * 3 + 1] = bounds[i][1];
        positions[i * 3 + 2] = bounds[i][2] || 0;
      }
    }

    return positions;
  }

  _getModel(gl) {
    if (!gl) {
      return null;
    }

    /*
      0,1 --- 1,1
       |       |
      0,0 --- 1,0
    */
    return new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Model"](
      gl,
      Object.assign({}, this.getShaders(), {
        id: this.props.id,
        shaderCache: this.context.shaderCache,
        geometry: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Geometry"]({
          drawMode: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TRIANGLE_FAN,
          vertexCount: 4,
          attributes: {
            texCoords: new Float32Array([0, 0, 0, 1, 1, 1, 1, 0])
          }
        }),
        isInstanced: false
      })
    );
  }

  draw({uniforms}) {
    const {bitmapTexture, model} = this.state;
    const {desaturate, transparentColor, tintColor} = this.props;

    // // TODO fix zFighting
    // Render the image
    if (bitmapTexture && model) {
      model
        .setUniforms(
          Object.assign({}, uniforms, {
            bitmapTexture,
            desaturate,
            transparentColor,
            tintColor
          })
        )
        .draw();
    }
  }

  loadTexture(image) {
    if (typeof image === 'string') {
      image = Object(_loaders_gl_images__WEBPACK_IMPORTED_MODULE_2__["loadImage"])(image);
    }
    if (image instanceof Promise) {
      image.then(data => this.loadTexture(data));
      return;
    }

    const {gl} = this.context;

    if (this.state.bitmapTexture) {
      this.state.bitmapTexture.delete();
    }

    if (image instanceof _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Texture2D"]) {
      this.setState({bitmapTexture: image});
    } else if (
      // browser object
      image instanceof Image ||
      image instanceof HTMLCanvasElement
    ) {
      this.setState({
        bitmapTexture: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Texture2D"](gl, {
          data: image,
          parameters: DEFAULT_TEXTURE_PARAMETERS
        })
      });
    }
  }

  calculatePositions({value}) {
    const {positions} = this.state;
    value.set(positions);
  }

  calculatePositions64xyLow(attribute) {
    const isFP64 = this.use64bitPositions();
    attribute.constant = !isFP64;

    if (!isFP64) {
      attribute.value = new Float32Array(4);
      return;
    }

    const {value} = attribute;
    value.set(this.state.positions.map(fp64LowPart));
  }
}

BitmapLayer.layerName = 'BitmapLayer';
BitmapLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/column-layer/column-geometry.js":
/*!*********************************************!*\
  !*** ./src/column-layer/column-geometry.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColumnGeometry; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/core */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_core__WEBPACK_IMPORTED_MODULE_1__);



class ColumnGeometry extends _luma_gl_core__WEBPACK_IMPORTED_MODULE_1__["Geometry"] {
  constructor(props = {}) {
    const {id = Object(_luma_gl_core__WEBPACK_IMPORTED_MODULE_1__["uid"])('column-geometry')} = props;
    const {indices, attributes} = tesselateColumn(props);
    super({
      ...props,
      id,
      indices,
      attributes
    });
  }
}

/* eslint-disable max-statements, complexity */
function tesselateColumn(props) {
  const {radius, height = 1, nradial = 10, vertices} = props;
  _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].assert(!vertices || vertices.length >= nradial);

  const vertsAroundEdge = nradial + 1; // loop
  const numVertices = vertsAroundEdge * 3; // top, side top edge, side bottom edge

  const stepAngle = (Math.PI * 2) / nradial;

  // Used for wireframe
  const indices = new Uint16Array(nradial * 3 * 2); // top loop, side vertical, bottom loop

  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);

  let i = 0;

  // side tesselation: 0, 1, 2, 3, 4, 5, ...
  //
  // 0 - 2 - 4  ... top
  // | / | / |
  // 1 - 3 - 5  ... bottom
  //
  for (let j = 0; j < vertsAroundEdge; j++) {
    const a = j * stepAngle;
    const vertex = vertices && vertices[j % nradial];
    const nextVertex = vertices && vertices[(j + 1) % nradial];
    const sin = Math.sin(a);
    const cos = Math.cos(a);

    for (let k = 0; k < 2; k++) {
      positions[i + 0] = vertex ? vertex[0] : cos * radius;
      positions[i + 1] = vertex ? vertex[1] : sin * radius;
      positions[i + 2] = (1 / 2 - k) * height;

      normals[i + 0] = vertex ? nextVertex[0] - vertex[0] : cos;
      normals[i + 1] = vertex ? nextVertex[1] - vertex[1] : sin;

      i += 3;
    }
  }

  // top tesselation: 0, -1, 1, -2, 2, -3, 3, ...
  //
  //    0 -- 1
  //   /      \
  // -1        2
  //  |        |
  // -2        3
  //   \      /
  //   -3 -- 4
  //
  for (let j = 0; j < vertsAroundEdge; j++) {
    const v = Math.floor(j / 2) * Math.sign((j % 2) - 0.5);
    const a = v * stepAngle;
    const vertex = vertices && vertices[(v + nradial) % nradial];
    const sin = Math.sin(a);
    const cos = Math.cos(a);

    positions[i + 0] = vertex ? vertex[0] : cos * radius;
    positions[i + 1] = vertex ? vertex[1] : sin * radius;
    positions[i + 2] = height / 2;

    normals[i + 2] = 1;

    i += 3;
  }

  let index = 0;
  for (let j = 0; j < nradial; j++) {
    // top loop
    indices[index++] = j * 2 + 0;
    indices[index++] = j * 2 + 2;
    // side vertical
    indices[index++] = j * 2 + 0;
    indices[index++] = j * 2 + 1;
    // bottom loop
    indices[index++] = j * 2 + 1;
    indices[index++] = j * 2 + 3;
  }

  return {
    indices,
    attributes: {
      POSITION: {size: 3, value: positions},
      NORMAL: {size: 3, value: normals}
    }
  };
}


/***/ }),

/***/ "./src/column-layer/column-layer-fragment.glsl.js":
/*!********************************************************!*\
  !*** ./src/column-layer/column-layer-fragment.glsl.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME column-layer-fragment-shader

precision highp float;

varying vec4 vColor;

void main(void) {
  gl_FragColor = vColor;

  // use highlight color if this fragment belongs to the selected object.
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);

  // use picking color if rendering to picking FBO.
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
}
`);


/***/ }),

/***/ "./src/column-layer/column-layer-vertex.glsl.js":
/*!******************************************************!*\
  !*** ./src/column-layer/column-layer-vertex.glsl.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\

#define SHADER_NAME column-layer-vertex-shader

attribute vec3 positions;
attribute vec3 normals;

attribute vec3 instancePositions;
attribute float instanceElevations;
attribute vec2 instancePositions64xyLow;
attribute vec4 instanceFillColors;
attribute vec4 instanceLineColors;
attribute float instanceStrokeWidths;

attribute vec3 instancePickingColors;

// Custom uniforms
uniform float opacity;
uniform float radius;
uniform float angle;
uniform vec2 offset;
uniform bool extruded;
uniform bool isStroke;
uniform float coverage;
uniform float elevationScale;
uniform float edgeDistance;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;

// Result
varying vec4 vColor;

void main(void) {
  
  vec4 color = isStroke ? instanceLineColors : instanceFillColors;
  // rotate primitive position and normal
  mat2 rotationMatrix = mat2(cos(angle), sin(angle), -sin(angle), cos(angle));

  // calculate elevation, if 3d not enabled set to 0
  // cylindar gemoetry height are between -1.0 to 1.0, transform it to between 0, 1
  float elevation = 0.0;
  // calculate stroke offset
  float strokeOffsetRatio = 1.0;

  if (extruded) {
    elevation = instanceElevations * (positions.z + 1.0) / 2.0 * elevationScale;
  } else if (isStroke) {
    float widthPixels = clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),
      widthMinPixels, widthMaxPixels) / 2.0;
    strokeOffsetRatio += sign(positions.z) * project_pixel_size(widthPixels) / project_size(edgeDistance * coverage * radius);
  }

  // if alpha == 0.0 or z < 0.0, do not render element
  float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
  float dotRadius = radius * coverage * shouldRender;

  // project center of column
  vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);
  vec2 centroidPosition64xyLow = instancePositions64xyLow;
  vec3 pos = vec3(project_size(rotationMatrix * positions.xy * strokeOffsetRatio + offset) * dotRadius, 0.);

  vec4 position_commonspace;
  gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64xyLow, pos, position_commonspace);

  // Light calculations
  // Worldspace is the linear space after Mercator projection

  vec3 normals_commonspace = project_normal(vec3(rotationMatrix * normals.xy, normals.z));

  if (extruded && !isStroke) {
    vec3 lightColor = lighting_getLightColor(color.rgb, project_uCameraPosition, position_commonspace.xyz, normals_commonspace);
    vColor = vec4(lightColor, color.a * opacity) / 255.0;
  } else {
    vColor = vec4(color.rgb, color.a * opacity) / 255.0;
  }

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);
}
`);


/***/ }),

/***/ "./src/column-layer/column-layer.js":
/*!******************************************!*\
  !*** ./src/column-layer/column-layer.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ColumnLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _column_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./column-geometry */ "./src/column-layer/column-geometry.js");
/* harmony import */ var _column_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./column-layer-vertex.glsl */ "./src/column-layer/column-layer-vertex.glsl.js");
/* harmony import */ var _column_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./column-layer-fragment.glsl */ "./src/column-layer/column-layer-fragment.glsl.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.





const {fp64LowPart} = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["fp64"];
const defaultMaterial = new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["PhongMaterial"]();




const DEFAULT_COLOR = [0, 0, 0, 255];

const defaultProps = {
  diskResolution: {type: 'number', min: 4, value: 20},
  vertices: null,
  radius: {type: 'number', min: 0, value: 1000},
  angle: {type: 'number', value: 0},
  offset: {type: 'array', value: [0, 0]},
  coverage: {type: 'number', min: 0, max: 1, value: 1},
  elevationScale: {type: 'number', min: 0, value: 1},

  lineWidthUnits: 'meters',
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,

  extruded: true,
  fp64: false,
  wireframe: false,
  filled: true,
  stroked: false,

  getPosition: {type: 'accessor', value: x => x.position},
  getFillColor: {type: 'accessor', value: DEFAULT_COLOR},
  getLineColor: {type: 'accessor', value: DEFAULT_COLOR},
  getLineWidth: {type: 'accessor', value: 1},
  getElevation: {type: 'accessor', value: 1000},
  material: defaultMaterial,
  getColor: {deprecatedFor: ['getFillColor', 'getLineColor']}
};

class ColumnLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["Layer"] {
  getShaders() {
    const projectModule = this.use64bitProjection() ? 'project64' : 'project32';
    return {vs: _column_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_3__["default"], fs: _column_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_4__["default"], modules: [projectModule, 'gouraud-lighting', 'picking']};
  }

  /**
   * DeckGL calls initializeState when GL context is available
   * Essentially a deferred constructor
   */
  initializeState() {
    const attributeManager = this.getAttributeManager();
    /* eslint-disable max-len */
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        transition: true,
        accessor: 'getPosition'
      },
      instanceElevations: {
        size: 1,
        transition: true,
        accessor: 'getElevation'
      },
      instancePositions64xyLow: {
        size: 2,
        accessor: 'getPosition',
        update: this.calculateInstancePositions64xyLow
      },
      instanceFillColors: {
        size: 4,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        transition: true,
        accessor: 'getFillColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceLineColors: {
        size: 4,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        transition: true,
        accessor: 'getLineColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: 'getLineWidth',
        transition: true
      }
    });
    /* eslint-enable max-len */
  }

  updateState({props, oldProps, changeFlags}) {
    super.updateState({props, oldProps, changeFlags});

    const regenerateModels = props.fp64 !== oldProps.fp64;

    if (regenerateModels) {
      const {gl} = this.context;
      if (this.state.model) {
        this.state.model.delete();
      }
      this.setState({model: this._getModel(gl)});
      this.getAttributeManager().invalidateAll();
    }

    if (
      regenerateModels ||
      props.diskResolution !== oldProps.diskResolution ||
      props.vertices !== oldProps.vertices
    ) {
      this._updateGeometry(props);
    }
  }

  getGeometry(diskResolution, vertices) {
    const geometry = new _column_geometry__WEBPACK_IMPORTED_MODULE_2__["default"]({
      radius: 1,
      height: 2,
      vertices,
      nradial: diskResolution
    });

    let meanVertexDistance = 0;
    if (vertices) {
      for (let i = 0; i < diskResolution; i++) {
        const p = vertices[i];
        const d = Math.sqrt(p[0] * p[0] + p[1] * p[1]);
        meanVertexDistance += d / diskResolution;
      }
    } else {
      meanVertexDistance = 1;
    }
    this.setState({
      edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance
    });

    return geometry;
  }

  _getModel(gl) {
    return new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Model"](
      gl,
      Object.assign({}, this.getShaders(), {
        id: this.props.id,
        isInstanced: true,
        shaderCache: this.context.shaderCache
      })
    );
  }

  _updateGeometry({diskResolution, vertices}) {
    const geometry = this.getGeometry(diskResolution, vertices);

    this.setState({
      fillVertexCount: geometry.attributes.POSITION.value.length / 3,
      wireframeVertexCount: geometry.indices.value.length
    });

    this.state.model.setProps({geometry});
  }

  draw({uniforms}) {
    const {viewport} = this.context;
    const {
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,

      elevationScale,
      extruded,
      filled,
      stroked,
      wireframe,
      offset,
      coverage,
      radius,
      angle
    } = this.props;
    const {model, fillVertexCount, wireframeVertexCount, edgeDistance} = this.state;

    const widthMultiplier =
      lineWidthUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1;

    model.setUniforms(
      Object.assign({}, uniforms, {
        radius,
        angle: (angle / 180) * Math.PI,
        offset,
        extruded,
        coverage,
        elevationScale,
        edgeDistance,
        widthScale: lineWidthScale * widthMultiplier,
        widthMinPixels: lineWidthMinPixels,
        widthMaxPixels: lineWidthMaxPixels
      })
    );

    // When drawing 3d: draw wireframe first so it doesn't get occluded by depth test
    if (extruded && wireframe) {
      model.setProps({isIndexed: true});
      model
        .setVertexCount(wireframeVertexCount)
        .setDrawMode(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.LINES)
        .setUniforms({isStroke: true})
        .draw();
    }
    if (filled) {
      model.setProps({isIndexed: false});
      model
        .setVertexCount(fillVertexCount)
        .setDrawMode(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.TRIANGLE_STRIP)
        .setUniforms({isStroke: false})
        .draw();
    }
    // When drawing 2d: draw fill before stroke so that the outline is always on top
    if (!extruded && stroked) {
      model.setProps({isIndexed: false});
      // The width of the stroke is achieved by flattening the side of the cylinder.
      // Skip the last 1/3 of the vertices which is the top.
      model
        .setVertexCount((fillVertexCount * 2) / 3)
        .setDrawMode(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.TRIANGLE_STRIP)
        .setUniforms({isStroke: true})
        .draw();
    }
  }

  calculateInstancePositions64xyLow(attribute, {startRow, endRow}) {
    const isFP64 = this.use64bitPositions();
    attribute.constant = !isFP64;

    if (!isFP64) {
      attribute.value = new Float32Array(2);
      return;
    }

    const {data, getPosition} = this.props;
    const {value, size} = attribute;
    let i = startRow * size;
    const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["createIterable"])(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      const position = getPosition(object, objectInfo);
      value[i++] = fp64LowPart(position[0]);
      value[i++] = fp64LowPart(position[1]);
    }
  }
}

ColumnLayer.layerName = 'ColumnLayer';
ColumnLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/column-layer/grid-cell-layer.js":
/*!*********************************************!*\
  !*** ./src/column-layer/grid-cell-layer.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GridCellLayer; });
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/core */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _column_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./column-layer */ "./src/column-layer/column-layer.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.




const defaultProps = {
  cellSize: {type: 'number', min: 0, value: 1000},
  offset: {type: 'array', min: 0, value: [1, 1]}
};

class GridCellLayer extends _column_layer__WEBPACK_IMPORTED_MODULE_1__["default"] {
  getGeometry(diskResolution) {
    return new _luma_gl_core__WEBPACK_IMPORTED_MODULE_0__["CubeGeometry"]();
  }

  draw({uniforms}) {
    const {elevationScale, extruded, offset, coverage, cellSize, angle} = this.props;
    this.state.model
      .setUniforms(
        Object.assign({}, uniforms, {
          radius: cellSize / 2,
          angle,
          offset,
          extruded,
          coverage,
          elevationScale,
          edgeDistance: 1,
          isWireframe: false
        })
      )
      .draw();
  }
}

GridCellLayer.layerName = 'GridCellLayer';
GridCellLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/geojson-layer/geojson-layer.js":
/*!********************************************!*\
  !*** ./src/geojson-layer/geojson-layer.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GeoJsonLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _scatterplot_layer_scatterplot_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scatterplot-layer/scatterplot-layer */ "./src/scatterplot-layer/scatterplot-layer.js");
/* harmony import */ var _path_layer_path_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../path-layer/path-layer */ "./src/path-layer/path-layer.js");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/core */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_core__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _solid_polygon_layer_solid_polygon_layer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../solid-polygon-layer/solid-polygon-layer */ "./src/solid-polygon-layer/solid-polygon-layer.js");
/* harmony import */ var _geojson__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./geojson */ "./src/geojson-layer/geojson.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.





// Use primitive layer to avoid "Composite Composite" layers for now




const defaultLineColor = [0, 0, 0, 255];
const defaultFillColor = [0, 0, 0, 255];
const defaultMaterial = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_3__["PhongMaterial"]();

const defaultProps = {
  stroked: true,
  filled: true,
  extruded: false,
  wireframe: false,

  lineWidthUnits: 'meters',
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: false,
  lineMiterLimit: 4,

  elevationScale: 1,

  pointRadiusScale: 1,
  pointRadiusMinPixels: 0, //  min point radius in pixels
  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER, // max point radius in pixels

  lineDashJustified: false,
  fp64: false,

  // Line and polygon outline color
  getLineColor: {type: 'accessor', value: defaultLineColor},
  // Point and polygon fill color
  getFillColor: {type: 'accessor', value: defaultFillColor},
  // Point radius
  getRadius: {type: 'accessor', value: 1},
  // Line and polygon outline accessors
  getLineWidth: {type: 'accessor', value: 1},
  // Line dash array accessor
  getLineDashArray: {type: 'accessor', value: [0, 0]},
  // Polygon extrusion accessor
  getElevation: {type: 'accessor', value: 1000},
  // Optional material for 'lighting' shader module
  material: defaultMaterial
};

function getCoordinates(f) {
  return f.geometry.coordinates;
}

/**
 * Unwraps the real source feature passed into props and passes as the argument to `accessor`.
 */
function unwrappingAccessor(accessor) {
  if (typeof accessor !== 'function') return accessor;

  return feature => accessor(Object(_geojson__WEBPACK_IMPORTED_MODULE_5__["unwrapSourceFeature"])(feature));
}

class GeoJsonLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["CompositeLayer"] {
  initializeState() {
    this.state = {
      features: {}
    };
  }

  updateState({oldProps, props, changeFlags}) {
    if (changeFlags.dataChanged) {
      const {data} = props;
      const features = Object(_geojson__WEBPACK_IMPORTED_MODULE_5__["getGeojsonFeatures"])(data);
      this.state.features = Object(_geojson__WEBPACK_IMPORTED_MODULE_5__["separateGeojsonFeatures"])(features);
    }
  }

  getPickingInfo({info, sourceLayer}) {
    // `info.index` is the index within the particular sub-layer
    // We want to expose the index of the feature the user provided

    return Object.assign(info, {
      // override object with picked feature
      object: info.object ? Object(_geojson__WEBPACK_IMPORTED_MODULE_5__["unwrapSourceFeature"])(info.object) : info.object,
      index: info.object ? Object(_geojson__WEBPACK_IMPORTED_MODULE_5__["unwrapSourceFeatureIndex"])(info.object) : info.index
    });
  }

  /* eslint-disable complexity */
  renderLayers() {
    const {features} = this.state;
    const {pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures} = features;

    // Layer composition props
    const {stroked, filled, extruded, wireframe, material, transitions} = this.props;

    // Rendering props underlying layer
    const {
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      lineJointRounded,
      lineMiterLimit,
      pointRadiusScale,
      pointRadiusMinPixels,
      pointRadiusMaxPixels,
      elevationScale,
      lineDashJustified,
      fp64
    } = this.props;

    // Accessor props for underlying layers
    const {
      getLineColor,
      getFillColor,
      getRadius,
      getLineWidth,
      getLineDashArray,
      getElevation,
      updateTriggers
    } = this.props;

    const PolygonFillLayer = this.getSubLayerClass('polygons-fill', _solid_polygon_layer_solid_polygon_layer__WEBPACK_IMPORTED_MODULE_4__["default"]);
    const PolygonStrokeLayer = this.getSubLayerClass('polygons-stroke', _path_layer_path_layer__WEBPACK_IMPORTED_MODULE_2__["default"]);
    const LineStringsLayer = this.getSubLayerClass('line-strings', _path_layer_path_layer__WEBPACK_IMPORTED_MODULE_2__["default"]);
    const PointsLayer = this.getSubLayerClass('points', _scatterplot_layer_scatterplot_layer__WEBPACK_IMPORTED_MODULE_1__["default"]);

    // Filled Polygon Layer
    const polygonFillLayer =
      this.shouldRenderSubLayer('polygons-fill', polygonFeatures) &&
      new PolygonFillLayer(
        {
          fp64,
          extruded,
          elevationScale,
          filled,
          wireframe,
          material,
          getElevation: unwrappingAccessor(getElevation),
          getFillColor: unwrappingAccessor(getFillColor),
          getLineColor: unwrappingAccessor(getLineColor),

          transitions: transitions && {
            getPolygon: transitions.geometry,
            getElevation: transitions.getElevation,
            getFillColor: transitions.getFillColor,
            getLineColor: transitions.getLineColor
          }
        },
        this.getSubLayerProps({
          id: 'polygons-fill',
          updateTriggers: {
            getElevation: updateTriggers.getElevation,
            getFillColor: updateTriggers.getFillColor,
            getLineColor: updateTriggers.getLineColor
          }
        }),
        {
          data: polygonFeatures,
          getPolygon: getCoordinates
        }
      );

    const polygonLineLayer =
      !extruded &&
      stroked &&
      this.shouldRenderSubLayer('polygons-stroke', polygonOutlineFeatures) &&
      new PolygonStrokeLayer(
        {
          fp64,
          widthUnits: lineWidthUnits,
          widthScale: lineWidthScale,
          widthMinPixels: lineWidthMinPixels,
          widthMaxPixels: lineWidthMaxPixels,
          rounded: lineJointRounded,
          miterLimit: lineMiterLimit,
          dashJustified: lineDashJustified,

          getColor: unwrappingAccessor(getLineColor),
          getWidth: unwrappingAccessor(getLineWidth),
          getDashArray: unwrappingAccessor(getLineDashArray),

          transitions: transitions && {
            getPath: transitions.geometry,
            getColor: transitions.getLineColor,
            getWidth: transitions.getLineWidth
          }
        },
        this.getSubLayerProps({
          id: 'polygons-stroke',
          updateTriggers: {
            getColor: updateTriggers.getLineColor,
            getWidth: updateTriggers.getLineWidth,
            getDashArray: updateTriggers.getLineDashArray
          }
        }),
        {
          data: polygonOutlineFeatures,
          getPath: getCoordinates
        }
      );

    const pathLayer =
      this.shouldRenderSubLayer('linestrings', lineFeatures) &&
      new LineStringsLayer(
        {
          fp64,
          widthUnits: lineWidthUnits,
          widthScale: lineWidthScale,
          widthMinPixels: lineWidthMinPixels,
          widthMaxPixels: lineWidthMaxPixels,
          rounded: lineJointRounded,
          miterLimit: lineMiterLimit,
          dashJustified: lineDashJustified,

          getColor: unwrappingAccessor(getLineColor),
          getWidth: unwrappingAccessor(getLineWidth),
          getDashArray: unwrappingAccessor(getLineDashArray),

          transitions: transitions && {
            getPath: transitions.geometry,
            getColor: transitions.getLineColor,
            getWidth: transitions.getLineWidth
          }
        },
        this.getSubLayerProps({
          id: 'line-strings',
          updateTriggers: {
            getColor: updateTriggers.getLineColor,
            getWidth: updateTriggers.getLineWidth,
            getDashArray: updateTriggers.getLineDashArray
          }
        }),
        {
          data: lineFeatures,
          getPath: getCoordinates
        }
      );

    const pointLayer =
      this.shouldRenderSubLayer('points', pointFeatures) &&
      new PointsLayer(
        {
          fp64,
          stroked,
          filled,
          radiusScale: pointRadiusScale,
          radiusMinPixels: pointRadiusMinPixels,
          radiusMaxPixels: pointRadiusMaxPixels,
          lineWidthUnits,
          lineWidthScale,
          lineWidthMinPixels,
          lineWidthMaxPixels,

          getFillColor: unwrappingAccessor(getFillColor),
          getLineColor: unwrappingAccessor(getLineColor),
          getRadius: unwrappingAccessor(getRadius),
          getLineWidth: unwrappingAccessor(getLineWidth),

          transitions: transitions && {
            getPosition: transitions.geometry,
            getFillColor: transitions.getFillColor,
            getLineColor: transitions.getLineColor,
            getRadius: transitions.getRadius,
            getLineWidth: transitions.getLineWidth
          }
        },
        this.getSubLayerProps({
          id: 'points',
          updateTriggers: {
            getFillColor: updateTriggers.getFillColor,
            getLineColor: updateTriggers.getLineColor,
            getRadius: updateTriggers.getRadius,
            getLineWidth: updateTriggers.getLineWidth
          }
        }),
        {
          data: pointFeatures,
          getPosition: getCoordinates
        }
      );

    return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonFillLayer,
      polygonLineLayer,
      pathLayer,
      pointLayer,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonFillLayer
    ];
  }
  /* eslint-enable complexity */
}

GeoJsonLayer.layerName = 'GeoJsonLayer';
GeoJsonLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/geojson-layer/geojson.js":
/*!**************************************!*\
  !*** ./src/geojson-layer/geojson.js ***!
  \**************************************/
/*! exports provided: getGeojsonFeatures, separateGeojsonFeatures, unwrapSourceFeature, unwrapSourceFeatureIndex, validateGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGeojsonFeatures", function() { return getGeojsonFeatures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "separateGeojsonFeatures", function() { return separateGeojsonFeatures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unwrapSourceFeature", function() { return unwrapSourceFeature; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unwrapSourceFeatureIndex", function() { return unwrapSourceFeatureIndex; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateGeometry", function() { return validateGeometry; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.


/**
 * "Normalizes" complete or partial GeoJSON data into iterable list of features
 * Can accept GeoJSON geometry or "Feature", "FeatureCollection" in addition
 * to plain arrays and iterables.
 * Works by extracting the feature array or wrapping single objects in an array,
 * so that subsequent code can simply iterate over features.
 *
 * @param {object} geojson - geojson data
 * @param {Object|Array} data - geojson object (FeatureCollection, Feature or
 *  Geometry) or array of features
 * @return {Array|"iteratable"} - iterable list of features
 */
function getGeojsonFeatures(geojson) {
  // If array, assume this is a list of features
  if (Array.isArray(geojson)) {
    return geojson;
  }

  _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].assert(geojson.type, 'GeoJSON does not have type');

  switch (geojson.type) {
    case 'Feature':
      // Wrap the feature in a 'Features' array
      return [geojson];
    case 'FeatureCollection':
      // Just return the 'Features' array from the collection
      _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');
      return geojson.features;
    default:
      // Assume it's a geometry, we'll check type in separateGeojsonFeatures
      // Wrap the geometry object in a 'Feature' object and wrap in an array
      return [{geometry: geojson}];
  }
}

// Linearize
function separateGeojsonFeatures(features) {
  const separated = {
    pointFeatures: [],
    lineFeatures: [],
    polygonFeatures: [],
    polygonOutlineFeatures: []
  };

  for (let featureIndex = 0; featureIndex < features.length; featureIndex++) {
    const feature = features[featureIndex];

    _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].assert(feature && feature.geometry, 'GeoJSON does not have geometry');

    const {geometry} = feature;

    const sourceFeature = {
      feature,
      index: featureIndex
    };

    if (geometry.type === 'GeometryCollection') {
      _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');
      const {geometries} = geometry;
      for (let i = 0; i < geometries.length; i++) {
        const subGeometry = geometries[i];
        separateGeometry(subGeometry, separated, sourceFeature);
      }
    } else {
      separateGeometry(geometry, separated, sourceFeature);
    }
  }

  return separated;
}

function separateGeometry(geometry, separated, sourceFeature) {
  const {type, coordinates} = geometry;
  const {pointFeatures, lineFeatures, polygonFeatures, polygonOutlineFeatures} = separated;

  if (!validateGeometry(type, coordinates)) {
    // Avoid hard failure if some features are malformed
    _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].warn(`${type} coordinates are malformed`)();
    return;
  }

  // Split each feature, but keep track of the source feature and index (for Multi* geometries)
  switch (type) {
    case 'Point':
      pointFeatures.push({
        geometry,
        sourceFeature
      });
      break;
    case 'MultiPoint':
      coordinates.forEach(point => {
        pointFeatures.push({
          geometry: {type: 'Point', coordinates: point},
          sourceFeature
        });
      });
      break;
    case 'LineString':
      lineFeatures.push({
        geometry,
        sourceFeature
      });
      break;
    case 'MultiLineString':
      // Break multilinestrings into multiple lines
      coordinates.forEach(path => {
        lineFeatures.push({
          geometry: {type: 'LineString', coordinates: path},
          sourceFeature
        });
      });
      break;
    case 'Polygon':
      polygonFeatures.push({
        geometry,
        sourceFeature
      });
      // Break polygon into multiple lines
      coordinates.forEach(path => {
        polygonOutlineFeatures.push({
          geometry: {type: 'LineString', coordinates: path},
          sourceFeature
        });
      });
      break;
    case 'MultiPolygon':
      // Break multipolygons into multiple polygons
      coordinates.forEach(polygon => {
        polygonFeatures.push({
          geometry: {type: 'Polygon', coordinates: polygon},
          sourceFeature
        });
        // Break polygon into multiple lines
        polygon.forEach(path => {
          polygonOutlineFeatures.push({
            geometry: {type: 'LineString', coordinates: path},
            sourceFeature
          });
        });
      });
      break;
    default:
  }
}

/**
 * Returns the source feature that was passed to `separateGeojsonFeatures`
 */
function unwrapSourceFeature(wrappedFeature) {
  // The feature provided by the user is under `sourceFeature.feature`
  return wrappedFeature.sourceFeature.feature;
}

/**
 * Returns the index of the source feature that was passed to `separateGeojsonFeatures`
 */
function unwrapSourceFeatureIndex(wrappedFeature) {
  // The index of the feature provided by the user is under `sourceFeature.index`
  return wrappedFeature.sourceFeature.index;
}

/**
 * Simple GeoJSON validation util. For perf reasons we do not validate against the full spec,
 * only the following:
   - geometry.type is supported
   - geometry.coordinate has correct nesting level
 */
const COORDINATE_NEST_LEVEL = {
  Point: 1,
  MultiPoint: 2,
  LineString: 2,
  MultiLineString: 3,
  Polygon: 3,
  MultiPolygon: 4
};

function validateGeometry(type, coordinates) {
  let nestLevel = COORDINATE_NEST_LEVEL[type];

  _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].assert(nestLevel, `Unknown GeoJSON type ${type}`);

  while (coordinates && --nestLevel > 0) {
    coordinates = coordinates[0];
  }

  return coordinates && Number.isFinite(coordinates[0]);
}


/***/ }),

/***/ "./src/icon-layer/icon-layer-fragment.glsl.js":
/*!****************************************************!*\
  !*** ./src/icon-layer/icon-layer-fragment.glsl.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME icon-layer-fragment-shader

precision highp float;

uniform float opacity;
uniform sampler2D iconsTexture;

varying float vColorMode;
varying vec4 vColor;
varying vec2 vTextureCoords;

const float MIN_ALPHA = 0.05;

void main(void) {
  vec4 texColor = texture2D(iconsTexture, vTextureCoords);

  // if colorMode == 0, use pixel color from the texture
  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask
  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);
  // Take the global opacity and the alpha from vColor into account for the alpha component
  float a = texColor.a * opacity * vColor.a;

  if (a < MIN_ALPHA) {
    discard;
  }

  gl_FragColor = vec4(color, a);

  // use highlight color if this fragment belongs to the selected object.
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);

  // use picking color if rendering to picking FBO.
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
}
`);


/***/ }),

/***/ "./src/icon-layer/icon-layer-vertex.glsl.js":
/*!**************************************************!*\
  !*** ./src/icon-layer/icon-layer-vertex.glsl.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME icon-layer-vertex-shader

attribute vec2 positions;

attribute vec3 instancePositions;
attribute vec2 instancePositions64xyLow;
attribute float instanceSizes;
attribute float instanceAngles;
attribute vec4 instanceColors;
attribute vec3 instancePickingColors;
attribute vec4 instanceIconFrames;
attribute float instanceColorModes;
attribute vec2 instanceOffsets;

uniform float sizeScale;
uniform vec2 iconsTextureDim;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform bool billboard;

varying float vColorMode;
varying vec4 vColor;
varying vec2 vTextureCoords;

vec2 rotate_by_angle(vec2 vertex, float angle) {
  float angle_radian = angle * PI / 180.0;
  float cos_angle = cos(angle_radian);
  float sin_angle = sin(angle_radian);
  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
  return rotationMatrix * vertex;
}

void main(void) {
  vec2 iconSize = instanceIconFrames.zw;
  // convert size in meters to pixels, then scaled and clamp
 
  // project meters to pixels and clamp to limits 
  float sizePixels = clamp(
    project_size_to_pixel(instanceSizes * sizeScale), 
    sizeMinPixels, sizeMaxPixels
  );

  // scale icon height to match instanceSize
  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;

  // scale and rotate vertex in "pixel" value and convert back to fraction in clipspace
  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;
  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;

  if (billboard)  {
    pixelOffset.y *= -1.0;
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, vec3(0.0)); 
    gl_Position.xy += project_pixel_size_to_clipspace(pixelOffset);

  } else {
    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, offset_common); 
  }

  vTextureCoords = mix(
    instanceIconFrames.xy,
    instanceIconFrames.xy + iconSize,
    (positions.xy + 1.0) / 2.0
  ) / iconsTextureDim;

  vTextureCoords.y = 1.0 - vTextureCoords.y;

  vColor = instanceColors / 255.;

  vColorMode = instanceColorModes;

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);
}
`);


/***/ }),

/***/ "./src/icon-layer/icon-layer.js":
/*!**************************************!*\
  !*** ./src/icon-layer/icon-layer.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IconLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _icon_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icon-layer-vertex.glsl */ "./src/icon-layer/icon-layer-vertex.glsl.js");
/* harmony import */ var _icon_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./icon-layer-fragment.glsl */ "./src/icon-layer/icon-layer-fragment.glsl.js");
/* harmony import */ var _icon_manager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./icon-manager */ "./src/icon-layer/icon-manager.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.




const {fp64LowPart} = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["fp64"];





const DEFAULT_COLOR = [0, 0, 0, 255];
/*
 * @param {object} props
 * @param {Texture2D | string} props.iconAtlas - atlas image url or texture
 * @param {object} props.iconMapping - icon names mapped to icon definitions
 * @param {object} props.iconMapping[icon_name].x - x position of icon on the atlas image
 * @param {object} props.iconMapping[icon_name].y - y position of icon on the atlas image
 * @param {object} props.iconMapping[icon_name].width - width of icon on the atlas image
 * @param {object} props.iconMapping[icon_name].height - height of icon on the atlas image
 * @param {object} props.iconMapping[icon_name].anchorX - x anchor of icon on the atlas image,
 *   default to width / 2
 * @param {object} props.iconMapping[icon_name].anchorY - y anchor of icon on the atlas image,
 *   default to height / 2
 * @param {object} props.iconMapping[icon_name].mask - whether icon is treated as a transparency
 *   mask. If true, user defined color is applied. If false, original color from the image is
 *   applied. Default to false.
 * @param {number} props.size - icon size in pixels
 * @param {func} props.getPosition - returns anchor position of the icon, in [lng, lat, z]
 * @param {func} props.getIcon - returns icon name as a string
 * @param {func} props.getSize - returns icon size multiplier as a number
 * @param {func} props.getColor - returns color of the icon in [r, g, b, a]. Only works on icons
 *   with mask: true.
 * @param {func} props.getAngle - returns rotating angle (in degree) of the icon.
 */
const defaultProps = {
  iconAtlas: null,
  iconMapping: {type: 'object', value: {}, async: true},
  sizeScale: {type: 'number', value: 1, min: 0},
  fp64: false,
  billboard: true,
  sizeUnits: 'pixels',
  sizeMinPixels: {type: 'number', min: 0, value: 0}, //  min point radius in pixels
  sizeMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER}, // max point radius in pixels

  getPosition: {type: 'accessor', value: x => x.position},
  getIcon: {type: 'accessor', value: x => x.icon},
  getColor: {type: 'accessor', value: DEFAULT_COLOR},
  getSize: {type: 'accessor', value: 1},
  getAngle: {type: 'accessor', value: 0}
};

class IconLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["Layer"] {
  getShaders() {
    const projectModule = this.use64bitProjection() ? 'project64' : 'project32';
    return {vs: _icon_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__["default"], fs: _icon_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__["default"], modules: [projectModule, 'picking']};
  }

  initializeState() {
    this.state = {
      iconManager: new _icon_manager__WEBPACK_IMPORTED_MODULE_4__["default"](this.context.gl, {onUpdate: () => this._onUpdate()})
    };

    const attributeManager = this.getAttributeManager();
    /* eslint-disable max-len */
    attributeManager.addInstanced({
      instancePositions: {
        size: 3,
        transition: true,
        accessor: 'getPosition'
      },
      instancePositions64xyLow: {
        size: 2,
        accessor: 'getPosition',
        update: this.calculateInstancePositions64xyLow
      },
      instanceSizes: {
        size: 1,
        transition: true,
        accessor: 'getSize',
        defaultValue: 1
      },
      instanceOffsets: {size: 2, accessor: 'getIcon', update: this.calculateInstanceOffsets},
      instanceIconFrames: {size: 4, accessor: 'getIcon', update: this.calculateInstanceIconFrames},
      instanceColorModes: {
        size: 1,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        accessor: 'getIcon',
        update: this.calculateInstanceColorMode
      },
      instanceColors: {
        size: 4,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        transition: true,
        accessor: 'getColor',
        defaultValue: DEFAULT_COLOR
      },
      instanceAngles: {
        size: 1,
        transition: true,
        accessor: 'getAngle',
        defaultValue: 0
      }
    });
    /* eslint-enable max-len */
  }

  /* eslint-disable max-statements, complexity */
  updateState({oldProps, props, changeFlags}) {
    super.updateState({props, oldProps, changeFlags});

    const attributeManager = this.getAttributeManager();
    const {iconManager} = this.state;
    const {iconAtlas, iconMapping, data, getIcon} = props;

    let iconMappingChanged = false;

    // prepacked iconAtlas from user
    if (iconAtlas) {
      if (oldProps.iconAtlas !== props.iconAtlas) {
        iconManager.setProps({iconAtlas, autoPacking: false});
      }

      if (oldProps.iconMapping !== props.iconMapping) {
        iconManager.setProps({iconMapping});
        iconMappingChanged = true;
      }
    } else {
      // otherwise, use autoPacking
      iconManager.setProps({autoPacking: true});
    }

    if (
      changeFlags.dataChanged ||
      (changeFlags.updateTriggersChanged &&
        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getIcon))
    ) {
      iconManager.setProps({data, getIcon});
      iconMappingChanged = true;
    }

    if (iconMappingChanged) {
      attributeManager.invalidate('instanceOffsets');
      attributeManager.invalidate('instanceIconFrames');
      attributeManager.invalidate('instanceColorModes');
    }

    if (props.fp64 !== oldProps.fp64) {
      const {gl} = this.context;
      if (this.state.model) {
        this.state.model.delete();
      }
      this.setState({model: this._getModel(gl)});
      attributeManager.invalidateAll();
    }
  }
  /* eslint-enable max-statements, complexity */

  finalizeState() {
    super.finalizeState();
    // Release resources held by the icon manager
    this.state.iconManager.finalize();
  }

  draw({uniforms}) {
    const {sizeScale, sizeMinPixels, sizeMaxPixels, sizeUnits, billboard} = this.props;
    const {iconManager} = this.state;
    const {viewport} = this.context;

    const iconsTexture = iconManager.getTexture();
    if (iconsTexture) {
      this.state.model
        .setUniforms(
          Object.assign({}, uniforms, {
            iconsTexture,
            iconsTextureDim: [iconsTexture.width, iconsTexture.height],
            sizeScale:
              sizeScale * (sizeUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1),
            sizeMinPixels,
            sizeMaxPixels,
            billboard
          })
        )
        .draw();
    }
  }

  _getModel(gl) {
    const positions = [-1, -1, 0, -1, 1, 0, 1, 1, 0, 1, -1, 0];

    return new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Model"](
      gl,
      Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Geometry"]({
          drawMode: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.TRIANGLE_FAN,
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      })
    );
  }

  _onUpdate() {
    this.setNeedsRedraw();
  }

  calculateInstancePositions64xyLow(attribute) {
    const isFP64 = this.use64bitPositions();
    attribute.constant = !isFP64;

    if (!isFP64) {
      attribute.value = new Float32Array(2);
      return;
    }

    const {data, getPosition} = this.props;
    const {value} = attribute;
    let i = 0;
    const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["createIterable"])(data);
    for (const object of iterable) {
      objectInfo.index++;
      const position = getPosition(object, objectInfo);
      value[i++] = fp64LowPart(position[0]);
      value[i++] = fp64LowPart(position[1]);
    }
  }

  calculateInstanceOffsets(attribute, {startRow, endRow}) {
    const {data} = this.props;
    const {iconManager} = this.state;
    const {value, size} = attribute;
    let i = startRow * size;
    const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["createIterable"])(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      const rect = iconManager.getIconMapping(object, objectInfo);
      value[i++] = rect.width / 2 - rect.anchorX || 0;
      value[i++] = rect.height / 2 - rect.anchorY || 0;
    }
  }

  calculateInstanceColorMode(attribute, {startRow, endRow}) {
    const {data} = this.props;
    const {iconManager} = this.state;
    const {value, size} = attribute;
    let i = startRow * size;
    const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["createIterable"])(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      const mapping = iconManager.getIconMapping(object, objectInfo);
      const colorMode = mapping.mask;
      value[i++] = colorMode ? 1 : 0;
    }
  }

  calculateInstanceIconFrames(attribute, {startRow, endRow}) {
    const {data} = this.props;
    const {iconManager} = this.state;
    const {value, size} = attribute;
    let i = startRow * size;
    const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["createIterable"])(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      const rect = iconManager.getIconMapping(object, objectInfo);
      value[i++] = rect.x || 0;
      value[i++] = rect.y || 0;
      value[i++] = rect.width || 0;
      value[i++] = rect.height || 0;
    }
  }
}

IconLayer.layerName = 'IconLayer';
IconLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/icon-layer/icon-manager.js":
/*!****************************************!*\
  !*** ./src/icon-layer/icon-manager.js ***!
  \****************************************/
/*! exports provided: buildMapping, getDiffIcons, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildMapping", function() { return buildMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDiffIcons", function() { return getDiffIcons; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IconManager; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _loaders_gl_images__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @loaders.gl/images */ "../../node_modules/@loaders.gl/images/dist/esm/index.js");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_2__);
/* global document */





const DEFAULT_CANVAS_WIDTH = 1024;
const DEFAULT_BUFFER = 4;

const noop = () => {};

const DEFAULT_TEXTURE_PARAMETERS = {
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MIN_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINEAR_MIPMAP_LINEAR,
  // GL.LINEAR is the default value but explicitly set it here
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MAG_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINEAR
};

function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}

// resize image to given width and height
function resizeImage(ctx, imageData, width, height) {
  const {naturalWidth, naturalHeight} = imageData;
  if (width === naturalWidth && height === naturalHeight) {
    return imageData;
  }

  ctx.canvas.height = height;
  ctx.canvas.width = width;

  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

  // image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight
  ctx.drawImage(imageData, 0, 0, naturalWidth, naturalHeight, 0, 0, width, height);

  return ctx.canvas;
}

function getIconId(icon) {
  return icon && (icon.id || icon.url);
}

// traverse icons in a row of icon atlas
// extend each icon with left-top coordinates
function buildRowMapping(mapping, columns, yOffset) {
  for (let i = 0; i < columns.length; i++) {
    const {icon, xOffset} = columns[i];
    const id = getIconId(icon);
    mapping[id] = Object.assign({}, icon, {
      x: xOffset,
      y: yOffset
    });
  }
}

// resize texture without losing original data
function resizeTexture(texture, width, height) {
  const oldWidth = texture.width;
  const oldHeight = texture.height;
  const oldPixels = Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["readPixelsToBuffer"])(texture, {});

  texture.resize({width, height});

  texture.setSubImageData({
    data: oldPixels,
    x: 0,
    y: height - oldHeight,
    width: oldWidth,
    height: oldHeight,
    parameters: DEFAULT_TEXTURE_PARAMETERS
  });

  texture.generateMipmap();

  oldPixels.delete();
  return texture;
}

/**
 * Generate coordinate mapping to retrieve icon left-top position from an icon atlas
 * @param icons {Array<Object>} list of icons, each icon requires url, width, height
 * @param buffer {Number} add buffer to the right and bottom side of the image
 * @param xOffset {Number} right position of last icon in old mapping
 * @param yOffset {Number} top position in last icon in old mapping
 * @param canvasWidth {Number} max width of canvas
 * @param mapping {object} old mapping
 * @returns {{mapping: {'/icon/1': {url, width, height, ...}},, canvasHeight: {Number}}}
 */
function buildMapping({icons, buffer, mapping = {}, xOffset = 0, yOffset = 0, canvasWidth}) {
  // height of current row
  let rowHeight = 0;

  let columns = [];
  // Strategy to layout all the icons into a texture:
  // traverse the icons sequentially, layout the icons from left to right, top to bottom
  // when the sum of the icons width is equal or larger than canvasWidth,
  // move to next row starting from total height so far plus max height of the icons in previous row
  // row width is equal to canvasWidth
  // row height is decided by the max height of the icons in that row
  // mapping coordinates of each icon is its left-top position in the texture
  for (let i = 0; i < icons.length; i++) {
    const icon = icons[i];
    const id = getIconId(icon);

    if (!mapping[id]) {
      const {height, width} = icon;

      // fill one row
      if (xOffset + width + buffer > canvasWidth) {
        buildRowMapping(mapping, columns, yOffset);

        xOffset = 0;
        yOffset = rowHeight + yOffset + buffer;
        rowHeight = 0;
        columns = [];
      }

      columns.push({
        icon,
        xOffset
      });

      xOffset = xOffset + width + buffer;
      rowHeight = Math.max(rowHeight, height);
    }
  }

  if (columns.length > 0) {
    buildRowMapping(mapping, columns, yOffset);
  }

  return {
    mapping,
    xOffset,
    yOffset,
    canvasWidth,
    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer)
  };
}

// extract icons from data
// return icons should be unique, and not cached or cached but url changed
function getDiffIcons(data, getIcon, cachedIcons) {
  if (!data || !getIcon) {
    return null;
  }

  cachedIcons = cachedIcons || {};
  const icons = {};
  const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_2__["createIterable"])(data);
  for (const object of iterable) {
    objectInfo.index++;
    const icon = getIcon(object, objectInfo);
    const id = getIconId(icon);

    if (!icon) {
      throw new Error('Icon is missing.');
    }

    if (!icon.url) {
      throw new Error('Icon url is missing.');
    }

    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {
      icons[id] = icon;
    }
  }
  return icons;
}

class IconManager {
  constructor(
    gl,
    {
      onUpdate = noop // notify IconLayer when icon texture update
    }
  ) {
    this.gl = gl;
    this.onUpdate = onUpdate;

    this._getIcon = null;

    this._texture = null;
    this._externalTexture = null;
    this._mapping = {};

    this._autoPacking = false;

    // internal props used when autoPacking applied
    // right position of last icon
    this._xOffset = 0;
    // top position of last icon
    this._yOffset = 0;
    this._buffer = DEFAULT_BUFFER;
    this._canvasWidth = DEFAULT_CANVAS_WIDTH;
    this._canvasHeight = 0;
    this._canvas = null;
  }

  finalize() {
    if (this._texture) {
      this._texture.delete();
    }
  }

  getTexture() {
    return this._texture || this._externalTexture;
  }

  getIconMapping(object, objectInfo) {
    const icon = this._getIcon(object, objectInfo);
    const id = this._autoPacking ? getIconId(icon) : icon;
    return this._mapping[id] || {};
  }

  setProps({autoPacking, iconAtlas, iconMapping, data, getIcon}) {
    if (autoPacking !== undefined) {
      this._autoPacking = autoPacking;
    }

    if (getIcon) {
      this._getIcon = getIcon;
    }

    if (iconMapping) {
      this._mapping = iconMapping;
    }

    if (iconAtlas) {
      this._updateIconAtlas(iconAtlas);
    }

    if (this._autoPacking && (data || getIcon) && typeof document !== 'undefined') {
      this._canvas = this._canvas || document.createElement('canvas');

      this._updateAutoPacking(data);
    }
  }

  _updateIconAtlas(iconAtlas) {
    if (this._texture) {
      this._texture.delete();
      this._texture = null;
    }
    if (iconAtlas instanceof _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Texture2D"]) {
      iconAtlas.setParameters(DEFAULT_TEXTURE_PARAMETERS);

      this._externalTexture = iconAtlas;
      this.onUpdate();
    } else if (typeof iconAtlas === 'string') {
      Object(_loaders_gl_images__WEBPACK_IMPORTED_MODULE_1__["loadImage"])(iconAtlas).then(data => {
        this._texture = new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Texture2D"](this.gl, {
          data,
          parameters: DEFAULT_TEXTURE_PARAMETERS
        });
        this.onUpdate();
      });
    }
  }

  _updateAutoPacking(data) {
    const icons = Object.values(getDiffIcons(data, this._getIcon, this._mapping) || {});

    if (icons.length > 0) {
      // generate icon mapping
      const {mapping, xOffset, yOffset, canvasHeight} = buildMapping({
        icons,
        buffer: this._buffer,
        canvasWidth: this._canvasWidth,
        mapping: this._mapping,
        xOffset: this._xOffset,
        yOffset: this._yOffset
      });

      this._mapping = mapping;
      this._xOffset = xOffset;
      this._yOffset = yOffset;
      this._canvasHeight = canvasHeight;

      // create new texture
      if (!this._texture) {
        this._texture = new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__["Texture2D"](this.gl, {
          width: this._canvasWidth,
          height: this._canvasHeight,
          parameters: DEFAULT_TEXTURE_PARAMETERS
        });
      }

      if (this._texture.height !== this._canvasHeight) {
        resizeTexture(this._texture, this._canvasWidth, this._canvasHeight);
      }

      this.onUpdate();

      // load images
      this._loadIcons(icons);
    }
  }

  _loadIcons(icons) {
    const ctx = this._canvas.getContext('2d');
    const canvasHeight = this._texture.height;

    for (const icon of icons) {
      Object(_loaders_gl_images__WEBPACK_IMPORTED_MODULE_1__["loadImage"])(icon.url).then(imageData => {
        const id = getIconId(icon);
        const {x, y, width, height} = this._mapping[id];

        const data = resizeImage(ctx, imageData, width, height);

        this._texture.setSubImageData({
          data,
          x,
          y: canvasHeight - y - height, // flip Y as texture stored as reversed Y
          width,
          height,
          parameters: Object.assign({}, DEFAULT_TEXTURE_PARAMETERS, {
            [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_FLIP_Y_WEBGL]: true
          })
        });

        // Call to regenerate mipmaps after modifying texture(s)
        this._texture.generateMipmap();

        this.onUpdate();
      });
    }
  }
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: ArcLayer, BitmapLayer, IconLayer, LineLayer, PointCloudLayer, ScatterplotLayer, ColumnLayer, GridCellLayer, PathLayer, PolygonLayer, GeoJsonLayer, TextLayer, SolidPolygonLayer, _MultiIconLayer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _arc_layer_arc_layer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arc-layer/arc-layer */ "./src/arc-layer/arc-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ArcLayer", function() { return _arc_layer_arc_layer__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _bitmap_layer_bitmap_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bitmap-layer/bitmap-layer */ "./src/bitmap-layer/bitmap-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BitmapLayer", function() { return _bitmap_layer_bitmap_layer__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _icon_layer_icon_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./icon-layer/icon-layer */ "./src/icon-layer/icon-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IconLayer", function() { return _icon_layer_icon_layer__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _line_layer_line_layer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line-layer/line-layer */ "./src/line-layer/line-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LineLayer", function() { return _line_layer_line_layer__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _point_cloud_layer_point_cloud_layer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./point-cloud-layer/point-cloud-layer */ "./src/point-cloud-layer/point-cloud-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointCloudLayer", function() { return _point_cloud_layer_point_cloud_layer__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _scatterplot_layer_scatterplot_layer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scatterplot-layer/scatterplot-layer */ "./src/scatterplot-layer/scatterplot-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScatterplotLayer", function() { return _scatterplot_layer_scatterplot_layer__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _column_layer_column_layer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./column-layer/column-layer */ "./src/column-layer/column-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ColumnLayer", function() { return _column_layer_column_layer__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _column_layer_grid_cell_layer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./column-layer/grid-cell-layer */ "./src/column-layer/grid-cell-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GridCellLayer", function() { return _column_layer_grid_cell_layer__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _path_layer_path_layer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./path-layer/path-layer */ "./src/path-layer/path-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PathLayer", function() { return _path_layer_path_layer__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _polygon_layer_polygon_layer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./polygon-layer/polygon-layer */ "./src/polygon-layer/polygon-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PolygonLayer", function() { return _polygon_layer_polygon_layer__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _geojson_layer_geojson_layer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./geojson-layer/geojson-layer */ "./src/geojson-layer/geojson-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GeoJsonLayer", function() { return _geojson_layer_geojson_layer__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _text_layer_text_layer__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./text-layer/text-layer */ "./src/text-layer/text-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextLayer", function() { return _text_layer_text_layer__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _solid_polygon_layer_solid_polygon_layer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./solid-polygon-layer/solid-polygon-layer */ "./src/solid-polygon-layer/solid-polygon-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SolidPolygonLayer", function() { return _solid_polygon_layer_solid_polygon_layer__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _text_layer_multi_icon_layer_multi_icon_layer__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./text-layer/multi-icon-layer/multi-icon-layer */ "./src/text-layer/multi-icon-layer/multi-icon-layer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MultiIconLayer", function() { return _text_layer_multi_icon_layer_multi_icon_layer__WEBPACK_IMPORTED_MODULE_13__["default"]; });

// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.
/* eslint-disable max-len */

// Core Layers














// Experimental layer exports



/***/ }),

/***/ "./src/line-layer/line-layer-fragment.glsl.js":
/*!****************************************************!*\
  !*** ./src/line-layer/line-layer-fragment.glsl.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME line-layer-fragment-shader

precision highp float;

varying vec4 vColor;

void main(void) {
  gl_FragColor = vColor;

  // use highlight color if this fragment belongs to the selected object.
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);

  // use picking color if rendering to picking FBO.
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
}
`);


/***/ }),

/***/ "./src/line-layer/line-layer-vertex.glsl.js":
/*!**************************************************!*\
  !*** ./src/line-layer/line-layer-vertex.glsl.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME line-layer-vertex-shader

attribute vec3 positions;
attribute vec3 instanceSourcePositions;
attribute vec3 instanceTargetPositions;
attribute vec4 instanceSourceTargetPositions64xyLow;
attribute vec4 instanceColors;
attribute vec3 instancePickingColors;
attribute float instanceWidths;

uniform float opacity;
uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;

varying vec4 vColor;

// offset vector by strokeWidth pixels
// offset_direction is -1 (left) or 1 (right)
vec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction, float width) {
  // normalized direction of the line
  vec2 dir_screenspace = normalize(line_clipspace * project_uViewportSize);
  // rotate by 90 degrees
  dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);

  vec2 offset_screenspace = dir_screenspace * offset_direction * width / 2.0;
  vec2 offset_clipspace = project_pixel_size_to_clipspace(offset_screenspace);

  return offset_clipspace;
}

void main(void) {
  // Position
  vec4 source = project_position_to_clipspace(instanceSourcePositions, instanceSourceTargetPositions64xyLow.xy, vec3(0.));
  vec4 target = project_position_to_clipspace(instanceTargetPositions, instanceSourceTargetPositions64xyLow.zw, vec3(0.));

  // Multiply out width and clamp to limits
  float widthPixels = clamp(
    project_size_to_pixel(instanceWidths * widthScale),
    widthMinPixels, widthMaxPixels
  );
  
  // linear interpolation of source & target to pick right coord
  float segmentIndex = positions.x;
  vec4 p = mix(source, target, segmentIndex);

  // extrude
  vec2 offset = getExtrusionOffset(target.xy - source.xy, positions.y, widthPixels);
  gl_Position = p + vec4(offset, 0.0, 0.0);

  // Color
  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);
}
`);


/***/ }),

/***/ "./src/line-layer/line-layer.js":
/*!**************************************!*\
  !*** ./src/line-layer/line-layer.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LineLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _line_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./line-layer-vertex.glsl */ "./src/line-layer/line-layer-vertex.glsl.js");
/* harmony import */ var _line_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./line-layer-fragment.glsl */ "./src/line-layer/line-layer-fragment.glsl.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.




const {fp64LowPart} = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["fp64"];




const DEFAULT_COLOR = [0, 0, 0, 255];

const defaultProps = {
  fp64: false,

  getSourcePosition: {type: 'accessor', value: x => x.sourcePosition},
  getTargetPosition: {type: 'accessor', value: x => x.targetPosition},
  getColor: {type: 'accessor', value: DEFAULT_COLOR},
  getWidth: {type: 'accessor', value: 1},

  widthUnits: 'pixels',
  widthScale: {type: 'number', value: 1, min: 0},
  widthMinPixels: {type: 'number', value: 0, min: 0},
  widthMaxPixels: {type: 'number', value: Number.MAX_SAFE_INTEGER, min: 0},

  // Deprecated, remove in v8
  getStrokeWidth: {deprecatedFor: 'getWidth'}
};

class LineLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["Layer"] {
  getShaders() {
    const projectModule = this.use64bitProjection() ? 'project64' : 'project32';
    return {vs: _line_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__["default"], fs: _line_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__["default"], modules: [projectModule, 'picking']};
  }

  initializeState() {
    const attributeManager = this.getAttributeManager();

    /* eslint-disable max-len */
    attributeManager.addInstanced({
      instanceSourcePositions: {
        size: 3,
        transition: true,
        accessor: 'getSourcePosition'
      },
      instanceTargetPositions: {
        size: 3,
        transition: true,
        accessor: 'getTargetPosition'
      },
      instanceSourceTargetPositions64xyLow: {
        size: 4,
        accessor: ['getSourcePosition', 'getTargetPosition'],
        update: this.calculateInstanceSourceTargetPositions64xyLow
      },
      instanceColors: {
        size: 4,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        transition: true,
        accessor: 'getColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceWidths: {
        size: 1,
        transition: true,
        accessor: 'getWidth',
        defaultValue: 1
      }
    });
    /* eslint-enable max-len */
  }

  updateState({props, oldProps, changeFlags}) {
    super.updateState({props, oldProps, changeFlags});

    if (props.fp64 !== oldProps.fp64) {
      const {gl} = this.context;
      if (this.state.model) {
        this.state.model.delete();
      }
      this.setState({model: this._getModel(gl)});
      this.getAttributeManager().invalidateAll();
    }
  }

  draw({uniforms}) {
    const {viewport} = this.context;
    const {widthUnits, widthScale, widthMinPixels, widthMaxPixels} = this.props;

    const widthMultiplier = widthUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1;

    this.state.model
      .setUniforms(
        Object.assign({}, uniforms, {
          widthScale: widthScale * widthMultiplier,
          widthMinPixels,
          widthMaxPixels
        })
      )
      .draw();
  }

  _getModel(gl) {
    /*
     *  (0, -1)-------------_(1, -1)
     *       |          _,-"  |
     *       o      _,-"      o
     *       |  _,-"          |
     *   (0, 1)"-------------(1, 1)
     */
    const positions = [0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0];

    return new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Model"](
      gl,
      Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Geometry"]({
          drawMode: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.TRIANGLE_STRIP,
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      })
    );
  }

  calculateInstanceSourceTargetPositions64xyLow(attribute, {startRow, endRow}) {
    const isFP64 = this.use64bitPositions();
    attribute.constant = !isFP64;

    if (!isFP64) {
      attribute.value = new Float32Array(4);
      return;
    }

    const {data, getSourcePosition, getTargetPosition} = this.props;
    const {value, size} = attribute;
    let i = startRow * size;
    const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["createIterable"])(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      const sourcePosition = getSourcePosition(object, objectInfo);
      const targetPosition = getTargetPosition(object, objectInfo);
      value[i++] = fp64LowPart(sourcePosition[0]);
      value[i++] = fp64LowPart(sourcePosition[1]);
      value[i++] = fp64LowPart(targetPosition[0]);
      value[i++] = fp64LowPart(targetPosition[1]);
    }
  }
}

LineLayer.layerName = 'LineLayer';
LineLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/path-layer/path-layer-fragment.glsl.js":
/*!****************************************************!*\
  !*** ./src/path-layer/path-layer-fragment.glsl.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME path-layer-fragment-shader

precision highp float;

uniform float jointType;
uniform float miterLimit;
uniform float alignMode;

varying vec4 vColor;
varying vec2 vCornerOffset;
varying float vMiterLength;
varying vec2 vDashArray;
/*
 * vPathPosition represents the relative coordinates of the current fragment on the path segment.
 * vPathPosition.x - position along the width of the path, between [-1, 1]. 0 is the center line.
 * vPathPosition.y - position along the length of the path, between [0, L / width].
 */
varying vec2 vPathPosition;
varying float vPathLength;

// mod doesn't work correctly for negative numbers
float mod2(float a, float b) {
  return a - floor(a / b) * b;
}

float round(float x) {
  return floor(x + 0.5);
}

// if given position is in the gap part of the dashed line
// dashArray.x: solid stroke length, relative to width
// dashArray.y: gap length, relative to width
// alignMode:
// 0 - no adjustment
// o----     ----     ----     ---- o----     -o----     ----     o
// 1 - stretch to fit, draw half dash at each end for nicer joints
// o--    ----    ----    ----    --o--      --o--     ----     --o
bool dash_isFragInGap() {
  float solidLength = vDashArray.x;
  float gapLength = vDashArray.y;

  float unitLength = solidLength + gapLength;

  if (unitLength == 0.0) {
    return false;
  }

  unitLength = mix(
    unitLength,
    vPathLength / round(vPathLength / unitLength),
    alignMode
  );

  float offset = alignMode * solidLength / 2.0;

  return gapLength > 0.0 &&
    vPathPosition.y >= 0.0 &&
    vPathPosition.y <= vPathLength &&
    mod2(vPathPosition.y + offset, unitLength) > solidLength;
}

void main(void) {
  // if joint is rounded, test distance from the corner
  if (jointType > 0.0 && vMiterLength > 0.0 && length(vCornerOffset) > 1.0) {
    // Enable to debug joints
    // gl_FragColor = vec4(0., 1., 0., 1.);
    // return;
    discard;
  }
  if (jointType == 0.0 && vMiterLength > miterLimit) {
    // Enable to debug joints
    // gl_FragColor = vec4(0., 0., 1., 1.);
    // return;
    discard;
  }
  if (vColor.a == 0.0 || dash_isFragInGap()) {
    // Enable to debug joints
    // gl_FragColor = vec4(0., 1., 1., 1.);
    // return;
    discard;
  }
  gl_FragColor = vColor;

  // use highlight color if this fragment belongs to the selected object.
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);

  // use picking color if rendering to picking FBO.
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
}
`);


/***/ }),

/***/ "./src/path-layer/path-layer-vertex-64.glsl.js":
/*!*****************************************************!*\
  !*** ./src/path-layer/path-layer-vertex-64.glsl.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\

#define SHADER_NAME path-layer-vertex-shader-64

attribute vec3 positions;

attribute vec3 instanceStartPositions;
attribute vec3 instanceEndPositions;
attribute vec4 instanceStartEndPositions64xyLow;
attribute vec3 instanceLeftPositions;
attribute vec3 instanceRightPositions;
attribute vec4 instanceNeighborPositions64xyLow;
attribute float instanceStrokeWidths;
attribute vec4 instanceColors;
attribute vec3 instancePickingColors;
attribute vec2 instanceDashArrays;

uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform float jointType;
uniform float miterLimit;

uniform float opacity;

varying vec4 vColor;
varying vec2 vCornerOffset;
varying float vMiterLength;
varying vec2 vDashArray;
varying vec2 vPathPosition;
varying float vPathLength;

const float EPSILON = 0.001;

float flipIfTrue(bool flag) {
  return -(float(flag) * 2. - 1.);
}

vec3 lineJoin(vec2 prevPoint64[2], vec2 currPoint64[2], vec2 nextPoint64[2]) {

  float widthPixels = clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),
    widthMinPixels, widthMaxPixels) / 2.0;
  float width = project_pixel_size(widthPixels);

  vec2 deltaA64[2];
  vec2 deltaB64[2];

  vec2_sub_fp64(currPoint64, prevPoint64, deltaA64);
  vec2_sub_fp64(nextPoint64, currPoint64, deltaB64);

  vec2 lengthA64 = vec2_length_fp64(deltaA64);
  vec2 lengthB64 = vec2_length_fp64(deltaB64);

  vec2 deltaA = vec2(deltaA64[0].x, deltaA64[1].x);
  vec2 deltaB = vec2(deltaB64[0].x, deltaB64[1].x);

  float lenA = lengthA64.x;
  float lenB = lengthB64.x;

  vec2 offsetVec;
  float offsetScale;
  float offsetDirection;

  // when two points are closer than PIXEL_EPSILON in pixels,
  // assume they are the same point to avoid precision issue
  lenA = lenA / width > EPSILON ? lenA : 0.0;
  lenB = lenB / width > EPSILON ? lenB : 0.0;
  vec2 dirA = lenA > 0. ? deltaA / lenA : vec2(0.0, 0.0);
  vec2 dirB = lenB > 0. ? deltaB / lenB : vec2(0.0, 0.0);

  vec2 perpA = vec2(-dirA.y, dirA.x);
  vec2 perpB = vec2(-dirB.y, dirB.x);

  // tangent of the corner
  vec2 tangent = vec2(dirA + dirB);
  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
  // direction of the corner
  vec2 miterVec = vec2(-tangent.y, tangent.x);
  // width offset from current position
  vec2 perp = mix(perpB, perpA, positions.x);
  float L = mix(lenB, lenA, positions.x);

  // cap super sharp angles
  float sinHalfA = abs(dot(miterVec, perp));
  float cosHalfA = abs(dot(dirA, miterVec));
  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;

  // relative position to the corner:
  // -1: inside (smaller side of the angle)
  // 0: center
  // 1: outside (bigger side of the angle)
  float cornerPosition = mix(
    flipIfTrue(turnsRight == (positions.y > 0.0)),
    0.0,
    positions.z
  );

  offsetScale = 1.0 / max(sinHalfA, EPSILON);

  // do not bevel if line segment is too short
  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);
  // trim if inside corner extends further than the line segment
  offsetScale = mix(
    offsetScale,
    min(offsetScale, L / width / max(cosHalfA, EPSILON)),
    float(cornerPosition < 0.0)
  );

  vMiterLength = mix(
    offsetScale * cornerPosition,
    mix(offsetScale, 0.0, cornerPosition),
    step(0.0, cornerPosition)
  ) - sinHalfA * jointType;
  offsetDirection = mix(
    positions.y,
    mix(
      flipIfTrue(turnsRight),
      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),
      cornerPosition
    ),
    step(0.0, cornerPosition)
  );
  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));
  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));

  // special treatment for start cap and end cap
  // using a small number as the limit for determining if the lenA or lenB is 0
  float isStartCap = step(lenA, 1.0e-5);
  float isEndCap = step(lenB, 1.0e-5);
  float isCap = max(isStartCap, isEndCap);

  // 0: center, 1: side
  cornerPosition = isCap * (1.0 - positions.z);

  // start of path: use next - curr
  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);
  // end of path: use curr - prev
  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);

  // extend out a triangle to envelope the round cap
  offsetScale = mix(
    offsetScale,
    mix(4.0 * jointType, 1.0, cornerPosition),
    isCap
  );
  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);

  offsetDirection = mix(
    offsetDirection,
    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),
    isCap
  );

  vCornerOffset = offsetVec * offsetDirection * offsetScale;

  // Generate variables for dash calculation
  vDashArray = instanceDashArrays;
  vPathLength = L / width;
  float isEnd = positions.x;
  vec2 offsetFromStartOfPath = mix(vCornerOffset, vCornerOffset + deltaA / width, isEnd);
  vec2 dir = mix(dirB, dirA, isEnd);
  vPathPosition = vec2(
    positions.y + positions.z * offsetDirection,
    dot(offsetFromStartOfPath, dir)
  );

  return vec3(vCornerOffset * width, 0.0);
}

void main() {
  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);

  float isEnd = positions.x;

  // Calculate current position 64bit

  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);
  vec2 projected_curr_position[2];
  project_position_fp64(currPosition.xy, currPosition64xyLow, projected_curr_position);
  float projected_curr_position_z = project_size(currPosition.z);

  // Calculate previous position

  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);

  // Calculate prev position 64bit

  vec2 projected_prev_position[2];
  project_position_fp64(prevPosition.xy, prevPosition64xyLow, projected_prev_position);

  // Calculate next positions
  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);

  // Calculate next position 64bit

  vec2 projected_next_position[2];
  project_position_fp64(nextPosition.xy, nextPosition64xyLow, projected_next_position);

  vec3 pos = lineJoin(projected_prev_position, projected_curr_position, projected_next_position);
  vec2 vertex_pos_modelspace[4];

  vertex_pos_modelspace[0] = sum_fp64(vec2(pos.x, 0.0), projected_curr_position[0]);
  vertex_pos_modelspace[1] = sum_fp64(vec2(pos.y, 0.0), projected_curr_position[1]);
  vertex_pos_modelspace[2] = vec2(pos.z + projected_curr_position_z, 0.0);
  vertex_pos_modelspace[3] = vec2(1.0, 0.0);

  gl_Position = project_common_position_to_clipspace_fp64(vertex_pos_modelspace);
}
`);


/***/ }),

/***/ "./src/path-layer/path-layer-vertex.glsl.js":
/*!**************************************************!*\
  !*** ./src/path-layer/path-layer-vertex.glsl.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME path-layer-vertex-shader

attribute vec3 positions;

attribute vec3 instanceStartPositions;
attribute vec3 instanceEndPositions;
attribute vec4 instanceStartEndPositions64xyLow;
attribute vec3 instanceLeftPositions;
attribute vec3 instanceRightPositions;
attribute vec4 instanceNeighborPositions64xyLow;
attribute float instanceStrokeWidths;
attribute vec4 instanceColors;
attribute vec3 instancePickingColors;
attribute vec2 instanceDashArrays;

uniform float widthScale;
uniform float widthMinPixels;
uniform float widthMaxPixels;
uniform float jointType;
uniform float miterLimit;
uniform bool billboard;

uniform float opacity;

varying vec4 vColor;
varying vec2 vCornerOffset;
varying float vMiterLength;
varying vec2 vDashArray;
varying vec2 vPathPosition;
varying float vPathLength;

const float EPSILON = 0.001;
const vec3 ZERO_OFFSET = vec3(0.0);

float flipIfTrue(bool flag) {
  return -(float(flag) * 2. - 1.);
}

// calculate line join positions
vec3 lineJoin(
  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,
  float relativePosition, bool isEnd, bool isJoint,
  vec2 width
) {
  vec2 deltaA = (currPoint.xy - prevPoint.xy) / width;
  vec2 deltaB = (nextPoint.xy - currPoint.xy) / width;

  float lenA = length(deltaA);
  float lenB = length(deltaB);

  // when two points are closer than PIXEL_EPSILON in pixels,
  // assume they are the same point to avoid precision issue
  lenA = lenA > EPSILON ? lenA : 0.0;
  lenB = lenB > EPSILON ? lenB : 0.0;

  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);
  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);

  vec2 perpA = vec2(-dirA.y, dirA.x);
  vec2 perpB = vec2(-dirB.y, dirB.x);

  // tangent of the corner
  vec2 tangent = vec2(dirA + dirB);
  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;
  // direction of the corner
  vec2 miterVec = vec2(-tangent.y, tangent.x);
  // width offset from current position
  vec2 perp = isEnd ? perpA : perpB;
  float L = isEnd ? lenA : lenB;

  // cap super sharp angles
  float sinHalfA = abs(dot(miterVec, perp));
  float cosHalfA = abs(dot(dirA, miterVec));

  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;

  float offsetScale = 1.0 / max(sinHalfA, EPSILON);

  float cornerPosition = isJoint ?
    0.0 :
    flipIfTrue(turnsRight == (relativePosition > 0.0));

  // do not bevel if line segment is too short
  cornerPosition *=
    float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) * cosHalfA);

  // trim if inside corner extends further than the line segment
  if (cornerPosition < 0.0) {
    offsetScale = min(offsetScale, L / max(cosHalfA, EPSILON));
  }

  vMiterLength = cornerPosition >= 0.0 ?
    mix(offsetScale, 0.0, cornerPosition) :
    offsetScale * cornerPosition;
  vMiterLength -= sinHalfA * jointType;

  float offsetDirection = mix(
    positions.y,
    mix(
      flipIfTrue(turnsRight),
      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),
      cornerPosition
    ),
    step(0.0, cornerPosition)
  );

  vec2 offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));
  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));

  // special treatment for start cap and end cap
  // TODO - This has an issue. len is always positive because it is length.
  // Step returns zero if -lenA<0, so practically this is a comparison of
  // lenA with zero, with lots of problems because of the -lenA. Can we use EPSILON?
  bool isStartCap = step(0.0, -lenA) > 0.5;
  bool isEndCap = step(0.0, -lenB) > 0.5;
  bool isCap = isStartCap || isEndCap;

  // 0: center, 1: side
  cornerPosition = isCap ? (1.0 - positions.z) : 0.;

  // start of path: use next - curr
  if (isStartCap) {
    offsetVec = mix(dirB, perpB, cornerPosition);
  }

  // end of path: use curr - prev
  if (isEndCap) {
    offsetVec = mix(dirA, perpA, cornerPosition);
  }

  // extend out a triangle to envelope the round cap
  if (isCap) {
    offsetScale = mix(4.0 * jointType, 1.0, cornerPosition);
    vMiterLength = 1.0 - cornerPosition;
    offsetDirection = mix(flipIfTrue(isStartCap), positions.y, cornerPosition);
  }

  vCornerOffset = offsetVec * offsetDirection * offsetScale;

  // Generate variables for dash calculation
  vDashArray = instanceDashArrays;
  vPathLength = L;
  // vec2 offsetFromStartOfPath = isEnd ? vCornerOffset + deltaA : vCornerOffset;
  vec2 offsetFromStartOfPath = vCornerOffset;
  if (isEnd) {
    offsetFromStartOfPath += deltaA;
  }
  vec2 dir = isEnd ? dirA : dirB;
  vPathPosition = vec2(
    positions.y + positions.z * offsetDirection,
    dot(offsetFromStartOfPath, dir)
  );

  return currPoint + vec3(vCornerOffset * width, 0.0);
}

// calculate line join positions
// extract params from attributes and uniforms
vec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {

  // relative position to the corner:
  // -1: inside (smaller side of the angle)
  // 0: center
  // 1: outside (bigger side of the angle)

  float relativePosition = positions.y;
  bool isEnd = positions.x > EPSILON;
  bool isJoint = positions.z > EPSILON;

  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),
    widthMinPixels, widthMaxPixels) / 2.0);

  return lineJoin(
    prevPoint, currPoint, nextPoint,
    relativePosition, isEnd, isJoint,
    billboard ? project_pixel_size_to_clipspace(widthPixels) : project_pixel_size(widthPixels)
  );
}

// In clipspace extrusion, if a line extends behind the camera, clip it to avoid visual artifacts
void clipLine(inout vec4 position, vec4 refPosition) {
  if (position.w < EPSILON) {
    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);
    position = refPosition + (position - refPosition) * r;
  }
}

void main() {
  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);

  float isEnd = positions.x;

  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);
  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);

  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);
  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);

  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);
  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);

  if (billboard) {
    // Extrude in clipspace
    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64xyLow, ZERO_OFFSET);
    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64xyLow, ZERO_OFFSET);
    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64xyLow, ZERO_OFFSET);

    clipLine(prevPositionScreen, currPositionScreen);
    clipLine(nextPositionScreen, currPositionScreen);
    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));

    vec3 pos = lineJoin(
      prevPositionScreen.xyz / prevPositionScreen.w,
      currPositionScreen.xyz / currPositionScreen.w,
      nextPositionScreen.xyz / nextPositionScreen.w
    );

    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);
  } else {
    // Extrude in commonspace
    prevPosition = project_position(prevPosition, prevPosition64xyLow);
    currPosition = project_position(currPosition, currPosition64xyLow);
    nextPosition = project_position(nextPosition, nextPosition64xyLow);

    vec3 pos = lineJoin(prevPosition, currPosition, nextPosition);
    gl_Position = project_common_position_to_clipspace(vec4(pos, 1.0));
  }
}
`);


/***/ }),

/***/ "./src/path-layer/path-layer.js":
/*!**************************************!*\
  !*** ./src/path-layer/path-layer.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PathLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _path_tesselator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./path-tesselator */ "./src/path-layer/path-tesselator.js");
/* harmony import */ var _path_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./path-layer-vertex.glsl */ "./src/path-layer/path-layer-vertex.glsl.js");
/* harmony import */ var _path_layer_vertex_64_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./path-layer-vertex-64.glsl */ "./src/path-layer/path-layer-vertex-64.glsl.js");
/* harmony import */ var _path_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./path-layer-fragment.glsl */ "./src/path-layer/path-layer-fragment.glsl.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.











const DEFAULT_COLOR = [0, 0, 0, 255];

const defaultProps = {
  widthUnits: 'meters',
  widthScale: {type: 'number', min: 0, value: 1}, // stroke width in meters
  widthMinPixels: {type: 'number', min: 0, value: 0}, //  min stroke width in pixels
  widthMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER}, // max stroke width in pixels
  rounded: false,
  miterLimit: {type: 'number', min: 0, value: 4},
  fp64: false,
  dashJustified: false,
  billboard: false,

  getPath: {type: 'accessor', value: object => object.path},
  getColor: {type: 'accessor', value: DEFAULT_COLOR},
  getWidth: {type: 'accessor', value: 1},
  getDashArray: {type: 'accessor', value: [0, 0]}
};

const ATTRIBUTE_TRANSITION = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};

class PathLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["Layer"] {
  getShaders() {
    return this.use64bitProjection()
      ? {vs: _path_layer_vertex_64_glsl__WEBPACK_IMPORTED_MODULE_4__["default"], fs: _path_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_5__["default"], modules: ['project64', 'picking']}
      : {vs: _path_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_3__["default"], fs: _path_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_5__["default"], modules: ['project32', 'picking']}; // 'project' module added by default.
  }

  initializeState() {
    const noAlloc = true;
    const attributeManager = this.getAttributeManager();
    /* eslint-disable max-len */
    attributeManager.addInstanced({
      instanceStartPositions: {
        size: 3,
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getPath',
        update: this.calculateStartPositions,
        noAlloc
      },
      instanceEndPositions: {
        size: 3,
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getPath',
        update: this.calculateEndPositions,
        noAlloc
      },
      instanceStartEndPositions64xyLow: {
        size: 4,
        update: this.calculateInstanceStartEndPositions64xyLow,
        noAlloc
      },
      instanceLeftPositions: {
        size: 3,
        accessor: 'getPath',
        update: this.calculateLeftPositions,
        noAlloc
      },
      instanceRightPositions: {
        size: 3,
        accessor: 'getPath',
        update: this.calculateRightPositions,
        noAlloc
      },
      instanceNeighborPositions64xyLow: {
        size: 4,
        update: this.calculateInstanceNeighborPositions64xyLow,
        noAlloc
      },
      instanceStrokeWidths: {
        size: 1,
        accessor: 'getWidth',
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: 1
      },
      instanceDashArrays: {size: 2, accessor: 'getDashArray'},
      instanceColors: {
        size: 4,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        accessor: 'getColor',
        transition: ATTRIBUTE_TRANSITION,
        defaultValue: DEFAULT_COLOR
      },
      instancePickingColors: {
        size: 3,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        accessor: (object, {index, target: value}) => this.encodePickingColor(index, value)
      }
    });
    /* eslint-enable max-len */

    this.setState({
      pathTesselator: new _path_tesselator__WEBPACK_IMPORTED_MODULE_2__["default"]({})
    });
  }

  updateState({oldProps, props, changeFlags}) {
    super.updateState({props, oldProps, changeFlags});

    const attributeManager = this.getAttributeManager();

    const geometryChanged =
      changeFlags.dataChanged ||
      props.fp64 !== oldProps.fp64 ||
      (changeFlags.updateTriggersChanged &&
        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath));

    if (geometryChanged) {
      const {pathTesselator} = this.state;
      pathTesselator.updateGeometry({
        data: props.data,
        getGeometry: props.getPath,
        positionFormat: props.positionFormat,
        fp64: this.use64bitPositions()
      });
      this.setState({
        numInstances: pathTesselator.instanceCount,
        bufferLayout: pathTesselator.bufferLayout
      });
      attributeManager.invalidateAll();
    }

    if (props.fp64 !== oldProps.fp64) {
      const {gl} = this.context;
      if (this.state.model) {
        this.state.model.delete();
      }
      this.setState({model: this._getModel(gl)});
      attributeManager.invalidateAll();
    }
  }

  draw({uniforms}) {
    const {viewport} = this.context;
    const {
      rounded,
      billboard,
      miterLimit,
      widthUnits,
      widthScale,
      widthMinPixels,
      widthMaxPixels,
      dashJustified
    } = this.props;

    const widthMultiplier = widthUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1;

    this.state.model
      .setUniforms(
        Object.assign({}, uniforms, {
          jointType: Number(rounded),
          billboard,
          alignMode: Number(dashJustified),
          widthScale: widthScale * widthMultiplier,
          miterLimit,
          widthMinPixels,
          widthMaxPixels
        })
      )
      .draw();
  }

  _getModel(gl) {
    /*
     *       _
     *        "-_ 1                   3                       5
     *     _     "o---------------------o-------------------_-o
     *       -   / ""--..__              '.             _.-' /
     *   _     "@- - - - - ""--..__- - - - x - - - -_.@'    /
     *    "-_  /                   ""--..__ '.  _,-` :     /
     *       "o----------------------------""-o'    :     /
     *      0,2                            4 / '.  :     /
     *                                      /   '.:     /
     *                                     /     :'.   /
     *                                    /     :  ', /
     *                                   /     :     o
     */

    const SEGMENT_INDICES = [
      // start corner
      0,
      2,
      1,
      // body
      1,
      2,
      4,
      1,
      4,
      3,
      // end corner
      3,
      4,
      5
    ];

    // [0] position on segment - 0: start, 1: end
    // [1] side of path - -1: left, 0: center, 1: right
    // [2] role - 0: offset point 1: joint point
    const SEGMENT_POSITIONS = [
      // bevel start corner
      0,
      0,
      1,
      // start inner corner
      0,
      -1,
      0,
      // start outer corner
      0,
      1,
      0,
      // end inner corner
      1,
      -1,
      0,
      // end outer corner
      1,
      1,
      0,
      // bevel end corner
      1,
      0,
      1
    ];

    return new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Model"](
      gl,
      Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Geometry"]({
          drawMode: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.TRIANGLES,
          attributes: {
            indices: new Uint16Array(SEGMENT_INDICES),
            positions: new Float32Array(SEGMENT_POSITIONS)
          }
        }),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      })
    );
  }

  calculateStartPositions(attribute) {
    const {pathTesselator} = this.state;

    attribute.bufferLayout = pathTesselator.bufferLayout;
    attribute.value = pathTesselator.get('startPositions');
  }

  calculateEndPositions(attribute) {
    const {pathTesselator} = this.state;

    attribute.bufferLayout = pathTesselator.bufferLayout;
    attribute.value = pathTesselator.get('endPositions');
  }

  calculateInstanceStartEndPositions64xyLow(attribute) {
    const isFP64 = this.use64bitPositions();
    attribute.constant = !isFP64;

    if (isFP64) {
      attribute.value = this.state.pathTesselator.get('startEndPositions64XyLow');
    } else {
      attribute.value = new Float32Array(4);
    }
  }

  calculateLeftPositions(attribute) {
    const {pathTesselator} = this.state;
    attribute.value = pathTesselator.get('leftPositions');
  }

  calculateRightPositions(attribute) {
    const {pathTesselator} = this.state;
    attribute.value = pathTesselator.get('rightPositions');
  }

  calculateInstanceNeighborPositions64xyLow(attribute) {
    const isFP64 = this.use64bitPositions();
    attribute.constant = !isFP64;

    if (isFP64) {
      attribute.value = this.state.pathTesselator.get('neighborPositions64XyLow');
    } else {
      attribute.value = new Float32Array(4);
    }
  }

  clearPickingColor(color) {
    const pickedPathIndex = this.decodePickingColor(color);
    const {bufferLayout} = this.state.pathTesselator;
    const numVertices = bufferLayout[pickedPathIndex];

    let startInstanceIndex = 0;
    for (let pathIndex = 0; pathIndex < pickedPathIndex; pathIndex++) {
      startInstanceIndex += bufferLayout[pathIndex];
    }

    const {instancePickingColors} = this.getAttributeManager().attributes;

    const {value} = instancePickingColors;
    const endInstanceIndex = startInstanceIndex + numVertices;
    value.fill(0, startInstanceIndex * 3, endInstanceIndex * 3);
    instancePickingColors.update({value});
  }
}

PathLayer.layerName = 'PathLayer';
PathLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/path-layer/path-tesselator.js":
/*!*******************************************!*\
  !*** ./src/path-layer/path-tesselator.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PathTesselator; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/core */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_core__WEBPACK_IMPORTED_MODULE_1__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

const {Tesselator} = _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["experimental"];

const {fp64LowPart} = _luma_gl_core__WEBPACK_IMPORTED_MODULE_1__["fp64"];

// This class is set up to allow querying one attribute at a time
// the way the AttributeManager expects it
class PathTesselator extends Tesselator {
  constructor({data, getGeometry, positionFormat, fp64}) {
    super({
      data,
      getGeometry,
      fp64,
      positionFormat,
      attributes: {
        startPositions: {size: 3},
        endPositions: {size: 3},
        leftPositions: {size: 3},
        rightPositions: {size: 3},
        startEndPositions64XyLow: {size: 4, fp64Only: true},
        neighborPositions64XyLow: {size: 4, fp64Only: true}
      }
    });
  }

  /* Getters */
  get(attributeName) {
    return this.attributes[attributeName];
  }

  /* Implement base Tesselator interface */
  getGeometrySize(path) {
    return Math.max(0, this.getPathLength(path) - 1);
  }

  /* eslint-disable max-statements, complexity */
  updateGeometryAttributes(path, context) {
    const {
      attributes: {
        startPositions,
        endPositions,
        leftPositions,
        rightPositions,
        startEndPositions64XyLow,
        neighborPositions64XyLow
      },
      fp64
    } = this;

    const numPoints = context.geometrySize + 1;
    if (numPoints < 2) {
      // ignore invalid path
      return;
    }
    const isPathClosed = this.isClosed(path);

    let startPoint = this.getPointOnPath(path, 0);
    let endPoint = this.getPointOnPath(path, 1);
    let prevPoint = isPathClosed ? this.getPointOnPath(path, numPoints - 2) : startPoint;
    let nextPoint;

    for (let i = context.vertexStart, ptIndex = 1; ptIndex < numPoints; i++, ptIndex++) {
      if (ptIndex + 1 < numPoints) {
        nextPoint = this.getPointOnPath(path, ptIndex + 1);
      } else {
        nextPoint = isPathClosed ? this.getPointOnPath(path, 1) : endPoint;
      }

      startPositions[i * 3] = startPoint[0];
      startPositions[i * 3 + 1] = startPoint[1];
      startPositions[i * 3 + 2] = startPoint[2] || 0;

      endPositions[i * 3] = endPoint[0];
      endPositions[i * 3 + 1] = endPoint[1];
      endPositions[i * 3 + 2] = endPoint[2] || 0;

      leftPositions[i * 3] = prevPoint[0];
      leftPositions[i * 3 + 1] = prevPoint[1];
      leftPositions[i * 3 + 2] = prevPoint[2] || 0;

      rightPositions[i * 3] = nextPoint[0];
      rightPositions[i * 3 + 1] = nextPoint[1];
      rightPositions[i * 3 + 2] = nextPoint[2] || 0;

      if (fp64) {
        startEndPositions64XyLow[i * 4] = fp64LowPart(startPoint[0]);
        startEndPositions64XyLow[i * 4 + 1] = fp64LowPart(startPoint[1]);
        startEndPositions64XyLow[i * 4 + 2] = fp64LowPart(endPoint[0]);
        startEndPositions64XyLow[i * 4 + 3] = fp64LowPart(endPoint[1]);

        neighborPositions64XyLow[i * 4] = fp64LowPart(prevPoint[0]);
        neighborPositions64XyLow[i * 4 + 1] = fp64LowPart(prevPoint[1]);
        neighborPositions64XyLow[i * 4 + 2] = fp64LowPart(nextPoint[0]);
        neighborPositions64XyLow[i * 4 + 3] = fp64LowPart(nextPoint[1]);
      }

      prevPoint = startPoint;
      startPoint = endPoint;
      endPoint = nextPoint;
    }
  }
  /* eslint-enable max-statements, complexity */

  /* Utilities */
  getPathLength(path) {
    if (Number.isFinite(path[0])) {
      // flat format
      return path.length / this.positionSize;
    }
    return path.length;
  }

  getPointOnPath(path, index) {
    if (Number.isFinite(path[0])) {
      // flat format
      const {positionSize} = this;
      // TODO - avoid creating new arrays when using binary
      return [
        path[index * positionSize],
        path[index * positionSize + 1],
        positionSize === 3 ? path[index * positionSize + 2] : 0
      ];
    }
    return path[index];
  }

  isClosed(path) {
    const numPoints = this.getPathLength(path);
    const firstPoint = this.getPointOnPath(path, 0);
    const lastPoint = this.getPointOnPath(path, numPoints - 1);
    return (
      firstPoint[0] === lastPoint[0] &&
      firstPoint[1] === lastPoint[1] &&
      firstPoint[2] === lastPoint[2]
    );
  }
}


/***/ }),

/***/ "./src/point-cloud-layer/point-cloud-layer-fragment.glsl.js":
/*!******************************************************************!*\
  !*** ./src/point-cloud-layer/point-cloud-layer-fragment.glsl.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME point-cloud-layer-fragment-shader

precision highp float;

varying vec4 vColor;
varying vec2 unitPosition;

void main(void) {

  float distToCenter = length(unitPosition);

  if (distToCenter > 1.0) {
    discard;
  }

  gl_FragColor = vColor;

  // use highlight color if this fragment belongs to the selected object.
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);

  // use picking color if rendering to picking FBO.
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
}
`);


/***/ }),

/***/ "./src/point-cloud-layer/point-cloud-layer-vertex.glsl.js":
/*!****************************************************************!*\
  !*** ./src/point-cloud-layer/point-cloud-layer-vertex.glsl.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME point-cloud-layer-vertex-shader

attribute vec3 positions;
attribute vec3 instanceNormals;
attribute vec4 instanceColors;
attribute vec3 instancePositions;
attribute vec2 instancePositions64xyLow;
attribute vec3 instancePickingColors;

uniform float opacity;
uniform float radiusPixels;

varying vec4 vColor;
varying vec2 unitPosition;

void main(void) {
  // position on the containing square in [-1, 1] space
  unitPosition = positions.xy;

  // Find the center of the point and add the current vertex
  vec4 position_commonspace;
  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, vec3(0.), position_commonspace);
  gl_Position.xy += project_pixel_size_to_clipspace(positions.xy * radiusPixels);

  // Apply lighting
  vec3 lightColor = lighting_getLightColor(instanceColors.rgb, project_uCameraPosition, position_commonspace.xyz, project_normal(instanceNormals));

  // Apply opacity to instance color, or return instance picking color
  vColor = vec4(lightColor, instanceColors.a * opacity) / 255.0;

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);
}
`);


/***/ }),

/***/ "./src/point-cloud-layer/point-cloud-layer.js":
/*!****************************************************!*\
  !*** ./src/point-cloud-layer/point-cloud-layer.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PointCloudLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _point_cloud_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./point-cloud-layer-vertex.glsl */ "./src/point-cloud-layer/point-cloud-layer-vertex.glsl.js");
/* harmony import */ var _point_cloud_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./point-cloud-layer-fragment.glsl */ "./src/point-cloud-layer/point-cloud-layer-fragment.glsl.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.




const {fp64LowPart} = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["fp64"];




const DEFAULT_COLOR = [0, 0, 0, 255];
const DEFAULT_NORMAL = [0, 0, 1];
const defaultMaterial = new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["PhongMaterial"]();

const defaultProps = {
  sizeUnits: 'pixels',
  pointSize: {type: 'number', min: 0, value: 10}, //  point radius in pixels
  fp64: false,

  getPosition: {type: 'accessor', value: x => x.position},
  getNormal: {type: 'accessor', value: DEFAULT_NORMAL},
  getColor: {type: 'accessor', value: DEFAULT_COLOR},

  material: defaultMaterial,

  // Depreated
  radiusPixels: {deprecatedFor: 'pointSize'}
};

class PointCloudLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["Layer"] {
  getShaders(id) {
    const projectModule = this.use64bitProjection() ? 'project64' : 'project32';
    return {vs: _point_cloud_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__["default"], fs: _point_cloud_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__["default"], modules: [projectModule, 'gouraud-lighting', 'picking']};
  }

  initializeState() {
    /* eslint-disable max-len */
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        transition: true,
        accessor: 'getPosition'
      },
      instancePositions64xyLow: {
        size: 2,
        accessor: 'getPosition',
        update: this.calculateInstancePositions64xyLow
      },
      instanceNormals: {
        size: 3,
        transition: true,
        accessor: 'getNormal',
        defaultValue: DEFAULT_NORMAL
      },
      instanceColors: {
        size: 4,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        transition: true,
        accessor: 'getColor',
        defaultValue: DEFAULT_COLOR
      }
    });
    /* eslint-enable max-len */
  }

  updateState({props, oldProps, changeFlags}) {
    super.updateState({props, oldProps, changeFlags});
    if (props.fp64 !== oldProps.fp64) {
      const {gl} = this.context;
      if (this.state.model) {
        this.state.model.delete();
      }
      this.setState({model: this._getModel(gl)});
      this.getAttributeManager().invalidateAll();
    }
  }

  draw({uniforms}) {
    const {viewport} = this.context;
    const {pointSize, sizeUnits} = this.props;

    const sizeMultiplier = sizeUnits === 'meters' ? viewport.distanceScales.pixelsPerMeter[2] : 1;

    this.state.model
      .setUniforms(
        Object.assign({}, uniforms, {
          radiusPixels: pointSize * sizeMultiplier
        })
      )
      .draw();
  }

  _getModel(gl) {
    // a triangle that minimally cover the unit circle
    const positions = [];
    for (let i = 0; i < 3; i++) {
      const angle = (i / 3) * Math.PI * 2;
      positions.push(Math.cos(angle) * 2, Math.sin(angle) * 2, 0);
    }

    return new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Model"](
      gl,
      Object.assign({}, this.getShaders(), {
        id: this.props.id,
        geometry: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Geometry"]({
          drawMode: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.TRIANGLES,
          attributes: {
            positions: new Float32Array(positions)
          }
        }),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      })
    );
  }

  calculateInstancePositions64xyLow(attribute, {startRow, endRow}) {
    const isFP64 = this.use64bitPositions();
    attribute.constant = !isFP64;

    if (!isFP64) {
      attribute.value = new Float32Array(2);
      return;
    }

    const {data, getPosition} = this.props;
    const {value, size} = attribute;
    let i = startRow * size;
    const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["createIterable"])(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      const position = getPosition(object, objectInfo);
      value[i++] = fp64LowPart(position[0]);
      value[i++] = fp64LowPart(position[1]);
    }
  }
}

PointCloudLayer.layerName = 'PointCloudLayer';
PointCloudLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/polygon-layer/polygon-layer.js":
/*!********************************************!*\
  !*** ./src/polygon-layer/polygon-layer.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonLayer; });
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/core */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _solid_polygon_layer_solid_polygon_layer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../solid-polygon-layer/solid-polygon-layer */ "./src/solid-polygon-layer/solid-polygon-layer.js");
/* harmony import */ var _path_layer_path_layer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../path-layer/path-layer */ "./src/path-layer/path-layer.js");
/* harmony import */ var _solid_polygon_layer_polygon__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../solid-polygon-layer/polygon */ "./src/solid-polygon-layer/polygon.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.







const defaultLineColor = [0, 0, 0, 255];
const defaultFillColor = [0, 0, 0, 255];
const defaultMaterial = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_0__["PhongMaterial"]();

const defaultProps = {
  stroked: true,
  filled: true,
  extruded: false,
  elevationScale: 1,
  wireframe: false,

  lineWidthUnits: 'meters',
  lineWidthScale: 1,
  lineWidthMinPixels: 0,
  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
  lineJointRounded: false,
  lineMiterLimit: 4,
  lineDashJustified: false,
  fp64: false,

  getPolygon: {type: 'accessor', value: f => f.polygon},
  // Polygon fill color
  getFillColor: {type: 'accessor', value: defaultFillColor},
  // Point, line and polygon outline color
  getLineColor: {type: 'accessor', value: defaultLineColor},
  // Line and polygon outline accessors
  getLineWidth: {type: 'accessor', value: 1},
  // Line dash array accessor
  getLineDashArray: {type: 'accessor', value: [0, 0]},
  // Polygon extrusion accessor
  getElevation: {type: 'accessor', value: 1000},

  // Optional material for 'lighting' shader module
  material: defaultMaterial
};

class PolygonLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__["CompositeLayer"] {
  initializeState() {
    this.state = {
      paths: []
    };
  }

  updateState({oldProps, props, changeFlags}) {
    const geometryChanged =
      changeFlags.dataChanged ||
      (changeFlags.updateTriggersChanged &&
        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon));

    if (geometryChanged) {
      this.state.paths = this._getPaths(props);
    }
  }

  getPickingInfo({info}) {
    return Object.assign(info, {
      // override object with picked data
      object: (info.object && info.object.object) || info.object
    });
  }

  _getPaths({data, getPolygon, positionFormat}) {
    const paths = [];
    const positionSize = positionFormat === 'XY' ? 2 : 3;

    const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_1__["createIterable"])(data);
    for (const object of iterable) {
      objectInfo.index++;
      const {positions, holeIndices} = _solid_polygon_layer_polygon__WEBPACK_IMPORTED_MODULE_4__["normalize"](
        getPolygon(object, objectInfo),
        positionSize
      );

      if (holeIndices) {
        // split the positions array into `holeIndices.length + 1` rings
        // holeIndices[-1] falls back to 0
        // holeIndices[holeIndices.length] falls back to positions.length
        for (let i = 0; i <= holeIndices.length; i++) {
          const path = positions.subarray(
            holeIndices[i - 1] || 0,
            holeIndices[i] || positions.length
          );
          paths.push({path, object});
        }
      } else {
        paths.push({path: positions, object});
      }
    }
    return paths;
  }

  _getAccessor(accessor) {
    if (typeof accessor === 'function') {
      return x => accessor(x.object);
    }
    return accessor;
  }

  /* eslint-disable complexity */
  renderLayers() {
    // Layer composition props
    const {data, stroked, filled, extruded, wireframe, elevationScale, transitions} = this.props;

    // Rendering props underlying layer
    const {
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels,
      lineJointRounded,
      lineMiterLimit,
      lineDashJustified,
      fp64
    } = this.props;

    // Accessor props for underlying layers
    const {
      getFillColor,
      getLineColor,
      getLineWidth,
      getLineDashArray,
      getElevation,
      getPolygon,
      updateTriggers,
      material
    } = this.props;

    const {paths} = this.state;

    const FillLayer = this.getSubLayerClass('fill', _solid_polygon_layer_solid_polygon_layer__WEBPACK_IMPORTED_MODULE_2__["default"]);
    const StrokeLayer = this.getSubLayerClass('stroke', _path_layer_path_layer__WEBPACK_IMPORTED_MODULE_3__["default"]);

    // Filled Polygon Layer
    const polygonLayer =
      this.shouldRenderSubLayer('fill', paths) &&
      new FillLayer(
        {
          extruded,
          elevationScale,

          fp64,
          filled,
          wireframe,

          getElevation,
          getFillColor,
          getLineColor,

          material,
          transitions
        },
        this.getSubLayerProps({
          id: 'fill',
          updateTriggers: {
            getPolygon: updateTriggers.getPolygon,
            getElevation: updateTriggers.getElevation,
            getFillColor: updateTriggers.getFillColor,
            getLineColor: updateTriggers.getLineColor
          }
        }),
        {
          data,
          getPolygon
        }
      );

    // Polygon line layer
    const polygonLineLayer =
      !extruded &&
      stroked &&
      this.shouldRenderSubLayer('stroke', paths) &&
      new StrokeLayer(
        {
          fp64,
          widthUnits: lineWidthUnits,
          widthScale: lineWidthScale,
          widthMinPixels: lineWidthMinPixels,
          widthMaxPixels: lineWidthMaxPixels,
          rounded: lineJointRounded,
          miterLimit: lineMiterLimit,
          dashJustified: lineDashJustified,

          transitions: transitions && {
            getWidth: transitions.getLineWidth,
            getColor: transitions.getLineColor,
            getPath: transitions.getPolygon
          },

          getColor: this._getAccessor(getLineColor),
          getWidth: this._getAccessor(getLineWidth),
          getDashArray: this._getAccessor(getLineDashArray)
        },
        this.getSubLayerProps({
          id: 'stroke',
          updateTriggers: {
            getWidth: updateTriggers.getLineWidth,
            getColor: updateTriggers.getLineColor,
            getDashArray: updateTriggers.getLineDashArray
          }
        }),
        {
          data: paths,
          getPath: x => x.path
        }
      );

    return [
      // If not extruded: flat fill layer is drawn below outlines
      !extruded && polygonLayer,
      polygonLineLayer,
      // If extruded: draw fill layer last for correct blending behavior
      extruded && polygonLayer
    ];
  }
  /* eslint-enable complexity */
}

PolygonLayer.layerName = 'PolygonLayer';
PolygonLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/scatterplot-layer/scatterplot-layer-fragment.glsl.js":
/*!******************************************************************!*\
  !*** ./src/scatterplot-layer/scatterplot-layer-fragment.glsl.js ***!
  \******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME scatterplot-layer-fragment-shader

precision highp float;

uniform bool filled;

varying vec4 vFillColor;
varying vec4 vLineColor;
varying vec2 unitPosition;
varying float innerUnitRadius;

void main(void) {

  float distToCenter = length(unitPosition);

  if (distToCenter > 1.0) {
    discard;
  } 
  if (distToCenter > innerUnitRadius) {
    gl_FragColor = vLineColor;
  } else if (filled) {
    gl_FragColor = vFillColor;
  } else {
    discard;
  }

  // use highlight color if this fragment belongs to the selected object.
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);

  // use picking color if rendering to picking FBO.
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
}
`);


/***/ }),

/***/ "./src/scatterplot-layer/scatterplot-layer-vertex.glsl.js":
/*!****************************************************************!*\
  !*** ./src/scatterplot-layer/scatterplot-layer-vertex.glsl.js ***!
  \****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME scatterplot-layer-vertex-shader

attribute vec3 positions;

attribute vec3 instancePositions;
attribute vec2 instancePositions64xyLow;
attribute float instanceRadius;
attribute float instanceLineWidths;
attribute vec4 instanceFillColors;
attribute vec4 instanceLineColors;
attribute vec3 instancePickingColors;

uniform float opacity;
uniform float radiusScale;
uniform float radiusMinPixels;
uniform float radiusMaxPixels;
uniform float lineWidthScale;
uniform float lineWidthMinPixels;
uniform float lineWidthMaxPixels;
uniform float stroked;
uniform bool filled;

varying vec4 vFillColor;
varying vec4 vLineColor;
varying vec2 unitPosition;
varying float innerUnitRadius;

void main(void) {
  // Multiply out radius and clamp to limits
  float outerRadiusPixels = clamp(
    project_size_to_pixel(radiusScale * instanceRadius),
    radiusMinPixels, radiusMaxPixels
  );
  
  // Multiply out line width and clamp to limits
  float lineWidthPixels = clamp(
    project_size_to_pixel(lineWidthScale * instanceLineWidths),
    lineWidthMinPixels, lineWidthMaxPixels
  );

  // outer radius needs to offset by half stroke width
  outerRadiusPixels += stroked * lineWidthPixels / 2.0;

  // position on the containing square in [-1, 1] space
  unitPosition = positions.xy;

  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;
  
  vec3 offset = positions * project_pixel_size(outerRadiusPixels);
  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, offset);

  // Apply opacity to instance color, or return instance picking color
  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity) / 255.;
  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity) / 255.;
  
  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(instancePickingColors);
}
`);


/***/ }),

/***/ "./src/scatterplot-layer/scatterplot-layer.js":
/*!****************************************************!*\
  !*** ./src/scatterplot-layer/scatterplot-layer.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ScatterplotLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _scatterplot_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scatterplot-layer-vertex.glsl */ "./src/scatterplot-layer/scatterplot-layer-vertex.glsl.js");
/* harmony import */ var _scatterplot_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scatterplot-layer-fragment.glsl */ "./src/scatterplot-layer/scatterplot-layer-fragment.glsl.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.




const {fp64LowPart} = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["fp64"];




const DEFAULT_COLOR = [0, 0, 0, 255];

const defaultProps = {
  radiusScale: {type: 'number', min: 0, value: 1},
  radiusMinPixels: {type: 'number', min: 0, value: 0}, //  min point radius in pixels
  radiusMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER}, // max point radius in pixels

  lineWidthUnits: 'meters',
  lineWidthScale: {type: 'number', min: 0, value: 1},
  lineWidthMinPixels: {type: 'number', min: 0, value: 0},
  lineWidthMaxPixels: {type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER},

  stroked: false,
  fp64: false,
  filled: true,

  getPosition: {type: 'accessor', value: x => x.position},
  getRadius: {type: 'accessor', value: 1},
  getFillColor: {type: 'accessor', value: DEFAULT_COLOR},
  getLineColor: {type: 'accessor', value: DEFAULT_COLOR},
  getLineWidth: {type: 'accessor', value: 1},

  // deprecated
  strokeWidth: {deprecatedFor: 'getLineWidth'},
  outline: {deprecatedFor: 'stroked'},
  getColor: {deprecatedFor: ['getFillColor', 'getLineColor']}
};

class ScatterplotLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["Layer"] {
  getShaders(id) {
    const projectModule = this.use64bitProjection() ? 'project64' : 'project32';
    return {vs: _scatterplot_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__["default"], fs: _scatterplot_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__["default"], modules: [projectModule, 'picking']};
  }

  initializeState() {
    this.getAttributeManager().addInstanced({
      instancePositions: {
        size: 3,
        transition: true,
        accessor: 'getPosition'
      },
      instancePositions64xyLow: {
        size: 2,
        accessor: 'getPosition',
        update: this.calculateInstancePositions64xyLow
      },
      instanceRadius: {
        size: 1,
        transition: true,
        accessor: 'getRadius',
        defaultValue: 1
      },
      instanceFillColors: {
        size: 4,
        transition: true,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        accessor: 'getFillColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineColors: {
        size: 4,
        transition: true,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        accessor: 'getLineColor',
        defaultValue: [0, 0, 0, 255]
      },
      instanceLineWidths: {
        size: 1,
        transition: true,
        accessor: 'getLineWidth',
        defaultValue: 1
      }
    });
  }

  updateState({props, oldProps, changeFlags}) {
    super.updateState({props, oldProps, changeFlags});
    if (props.fp64 !== oldProps.fp64) {
      const {gl} = this.context;
      if (this.state.model) {
        this.state.model.delete();
      }
      this.setState({model: this._getModel(gl)});
      this.getAttributeManager().invalidateAll();
    }
  }

  draw({uniforms}) {
    const {viewport} = this.context;
    const {
      radiusScale,
      radiusMinPixels,
      radiusMaxPixels,
      stroked,
      filled,
      lineWidthUnits,
      lineWidthScale,
      lineWidthMinPixels,
      lineWidthMaxPixels
    } = this.props;

    const widthMultiplier =
      lineWidthUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1;

    this.state.model
      .setUniforms(
        Object.assign({}, uniforms, {
          stroked: stroked ? 1 : 0,
          filled,
          radiusScale,
          radiusMinPixels,
          radiusMaxPixels,
          lineWidthScale: lineWidthScale * widthMultiplier,
          lineWidthMinPixels,
          lineWidthMaxPixels
        })
      )
      .draw();
  }

  _getModel(gl) {
    // a square that minimally cover the unit circle
    const positions = [-1, -1, 0, -1, 1, 0, 1, 1, 0, 1, -1, 0];

    return new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Model"](
      gl,
      Object.assign(this.getShaders(), {
        id: this.props.id,
        geometry: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Geometry"]({
          drawMode: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.TRIANGLE_FAN,
          vertexCount: 4,
          attributes: {
            positions: {size: 3, value: new Float32Array(positions)}
          }
        }),
        isInstanced: true,
        shaderCache: this.context.shaderCache
      })
    );
  }

  calculateInstancePositions64xyLow(attribute, {startRow, endRow}) {
    const isFP64 = this.use64bitPositions();
    attribute.constant = !isFP64;

    if (!isFP64) {
      attribute.value = new Float32Array(2);
      return;
    }

    const {data, getPosition} = this.props;
    const {value, size} = attribute;
    let i = startRow * size;
    const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["createIterable"])(data, startRow, endRow);
    for (const object of iterable) {
      objectInfo.index++;
      const position = getPosition(object, objectInfo);
      value[i++] = fp64LowPart(position[0]);
      value[i++] = fp64LowPart(position[1]);
    }
  }
}

ScatterplotLayer.layerName = 'ScatterplotLayer';
ScatterplotLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/solid-polygon-layer/polygon-tesselator.js":
/*!*******************************************************!*\
  !*** ./src/solid-polygon-layer/polygon-tesselator.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PolygonTesselator; });
/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polygon */ "./src/solid-polygon-layer/polygon.js");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/core */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_core__WEBPACK_IMPORTED_MODULE_2__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Handles tesselation of polygons with holes
// - 2D surfaces
// - 2D outlines
// - 3D surfaces (top and sides only)
// - 3D wireframes (not yet)


const {Tesselator} = _deck_gl_core__WEBPACK_IMPORTED_MODULE_1__["experimental"];

const {fp64LowPart} = _luma_gl_core__WEBPACK_IMPORTED_MODULE_2__["fp64"];

// This class is set up to allow querying one attribute at a time
// the way the AttributeManager expects it
class PolygonTesselator extends Tesselator {
  constructor({data, getGeometry, fp64, positionFormat, IndexType = Uint32Array}) {
    super({
      data,
      getGeometry,
      fp64,
      positionFormat,
      attributes: {
        positions: {size: 3},
        positions64xyLow: {size: 2, fp64Only: true},
        vertexValid: {type: Uint8ClampedArray, size: 1},
        indices: {type: IndexType, size: 1}
      }
    });
  }

  /* Getters */
  get(attributeName) {
    if (attributeName === 'indices') {
      return this.attributes.indices.subarray(0, this.vertexCount);
    }

    return this.attributes[attributeName];
  }

  /* Implement base Tesselator interface */
  getGeometrySize(polygon) {
    return _polygon__WEBPACK_IMPORTED_MODULE_0__["getVertexCount"](polygon, this.positionSize);
  }

  updateGeometryAttributes(polygon, context) {
    polygon = _polygon__WEBPACK_IMPORTED_MODULE_0__["normalize"](polygon, this.positionSize, context.geometrySize);

    this._updateIndices(polygon, context);
    this._updatePositions(polygon, context);
  }

  // Flatten the indices array
  _updateIndices(polygon, {geometryIndex, vertexStart: offset, indexStart}) {
    const {attributes, indexLayout, typedArrayManager} = this;

    let target = attributes.indices;
    let currentLength = target.length;
    let i = indexStart;

    // 1. get triangulated indices for the internal areas
    const indices = _polygon__WEBPACK_IMPORTED_MODULE_0__["getSurfaceIndices"](polygon, this.positionSize);

    // make sure the buffer is large enough
    if (currentLength < i + indices.length) {
      currentLength = (i + indices.length) * 2;
      target = typedArrayManager.allocate(target, currentLength, {
        type: target.constructor,
        size: 1,
        copy: true
      });
    }

    // 2. offset each index by the number of indices in previous polygons
    for (let j = 0; j < indices.length; j++) {
      target[i++] = indices[j] + offset;
    }

    indexLayout[geometryIndex] = indices.length;
    attributes.indices = target;
  }

  // Flatten out all the vertices of all the sub subPolygons
  _updatePositions(polygon, {vertexStart, geometrySize}) {
    const {
      attributes: {positions, positions64xyLow, vertexValid},
      fp64,
      positionSize
    } = this;

    let i = vertexStart;
    const {positions: polygonPositions, holeIndices} = polygon;

    for (let j = 0; j < geometrySize; j++) {
      const x = polygonPositions[j * positionSize];
      const y = polygonPositions[j * positionSize + 1];
      const z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;

      positions[i * 3] = x;
      positions[i * 3 + 1] = y;
      positions[i * 3 + 2] = z;
      if (fp64) {
        positions64xyLow[i * 2] = fp64LowPart(x);
        positions64xyLow[i * 2 + 1] = fp64LowPart(y);
      }
      vertexValid[i] = 1;
      i++;
    }

    /* We are reusing the some buffer for `nextPositions` by offseting one vertex
     * to the left. As a result,
     * the last vertex of each ring overlaps with the first vertex of the next ring.
     * `vertexValid` is used to mark the end of each ring so we don't draw these
     * segments:
      positions      A0 A1 A2 A3 A4 B0 B1 B2 C0 ...
      nextPositions  A1 A2 A3 A4 B0 B1 B2 C0 C1 ...
      vertexValid    1  1  1  1  0  1  1  0  1 ...
     */
    if (holeIndices) {
      for (let j = 0; j < holeIndices.length; j++) {
        vertexValid[vertexStart + holeIndices[j] / positionSize - 1] = 0;
      }
    }
    vertexValid[vertexStart + geometrySize - 1] = 0;
  }
}


/***/ }),

/***/ "./src/solid-polygon-layer/polygon.js":
/*!********************************************!*\
  !*** ./src/solid-polygon-layer/polygon.js ***!
  \********************************************/
/*! exports provided: getVertexCount, normalize, getSurfaceIndices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVertexCount", function() { return getVertexCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSurfaceIndices", function() { return getSurfaceIndices; });
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! earcut */ "../../node_modules/earcut/src/earcut.js");
/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(earcut__WEBPACK_IMPORTED_MODULE_0__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* eslint-disable max-params */


// 4 data formats are supported:
// Simple Polygon: an array of points
// Complex Polygon: an array of array of points (array of rings)
//   with the first ring representing the outer hull and other rings representing holes
// Simple Flat: an array of numbers (flattened "simple polygon")
// Complex Flat: {position: array<number>, holeIndices: array<number>}
//   (flattened "complex polygon")

/**
 * Ensure a polygon is valid format
 * @param {Array|Object} polygon
 */
function validate(polygon) {
  polygon = (polygon && polygon.positions) || polygon;
  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {
    throw new Error('invalid polygon');
  }
}

/**
 * Check if a polygon is simple or complex
 * @param {Array} polygon - either a complex or simple polygon
 * @return {Boolean} - true if the polygon is a simple polygon (i.e. not an array of polygons)
 */
function isSimple(polygon) {
  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);
}

/**
 * Check if a simple polygon is a closed ring
 * @param {Array} simplePolygon - array of points
 * @return {Boolean} - true if the simple polygon is a closed ring
 */
function isNestedRingClosed(simplePolygon) {
  // check if first and last vertex are the same
  const p0 = simplePolygon[0];
  const p1 = simplePolygon[simplePolygon.length - 1];

  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];
}

/**
 * Check if a simple flat array is a closed ring
 * @param {Array} positions - array of numbers
 * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)
 * @param {Number} startIndex - start index of the path in the positions array
 * @param {Number} endIndex - end index of the path in the positions array
 * @return {Boolean} - true if the simple flat array is a closed ring
 */
function isFlatRingClosed(positions, size, startIndex, endIndex) {
  for (let i = 0; i < size; i++) {
    if (positions[startIndex + i] !== positions[endIndex - size + i]) {
      return false;
    }
  }
  return true;
}

/**
 * Copy a simple polygon coordinates into a flat array, closes the ring if needed.
 * @param {Float64Array} target - destination
 * @param {Number} targetStartIndex - index in the destination to start copying into
 * @param {Array} simplePolygon - array of points
 * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)
 * @returns {Number} - the index of the write head in the destination
 */
function copyNestedRing(target, targetStartIndex, simplePolygon, size) {
  let targetIndex = targetStartIndex;
  const len = simplePolygon.length;
  for (let i = 0; i < len; i++) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[i][j] || 0;
    }
  }

  if (!isNestedRingClosed(simplePolygon)) {
    for (let j = 0; j < size; j++) {
      target[targetIndex++] = simplePolygon[0][j] || 0;
    }
  }
  return targetIndex;
}

/**
 * Copy a simple flat array into another flat array, closes the ring if needed.
 * @param {Float64Array} target - destination
 * @param {Number} targetStartIndex - index in the destination to start copying into
 * @param {Array} positions - array of numbers
 * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)
 * @param {Number} [srcStartIndex] - start index of the path in the positions array
 * @param {Number} [srcEndIndex] - end index of the path in the positions array
 * @returns {Number} - the index of the write head in the destination
 */
function copyFlatRing(target, targetStartIndex, positions, size, srcStartIndex = 0, srcEndIndex) {
  srcEndIndex = srcEndIndex || positions.length;
  const srcLength = srcEndIndex - srcStartIndex;
  if (srcLength <= 0) {
    return targetStartIndex;
  }
  let targetIndex = targetStartIndex;

  for (let i = 0; i < srcLength; i++) {
    target[targetIndex++] = positions[srcStartIndex + i];
  }

  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {
    for (let i = 0; i < size; i++) {
      target[targetIndex++] = positions[srcStartIndex + i];
    }
  }
  return targetIndex;
}

/**
 * Counts the number of vertices in a simple polygon, closes the polygon if needed.
 * @param {Array} simplePolygon - array of points
 * @returns {Number} vertex count
 */
function getNestedVertexCount(simplePolygon) {
  return (isNestedRingClosed(simplePolygon) ? 0 : 1) + simplePolygon.length;
}

/**
 * Counts the number of vertices in a simple flat array, closes the polygon if needed.
 * @param {Array} positions - array of numbers
 * @param {Number} size - size of a position, 2 (xy) or 3 (xyz)
 * @param {Number} [startIndex] - start index of the path in the positions array
 * @param {Number} [endIndex] - end index of the path in the positions array
 * @returns {Number} vertex count
 */
function getFlatVertexCount(positions, size, startIndex = 0, endIndex) {
  endIndex = endIndex || positions.length;
  if (startIndex >= endIndex) {
    return 0;
  }
  return (
    (isFlatRingClosed(positions, size, startIndex, endIndex) ? 0 : 1) +
    (endIndex - startIndex) / size
  );
}

/**
 * Counts the number of vertices in any polygon representation.
 * @param {Array|Object} polygon
 * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)
 * @returns {Number} vertex count
 */
function getVertexCount(polygon, positionSize) {
  validate(polygon);

  if (polygon.positions) {
    // complex flat
    const {positions, holeIndices} = polygon;

    if (holeIndices) {
      let vertexCount = 0;
      // split the positions array into `holeIndices.length + 1` rings
      // holeIndices[-1] falls back to 0
      // holeIndices[holeIndices.length] falls back to positions.length
      for (let i = 0; i <= holeIndices.length; i++) {
        vertexCount += getFlatVertexCount(
          polygon.positions,
          positionSize,
          holeIndices[i - 1],
          holeIndices[i]
        );
      }
      return vertexCount;
    }
    polygon = positions;
  }
  if (Number.isFinite(polygon[0])) {
    // simple flat
    return getFlatVertexCount(polygon, positionSize);
  }
  if (!isSimple(polygon)) {
    // complex polygon
    let vertexCount = 0;
    for (const simplePolygon of polygon) {
      vertexCount += getNestedVertexCount(simplePolygon);
    }
    return vertexCount;
  }
  // simple polygon
  return getNestedVertexCount(polygon);
}

/**
 * Normalize any polygon representation into the "complex flat" format
 * @param {Array|Object} polygon
 * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)
 * @param {Number} [vertexCount] - pre-computed vertex count in the polygon.
 *   If provided, will skip counting.
 * @return {Object} - {positions: <Float64Array>, holeIndices: <Array|null>}
 */
/* eslint-disable max-statements */
function normalize(polygon, positionSize, vertexCount) {
  validate(polygon);

  vertexCount = vertexCount || getVertexCount(polygon, positionSize);

  const positions = new Float64Array(vertexCount * positionSize);
  const holeIndices = [];

  if (polygon.positions) {
    // complex flat
    const {positions: srcPositions, holeIndices: srcHoleIndices} = polygon;

    if (srcHoleIndices) {
      let targetIndex = 0;
      // split the positions array into `holeIndices.length + 1` rings
      // holeIndices[-1] falls back to 0
      // holeIndices[holeIndices.length] falls back to positions.length
      for (let i = 0; i <= srcHoleIndices.length; i++) {
        targetIndex = copyFlatRing(
          positions,
          targetIndex,
          srcPositions,
          positionSize,
          srcHoleIndices[i - 1],
          srcHoleIndices[i]
        );
        holeIndices.push(targetIndex);
      }
      // The last one is not a starting index of a hole, remove
      holeIndices.pop();

      return {positions, holeIndices};
    }
    polygon = srcPositions;
  }
  if (Number.isFinite(polygon[0])) {
    // simple flat
    copyFlatRing(positions, 0, polygon, positionSize);
    return {positions, holeIndices: null};
  }
  if (!isSimple(polygon)) {
    // complex polygon
    let targetIndex = 0;

    for (const simplePolygon of polygon) {
      targetIndex = copyNestedRing(positions, targetIndex, simplePolygon, positionSize);
      holeIndices.push(targetIndex);
    }
    // The last one is not a starting index of a hole, remove
    holeIndices.pop();
    // last index points to the end of the array, remove it
    return {positions, holeIndices};
  }
  // simple polygon
  copyNestedRing(positions, 0, polygon, positionSize);
  return {positions, holeIndices: null};
}
/* eslint-enable max-statements */

/*
 * Get vertex indices for drawing polygon mesh
 * @param {Object} normalizedPolygon - {positions, holeIndices}
 * @param {Number} positionSize - size of a position, 2 (xy) or 3 (xyz)
 * @returns {Array} array of indices
 */
function getSurfaceIndices(normalizedPolygon, positionSize) {
  let holeIndices = null;

  if (normalizedPolygon.holeIndices) {
    holeIndices = normalizedPolygon.holeIndices.map(positionIndex => positionIndex / positionSize);
  }
  // Let earcut triangulate the polygon
  return earcut__WEBPACK_IMPORTED_MODULE_0___default()(normalizedPolygon.positions, holeIndices, positionSize);
}


/***/ }),

/***/ "./src/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js":
/*!**********************************************************************!*\
  !*** ./src/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js ***!
  \**********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME solid-polygon-layer-fragment-shader

precision highp float;

varying vec4 vColor;
varying float isValid;

void main(void) {
  if (isValid < 0.5) {
    discard;
  }

  gl_FragColor = vColor;

  // use highlight color if this fragment belongs to the selected object.
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);

  // use picking color if rendering to picking FBO.
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
}
`);


/***/ }),

/***/ "./src/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js":
/*!*************************************************************************!*\
  !*** ./src/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\

attribute vec2 vertexPositions;
attribute float vertexValid;

uniform bool extruded;
uniform bool isWireframe;
uniform float elevationScale;
uniform float opacity;

varying vec4 vColor;
varying float isValid;

struct PolygonProps {
  vec4 fillColors;
  vec4 lineColors;
  vec3 positions;
  vec3 nextPositions;
  vec3 pickingColors;
  vec2 positions64xyLow;
  vec2 nextPositions64xyLow;
  float elevations;
};

vec3 project_offset_normal(vec3 vector) {
  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNG_LAT ||
    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS ||
    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_AUTO_OFFSET) {
    // normals generated by the polygon tesselator are in lnglat offsets instead of meters
    return normalize(vector * project_uCommonUnitsPerWorldUnit);
  }
  return project_normal(vector);
}

void calculatePosition(PolygonProps props) {
  vec3 pos;
  vec2 pos64xyLow;
  vec3 normal;
  vec4 colors = isWireframe ? props.lineColors : props.fillColors;

#ifdef IS_SIDE_VERTEX
  pos = mix(props.positions, props.nextPositions, vertexPositions.x);
  pos64xyLow = mix(props.positions64xyLow, props.nextPositions64xyLow, vertexPositions.x);
  isValid = vertexValid;
#else
  pos = props.positions;
  pos64xyLow = props.positions64xyLow;
  isValid = 1.0;
#endif

  if (extruded) {
    pos.z += props.elevations * vertexPositions.y * elevationScale;
  }

  vec4 position_commonspace;
  gl_Position = project_position_to_clipspace(pos, pos64xyLow, vec3(0.), position_commonspace);

  if (extruded) {
#ifdef IS_SIDE_VERTEX
    normal = vec3(props.positions.y - props.nextPositions.y, props.nextPositions.x - props.positions.x, 0.0);
    normal = project_offset_normal(normal);
#else
    normal = vec3(0.0, 0.0, 1.0);
#endif

    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, position_commonspace.xyz, normal);
    vColor = vec4(lightColor, colors.a * opacity) / 255.0;
  } else {
    vColor = vec4(colors.rgb, colors.a * opacity) / 255.0;
  }

  // Set color to be rendered to picking fbo (also used to check for selection highlight).
  picking_setPickingColor(props.pickingColors);
}
`);


/***/ }),

/***/ "./src/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js":
/*!*************************************************************************!*\
  !*** ./src/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _solid_polygon_layer_vertex_main_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./solid-polygon-layer-vertex-main.glsl */ "./src/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME solid-polygon-layer-vertex-shader-side
#define IS_SIDE_VERTEX


attribute vec3 instancePositions;
attribute vec2 instancePositions64xyLow;
attribute vec3 nextPositions;
attribute vec2 nextPositions64xyLow;
attribute float instanceElevations;
attribute vec4 instanceFillColors;
attribute vec4 instanceLineColors;
attribute vec3 instancePickingColors;

${_solid_polygon_layer_vertex_main_glsl__WEBPACK_IMPORTED_MODULE_0__["default"]}

void main(void) {
  PolygonProps props;

  props.positions = instancePositions;
  props.positions64xyLow = instancePositions64xyLow;
  props.elevations = instanceElevations;
  props.fillColors = instanceFillColors;
  props.lineColors = instanceLineColors;
  props.pickingColors = instancePickingColors;
  props.nextPositions = nextPositions;
  props.nextPositions64xyLow = nextPositions64xyLow;

  calculatePosition(props);
}
`);


/***/ }),

/***/ "./src/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js":
/*!************************************************************************!*\
  !*** ./src/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _solid_polygon_layer_vertex_main_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./solid-polygon-layer-vertex-main.glsl */ "./src/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.



/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME solid-polygon-layer-vertex-shader

attribute vec3 positions;
attribute vec2 positions64xyLow;
attribute float elevations;
attribute vec4 fillColors;
attribute vec4 lineColors;
attribute vec3 pickingColors;

${_solid_polygon_layer_vertex_main_glsl__WEBPACK_IMPORTED_MODULE_0__["default"]}

void main(void) {
  PolygonProps props;

  props.positions = positions;
  props.positions64xyLow = positions64xyLow;
  props.elevations = elevations;
  props.fillColors = fillColors;
  props.lineColors = lineColors;
  props.pickingColors = pickingColors;

  calculatePosition(props);
}
`);


/***/ }),

/***/ "./src/solid-polygon-layer/solid-polygon-layer.js":
/*!********************************************************!*\
  !*** ./src/solid-polygon-layer/solid-polygon-layer.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SolidPolygonLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/constants */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _polygon_tesselator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polygon-tesselator */ "./src/solid-polygon-layer/polygon-tesselator.js");
/* harmony import */ var _solid_polygon_layer_vertex_top_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./solid-polygon-layer-vertex-top.glsl */ "./src/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js");
/* harmony import */ var _solid_polygon_layer_vertex_side_glsl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./solid-polygon-layer-vertex-side.glsl */ "./src/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js");
/* harmony import */ var _solid_polygon_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./solid-polygon-layer-fragment.glsl */ "./src/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.





// Polygon geometry generation is managed by the polygon tesselator






const DEFAULT_COLOR = [0, 0, 0, 255];
const defaultMaterial = new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["PhongMaterial"]();

const defaultProps = {
  filled: true,
  // Whether to extrude
  extruded: false,
  // Whether to draw a GL.LINES wireframe of the polygon
  wireframe: false,
  fp64: false,

  // elevation multiplier
  elevationScale: {type: 'number', min: 0, value: 1},

  // Accessor for polygon geometry
  getPolygon: {type: 'accessor', value: f => f.polygon},
  // Accessor for extrusion height
  getElevation: {type: 'accessor', value: 1000},
  // Accessor for colors
  getFillColor: {type: 'accessor', value: DEFAULT_COLOR},
  getLineColor: {type: 'accessor', value: DEFAULT_COLOR},

  // Optional settings for 'lighting' shader module
  material: defaultMaterial
};

const ATTRIBUTE_TRANSITION = {
  enter: (value, chunk) => {
    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;
  }
};

class SolidPolygonLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["Layer"] {
  getShaders(vs) {
    const projectModule = this.use64bitProjection() ? 'project64' : 'project32';
    return {
      vs,
      fs: _solid_polygon_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_5__["default"],
      defines: {},
      modules: [projectModule, 'gouraud-lighting', 'picking']
    };
  }

  initializeState() {
    const {gl} = this.context;
    this.setState({
      numInstances: 0,
      polygonTesselator: new _polygon_tesselator__WEBPACK_IMPORTED_MODULE_2__["default"]({
        IndexType: !gl || Object(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["hasFeature"])(gl, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["FEATURES"].ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array
      })
    });

    const attributeManager = this.getAttributeManager();
    const noAlloc = true;

    attributeManager.remove(['instancePickingColors']);

    /* eslint-disable max-len */
    attributeManager.add({
      indices: {size: 1, isIndexed: true, update: this.calculateIndices, noAlloc},
      positions: {
        size: 3,
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getPolygon',
        update: this.calculatePositions,
        noAlloc,
        shaderAttributes: {
          positions: {
            offset: 0,
            divisor: 0
          },
          instancePositions: {
            offset: 0,
            divisor: 1
          },
          nextPositions: {
            offset: 12,
            divisor: 1
          }
        }
      },
      positions64xyLow: {
        size: 2,
        update: this.calculatePositionsLow,
        noAlloc,
        shaderAttributes: {
          positions64xyLow: {
            offset: 0,
            divisor: 0
          },
          instancePositions64xyLow: {
            offset: 0,
            divisor: 1
          },
          nextPositions64xyLow: {
            offset: 8,
            divisor: 1
          }
        }
      },
      vertexValid: {
        size: 1,
        divisor: 1,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        update: this.calculateVertexValid,
        noAlloc
      },
      elevations: {
        size: 1,
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getElevation',
        shaderAttributes: {
          elevations: {
            divisor: 0
          },
          instanceElevations: {
            divisor: 1
          }
        }
      },
      fillColors: {
        alias: 'colors',
        size: 4,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getFillColor',
        defaultValue: DEFAULT_COLOR,
        shaderAttributes: {
          fillColors: {
            divisor: 0
          },
          instanceFillColors: {
            divisor: 1
          }
        }
      },
      lineColors: {
        alias: 'colors',
        size: 4,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        transition: ATTRIBUTE_TRANSITION,
        accessor: 'getLineColor',
        defaultValue: DEFAULT_COLOR,
        shaderAttributes: {
          lineColors: {
            divisor: 0
          },
          instanceLineColors: {
            divisor: 1
          }
        }
      },
      pickingColors: {
        size: 3,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.UNSIGNED_BYTE,
        accessor: (object, {index, target: value}) => this.encodePickingColor(index, value),
        shaderAttributes: {
          pickingColors: {
            divisor: 0
          },
          instancePickingColors: {
            divisor: 1
          }
        }
      }
    });
    /* eslint-enable max-len */
  }

  draw({uniforms}) {
    const {extruded, filled, wireframe, elevationScale} = this.props;
    const {topModel, sideModel, polygonTesselator} = this.state;

    const renderUniforms = Object.assign({}, uniforms, {
      extruded: Boolean(extruded),
      elevationScale
    });

    // Note: the order is important
    if (sideModel) {
      sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);
      sideModel.setUniforms(renderUniforms);
      if (wireframe) {
        sideModel.setDrawMode(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.LINE_STRIP);
        sideModel.setUniforms({isWireframe: true}).draw();
      }
      if (filled) {
        sideModel.setDrawMode(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.TRIANGLE_FAN);
        sideModel.setUniforms({isWireframe: false}).draw();
      }
    }

    if (topModel) {
      topModel.setVertexCount(polygonTesselator.get('indices').length);
      topModel.setUniforms(renderUniforms).draw();
    }
  }

  updateState(updateParams) {
    super.updateState(updateParams);

    this.updateGeometry(updateParams);

    const {props, oldProps} = updateParams;
    const attributeManager = this.getAttributeManager();

    const regenerateModels =
      props.fp64 !== oldProps.fp64 ||
      props.filled !== oldProps.filled ||
      props.extruded !== oldProps.extruded;

    if (regenerateModels) {
      if (this.state.models) {
        this.state.models.forEach(model => model.delete());
      }

      this.setState(this._getModels(this.context.gl));
      attributeManager.invalidateAll();
    }
  }

  updateGeometry({props, oldProps, changeFlags}) {
    const geometryConfigChanged =
      changeFlags.dataChanged ||
      props.fp64 !== oldProps.fp64 ||
      (changeFlags.updateTriggersChanged &&
        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon));

    // When the geometry config  or the data is changed,
    // tessellator needs to be invoked
    if (geometryConfigChanged) {
      const {polygonTesselator} = this.state;
      polygonTesselator.updateGeometry({
        data: props.data,
        getGeometry: props.getPolygon,
        positionFormat: props.positionFormat,
        fp64: this.use64bitPositions()
      });

      this.setState({
        numInstances: polygonTesselator.instanceCount,
        bufferLayout: polygonTesselator.bufferLayout
      });

      this.getAttributeManager().invalidateAll();
    }
  }

  _getModels(gl) {
    const {id, filled, extruded} = this.props;

    let topModel;
    let sideModel;

    if (filled) {
      const shaders = this.getShaders(_solid_polygon_layer_vertex_top_glsl__WEBPACK_IMPORTED_MODULE_3__["default"]);
      shaders.defines.NON_INSTANCED_MODEL = 1;

      topModel = new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Model"](
        gl,
        Object.assign({}, shaders, {
          id: `${id}-top`,
          drawMode: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.TRIANGLES,
          attributes: {
            vertexPositions: new Float32Array([0, 1])
          },
          uniforms: {
            isWireframe: false,
            isSideVertex: false
          },
          vertexCount: 0,
          isIndexed: true,
          shaderCache: this.context.shaderCache
        })
      );
    }
    if (extruded) {
      sideModel = new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Model"](
        gl,
        Object.assign({}, this.getShaders(_solid_polygon_layer_vertex_side_glsl__WEBPACK_IMPORTED_MODULE_4__["default"]), {
          id: `${id}-side`,
          geometry: new _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1__["Geometry"]({
            drawMode: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_1___default.a.LINES,
            vertexCount: 4,
            attributes: {
              // top right - top left - bootom left - bottom right
              vertexPositions: {
                size: 2,
                value: new Float32Array([1, 1, 0, 1, 0, 0, 1, 0])
              }
            }
          }),
          instanceCount: 0,
          isInstanced: 1,
          shaderCache: this.context.shaderCache
        })
      );

      sideModel.userData.excludeAttributes = {indices: true};
    }

    return {
      models: [sideModel, topModel].filter(Boolean),
      topModel,
      sideModel
    };
  }

  calculateIndices(attribute) {
    const {polygonTesselator} = this.state;
    attribute.bufferLayout = polygonTesselator.indexLayout;
    attribute.value = polygonTesselator.get('indices');
  }

  calculatePositions(attribute) {
    const {polygonTesselator} = this.state;
    attribute.bufferLayout = polygonTesselator.bufferLayout;
    attribute.value = polygonTesselator.get('positions');
  }
  calculatePositionsLow(attribute) {
    const isFP64 = this.use64bitPositions();
    attribute.constant = !isFP64;

    if (!isFP64) {
      attribute.value = new Float32Array(2);
      return;
    }

    attribute.value = this.state.polygonTesselator.get('positions64xyLow');
  }

  calculateVertexValid(attribute) {
    attribute.value = this.state.polygonTesselator.get('vertexValid');
  }

  clearPickingColor(color) {
    const pickedPolygonIndex = this.decodePickingColor(color);
    const {bufferLayout} = this.state.polygonTesselator;
    const numVertices = bufferLayout[pickedPolygonIndex];

    let startInstanceIndex = 0;
    for (let polygonIndex = 0; polygonIndex < pickedPolygonIndex; polygonIndex++) {
      startInstanceIndex += bufferLayout[polygonIndex];
    }

    const {pickingColors} = this.getAttributeManager().attributes;

    const {value} = pickingColors;
    const endInstanceIndex = startInstanceIndex + numVertices;
    value.fill(0, startInstanceIndex * 3, endInstanceIndex * 3);
    pickingColors.update({value});
  }
}

SolidPolygonLayer.layerName = 'SolidPolygonLayer';
SolidPolygonLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/text-layer/font-atlas-manager.js":
/*!**********************************************!*\
  !*** ./src/text-layer/font-atlas-manager.js ***!
  \**********************************************/
/*! exports provided: DEFAULT_CHAR_SET, DEFAULT_FONT_FAMILY, DEFAULT_FONT_WEIGHT, DEFAULT_FONT_SIZE, DEFAULT_BUFFER, DEFAULT_CUTOFF, DEFAULT_RADIUS, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_CHAR_SET", function() { return DEFAULT_CHAR_SET; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_FONT_FAMILY", function() { return DEFAULT_FONT_FAMILY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_FONT_WEIGHT", function() { return DEFAULT_FONT_WEIGHT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_FONT_SIZE", function() { return DEFAULT_FONT_SIZE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_BUFFER", function() { return DEFAULT_BUFFER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_CUTOFF", function() { return DEFAULT_CUTOFF; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_RADIUS", function() { return DEFAULT_RADIUS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return FontAtlasManager; });
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/core */ "@luma.gl/constants");
/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _mapbox_tiny_sdf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mapbox/tiny-sdf */ "../../node_modules/@mapbox/tiny-sdf/index.js");
/* harmony import */ var _mapbox_tiny_sdf__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_mapbox_tiny_sdf__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _font_atlas_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./font-atlas-utils */ "./src/text-layer/font-atlas-utils.js");
/* harmony import */ var _lru_cache__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lru-cache */ "./src/text-layer/lru-cache.js");
/* global document */








function getDefaultCharacterSet() {
  const charSet = [];
  for (let i = 32; i < 128; i++) {
    charSet.push(String.fromCharCode(i));
  }
  return charSet;
}

const DEFAULT_CHAR_SET = getDefaultCharacterSet();
const DEFAULT_FONT_FAMILY = 'Monaco, monospace';
const DEFAULT_FONT_WEIGHT = 'normal';
const DEFAULT_FONT_SIZE = 64;
const DEFAULT_BUFFER = 2;
const DEFAULT_CUTOFF = 0.25;
const DEFAULT_RADIUS = 3;

const GL_TEXTURE_WRAP_S = 0x2802;
const GL_TEXTURE_WRAP_T = 0x2803;
const GL_CLAMP_TO_EDGE = 0x812f;
const MAX_CANVAS_WIDTH = 1024;

const BASELINE_SCALE = 0.9;
const HEIGHT_SCALE = 1.2;

// only preserve latest three fontAtlas
const CACHE_LIMIT = 3;

/**
 * [key]: {
 *   xOffset, // x position of last character in mapping
 *   yOffset, // y position of last character in mapping
 *   mapping, // x, y coordinate of each character in shared `fontAtlas`
 *   data, // canvas
 *   width. // canvas.width,
 *   height, // canvas.height
 * }
 *
 */
const cache = new _lru_cache__WEBPACK_IMPORTED_MODULE_3__["default"](CACHE_LIMIT);

const VALID_PROPS = [
  'fontFamily',
  'fontWeight',
  'characterSet',
  'fontSize',
  'sdf',
  'buffer',
  'cutoff',
  'radius'
];

/**
 * get all the chars not in cache
 * @param key cache key
 * @param characterSet (Array|Set)
 * @returns {Array} chars not in cache
 */
function getNewChars(key, characterSet) {
  const cachedFontAtlas = cache.get(key);
  if (!cachedFontAtlas) {
    return characterSet;
  }

  const newChars = [];
  const cachedMapping = cachedFontAtlas.mapping;
  let cachedCharSet = Object.keys(cachedMapping);
  cachedCharSet = new Set(cachedCharSet);

  let charSet = characterSet;
  if (charSet instanceof Array) {
    charSet = new Set(charSet);
  }

  charSet.forEach(char => {
    if (!cachedCharSet.has(char)) {
      newChars.push(char);
    }
  });

  return newChars;
}

function populateAlphaChannel(alphaChannel, imageData) {
  // populate distance value from tinySDF to image alpha channel
  for (let i = 0; i < alphaChannel.length; i++) {
    imageData.data[4 * i + 3] = alphaChannel[i];
  }
}

function setTextStyle(ctx, fontFamily, fontSize, fontWeight) {
  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;
  ctx.fillStyle = '#000';
  ctx.textBaseline = 'baseline';
  ctx.textAlign = 'left';
}

class FontAtlasManager {
  constructor(gl) {
    this.gl = gl;

    // font settings
    this.props = {
      fontFamily: DEFAULT_FONT_FAMILY,
      fontWeight: DEFAULT_FONT_WEIGHT,
      characterSet: DEFAULT_CHAR_SET,
      fontSize: DEFAULT_FONT_SIZE,
      buffer: DEFAULT_BUFFER,
      // sdf only props
      // https://github.com/mapbox/tiny-sdf
      sdf: false,
      cutoff: DEFAULT_CUTOFF,
      radius: DEFAULT_RADIUS
    };

    // key is used for caching generated fontAtlas
    this._key = null;
    this._texture = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_0__["Texture2D"](this.gl);
  }

  finalize() {
    this._texture.delete();
  }

  get texture() {
    return this._texture;
  }

  get mapping() {
    const data = cache.get(this._key);
    return data && data.mapping;
  }

  get scale() {
    return HEIGHT_SCALE;
  }

  setProps(props = {}) {
    VALID_PROPS.forEach(prop => {
      if (prop in props) {
        this.props[prop] = props[prop];
      }
    });

    // update cache key
    const oldKey = this._key;
    this._key = this._getKey();

    const charSet = getNewChars(this._key, this.props.characterSet);
    const cachedFontAtlas = cache.get(this._key);

    // if a fontAtlas associated with the new settings is cached and
    // there are no new chars
    if (cachedFontAtlas && charSet.length === 0) {
      // update texture with cached fontAtlas
      if (this._key !== oldKey) {
        this._updateTexture(cachedFontAtlas);
      }
      return;
    }

    // update fontAtlas with new settings
    const fontAtlas = this._generateFontAtlas(this._key, charSet, cachedFontAtlas);
    this._updateTexture(fontAtlas);

    // update cache
    cache.set(this._key, fontAtlas);
  }

  _updateTexture({data: canvas, width, height}) {
    // resize texture
    if (this._texture.width !== width || this._texture.height !== height) {
      this._texture.resize({width, height});
    }

    // update image data
    this._texture.setImageData({
      data: canvas,
      width,
      height,
      parameters: {
        [GL_TEXTURE_WRAP_S]: GL_CLAMP_TO_EDGE,
        [GL_TEXTURE_WRAP_T]: GL_CLAMP_TO_EDGE,
        [_luma_gl_core__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_FLIP_Y_WEBGL]: true
      }
    });

    // this is required step after texture data changed
    this._texture.generateMipmap();
  }

  _generateFontAtlas(key, characterSet, cachedFontAtlas) {
    const {fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;
    let canvas = cachedFontAtlas && cachedFontAtlas.data;
    if (!canvas) {
      canvas = document.createElement('canvas');
      canvas.width = MAX_CANVAS_WIDTH;
    }
    const ctx = canvas.getContext('2d');

    setTextStyle(ctx, fontFamily, fontSize, fontWeight);

    // 1. build mapping
    const {mapping, canvasHeight, xOffset, yOffset} = Object(_font_atlas_utils__WEBPACK_IMPORTED_MODULE_2__["buildMapping"])(
      Object.assign(
        {
          getFontWidth: char => ctx.measureText(char).width,
          fontHeight: fontSize * HEIGHT_SCALE,
          buffer,
          characterSet,
          maxCanvasWidth: MAX_CANVAS_WIDTH
        },
        cachedFontAtlas && {
          mapping: cachedFontAtlas.mapping,
          xOffset: cachedFontAtlas.xOffset,
          yOffset: cachedFontAtlas.yOffset
        }
      )
    );

    // 2. update canvas
    // copy old canvas data to new canvas only when height changed
    if (canvas.height !== canvasHeight) {
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      canvas.height = canvasHeight;
      ctx.putImageData(imageData, 0, 0);
    }
    setTextStyle(ctx, fontFamily, fontSize, fontWeight);

    // 3. layout characters
    if (sdf) {
      const tinySDF = new _mapbox_tiny_sdf__WEBPACK_IMPORTED_MODULE_1___default.a(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);
      // used to store distance values from tinySDF
      // tinySDF.size equals `fontSize + buffer * 2`
      const imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);

      for (const char of characterSet) {
        populateAlphaChannel(tinySDF.draw(char), imageData);
        ctx.putImageData(imageData, mapping[char].x - buffer, mapping[char].y - buffer);
      }
    } else {
      for (const char of characterSet) {
        ctx.fillText(char, mapping[char].x, mapping[char].y + fontSize * BASELINE_SCALE);
      }
    }

    return {
      xOffset,
      yOffset,
      mapping,
      data: canvas,
      width: canvas.width,
      height: canvas.height
    };
  }

  _getKey() {
    const {gl, fontFamily, fontWeight, fontSize, buffer, sdf, radius, cutoff} = this.props;
    if (sdf) {
      return `${gl} ${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff}`;
    }
    return `${gl} ${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;
  }
}


/***/ }),

/***/ "./src/text-layer/font-atlas-utils.js":
/*!********************************************!*\
  !*** ./src/text-layer/font-atlas-utils.js ***!
  \********************************************/
/*! exports provided: nextPowOfTwo, buildMapping */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nextPowOfTwo", function() { return nextPowOfTwo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "buildMapping", function() { return buildMapping; });
// TODO merge with icon-layer/icon-manager
function nextPowOfTwo(number) {
  return Math.pow(2, Math.ceil(Math.log2(number)));
}

/**
 * Generate character mapping table or update from an existing mapping table
 * @param characterSet {Array|Set} new characters
 * @param getFontWidth {Function} function to get width of each character
 * @param fontHeight {Number} height of font
 * @param buffer {Number} buffer surround each character
 * @param maxCanvasWidth {Number} max width of font atlas
 * @param mapping {Object} old mapping table
 * @param xOffset {Number} x position of last character in old mapping table
 * @param yOffset {Number} y position of last character in old mapping table
 * @returns {{
 *   mapping: Object,
 *   xOffset: Number, x position of last character
 *   yOffset: Number, y position of last character in old mapping table
 *   canvasHeight: Number, height of the font atlas canvas, power of 2
 *  }}
 */
function buildMapping({
  characterSet,
  getFontWidth,
  fontHeight,
  buffer,
  maxCanvasWidth,
  mapping = {},
  xOffset = 0,
  yOffset = 0
}) {
  let row = 0;
  // continue from x position of last character in the old mapping
  let x = xOffset;
  Array.from(characterSet).forEach((char, i) => {
    if (!mapping[char]) {
      // measure texts
      // TODO - use Advanced text metrics when they are adopted:
      // https://developer.mozilla.org/en-US/docs/Web/API/TextMetrics
      const width = getFontWidth(char, i);

      if (x + width + buffer * 2 > maxCanvasWidth) {
        x = 0;
        row++;
      }
      mapping[char] = {
        x: x + buffer,
        y: yOffset + row * (fontHeight + buffer * 2) + buffer,
        width,
        height: fontHeight,
        mask: true
      };
      x += width + buffer * 2;
    }
  });

  const rowHeight = fontHeight + buffer * 2;

  return {
    mapping,
    xOffset: x,
    yOffset: yOffset + row * rowHeight,
    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)
  };
}


/***/ }),

/***/ "./src/text-layer/lru-cache.js":
/*!*************************************!*\
  !*** ./src/text-layer/lru-cache.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LRUCache; });
/**
 * LRU Cache class with limit
 *
 * Update order for each get/set operation
 * Delete oldest when reach given limit
 */

class LRUCache {
  constructor(limit = 5) {
    this.limit = limit;

    this.clear();
  }

  clear() {
    this._cache = {};
    // access/update order, first item is oldest, last item is newest
    this._order = [];
  }

  get(key) {
    const value = this._cache[key];
    if (value) {
      // update order
      this._deleteOrder(key);
      this._appendOrder(key);
    }
    return value;
  }

  set(key, value) {
    if (!this._cache[key]) {
      // if reach limit, delete the oldest
      if (Object.keys(this._cache).length === this.limit) {
        this.delete(this._order[0]);
      }

      this._cache[key] = value;
      this._appendOrder(key);
    } else {
      // if found in cache, delete the old one, insert new one to the first of list
      this.delete(key);

      this._cache[key] = value;
      this._appendOrder(key);
    }
  }

  delete(key) {
    const value = this._cache[key];
    if (value) {
      this._deleteCache(key);
      this._deleteOrder(key);
    }
  }

  _deleteCache(key) {
    delete this._cache[key];
  }

  _deleteOrder(key) {
    const index = this._order.findIndex(o => o === key);
    if (index >= 0) {
      this._order.splice(index, 1);
    }
  }

  _appendOrder(key) {
    this._order.push(key);
  }
}


/***/ }),

/***/ "./src/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js":
/*!***************************************************************************!*\
  !*** ./src/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js ***!
  \***************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME multi-icon-layer-fragment-shader

precision highp float;

uniform sampler2D iconsTexture;
uniform float buffer;
uniform bool sdf;

varying vec4 vColor;
varying vec2 vTextureCoords;
varying float vGamma;

const float MIN_ALPHA = 0.05;

void main(void) {
  vec4 texColor = texture2D(iconsTexture, vTextureCoords);
  
  float alpha = texColor.a;
  // if enable sdf (signed distance fields)
  if (sdf) {
    float distance = texture2D(iconsTexture, vTextureCoords).a;
    alpha = smoothstep(buffer - vGamma, buffer + vGamma, distance);
  }

  // Take the global opacity and the alpha from vColor into account for the alpha component
  float a = alpha * vColor.a;

  if (a < MIN_ALPHA) {
    discard;
  }

  gl_FragColor = vec4(vColor.rgb, a);

  // use highlight color if this fragment belongs to the selected object.
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);

  // use picking color if rendering to picking FBO.
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
}
`);


/***/ }),

/***/ "./src/text-layer/multi-icon-layer/multi-icon-layer-vertex.glsl.js":
/*!*************************************************************************!*\
  !*** ./src/text-layer/multi-icon-layer/multi-icon-layer-vertex.glsl.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME multi-icon-layer-vertex-shader

attribute vec2 positions;

attribute vec3 instancePositions;
attribute vec2 instancePositions64xyLow;
attribute float instanceSizes;
attribute float instanceAngles;
attribute vec4 instanceColors;
attribute vec3 instancePickingColors;
attribute vec4 instanceIconFrames;
attribute float instanceColorModes;
attribute vec2 instanceOffsets;

// the following three attributes are for the multi-icon layer
attribute vec2 instancePixelOffset;

uniform float sizeScale;
uniform float sizeMinPixels;
uniform float sizeMaxPixels;
uniform vec2 iconsTextureDim;
uniform float gamma;
uniform float opacity;
uniform bool billboard;

varying float vColorMode;
varying vec4 vColor;
varying vec2 vTextureCoords;
varying float vGamma;

vec2 rotate_by_angle(vec2 vertex, float angle) {
  float angle_radian = angle * PI / 180.0;
  float cos_angle = cos(angle_radian);
  float sin_angle = sin(angle_radian);
  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);
  return rotationMatrix * vertex;
}

void main(void) {
  vec2 iconSize = instanceIconFrames.zw;
 
  // project meters to pixels and clamp to limits 
  float sizePixels = clamp(
    project_size_to_pixel(instanceSizes * sizeScale),
    sizeMinPixels, sizeMaxPixels
  );

  // scale icon height to match instanceSize
  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;

  // scale and rotate vertex in "pixel" value and convert back to fraction in clipspace
  vec2 pixelOffset = positions / 2.0 * iconSize + instanceOffsets;

  pixelOffset = rotate_by_angle(pixelOffset, instanceAngles) * instanceScale;
  pixelOffset += instancePixelOffset;
  
  if (billboard)  {
    pixelOffset.y *= -1.0;
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, vec3(0.0)); 
    gl_Position.xy += project_pixel_size_to_clipspace(pixelOffset);

  } else {
    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);
    gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, offset_common); 
  }

  vTextureCoords = mix(
    instanceIconFrames.xy,
    instanceIconFrames.xy + iconSize,
    (positions.xy + 1.0) / 2.0
  ) / iconsTextureDim;

  vTextureCoords.y = 1.0 - vTextureCoords.y;

  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;
  picking_setPickingColor(instancePickingColors);

  vGamma = gamma / (sizeScale * iconSize.y);
}
`);


/***/ }),

/***/ "./src/text-layer/multi-icon-layer/multi-icon-layer.js":
/*!*************************************************************!*\
  !*** ./src/text-layer/multi-icon-layer/multi-icon-layer.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MultiIconLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _icon_layer_icon_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../icon-layer/icon-layer */ "./src/icon-layer/icon-layer.js");
/* harmony import */ var _multi_icon_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./multi-icon-layer-vertex.glsl */ "./src/text-layer/multi-icon-layer/multi-icon-layer-vertex.glsl.js");
/* harmony import */ var _multi_icon_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./multi-icon-layer-fragment.glsl */ "./src/text-layer/multi-icon-layer/multi-icon-layer-fragment.glsl.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.







// TODO expose as layer properties
const DEFAULT_GAMMA = 0.2;
const DEFAULT_BUFFER = 192.0 / 256;

const defaultProps = {
  getShiftInQueue: {type: 'accessor', value: x => x.shift || 0},
  getLengthOfQueue: {type: 'accessor', value: x => x.len || 1},
  // 1: left, 0: middle, -1: right
  getAnchorX: {type: 'accessor', value: x => x.anchorX || 0},
  // 1: top, 0: center, -1: bottom
  getAnchorY: {type: 'accessor', value: x => x.anchorY || 0},
  getPixelOffset: {type: 'accessor', value: [0, 0]},

  // object with the same pickingIndex will be picked when any one of them is being picked
  getPickingIndex: {type: 'accessor', value: x => x.objectIndex}
};

class MultiIconLayer extends _icon_layer_icon_layer__WEBPACK_IMPORTED_MODULE_1__["default"] {
  getShaders() {
    return Object.assign({}, super.getShaders(), {
      vs: _multi_icon_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__["default"],
      fs: _multi_icon_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__["default"]
    });
  }

  initializeState() {
    super.initializeState();

    const attributeManager = this.getAttributeManager();
    attributeManager.addInstanced({
      instancePixelOffset: {
        size: 2,
        transition: true,
        accessor: 'getPixelOffset'
      }
    });
  }

  updateState(updateParams) {
    super.updateState(updateParams);
    const {changeFlags} = updateParams;

    if (
      changeFlags.updateTriggersChanged &&
      (changeFlags.updateTriggersChanged.getAnchorX || changeFlags.updateTriggersChanged.getAnchorY)
    ) {
      this.getAttributeManager().invalidate('instanceOffsets');
    }
  }

  draw({uniforms}) {
    const {sdf} = this.props;
    super.draw({
      uniforms: Object.assign({}, uniforms, {
        // Refer the following doc about gamma and buffer
        // https://blog.mapbox.com/drawing-text-with-signed-distance-fields-in-mapbox-gl-b0933af6f817
        buffer: DEFAULT_BUFFER,
        gamma: DEFAULT_GAMMA,
        sdf: Boolean(sdf)
      })
    });
  }

  calculateInstanceOffsets(attribute, {startRow, endRow}) {
    const {
      data,
      iconMapping,
      getIcon,
      getAnchorX,
      getAnchorY,
      getLengthOfQueue,
      getShiftInQueue
    } = this.props;
    const {value, size} = attribute;
    let i = startRow * size;
    const {iterable} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["createIterable"])(data, startRow, endRow);

    for (const object of iterable) {
      const icon = getIcon(object);
      const rect = iconMapping[icon] || {};
      const len = getLengthOfQueue(object);
      const shiftX = getShiftInQueue(object);

      value[i++] = ((getAnchorX(object) - 1) * len) / 2 + rect.width / 2 + shiftX || 0;
      value[i++] = (rect.height / 2) * getAnchorY(object) || 0;
    }
  }

  calculateInstancePickingColors(attribute, {startRow, endRow}) {
    const {data, getPickingIndex} = this.props;
    const {value, size} = attribute;
    let i = startRow * size;
    const pickingColor = [];
    const {iterable} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["createIterable"])(data, startRow, endRow);

    for (const point of iterable) {
      const index = getPickingIndex(point);
      this.encodePickingColor(index, pickingColor);

      value[i++] = pickingColor[0];
      value[i++] = pickingColor[1];
      value[i++] = pickingColor[2];
    }
  }
}

MultiIconLayer.layerName = 'MultiIconLayer';
MultiIconLayer.defaultProps = defaultProps;


/***/ }),

/***/ "./src/text-layer/text-layer.js":
/*!**************************************!*\
  !*** ./src/text-layer/text-layer.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TextLayer; });
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ "@deck.gl/core");
/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _multi_icon_layer_multi_icon_layer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./multi-icon-layer/multi-icon-layer */ "./src/text-layer/multi-icon-layer/multi-icon-layer.js");
/* harmony import */ var _font_atlas_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./font-atlas-manager */ "./src/text-layer/font-atlas-manager.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.





const DEFAULT_FONT_SETTINGS = {
  fontSize: _font_atlas_manager__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_FONT_SIZE"],
  buffer: _font_atlas_manager__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_BUFFER"],
  sdf: false,
  radius: _font_atlas_manager__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_RADIUS"],
  cutoff: _font_atlas_manager__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_CUTOFF"]
};

const TEXT_ANCHOR = {
  start: 1,
  middle: 0,
  end: -1
};

const ALIGNMENT_BASELINE = {
  top: 1,
  center: 0,
  bottom: -1
};

const DEFAULT_COLOR = [0, 0, 0, 255];

const MISSING_CHAR_WIDTH = 32;
const FONT_SETTINGS_PROPS = ['fontSize', 'buffer', 'sdf', 'radius', 'cutoff'];

const defaultProps = {
  fp64: false,
  billboard: true,
  sizeScale: 1,
  sizeUnits: 'pixels',
  sizeMinPixels: 0,
  sizeMaxPixels: Number.MAX_SAFE_INTEGER,

  characterSet: _font_atlas_manager__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_CHAR_SET"],
  fontFamily: _font_atlas_manager__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_FONT_FAMILY"],
  fontWeight: _font_atlas_manager__WEBPACK_IMPORTED_MODULE_2__["DEFAULT_FONT_WEIGHT"],
  fontSettings: {},

  getText: {type: 'accessor', value: x => x.text},
  getPosition: {type: 'accessor', value: x => x.position},
  getColor: {type: 'accessor', value: DEFAULT_COLOR},
  getSize: {type: 'accessor', value: 32},
  getAngle: {type: 'accessor', value: 0},
  getTextAnchor: {type: 'accessor', value: 'middle'},
  getAlignmentBaseline: {type: 'accessor', value: 'center'},
  getPixelOffset: {type: 'accessor', value: [0, 0]}
};

class TextLayer extends _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["CompositeLayer"] {
  initializeState() {
    this.state = {
      fontAtlasManager: new _font_atlas_manager__WEBPACK_IMPORTED_MODULE_2__["default"](this.context.gl)
    };
  }

  updateState({props, oldProps, changeFlags}) {
    const fontChanged = this.fontChanged(oldProps, props);
    if (fontChanged) {
      this.updateFontAtlas({oldProps, props});
    }

    if (
      changeFlags.dataChanged ||
      fontChanged ||
      (changeFlags.updateTriggersChanged &&
        (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getText))
    ) {
      this.transformStringToLetters();
    }
  }

  finalizeState() {
    super.finalizeState();
    // Release resources held by the font atlas manager
    this.state.fontAtlasManager.finalize();
  }

  updateFontAtlas({oldProps, props}) {
    const {characterSet, fontSettings, fontFamily, fontWeight} = props;

    // generate test characterSet
    const fontAtlasManager = this.state.fontAtlasManager;
    fontAtlasManager.setProps(
      Object.assign({}, DEFAULT_FONT_SETTINGS, fontSettings, {
        characterSet,
        fontFamily,
        fontWeight
      })
    );

    const {scale, texture, mapping} = fontAtlasManager;

    this.setState({
      scale,
      iconAtlas: texture,
      iconMapping: mapping
    });

    this.setNeedsRedraw(true);
  }

  fontChanged(oldProps, props) {
    if (
      oldProps.fontFamily !== props.fontFamily ||
      oldProps.characterSet !== props.characterSet ||
      oldProps.fontWeight !== props.fontWeight
    ) {
      return true;
    }

    if (oldProps.fontSettings === props.fontSettings) {
      return false;
    }

    const oldFontSettings = oldProps.fontSettings || {};
    const fontSettings = props.fontSettings || {};

    return FONT_SETTINGS_PROPS.some(prop => oldFontSettings[prop] !== fontSettings[prop]);
  }

  getPickingInfo({info}) {
    // because `TextLayer` assign the same pickingInfoIndex for one text label,
    // here info.index refers the index of text label in props.data
    return Object.assign(info, {
      // override object with original data
      object: info.index >= 0 ? this.props.data[info.index] : null
    });
  }

  /* eslint-disable no-loop-func */
  transformStringToLetters() {
    const {data, getText} = this.props;
    const {iconMapping} = this.state;

    const transformedData = [];

    const {iterable, objectInfo} = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["createIterable"])(data);
    for (const object of iterable) {
      objectInfo.index++;
      const text = getText(object, objectInfo);
      if (text) {
        const letters = Array.from(text);
        const offsets = [0];
        let offsetLeft = 0;

        letters.forEach((letter, i) => {
          const datum = {
            text: letter,
            index: i,
            offsets,
            len: text.length,
            // reference of original object and object index
            object,
            objectIndex: objectInfo.index
          };

          const frame = iconMapping[letter];
          if (frame) {
            offsetLeft += frame.width;
          } else {
            _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__["log"].warn(`Missing character: ${letter}`)();
            offsetLeft += MISSING_CHAR_WIDTH;
          }
          offsets.push(offsetLeft);
          transformedData.push(datum);
        });
      }
    }

    this.setState({data: transformedData});
  }
  /* eslint-enable no-loop-func */

  getLetterOffset(datum) {
    return datum.offsets[datum.index];
  }

  getTextLength(datum) {
    return datum.offsets[datum.offsets.length - 1];
  }

  _getAccessor(accessor) {
    if (typeof accessor === 'function') {
      return x => accessor(x.object);
    }
    return accessor;
  }

  getAnchorXFromTextAnchor(getTextAnchor) {
    return x => {
      const textAnchor =
        typeof getTextAnchor === 'function' ? getTextAnchor(x.object) : getTextAnchor;
      if (!TEXT_ANCHOR.hasOwnProperty(textAnchor)) {
        throw new Error(`Invalid text anchor parameter: ${textAnchor}`);
      }
      return TEXT_ANCHOR[textAnchor];
    };
  }

  getAnchorYFromAlignmentBaseline(getAlignmentBaseline) {
    return x => {
      const alignmentBaseline =
        typeof getAlignmentBaseline === 'function'
          ? getAlignmentBaseline(x.object)
          : getAlignmentBaseline;
      if (!ALIGNMENT_BASELINE.hasOwnProperty(alignmentBaseline)) {
        throw new Error(`Invalid alignment baseline parameter: ${alignmentBaseline}`);
      }
      return ALIGNMENT_BASELINE[alignmentBaseline];
    };
  }

  renderLayers() {
    const {data, scale, iconAtlas, iconMapping} = this.state;

    const {
      getPosition,
      getColor,
      getSize,
      getAngle,
      getTextAnchor,
      getAlignmentBaseline,
      getPixelOffset,
      fp64,
      billboard,
      sdf,
      sizeScale,
      sizeUnits,
      sizeMinPixels,
      sizeMaxPixels,
      transitions,
      updateTriggers
    } = this.props;

    const SubLayerClass = this.getSubLayerClass('characters', _multi_icon_layer_multi_icon_layer__WEBPACK_IMPORTED_MODULE_1__["default"]);

    return new SubLayerClass(
      {
        sdf,
        iconAtlas,
        iconMapping,

        getPosition: d => getPosition(d.object),
        getColor: this._getAccessor(getColor),
        getSize: this._getAccessor(getSize),
        getAngle: this._getAccessor(getAngle),
        getAnchorX: this.getAnchorXFromTextAnchor(getTextAnchor),
        getAnchorY: this.getAnchorYFromAlignmentBaseline(getAlignmentBaseline),
        getPixelOffset: this._getAccessor(getPixelOffset),
        fp64,
        billboard,
        sizeScale: sizeScale * scale,
        sizeUnits,
        sizeMinPixels: sizeMinPixels * scale,
        sizeMaxPixels: sizeMaxPixels * scale,

        transitions: transitions && {
          getPosition: transitions.getPosition,
          getAngle: transitions.getAngle,
          getColor: transitions.getColor,
          getSize: transitions.getSize,
          getPixelOffset: updateTriggers.getPixelOffset
        }
      },
      this.getSubLayerProps({
        id: 'characters',
        updateTriggers: {
          getPosition: updateTriggers.getPosition,
          getAngle: updateTriggers.getAngle,
          getColor: updateTriggers.getColor,
          getSize: updateTriggers.getSize,
          getPixelOffset: updateTriggers.getPixelOffset,
          getAnchorX: updateTriggers.getTextAnchor,
          getAnchorY: updateTriggers.getAlignmentBaseline
        }
      }),
      {
        data,

        getIcon: d => d.text,
        getShiftInQueue: d => this.getLetterOffset(d),
        getLengthOfQueue: d => this.getTextLength(d)
      }
    );
  }
}

TextLayer.layerName = 'TextLayer';
TextLayer.defaultProps = defaultProps;


/***/ }),

/***/ 0:
/*!****************************!*\
  !*** get-pixels (ignored) ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 2:
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 3:
/*!**********************!*\
  !*** http (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 4:
/*!***********************!*\
  !*** https (ignored) ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 5:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 6:
/*!*****************************!*\
  !*** save-pixels (ignored) ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 7:
/*!*************************!*\
  !*** ndarray (ignored) ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ "@deck.gl/core":
/*!***********************!*\
  !*** external "deck" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__deck_gl_core__;

/***/ }),

/***/ "@luma.gl/constants":
/*!***********************!*\
  !*** external "luma" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__luma_gl_constants__;

/***/ })

/******/ });
});