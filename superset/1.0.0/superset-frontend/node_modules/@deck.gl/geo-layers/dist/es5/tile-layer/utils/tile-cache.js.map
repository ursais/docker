{"version":3,"sources":["../../../../src/tile-layer/utils/tile-cache.js"],"names":["TileCache","getTileData","maxSize","maxZoom","minZoom","onTileError","_getTileData","_maxSize","_cache","Map","parseInt","_maxZoom","_minZoom","clear","viewport","onUpdate","_markOldTiles","tileIndices","length","viewportTiles","Set","forEach","cachedTile","some","tile","isOverlapped","isVisible","add","i","tileIndex","x","y","z","_getTile","Tile","tileId","_getTileId","set","commonZoomRange","_resizeCache","viewportTilesArray","Array","from","sort","t1","t2","size","iterator","Symbol","delete","get"],"mappings":"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","sourcesContent":["import Tile from './tile';\nimport {getTileIndices} from './viewport-util';\n\n/**\n * Manages loading and purging of tiles data. This class caches recently visited tiles\n * and only create new tiles if they are present.\n */\n\nexport default class TileCache {\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor({getTileData, maxSize, maxZoom, minZoom, onTileError}) {\n    // TODO: Instead of hardcode size, we should calculate how much memory left\n    this._getTileData = getTileData;\n    this._maxSize = maxSize;\n    this.onTileError = onTileError;\n\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n\n    if (maxZoom && parseInt(maxZoom, 10) === maxZoom) {\n      this._maxZoom = maxZoom;\n    }\n    if (minZoom && parseInt(minZoom, 10) === minZoom) {\n      this._minZoom = minZoom;\n    }\n  }\n\n  /**\n   * Clear the current cache\n   */\n  finalize() {\n    this._cache.clear();\n  }\n\n  /**\n   * Update the cache with the given viewport and triggers callback onUpdate.\n   * @param {*} viewport\n   * @param {*} onUpdate\n   */\n  update(viewport, onUpdate) {\n    const {_cache, _getTileData, _maxSize, _maxZoom, _minZoom} = this;\n    this._markOldTiles();\n    const tileIndices = getTileIndices(viewport, _maxZoom, _minZoom);\n    if (!tileIndices || tileIndices.length === 0) {\n      onUpdate(tileIndices);\n      return;\n    }\n    const viewportTiles = new Set();\n    _cache.forEach(cachedTile => {\n      if (tileIndices.some(tile => cachedTile.isOverlapped(tile))) {\n        cachedTile.isVisible = true;\n        viewportTiles.add(cachedTile);\n      }\n    });\n\n    for (let i = 0; i < tileIndices.length; i++) {\n      const tileIndex = tileIndices[i];\n\n      const {x, y, z} = tileIndex;\n      let tile = this._getTile(x, y, z);\n      if (!tile) {\n        tile = new Tile({\n          getTileData: _getTileData,\n          x,\n          y,\n          z,\n          onTileError: this.onTileError\n        });\n      }\n      const tileId = this._getTileId(x, y, z);\n      _cache.set(tileId, tile);\n      viewportTiles.add(tile);\n    }\n\n    // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n    const commonZoomRange = 5;\n    this._resizeCache(_maxSize || commonZoomRange * tileIndices.length);\n    // sort by zoom level so parents tiles don't show up when children tiles are rendered\n    const viewportTilesArray = Array.from(viewportTiles).sort((t1, t2) => t1.z - t2.z);\n    onUpdate(viewportTilesArray);\n  }\n\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  _resizeCache(maxSize) {\n    const {_cache} = this;\n    if (_cache.size > maxSize) {\n      const iterator = _cache[Symbol.iterator]();\n      for (const cachedTile of iterator) {\n        if (_cache.size <= maxSize) {\n          break;\n        }\n        const tileId = cachedTile[0];\n        const tile = cachedTile[1];\n        if (!tile.isVisible) {\n          _cache.delete(tileId);\n        }\n      }\n    }\n  }\n\n  _markOldTiles() {\n    this._cache.forEach(cachedTile => {\n      cachedTile.isVisible = false;\n    });\n  }\n\n  _getTile(x, y, z) {\n    const tileId = this._getTileId(x, y, z);\n    return this._cache.get(tileId);\n  }\n\n  _getTileId(x, y, z) {\n    return `${z}-${x}-${y}`;\n  }\n}\n"],"file":"tile-cache.js"}