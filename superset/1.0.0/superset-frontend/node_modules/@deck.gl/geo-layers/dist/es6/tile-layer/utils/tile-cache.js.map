{"version":3,"sources":["../../../../src/tile-layer/utils/tile-cache.js"],"names":["Tile","getTileIndices","TileCache","constructor","getTileData","maxSize","maxZoom","minZoom","onTileError","_getTileData","_maxSize","_cache","Map","parseInt","_maxZoom","_minZoom","finalize","clear","update","viewport","onUpdate","_markOldTiles","tileIndices","length","viewportTiles","Set","forEach","cachedTile","some","tile","isOverlapped","isVisible","add","i","tileIndex","x","y","z","_getTile","tileId","_getTileId","set","commonZoomRange","_resizeCache","viewportTilesArray","Array","from","sort","t1","t2","size","iterator","Symbol","delete","get"],"mappings":"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","sourcesContent":["import Tile from './tile';\nimport {getTileIndices} from './viewport-util';\n\n/**\n * Manages loading and purging of tiles data. This class caches recently visited tiles\n * and only create new tiles if they are present.\n */\n\nexport default class TileCache {\n  /**\n   * Takes in a function that returns tile data, a cache size, and a max and a min zoom level.\n   * Cache size defaults to 5 * number of tiles in the current viewport\n   */\n  constructor({getTileData, maxSize, maxZoom, minZoom, onTileError}) {\n    // TODO: Instead of hardcode size, we should calculate how much memory left\n    this._getTileData = getTileData;\n    this._maxSize = maxSize;\n    this.onTileError = onTileError;\n\n    // Maps tile id in string {z}-{x}-{y} to a Tile object\n    this._cache = new Map();\n\n    if (maxZoom && parseInt(maxZoom, 10) === maxZoom) {\n      this._maxZoom = maxZoom;\n    }\n    if (minZoom && parseInt(minZoom, 10) === minZoom) {\n      this._minZoom = minZoom;\n    }\n  }\n\n  /**\n   * Clear the current cache\n   */\n  finalize() {\n    this._cache.clear();\n  }\n\n  /**\n   * Update the cache with the given viewport and triggers callback onUpdate.\n   * @param {*} viewport\n   * @param {*} onUpdate\n   */\n  update(viewport, onUpdate) {\n    const {_cache, _getTileData, _maxSize, _maxZoom, _minZoom} = this;\n    this._markOldTiles();\n    const tileIndices = getTileIndices(viewport, _maxZoom, _minZoom);\n    if (!tileIndices || tileIndices.length === 0) {\n      onUpdate(tileIndices);\n      return;\n    }\n    const viewportTiles = new Set();\n    _cache.forEach(cachedTile => {\n      if (tileIndices.some(tile => cachedTile.isOverlapped(tile))) {\n        cachedTile.isVisible = true;\n        viewportTiles.add(cachedTile);\n      }\n    });\n\n    for (let i = 0; i < tileIndices.length; i++) {\n      const tileIndex = tileIndices[i];\n\n      const {x, y, z} = tileIndex;\n      let tile = this._getTile(x, y, z);\n      if (!tile) {\n        tile = new Tile({\n          getTileData: _getTileData,\n          x,\n          y,\n          z,\n          onTileError: this.onTileError\n        });\n      }\n      const tileId = this._getTileId(x, y, z);\n      _cache.set(tileId, tile);\n      viewportTiles.add(tile);\n    }\n\n    // cache size is either the user defined maxSize or 5 * number of current tiles in the viewport.\n    const commonZoomRange = 5;\n    this._resizeCache(_maxSize || commonZoomRange * tileIndices.length);\n    // sort by zoom level so parents tiles don't show up when children tiles are rendered\n    const viewportTilesArray = Array.from(viewportTiles).sort((t1, t2) => t1.z - t2.z);\n    onUpdate(viewportTilesArray);\n  }\n\n  /**\n   * Clear tiles that are not visible when the cache is full\n   */\n  _resizeCache(maxSize) {\n    const {_cache} = this;\n    if (_cache.size > maxSize) {\n      const iterator = _cache[Symbol.iterator]();\n      for (const cachedTile of iterator) {\n        if (_cache.size <= maxSize) {\n          break;\n        }\n        const tileId = cachedTile[0];\n        const tile = cachedTile[1];\n        if (!tile.isVisible) {\n          _cache.delete(tileId);\n        }\n      }\n    }\n  }\n\n  _markOldTiles() {\n    this._cache.forEach(cachedTile => {\n      cachedTile.isVisible = false;\n    });\n  }\n\n  _getTile(x, y, z) {\n    const tileId = this._getTileId(x, y, z);\n    return this._cache.get(tileId);\n  }\n\n  _getTileId(x, y, z) {\n    return `${z}-${x}-${y}`;\n  }\n}\n"],"file":"tile-cache.js"}