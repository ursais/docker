{"version":3,"sources":["../../../../src/utils/gpu-grid-aggregation/grid-aggregation-utils.js"],"names":["count","experimental","fp64LowPart","fp64Utils","R_EARTH","toFinite","n","Number","isFinite","pointToDensityGridData","data","getPosition","cellSizeMeters","gpuGridAggregator","gpuAggregation","aggregationFlags","weightParams","fp64","coordinateSystem","COORDINATE_SYSTEM","LNGLAT","viewport","boundingBox","gridData","dataChanged","parseGridData","cellSize","worldOrigin","log","assert","IDENTITY","LNGLAT_DEPRECATED","gridOffset","getGridOffset","xOffset","yOffset","width","height","opts","getGPUAggregationParams","aggregatedData","run","positions","positions64xyLow","weights","gridTransformMatrix","useGPU","changeFlags","gridSize","gridOrigin","pointCount","Float64Array","Float32Array","yMin","Infinity","yMax","xMin","xMax","y","x","name","Object","assign","values","iterable","objectInfo","object","index","position","weight","getWeight","Array","isArray","latMin","latMax","centerLat","calculateGridLatLonOffset","latitude","calculateLatOffset","calculateLonOffset","dy","Math","PI","lat","dx","cos","alignToCell","inValue","sign","value","abs","floor","originX","originY","Matrix4","translate","ceil"],"mappings":"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","sourcesContent":["import {Matrix4} from 'math.gl';\nimport {fp64 as fp64Utils} from '@luma.gl/core';\nimport {COORDINATE_SYSTEM, log, createIterable, experimental} from '@deck.gl/core';\nconst {count} = experimental;\nconst {fp64LowPart} = fp64Utils;\n\nconst R_EARTH = 6378000;\n\nfunction toFinite(n) {\n  return Number.isFinite(n) ? n : 0;\n}\n\n// Takes data and aggregation params and returns aggregated data.\nexport function pointToDensityGridData({\n  data,\n  getPosition,\n  cellSizeMeters,\n  gpuGridAggregator,\n  gpuAggregation,\n  aggregationFlags,\n  weightParams,\n  fp64 = false,\n  coordinateSystem = COORDINATE_SYSTEM.LNGLAT,\n  viewport = null,\n  boundingBox = null\n}) {\n  let gridData = {};\n  if (aggregationFlags.dataChanged) {\n    gridData = parseGridData(data, getPosition, weightParams);\n    boundingBox = gridData.boundingBox;\n  }\n  let cellSize = [cellSizeMeters, cellSizeMeters];\n  let worldOrigin = [0, 0];\n  log.assert(\n    coordinateSystem === COORDINATE_SYSTEM.LNGLAT || coordinateSystem === COORDINATE_SYSTEM.IDENTITY\n  );\n\n  switch (coordinateSystem) {\n    case COORDINATE_SYSTEM.LNGLAT:\n    case COORDINATE_SYSTEM.LNGLAT_DEPRECATED:\n      const gridOffset = getGridOffset(boundingBox, cellSizeMeters);\n      cellSize = [gridOffset.xOffset, gridOffset.yOffset];\n      worldOrigin = [-180, -90]; // Origin used to define grid cell boundaries\n      break;\n    case COORDINATE_SYSTEM.IDENTITY:\n      const {width, height} = viewport;\n      worldOrigin = [-width / 2, -height / 2]; // Origin used to define grid cell boundaries\n      break;\n    default:\n      // Currently other coodinate systems not supported/verified.\n      log.assert(false);\n  }\n\n  const opts = getGPUAggregationParams({boundingBox, cellSize, worldOrigin});\n\n  const aggregatedData = gpuGridAggregator.run({\n    positions: gridData.positions,\n    positions64xyLow: gridData.positions64xyLow,\n    weights: gridData.weights,\n    cellSize,\n    width: opts.width,\n    height: opts.height,\n    gridTransformMatrix: opts.gridTransformMatrix,\n    useGPU: gpuAggregation,\n    changeFlags: aggregationFlags,\n    fp64\n  });\n\n  return {\n    weights: aggregatedData,\n    gridSize: opts.gridSize,\n    gridOrigin: opts.gridOrigin,\n    cellSize,\n    boundingBox\n  };\n}\n\n// Parse input data to build positions, wights and bounding box.\n/* eslint-disable max-statements */\nfunction parseGridData(data, getPosition, weightParams) {\n  const pointCount = count(data);\n\n  // For CPU Aggregation this needs to have full 64 bit precession, hence don't use FLoat32Array\n  // For GPU Aggregation this will be converted into Float32Array\n  const positions = new Float64Array(pointCount * 2);\n  const positions64xyLow = new Float32Array(pointCount * 2);\n\n  let yMin = Infinity;\n  let yMax = -Infinity;\n  let xMin = Infinity;\n  let xMax = -Infinity;\n  let y;\n  let x;\n\n  const weights = {};\n  for (const name in weightParams) {\n    weights[name] = Object.assign({}, weightParams[name], {\n      values: new Float32Array(pointCount * 3)\n    });\n  }\n\n  const {iterable, objectInfo} = createIterable(data);\n  for (const object of iterable) {\n    objectInfo.index++;\n    const position = getPosition(object, objectInfo);\n    const {index} = objectInfo;\n    x = position[0];\n    y = position[1];\n    positions[index * 2] = x;\n    positions[index * 2 + 1] = y;\n\n    positions64xyLow[index * 2] = fp64LowPart(x);\n    positions64xyLow[index * 2 + 1] = fp64LowPart(y);\n\n    for (const name in weightParams) {\n      const weight = weightParams[name].getWeight(object);\n\n      // Aggregator expects each weight is an array of size 3\n      if (Array.isArray(weight)) {\n        weights[name].values[index * 3] = weight[0];\n        weights[name].values[index * 3 + 1] = weight[1];\n        weights[name].values[index * 3 + 2] = weight[2];\n      } else {\n        // backward compitability\n        weights[name].values[index * 3] = weight;\n      }\n    }\n\n    if (Number.isFinite(y) && Number.isFinite(x)) {\n      yMin = y < yMin ? y : yMin;\n      yMax = y > yMax ? y : yMax;\n\n      xMin = x < xMin ? x : xMin;\n      xMax = x > xMax ? x : xMax;\n    }\n  }\n\n  const boundingBox = {\n    xMin: toFinite(xMin),\n    xMax: toFinite(xMax),\n    yMin: toFinite(yMin),\n    yMax: toFinite(yMax)\n  };\n  return {\n    positions,\n    positions64xyLow,\n    weights,\n    boundingBox\n  };\n}\n/* eslint-enable max-statements */\n\n/**\n * Based on geometric center of sample points, calculate cellSize in lng/lat (degree) space\n * @param {object} gridData - contains bounding box of data\n * @param {number} cellSize - grid cell size in meters\n * @returns {yOffset, xOffset} - cellSize size lng/lat (degree) space.\n */\n\nfunction getGridOffset(boundingBox, cellSize) {\n  const {yMin, yMax} = boundingBox;\n  const latMin = yMin;\n  const latMax = yMax;\n  const centerLat = (latMin + latMax) / 2;\n\n  return calculateGridLatLonOffset(cellSize, centerLat);\n}\n\n/**\n * calculate grid layer cell size in lat lon based on world unit size\n * and current latitude\n * @param {number} cellSize\n * @param {number} latitude\n * @returns {object} - lat delta and lon delta\n */\nfunction calculateGridLatLonOffset(cellSize, latitude) {\n  const yOffset = calculateLatOffset(cellSize);\n  const xOffset = calculateLonOffset(latitude, cellSize);\n  return {yOffset, xOffset};\n}\n\n/**\n * with a given x-km change, calculate the increment of latitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} dy - change in km\n * @return {number} - increment in latitude\n */\nfunction calculateLatOffset(dy) {\n  return (dy / R_EARTH) * (180 / Math.PI);\n}\n\n/**\n * with a given x-km change, and current latitude\n * calculate the increment of longitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} lat - latitude of current location (based on city)\n * @param {number} dx - change in km\n * @return {number} - increment in longitude\n */\nfunction calculateLonOffset(lat, dx) {\n  return ((dx / R_EARTH) * (180 / Math.PI)) / Math.cos((lat * Math.PI) / 180);\n}\n\n// Aligns `inValue` to given `cellSize`\nexport function alignToCell(inValue, cellSize) {\n  const sign = inValue < 0 ? -1 : 1;\n\n  let value = sign < 0 ? Math.abs(inValue) + cellSize : Math.abs(inValue);\n\n  value = Math.floor(value / cellSize) * cellSize;\n\n  return value * sign;\n}\n\n// Calculate grid parameters\nfunction getGPUAggregationParams({boundingBox, cellSize, worldOrigin}) {\n  const {yMin, yMax, xMin, xMax} = boundingBox;\n\n  // NOTE: this alignment will match grid cell boundaries with existing CPU implementation\n  // this gurantees identical aggregation results when switching between CPU and GPU aggregation.\n  // Also gurantees same cell boundaries, when overlapping between two different layers (like ScreenGrid and Contour)\n  // We first move worldOrigin to [0, 0], align the lower bounding box , then move worldOrigin to its original value.\n  const originX = alignToCell(xMin - worldOrigin[0], cellSize[0]) + worldOrigin[0];\n  const originY = alignToCell(yMin - worldOrigin[1], cellSize[1]) + worldOrigin[1];\n\n  // Setup transformation matrix so that every point is in +ve range\n  const gridTransformMatrix = new Matrix4().translate([-1 * originX, -1 * originY, 0]);\n\n  const gridOrigin = [originX, originY];\n  const width = xMax - xMin + cellSize[0];\n  const height = yMax - yMin + cellSize[1];\n\n  const gridSize = [Math.ceil(width / cellSize[0]), Math.ceil(height / cellSize[1])];\n\n  return {\n    gridOrigin,\n    gridSize,\n    width,\n    height,\n    gridTransformMatrix\n  };\n}\n"],"file":"grid-aggregation-utils.js"}