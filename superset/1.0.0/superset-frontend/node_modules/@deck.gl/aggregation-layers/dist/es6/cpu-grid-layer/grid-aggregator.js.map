{"version":3,"sources":["../../../src/cpu-grid-layer/grid-aggregator.js"],"names":["createIterable","R_EARTH","pointToDensityGridDataCPU","points","cellSize","getPosition","_pointsToGridHashing","gridHash","gridOffset","layerData","_getGridLayerDataFromGridHash","latMin","Infinity","latMax","pLat","iterable","objectInfo","pt","index","Number","isFinite","centerLat","_calculateGridLatLonOffset","xOffset","yOffset","lng","lat","latIdx","Math","floor","lonIdx","key","count","push","Object","keys","reduce","accu","i","idxs","split","parseInt","assign","position","latitude","_calculateLatOffset","_calculateLonOffset","dy","PI","dx","cos"],"mappings":"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","sourcesContent":["// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\nimport {createIterable} from '@deck.gl/core';\n\nconst R_EARTH = 6378000;\n\n/**\n * Calculate density grid from an array of points\n * @param {Iterable} points\n * @param {number} cellSize - cell size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid data, cell dimension\n */\nexport function pointToDensityGridDataCPU(points, cellSize, getPosition) {\n  const {gridHash, gridOffset} = _pointsToGridHashing(points, cellSize, getPosition);\n  const layerData = _getGridLayerDataFromGridHash(gridHash, gridOffset);\n\n  return {\n    gridHash,\n    gridOffset,\n    layerData\n  };\n}\n\n/**\n * Project points into each cell, return a hash table of cells\n * @param {Iterable} points\n * @param {number} cellSize - unit size in meters\n * @param {function} getPosition - position accessor\n * @returns {object} - grid hash and cell dimension\n */\n/* eslint-disable max-statements */\nfunction _pointsToGridHashing(points = [], cellSize, getPosition) {\n  // find the geometric center of sample points\n  let latMin = Infinity;\n  let latMax = -Infinity;\n  let pLat;\n\n  const {iterable, objectInfo} = createIterable(points);\n  for (const pt of iterable) {\n    objectInfo.index++;\n    pLat = getPosition(pt, objectInfo)[1];\n    if (Number.isFinite(pLat)) {\n      latMin = pLat < latMin ? pLat : latMin;\n      latMax = pLat > latMax ? pLat : latMax;\n    }\n  }\n\n  const centerLat = (latMin + latMax) / 2;\n\n  const gridOffset = _calculateGridLatLonOffset(cellSize, centerLat);\n\n  if (gridOffset.xOffset <= 0 || gridOffset.yOffset <= 0) {\n    return {gridHash: {}, gridOffset};\n  }\n\n  // calculate count per cell\n  const gridHash = {};\n\n  // Iterating over again, reset index\n  objectInfo.index = -1;\n  for (const pt of iterable) {\n    objectInfo.index++;\n    const [lng, lat] = getPosition(pt, objectInfo);\n\n    if (Number.isFinite(lat) && Number.isFinite(lng)) {\n      const latIdx = Math.floor((lat + 90) / gridOffset.yOffset);\n      const lonIdx = Math.floor((lng + 180) / gridOffset.xOffset);\n      const key = `${latIdx}-${lonIdx}`;\n\n      gridHash[key] = gridHash[key] || {count: 0, points: []};\n      gridHash[key].count += 1;\n      gridHash[key].points.push(pt);\n    }\n  }\n\n  return {gridHash, gridOffset};\n}\n/* eslint-enable max-statements */\n\nfunction _getGridLayerDataFromGridHash(gridHash, gridOffset) {\n  return Object.keys(gridHash).reduce((accu, key, i) => {\n    const idxs = key.split('-');\n    const latIdx = parseInt(idxs[0], 10);\n    const lonIdx = parseInt(idxs[1], 10);\n\n    accu.push(\n      Object.assign(\n        {\n          index: i,\n          position: [-180 + gridOffset.xOffset * lonIdx, -90 + gridOffset.yOffset * latIdx]\n        },\n        gridHash[key]\n      )\n    );\n\n    return accu;\n  }, []);\n}\n\n/**\n * calculate grid layer cell size in lat lon based on world unit size\n * and current latitude\n * @param {number} cellSize\n * @param {number} latitude\n * @returns {object} - lat delta and lon delta\n */\nfunction _calculateGridLatLonOffset(cellSize, latitude) {\n  const yOffset = _calculateLatOffset(cellSize);\n  const xOffset = _calculateLonOffset(latitude, cellSize);\n  return {yOffset, xOffset};\n}\n\n/**\n * with a given x-km change, calculate the increment of latitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} dy - change in km\n * @return {number} - increment in latitude\n */\nfunction _calculateLatOffset(dy) {\n  return (dy / R_EARTH) * (180 / Math.PI);\n}\n\n/**\n * with a given x-km change, and current latitude\n * calculate the increment of longitude\n * based on stackoverflow http://stackoverflow.com/questions/7477003\n * @param {number} lat - latitude of current location (based on city)\n * @param {number} dx - change in km\n * @return {number} - increment in longitude\n */\nfunction _calculateLonOffset(lat, dx) {\n  return ((dx / R_EARTH) * (180 / Math.PI)) / Math.cos((lat * Math.PI) / 180);\n}\n"],"file":"grid-aggregator.js"}