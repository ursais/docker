"use strict";

exports.__esModule = true;
exports.default = void 0;

var _core = require("@superset-ui/core");

var _chartControls = require("@superset-ui/chart-controls");

var _dndControls = require("@superset-ui/chart-controls/lib/shared-controls/dndControls");

/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
const allColumns = {
  type: 'SelectControl',
  default: null,
  mapStateToProps: state => ({
    choices: (0, _chartControls.columnChoices)(state.datasource)
  })
};
const columnsConfig = (0, _core.isFeatureEnabled)(_core.FeatureFlag.ENABLE_EXPLORE_DRAG_AND_DROP) ? _dndControls.dndEntity : allColumns;
const config = {
  controlPanelSections: [_chartControls.sections.legacyRegularTime, {
    label: (0, _core.t)('Query'),
    expanded: true,
    controlSetRows: [[{
      name: 'all_columns_x',
      config: { ...columnsConfig,
        label: (0, _core.t)('Longitude'),
        description: (0, _core.t)('Column containing longitude data')
      }
    }], [{
      name: 'all_columns_y',
      config: { ...columnsConfig,
        label: (0, _core.t)('Latitude'),
        description: (0, _core.t)('Column containing latitude data')
      }
    }], [{
      name: 'clustering_radius',
      config: {
        type: 'SelectControl',
        freeForm: true,
        label: (0, _core.t)('Clustering Radius'),
        default: '60',
        choices: (0, _chartControls.formatSelectOptions)(['0', '20', '40', '60', '80', '100', '200', '500', '1000']),
        description: (0, _core.t)('The radius (in pixels) the algorithm uses to define a cluster. ' + 'Choose 0 to turn off clustering, but beware that a large ' + 'number of points (>1000) will cause lag.')
      }
    }], ['row_limit'], ['adhoc_filters'], ['groupby']]
  }, {
    label: (0, _core.t)('Points'),
    controlSetRows: [[{
      name: 'point_radius',
      config: {
        type: 'SelectControl',
        label: (0, _core.t)('Point Radius'),
        default: 'Auto',
        description: (0, _core.t)('The radius of individual points (ones that are not in a cluster). ' + 'Either a numerical column or `Auto`, which scales the point based ' + 'on the largest cluster'),
        mapStateToProps: state => {
          const datasourceChoices = (0, _chartControls.columnChoices)(state.datasource);
          const choices = (0, _chartControls.formatSelectOptions)(['Auto']);
          return {
            choices: choices.concat(datasourceChoices)
          };
        }
      }
    }], [{
      name: 'point_radius_unit',
      config: {
        type: 'SelectControl',
        label: (0, _core.t)('Point Radius Unit'),
        default: 'Pixels',
        choices: (0, _chartControls.formatSelectOptions)(['Pixels', 'Miles', 'Kilometers']),
        description: (0, _core.t)('The unit of measure for the specified point radius')
      }
    }]]
  }, {
    label: (0, _core.t)('Labelling'),
    controlSetRows: [[{
      name: 'mapbox_label',
      config: {
        type: 'SelectControl',
        multi: true,
        label: (0, _core.t)('label'),
        default: [],
        description: (0, _core.t)('`count` is COUNT(*) if a group by is used. ' + 'Numerical columns will be aggregated with the aggregator. ' + 'Non-numerical columns will be used to label points. ' + 'Leave empty to get a count of points in each cluster.'),
        mapStateToProps: state => ({
          choices: (0, _chartControls.columnChoices)(state.datasource)
        })
      }
    }], [{
      name: 'pandas_aggfunc',
      config: {
        type: 'SelectControl',
        label: (0, _core.t)('Cluster label aggregator'),
        clearable: false,
        choices: (0, _chartControls.formatSelectOptions)(['sum', 'mean', 'min', 'max', 'std', 'var']),
        default: 'sum',
        description: (0, _core.t)('Aggregate function applied to the list of points ' + 'in each cluster to produce the cluster label.')
      }
    }]]
  }, {
    label: (0, _core.t)('Visual Tweaks'),
    controlSetRows: [[{
      name: 'render_while_dragging',
      config: {
        type: 'CheckboxControl',
        label: (0, _core.t)('Live render'),
        default: true,
        description: (0, _core.t)('Points and clusters will update as the viewport is being changed')
      }
    }], [{
      name: 'mapbox_style',
      config: {
        type: 'SelectControl',
        label: (0, _core.t)('Map Style'),
        clearable: false,
        renderTrigger: true,
        choices: [['mapbox://styles/mapbox/streets-v9', 'Streets'], ['mapbox://styles/mapbox/dark-v9', 'Dark'], ['mapbox://styles/mapbox/light-v9', 'Light'], ['mapbox://styles/mapbox/satellite-streets-v9', 'Satellite Streets'], ['mapbox://styles/mapbox/satellite-v9', 'Satellite'], ['mapbox://styles/mapbox/outdoors-v9', 'Outdoors']],
        default: 'mapbox://styles/mapbox/light-v9',
        description: (0, _core.t)('Base layer map style')
      }
    }], [{
      name: 'global_opacity',
      config: {
        type: 'TextControl',
        label: (0, _core.t)('Opacity'),
        default: 1,
        isFloat: true,
        description: (0, _core.t)('Opacity of all clusters, points, and labels. Between 0 and 1.')
      }
    }], [{
      name: 'mapbox_color',
      config: {
        type: 'SelectControl',
        freeForm: true,
        label: (0, _core.t)('RGB Color'),
        default: 'rgb(0, 122, 135)',
        choices: [['rgb(0, 139, 139)', 'Dark Cyan'], ['rgb(128, 0, 128)', 'Purple'], ['rgb(255, 215, 0)', 'Gold'], ['rgb(69, 69, 69)', 'Dim Gray'], ['rgb(220, 20, 60)', 'Crimson'], ['rgb(34, 139, 34)', 'Forest Green']],
        description: (0, _core.t)('The color for points and clusters in RGB')
      }
    }]]
  }, {
    label: (0, _core.t)('Viewport'),
    expanded: true,
    controlSetRows: [[{
      name: 'viewport_longitude',
      config: {
        type: 'TextControl',
        label: (0, _core.t)('Default longitude'),
        renderTrigger: true,
        default: -122.405293,
        isFloat: true,
        description: (0, _core.t)('Longitude of default viewport'),
        places: 8,
        // Viewport longitude changes shouldn't prompt user to re-run query
        dontRefreshOnChange: true
      }
    }, {
      name: 'viewport_latitude',
      config: {
        type: 'TextControl',
        label: (0, _core.t)('Default latitude'),
        renderTrigger: true,
        default: 37.772123,
        isFloat: true,
        description: (0, _core.t)('Latitude of default viewport'),
        places: 8,
        // Viewport latitude changes shouldn't prompt user to re-run query
        dontRefreshOnChange: true
      }
    }], [{
      name: 'viewport_zoom',
      config: {
        type: 'TextControl',
        label: (0, _core.t)('Zoom'),
        renderTrigger: true,
        isFloat: true,
        default: 11,
        description: (0, _core.t)('Zoom level of the map'),
        places: 8,
        // Viewport zoom shouldn't prompt user to re-run query
        dontRefreshOnChange: true
      }
    }, null]]
  }],
  controlOverrides: {
    groupby: {
      description: (0, _core.t)('One or many controls to group by. If grouping, latitude ' + 'and longitude columns must be present.')
    }
  }
};
var _default = config;
exports.default = _default;