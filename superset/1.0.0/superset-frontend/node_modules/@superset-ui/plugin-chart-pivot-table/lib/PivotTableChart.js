"use strict";

exports.__esModule = true;
exports.default = PivotTableChart;

var _react = _interopRequireWildcard(require("react"));

var _core = require("@superset-ui/core");

var _PivotTable = _interopRequireDefault(require("@superset-ui/react-pivottable/PivotTable"));

var _Utilities = require("@superset-ui/react-pivottable/Utilities");

require("@superset-ui/react-pivottable/pivottable.css");

var _react2 = require("@emotion/react");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
// @ts-ignore
// @ts-ignore
const Styles = _core.styled.div`
  padding: ${({
  theme
}) => theme.gridUnit * 4}px;
  height: ${({
  height
}) => height}px;
  width: ${({
  width
}) => width}px;
  overflow-y: scroll;
  }
`;
const METRIC_KEY = 'metric';

function PivotTableChart(props) {
  const {
    data,
    height,
    width,
    groupbyRows,
    groupbyColumns,
    metrics,
    tableRenderer,
    colOrder,
    rowOrder,
    aggregateFunction,
    transposePivot,
    rowSubtotalPosition,
    colSubtotalPosition,
    colTotals,
    rowTotals,
    valueFormat,
    emitFilter,
    setDataMask,
    selectedFilters,
    verboseMap
  } = props;
  const adaptiveFormatter = (0, _core.getNumberFormatter)(valueFormat);

  const aggregators = (tpl => ({
    Count: tpl.count(adaptiveFormatter),
    'Count Unique Values': tpl.countUnique(adaptiveFormatter),
    'List Unique Values': tpl.listUnique(', '),
    Sum: tpl.sum(adaptiveFormatter),
    Average: tpl.average(adaptiveFormatter),
    Median: tpl.median(adaptiveFormatter),
    'Sample Variance': tpl.var(1, adaptiveFormatter),
    'Sample Standard Deviation': tpl.stdev(1, adaptiveFormatter),
    Minimum: tpl.min(adaptiveFormatter),
    Maximum: tpl.max(adaptiveFormatter),
    First: tpl.first(adaptiveFormatter),
    Last: tpl.last(adaptiveFormatter),
    'Sum as Fraction of Total': tpl.fractionOf(tpl.sum(), 'total', adaptiveFormatter),
    'Sum as Fraction of Rows': tpl.fractionOf(tpl.sum(), 'row', adaptiveFormatter),
    'Sum as Fraction of Columns': tpl.fractionOf(tpl.sum(), 'col', adaptiveFormatter),
    'Count as Fraction of Total': tpl.fractionOf(tpl.count(), 'total', adaptiveFormatter),
    'Count as Fraction of Rows': tpl.fractionOf(tpl.count(), 'row', adaptiveFormatter),
    'Count as Fraction of Columns': tpl.fractionOf(tpl.count(), 'col', adaptiveFormatter)
  }))(_Utilities.aggregatorTemplates);

  const metricNames = metrics.map(metric => typeof metric === 'string' ? metric : metric.label);
  const unpivotedData = data.reduce((acc, record) => [...acc, ...metricNames.map(name => ({ ...record,
    [METRIC_KEY]: name,
    value: record[name]
  }))], []);
  const [rows, cols] = transposePivot ? [groupbyColumns, [METRIC_KEY, ...groupbyRows]] : [groupbyRows, [METRIC_KEY, ...groupbyColumns]];
  const handleChange = (0, _react.useCallback)(filters => {
    const groupBy = Object.keys(filters);
    setDataMask({
      extraFormData: {
        filters: groupBy.length === 0 ? undefined : groupBy.map(col => {
          const val = filters == null ? void 0 : filters[col];
          if (val === null || val === undefined) return {
            col,
            op: 'IS NULL'
          };
          return {
            col,
            op: 'IN',
            val: val
          };
        })
      },
      filterState: {
        value: filters && Object.keys(filters).length ? Object.values(filters) : null,
        selectedFilters: filters && Object.keys(filters).length ? filters : null
      }
    });
  }, [setDataMask]);
  const isActiveFilterValue = (0, _react.useCallback)((key, val) => {
    var _selectedFilters$key;

    return !!selectedFilters && ((_selectedFilters$key = selectedFilters[key]) == null ? void 0 : _selectedFilters$key.includes(val));
  }, [selectedFilters]);
  const toggleFilter = (0, _react.useCallback)((e, value, filters, pivotData, isSubtotal, isGrandTotal) => {
    if (isSubtotal || isGrandTotal || !emitFilter) {
      return;
    }

    const filtersCopy = { ...filters
    };
    delete filtersCopy[METRIC_KEY];
    const filtersEntries = Object.entries(filtersCopy);

    if (filtersEntries.length === 0) {
      return;
    }

    const [key, val] = filtersEntries[filtersEntries.length - 1];
    const updatedFilters = { ...(selectedFilters || {})
    };

    if (selectedFilters && isActiveFilterValue(key, val)) {
      updatedFilters[key] = selectedFilters[key].filter(x => x !== val);
    } else {
      updatedFilters[key] = [...((selectedFilters == null ? void 0 : selectedFilters[key]) || []), val];
    }

    if (Array.isArray(updatedFilters[key]) && updatedFilters[key].length === 0) {
      delete updatedFilters[key];
    }

    handleChange(updatedFilters);
  }, [emitFilter, selectedFilters, handleChange]);
  return (0, _react2.jsx)(Styles, {
    height: height,
    width: width
  }, (0, _react2.jsx)(_PivotTable.default, {
    data: unpivotedData,
    rows: rows,
    cols: cols,
    aggregators: aggregators,
    aggregatorName: aggregateFunction,
    vals: ['value'],
    rendererName: tableRenderer,
    colOrder: colOrder,
    rowOrder: rowOrder,
    sorters: {
      metric: (0, _Utilities.sortAs)(metricNames)
    },
    tableOptions: {
      clickRowHeaderCallback: toggleFilter,
      clickColumnHeaderCallback: toggleFilter,
      colTotals,
      rowTotals,
      highlightHeaderCellsOnHover: emitFilter,
      highlightedHeaderCells: selectedFilters,
      omittedHighlightHeaderGroups: [METRIC_KEY]
    },
    subtotalOptions: {
      colSubtotalDisplay: {
        displayOnTop: colSubtotalPosition
      },
      rowSubtotalDisplay: {
        displayOnTop: rowSubtotalPosition
      }
    },
    namesMapping: verboseMap
  }));
}