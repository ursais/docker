"use strict";

exports.__esModule = true;
exports.extractTimeseriesSeries = extractTimeseriesSeries;
exports.formatSeriesName = formatSeriesName;
exports.extractGroupbyLabel = extractGroupbyLabel;
exports.getLegendProps = getLegendProps;
exports.getChartPadding = getChartPadding;
exports.dedupSeries = dedupSeries;
exports.getColtypesMapping = void 0;

var _core = require("@superset-ui/core");

var _constants = require("../constants");

var _types = require("../types");

var _defaults = require("../defaults");

/* eslint-disable no-underscore-dangle */

/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
function isDefined(value) {
  return value !== undefined && value !== null;
}

function extractTimeseriesSeries(data, opts = {}) {
  const {
    fillNeighborValue
  } = opts;
  if (data.length === 0) return [];
  const rows = data.map(datum => ({ ...datum,
    __timestamp: datum.__timestamp || datum.__timestamp === 0 ? new Date(datum.__timestamp) : null
  }));
  return Object.keys(rows[0]).filter(key => key !== '__timestamp').map(key => ({
    id: key,
    name: key,
    data: rows.map((row, idx) => {
      var _rows, _rows2;

      const isNextToDefinedValue = isDefined((_rows = rows[idx - 1]) == null ? void 0 : _rows[key]) || isDefined((_rows2 = rows[idx + 1]) == null ? void 0 : _rows2[key]);
      return [row.__timestamp, !isDefined(row[key]) && isNextToDefinedValue && fillNeighborValue !== undefined ? fillNeighborValue : row[key]];
    })
  }));
}

function formatSeriesName(name, {
  numberFormatter,
  timeFormatter,
  coltype
} = {}) {
  if (name === undefined || name === null) {
    return _constants.NULL_STRING;
  }

  if (typeof name === 'number') {
    return numberFormatter ? numberFormatter(name) : name.toString();
  }

  if (typeof name === 'boolean') {
    return name.toString();
  }

  if (name instanceof Date || coltype === _core.GenericDataType.TEMPORAL) {
    const d = name instanceof Date ? name : new Date(name);
    return timeFormatter ? timeFormatter(d) : d.toISOString();
  }

  return name;
}

const getColtypesMapping = ({
  coltypes = [],
  colnames = []
}) => colnames.reduce((accumulator, item, index) => ({ ...accumulator,
  [item]: coltypes[index]
}), {});

exports.getColtypesMapping = getColtypesMapping;

function extractGroupbyLabel({
  datum = {},
  groupby,
  numberFormatter,
  timeFormatter,
  coltypeMapping = {}
}) {
  return (groupby || []).map(val => formatSeriesName(datum[val], {
    numberFormatter,
    timeFormatter,
    ...(coltypeMapping[val] && {
      coltype: coltypeMapping[val]
    })
  })).join(', ');
}

function getLegendProps(type, orientation, show, zoomable = false) {
  const legend = {
    orient: [_types.LegendOrientation.Top, _types.LegendOrientation.Bottom].includes(orientation) ? 'horizontal' : 'vertical',
    show,
    type
  };

  switch (orientation) {
    case _types.LegendOrientation.Left:
      legend.left = 0;
      break;

    case _types.LegendOrientation.Right:
      legend.right = 0;
      legend.top = zoomable ? _constants.TIMESERIES_CONSTANTS.legendRightTopOffset : 0;
      break;

    case _types.LegendOrientation.Bottom:
      legend.bottom = 0;
      break;

    case _types.LegendOrientation.Top:
    default:
      legend.top = 0;
      legend.right = zoomable ? _constants.TIMESERIES_CONSTANTS.legendTopRightOffset : 0;
      break;
  }

  return legend;
}

function getChartPadding(show, orientation, margin, padding) {
  let legendMargin;

  if (!show) {
    legendMargin = 0;
  } else if (margin === null || margin === undefined || typeof margin === 'string') {
    legendMargin = _defaults.defaultLegendPadding[orientation];
  } else {
    legendMargin = margin;
  }

  const {
    bottom = 0,
    left = 0,
    right = 0,
    top = 0
  } = padding || {};
  return {
    left: left + (orientation === _types.LegendOrientation.Left ? legendMargin : 0),
    right: right + (orientation === _types.LegendOrientation.Right ? legendMargin : 0),
    top: top + (orientation === _types.LegendOrientation.Top ? legendMargin : 0),
    bottom: bottom + (orientation === _types.LegendOrientation.Bottom ? legendMargin : 0)
  };
}

function dedupSeries(series) {
  const counter = new Map();
  return series.map(row => {
    let {
      id
    } = row;
    if (id === undefined) return row;
    id = String(id);
    const count = counter.get(id) || 0;
    const suffix = count > 0 ? ` (${count})` : '';
    counter.set(id, count + 1);
    return { ...row,
      id: `${id}${suffix}`
    };
  });
}