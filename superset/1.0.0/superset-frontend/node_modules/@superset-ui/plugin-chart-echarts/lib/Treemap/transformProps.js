"use strict";

exports.__esModule = true;
exports.formatLabel = formatLabel;
exports.formatTooltip = formatTooltip;
exports.default = transformProps;

var _core = require("@superset-ui/core");

var _lodash = require("lodash");

var _types = require("./types");

var _series = require("../utils/series");

var _defaults = require("../defaults");

var _constants = require("./constants");

/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */
function formatLabel({
  params,
  labelType,
  numberFormatter
}) {
  const {
    name = '',
    value
  } = params;
  const formattedValue = numberFormatter(value);

  switch (labelType) {
    case _types.EchartsTreemapLabelType.Key:
      return name;

    case _types.EchartsTreemapLabelType.Value:
      return formattedValue;

    case _types.EchartsTreemapLabelType.KeyValue:
      return `${name}: ${formattedValue}`;

    default:
      return name;
  }
}

function formatTooltip({
  params,
  numberFormatter
}) {
  const {
    value,
    treePathInfo = []
  } = params;
  const formattedValue = numberFormatter(value);
  const {
    metricLabel,
    treePath
  } = (0, _constants.extractTreePathInfo)(treePathInfo);
  const percentFormatter = (0, _core.getNumberFormatter)(_core.NumberFormats.PERCENT_2_POINT);
  let formattedPercent = ''; // the last item is current node, here we should find the parent node

  const currentNode = treePathInfo[treePathInfo.length - 1];
  const parentNode = treePathInfo[treePathInfo.length - 2];

  if (parentNode) {
    const percent = parentNode.value ? currentNode.value / parentNode.value : 0;
    formattedPercent = percentFormatter(percent);
  } // groupby1/groupby2/...
  // metric: value (percent of parent)


  return [`<div>${treePath.join(' â–¸ ')}</div>`, `${metricLabel}: ${formattedValue}`, formattedPercent ? ` (${formattedPercent})` : ''].join('');
}

function transformProps(chartProps) {
  const {
    formData,
    height,
    queriesData,
    width,
    hooks,
    filterState
  } = chartProps;
  const {
    data = []
  } = queriesData[0];
  const {
    setDataMask = () => {}
  } = hooks;
  const coltypeMapping = (0, _series.getColtypesMapping)(queriesData[0]);
  const {
    colorScheme,
    groupby = [],
    metric = '',
    labelType,
    labelPosition,
    numberFormat,
    dateFormat,
    showLabels,
    showUpperLabels,
    dashboardId,
    emitFilter
  } = { ..._types.DEFAULT_FORM_DATA,
    ...formData
  };

  const colorFn = _core.CategoricalColorNamespace.getScale(colorScheme);

  const numberFormatter = (0, _core.getNumberFormatter)(numberFormat);

  const formatter = params => formatLabel({
    params,
    numberFormatter,
    labelType
  });

  const columnsLabelMap = new Map();

  const transformer = (data, groupbyData, metric, depth, path) => {
    const [currGroupby, ...restGroupby] = groupbyData;
    const currGrouping = (0, _lodash.groupBy)(data, currGroupby);

    if (!restGroupby.length) {
      return (0, _lodash.transform)(currGrouping, (result, value, key) => {
        (value != null ? value : []).forEach(datum => {
          const name = (0, _series.formatSeriesName)(key, {
            numberFormatter,
            timeFormatter: (0, _core.getTimeFormatter)(dateFormat),
            ...(coltypeMapping[currGroupby] && {
              coltype: coltypeMapping[currGroupby]
            })
          });
          const item = {
            name,
            value: (0, _lodash.isNumber)(datum[metric]) ? datum[metric] : 0
          };
          const joinedName = path.concat(name).join(','); // map(joined_name: [columnLabel_1, columnLabel_2, ...])

          columnsLabelMap.set(joinedName, path.concat(name));

          if (filterState.selectedValues && !filterState.selectedValues.includes(joinedName)) {
            item.itemStyle = {
              colorAlpha: _constants.COLOR_ALPHA
            };
            item.label = {
              color: `rgba(0, 0, 0, ${_constants.COLOR_ALPHA})`
            };
          }

          result.push(item);
        });
      }, []);
    }

    const sortedData = (0, _lodash.transform)(currGrouping, (result, value, key) => {
      const name = (0, _series.formatSeriesName)(key, {
        numberFormatter,
        timeFormatter: (0, _core.getTimeFormatter)(dateFormat),
        ...(coltypeMapping[currGroupby] && {
          coltype: coltypeMapping[currGroupby]
        })
      });
      const children = transformer(value, restGroupby, metric, depth + 1, path.concat(name));
      result.push({
        name,
        children,
        value: children.reduce((prev, cur) => prev + cur.value, 0)
      });
      result.sort((a, b) => b.value - a.value);
    }, []); // sort according to the area and then take the color value in order

    return sortedData.map(child => ({ ...child,
      colorSaturation: _constants.COLOR_SATURATION,
      itemStyle: {
        borderColor: _constants.BORDER_COLOR,
        color: colorFn(`${child.name}_${depth}`),
        borderWidth: _constants.BORDER_WIDTH,
        gapWidth: _constants.GAP_WIDTH
      }
    }));
  };

  const metricLabel = (0, _core.getMetricLabel)(metric);
  const initialDepth = 1;
  const transformedData = [{
    name: metricLabel,
    colorSaturation: _constants.COLOR_SATURATION,
    itemStyle: {
      borderColor: _constants.BORDER_COLOR,
      borderWidth: _constants.BORDER_WIDTH,
      gapWidth: _constants.GAP_WIDTH
    },
    upperLabel: {
      show: false
    },
    children: transformer(data, groupby, metricLabel, initialDepth, [])
  }]; // set a default color when metric values are 0 over all.

  const levels = [{
    upperLabel: {
      show: false
    },
    label: {
      show: false
    },
    itemStyle: {
      color: _core.CategoricalColorNamespace.getColor()
    }
  }];
  const series = [{
    type: 'treemap',
    animation: false,
    width: '100%',
    height: '100%',
    nodeClick: dashboardId ? undefined : 'zoomToNode',
    roam: !dashboardId,
    breadcrumb: {
      show: false,
      emptyItemWidth: 25
    },
    emphasis: {
      label: {
        show: true
      }
    },
    levels,
    label: {
      show: showLabels,
      position: labelPosition,
      formatter,
      color: '#000',
      fontSize: _constants.LABEL_FONTSIZE
    },
    upperLabel: {
      show: showUpperLabels,
      formatter,
      textBorderColor: 'transparent',
      fontSize: _constants.LABEL_FONTSIZE
    },
    data: transformedData
  }];
  const echartOptions = {
    tooltip: { ..._defaults.defaultTooltip,
      trigger: 'item',
      formatter: params => formatTooltip({
        params,
        numberFormatter
      })
    },
    series
  };
  return {
    formData,
    width,
    height,
    echartOptions,
    setDataMask,
    emitFilter,
    labelMap: Object.fromEntries(columnsLabelMap),
    groupby,
    selectedValues: filterState.selectedValues || []
  };
}