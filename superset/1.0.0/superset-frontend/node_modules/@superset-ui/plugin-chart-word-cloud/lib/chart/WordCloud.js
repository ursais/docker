"use strict";

exports.__esModule = true;
exports.default = exports.ROTATION = void 0;

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _d3Cloud = _interopRequireDefault(require("d3-cloud"));

var _encodable = require("encodable");

var _core = require("@superset-ui/core");

var _react2 = require("@emotion/react");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const ROTATION = {
  flat: () => 0,
  // this calculates a random rotation between -90 and 90 degrees.
  random: () => Math.floor((0, _core.seedRandom)() * 6 - 3) * 30,
  square: () => Math.floor((0, _core.seedRandom)() * 2) * 90
};
exports.ROTATION = ROTATION;
const defaultProps = {
  encoding: {},
  rotation: 'flat'
};
const SCALE_FACTOR_STEP = 0.5;
const MAX_SCALE_FACTOR = 3; // Percentage of top results that will always be displayed.
// Needed to avoid clutter when shrinking a chart with many records.

const TOP_RESULTS_PERCENTAGE = 0.1;

class WordCloud extends _react.default.PureComponent {
  // Cannot name it isMounted because of conflict
  // with React's component function name
  constructor(props) {
    super(props);
    this.isComponentMounted = false;
    this.wordCloudEncoderFactory = (0, _encodable.createEncoderFactory)({
      channelTypes: {
        color: 'Color',
        fontFamily: 'Category',
        fontSize: 'Numeric',
        fontWeight: 'Category',
        text: 'Text'
      },
      defaultEncoding: {
        color: {
          value: 'black'
        },
        fontFamily: {
          value: this.props.theme.typography.families.sansSerif
        },
        fontSize: {
          value: 20
        },
        fontWeight: {
          value: 'bold'
        },
        text: {
          value: ''
        }
      }
    });
    this.createEncoder = this.wordCloudEncoderFactory.createSelector();
    this.state = {
      words: [],
      scaleFactor: 1
    };
    this.setWords = this.setWords.bind(this);
  }

  componentDidMount() {
    this.isComponentMounted = true;
    this.update();
  }

  componentDidUpdate(prevProps) {
    const {
      data,
      encoding,
      width,
      height,
      rotation
    } = this.props;

    if (prevProps.data !== data || prevProps.encoding !== encoding || prevProps.width !== width || prevProps.height !== height || prevProps.rotation !== rotation) {
      this.update();
    }
  }

  componentWillUnmount() {
    this.isComponentMounted = false;
  }

  setWords(words) {
    if (this.isComponentMounted) {
      this.setState({
        words
      });
    }
  }

  update() {
    const {
      data,
      encoding
    } = this.props;
    const encoder = this.createEncoder(encoding);
    encoder.setDomainFromDataset(data);
    const sortedData = [...data].sort((a, b) => encoder.channels.fontSize.encodeDatum(b, 0) - encoder.channels.fontSize.encodeDatum(a, 0));
    const topResultsCount = Math.max(sortedData.length * TOP_RESULTS_PERCENTAGE, 10);
    const topResults = sortedData.slice(0, topResultsCount); // Ensure top results are always included in the final word cloud by scaling chart down if needed

    this.generateCloud(encoder, 1, words => topResults.every(d => words.find(({
      text
    }) => encoder.channels.text.getValueFromDatum(d) === text)));
  }

  generateCloud(encoder, scaleFactor, isValid) {
    const {
      data,
      width,
      height,
      rotation
    } = this.props;
    (0, _d3Cloud.default)().size([width * scaleFactor, height * scaleFactor]) // clone the data because cloudLayout mutates input
    .words(data.map(d => ({ ...d
    }))).padding(5).rotate(ROTATION[rotation] || ROTATION.flat).text(d => encoder.channels.text.getValueFromDatum(d)).font(d => encoder.channels.fontFamily.encodeDatum(d, this.props.theme.typography.families.sansSerif)).fontWeight(d => encoder.channels.fontWeight.encodeDatum(d, 'normal')).fontSize(d => encoder.channels.fontSize.encodeDatum(d, 0)).on('end', words => {
      if (isValid(words) || scaleFactor > MAX_SCALE_FACTOR) {
        if (this.isComponentMounted) {
          this.setState({
            words,
            scaleFactor
          });
        }
      } else {
        this.generateCloud(encoder, scaleFactor + SCALE_FACTOR_STEP, isValid);
      }
    }).start();
  }

  render() {
    const {
      scaleFactor
    } = this.state;
    const {
      width,
      height,
      encoding
    } = this.props;
    const {
      words
    } = this.state;
    const encoder = this.createEncoder(encoding);
    encoder.channels.color.setDomainFromDataset(words);
    const viewBoxWidth = width * scaleFactor;
    const viewBoxHeight = height * scaleFactor;
    return (0, _react2.jsx)("svg", {
      width: width,
      height: height,
      viewBox: `-${viewBoxWidth / 2} -${viewBoxHeight / 2} ${viewBoxWidth} ${viewBoxHeight}`
    }, (0, _react2.jsx)("g", null, words.map(w => (0, _react2.jsx)("text", {
      key: w.text,
      fontSize: `${w.size}px`,
      fontWeight: w.weight,
      fontFamily: w.font,
      fill: encoder.channels.color.encodeDatum(w, ''),
      textAnchor: "middle",
      transform: `translate(${w.x}, ${w.y}) rotate(${w.rotate})`
    }, w.text))));
  }

}

WordCloud.propTypes = {
  rotation: _propTypes.default.any,
  data: _propTypes.default.array.isRequired,
  height: _propTypes.default.number.isRequired,
  width: _propTypes.default.number.isRequired
};
WordCloud.defaultProps = defaultProps;

var _default = (0, _core.withTheme)(WordCloud);

exports.default = _default;