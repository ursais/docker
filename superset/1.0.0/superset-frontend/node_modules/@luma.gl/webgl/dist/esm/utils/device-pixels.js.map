{"version":3,"sources":["../../../src/utils/device-pixels.js"],"names":["cssToDeviceRatio","gl","canvas","drawingBufferWidth","clientWidth","width","cssToDevicePixels","cssPixel","yInvert","ratio","height","drawingBufferHeight","scalePixels","getDevicePixelRatio","useDevicePixels","windowRatio","window","devicePixelRatio","Number","isFinite","pixel","x","scaleX","y","scaleY","t","xHigh","yHigh","Math","max","r","min","round"],"mappings":"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","sourcesContent":["/* global window */\n\n// multiplier need to convert CSS size to Device size\nexport function cssToDeviceRatio(gl) {\n  if (gl.canvas) {\n    return gl.drawingBufferWidth / (gl.canvas.clientWidth || gl.canvas.width || 1);\n  }\n  // use default device pixel ratio\n  return 1;\n}\n\n// Maps CSS pixel position to device pixel position\nexport function cssToDevicePixels(gl, cssPixel, yInvert = true) {\n  const ratio = cssToDeviceRatio(gl);\n  const width = gl.drawingBufferWidth;\n  const height = gl.drawingBufferHeight;\n  return scalePixels(cssPixel, ratio, width, height, yInvert);\n}\n\n// HELPER METHODS\n\n/**\n * Calulates device pixel ratio, used during context creation\n *\n * @param {boolean or Number} useDevicePixels - boolean or a Number\n * @return {Number} - device pixel ratio\n */\nexport function getDevicePixelRatio(useDevicePixels) {\n  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;\n  if (Number.isFinite(useDevicePixels)) {\n    return useDevicePixels <= 0 ? 1 : useDevicePixels;\n  }\n  return useDevicePixels ? windowRatio : 1;\n}\n\n// PRIVATE\n\nfunction scalePixels(pixel, ratio, width, height, yInvert) {\n  const x = scaleX(pixel[0], ratio, width);\n  let y = scaleY(pixel[1], ratio, height, yInvert);\n\n  // Find boundaries of next pixel to provide valid range of device pixel locaitons\n\n  let t = scaleX(pixel[0] + 1, ratio, width);\n  // If next pixel's position is clamped to boundary, use it as is, otherwise subtract 1 for current pixel boundary\n  const xHigh = t === width - 1 ? t : t - 1;\n\n  t = scaleY(pixel[1] + 1, ratio, height, yInvert);\n  let yHigh;\n  if (yInvert) {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    t = t === 0 ? t : t + 1;\n    // swap y and yHigh\n    yHigh = y;\n    y = t;\n  } else {\n    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range\n    yHigh = t === height - 1 ? t : t - 1;\n    // y remains same\n  }\n  return {\n    x,\n    y,\n    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.\n    width: Math.max(xHigh - x + 1, 1),\n    height: Math.max(yHigh - y + 1, 1)\n  };\n}\n\nfunction scaleX(x, ratio, width) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  const r = Math.min(Math.round(x * ratio), width - 1);\n  return r;\n}\n\nfunction scaleY(y, ratio, height, yInvert) {\n  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit\n  return yInvert\n    ? Math.max(0, height - 1 - Math.round(y * ratio))\n    : Math.min(Math.round(y * ratio), height - 1);\n}\n"],"file":"device-pixels.js"}