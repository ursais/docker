import _objectSpread from "@babel/runtime/helpers/esm/objectSpread";
import { trackContextState } from '@luma.gl/webgl-state-tracker';
import { createHeadlessContext } from './create-headless-context';
import { getCanvas } from './create-canvas';
import { createBrowserContext } from './create-browser-context';
import { getContextDebugInfo } from '../debug/get-context-debug-info';
import { WebGL2RenderingContext } from '../webgl-utils';
import { log as _log, isBrowser, assert, getDevicePixelRatio } from '../utils';
import { global } from '../utils/globals';
export const ERR_CONTEXT = 'Invalid WebGLRenderingContext';
export const ERR_WEBGL = ERR_CONTEXT;
export const ERR_WEBGL2 = 'Requires WebGL2';
export function isWebGL(gl) {
  return Boolean(gl && Number.isFinite(gl._version));
}
export function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}
export function assertWebGLContext(gl) {
  assert(isWebGL(gl), ERR_CONTEXT);
}
export function assertWebGL2Context(gl) {
  assert(isWebGL2(gl), ERR_WEBGL2);
}
const contextDefaults = {
  webgl2: true,
  webgl1: true,
  throwOnFailure: true,
  manageState: true,
  canvas: null,
  debug: false,
  width: 800,
  height: 600
};
export function setGLContextDefaults(options = {}) {
  Object.assign(contextDefaults, {
    width: 1,
    height: 1
  }, options);
}
export function createGLContext(options = {}) {
  options = Object.assign({}, contextDefaults, options);
  const {
    width,
    height
  } = options;

  function onError(message) {
    if (options.throwOnError) {
      throw new Error(message);
    }

    return null;
  }

  let gl;

  if (isBrowser) {
    const {
      canvas
    } = options;
    const targetCanvas = getCanvas({
      canvas,
      width,
      height,
      onError
    });
    gl = createBrowserContext(targetCanvas, options);
  } else {
    gl = createHeadlessContext(_objectSpread({}, options, {
      width,
      height,
      onError
    }));
  }

  if (!gl) {
    return null;
  }

  gl = instrumentGLContext(gl, options);
  logInfo(gl);
  return gl;
}
export function instrumentGLContext(gl, options = {}) {
  if (gl._instrumented) {
    return gl;
  }

  gl._version = gl._version || getVersion(gl);
  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  options = Object.assign({}, contextDefaults, options);
  const {
    manageState,
    debug
  } = options;

  if (manageState) {
    trackContextState(gl, {
      copyState: false,
      log: (...args) => _log.log(1, ...args)()
    });
  }

  if (isBrowser && debug) {
    if (!global.makeDebugContext) {
      _log.warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
    } else {
      gl = global.makeDebugContext(gl, options);
      _log.priority = Math.max(_log.priority, 1);
    }
  }

  gl._instrumented = true;
  return gl;
}
export function destroyGLContext(gl) {
  const ext = gl.getExtension('STACKGL_destroy_context');

  if (ext) {
    ext.destroy();
  }
}
export function resizeGLContext(gl, options = {}) {
  if (gl.canvas) {
    const devicePixelRatio = getDevicePixelRatio(options.useDevicePixels);
    setDevicePixelRatio(gl, devicePixelRatio, options);
    return;
  }

  const ext = gl.getExtension('STACKGL_resize_drawingbuffer');

  if (ext && "width" in options && "height" in options) {
    ext.resize(options.width, options.height);
  }
}

function logInfo(gl) {
  const webGL = isWebGL2(gl) ? 'WebGL2' : 'WebGL1';
  const info = getContextDebugInfo(gl);
  const driver = info ? "(".concat(info.vendor, ",").concat(info.renderer, ")") : '';
  const debug = gl.debug ? ' debug' : '';

  _log.info(1, "".concat(webGL).concat(debug, " context ").concat(driver))();
}

function getVersion(gl) {
  if (typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext) {
    return 2;
  }

  return 1;
}

function setDevicePixelRatio(gl, devicePixelRatio, options) {
  const clientWidth = 'width' in options ? options.width : gl.canvas.clientWidth || gl.canvas.width || 1;
  const clientHeight = 'height' in options ? options.height : gl.canvas.clientHeight || gl.canvas.height || 1;
  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  const cachedSize = gl.luma.canvasSizeInfo;

  if (cachedSize.clientWidth !== clientWidth || cachedSize.clientHeight !== clientHeight || cachedSize.devicePixelRatio !== devicePixelRatio) {
    let clampedPixelRatio = devicePixelRatio;
    const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
    const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
    gl.canvas.width = canvasWidth;
    gl.canvas.height = canvasHeight;

    if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
      _log.warn("Device pixel ratio clamped")();

      clampedPixelRatio = Math.min(gl.drawingBufferWidth / clientWidth, gl.drawingBufferHeight / clientHeight);
      gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
      gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
    }

    Object.assign(gl.luma.canvasSizeInfo, {
      clientWidth,
      clientHeight,
      devicePixelRatio
    });
  }
}
//# sourceMappingURL=context.js.map