{"version":3,"sources":["../../../../src/lib/transform/texture-transform.js"],"names":["SRC_TEX_PARAMETER_OVERRIDES","FS_OUTPUT_VARIABLE","TextureTransform","gl","props","currentIndex","_swapTexture","targetTextureVarying","targetTextureType","samplerTextureMap","bindings","resources","_initialize","Object","seal","updatedModelProps","_processVertexShader","assign","opts","sourceTextures","framebuffer","targetTexture","attributes","uniforms","parameters","discard","hasSourceTextures","hasTargetTexture","transform_elementID","elementIDBuffer","sampler","textureName","_setSourceTextureParameters","sizeUniforms","sourceTextureMap","viewport","width","height","_getNextIndex","_setupTextures","packed","pixels","ArrayType","constructor","channelCount","packedPixels","length","packCount","i","j","currentResources","ownTexture","_targetTextureVarying","textureOrReference","Texture2D","refTexture","_targetRefTexName","_createNewTexture","_sourceTextures","_targetTexture","_createTargetTexture","keys","_updateBindings","_updateElementIDBuffer","elementCount","elementIds","Float32Array","forEach","_","index","array","Buffer","data","accessor","size","setData","_updateBinding","_swapTextures","nextIndex","binding","update","attachments","resizeAttachments","resize","Framebuffer","id","name","setParameters","texture","pixelStore","vs","inject","combinedInject","fs","_fs","version","input","inputType","output","modules","transformModule","concat"],"mappings":"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","sourcesContent":["import GL from '@luma.gl/constants';\nimport {\n  cloneTextureFrom,\n  readPixelsToArray,\n  getShaderVersion,\n  Buffer,\n  Texture2D,\n  Framebuffer\n} from '@luma.gl/webgl';\nimport {\n  _transform as transformModule,\n  getPassthroughFS,\n  typeToChannelCount,\n  combineInjects\n} from '@luma.gl/shadertools';\nimport {updateForTextures, getSizeUniforms} from './transform-shader-utils';\n\n// TODO: move these constants to transform-shader-utils\n// Texture parameters needed so sample can precisely pick pixel for given element id.\nconst SRC_TEX_PARAMETER_OVERRIDES = {\n  [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n};\nconst FS_OUTPUT_VARIABLE = 'transform_output';\n\nexport default class TextureTransform {\n  constructor(gl, props = {}) {\n    this.gl = gl;\n    this.currentIndex = 0;\n    this._swapTexture = null;\n    this.targetTextureVarying = null;\n    this.targetTextureType = null;\n    this.samplerTextureMap = null;\n    this.bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}\n\n    this.resources = {}; // resources to be deleted\n\n    this._initialize(props);\n    Object.seal(this);\n  }\n\n  updateModelProps(props = {}) {\n    const updatedModelProps = this._processVertexShader(props);\n    return Object.assign({}, props, updatedModelProps);\n  }\n\n  getDrawOptions(opts = {}) {\n    const {sourceTextures, framebuffer, targetTexture} = this.bindings[this.currentIndex];\n\n    const attributes = Object.assign({}, opts.attributes);\n    const uniforms = Object.assign({}, opts.uniforms);\n    const parameters = Object.assign({}, opts.parameters);\n    let discard = opts.discard;\n\n    if (this.hasSourceTextures || this.hasTargetTexture) {\n      attributes.transform_elementID = this.elementIDBuffer;\n\n      for (const sampler in this.samplerTextureMap) {\n        const textureName = this.samplerTextureMap[sampler];\n        uniforms[sampler] = sourceTextures[textureName];\n      }\n      this._setSourceTextureParameters();\n      // get texture size uniforms\n      const sizeUniforms = getSizeUniforms({\n        sourceTextureMap: sourceTextures,\n        targetTextureVarying: this.targetTextureVarying,\n        targetTexture\n      });\n      Object.assign(uniforms, sizeUniforms);\n    }\n\n    if (this.hasTargetTexture) {\n      discard = false;\n      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];\n    }\n\n    return {attributes, framebuffer, uniforms, discard, parameters};\n  }\n\n  swap() {\n    if (this._swapTexture) {\n      this.currentIndex = this._getNextIndex();\n      return true;\n    }\n    return false;\n  }\n\n  // update source and/or feedbackBuffers\n  update(opts = {}) {\n    this._setupTextures(opts);\n  }\n\n  // returns current target texture\n  getTargetTexture() {\n    const {targetTexture} = this.bindings[this.currentIndex];\n    return targetTexture;\n  }\n\n  getData({packed = false} = {}) {\n    const {framebuffer} = this.bindings[this.currentIndex];\n    const pixels = readPixelsToArray(framebuffer);\n\n    if (!packed) {\n      return pixels;\n    }\n\n    // readPixels returns 4 elements for each pixel, pack the elements when requested\n    const ArrayType = pixels.constructor;\n    const channelCount = typeToChannelCount(this.targetTextureType);\n    const packedPixels = new ArrayType((pixels.length * channelCount) / 4);\n    let packCount = 0;\n    for (let i = 0; i < pixels.length; i += 4) {\n      for (let j = 0; j < channelCount; j++) {\n        packedPixels[packCount++] = pixels[i + j];\n      }\n    }\n    return packedPixels;\n  }\n\n  // returns current framebuffer object that is being used.\n  getFramebuffer() {\n    const currentResources = this.bindings[this.currentIndex];\n    return currentResources.framebuffer;\n  }\n\n  // Delete owned resources.\n  delete() {\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    if (this.elementIDBuffer) {\n      this.elementIDBuffer.delete();\n    }\n  }\n\n  // Private\n\n  _initialize(props = {}) {\n    const {_targetTextureVarying, _swapTexture} = props;\n    this._swapTexture = _swapTexture;\n    this.targetTextureVarying = _targetTextureVarying;\n    this.hasTargetTexture = _targetTextureVarying;\n    this._setupTextures(props);\n  }\n\n  // auto create target texture if requested\n  _createTargetTexture(props) {\n    const {sourceTextures, textureOrReference} = props;\n    if (textureOrReference instanceof Texture2D) {\n      return textureOrReference;\n    }\n    // 'targetTexture' is a reference souce texture.\n    const refTexture = sourceTextures[textureOrReference];\n    if (!refTexture) {\n      return null;\n    }\n\n    // save reference texture name, when corresponding source texture is updated\n    // we also update target texture.\n    this._targetRefTexName = textureOrReference;\n\n    return this._createNewTexture(refTexture);\n  }\n\n  _setupTextures(props = {}) {\n    const {_sourceTextures = {}, _targetTexture} = props;\n    const targetTexture = this._createTargetTexture({\n      sourceTextures: _sourceTextures,\n      textureOrReference: _targetTexture\n    });\n    this.hasSourceTextures =\n      this.hasSourceTextures || (_sourceTextures && Object.keys(_sourceTextures).length > 0);\n    this._updateBindings({sourceTextures: _sourceTextures, targetTexture});\n    if ('elementCount' in props) {\n      this._updateElementIDBuffer(props.elementCount);\n    }\n  }\n\n  _updateElementIDBuffer(elementCount) {\n    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {\n      return;\n    }\n    // NOTE: using float so this will work with GLSL 1.0 shaders.\n    const elementIds = new Float32Array(elementCount);\n    elementIds.forEach((_, index, array) => {\n      array[index] = index;\n    });\n    if (!this.elementIDBuffer) {\n      this.elementIDBuffer = new Buffer(this.gl, {\n        data: elementIds,\n        accessor: {size: 1}\n      });\n    } else {\n      this.elementIDBuffer.setData({data: elementIds});\n    }\n    this.elementCount = elementCount;\n  }\n\n  _updateBindings(opts) {\n    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);\n    if (this._swapTexture) {\n      const {sourceTextures, targetTexture} = this._swapTextures(this.bindings[this.currentIndex]);\n      const nextIndex = this._getNextIndex();\n      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {\n        sourceTextures,\n        targetTexture\n      });\n    }\n  }\n\n  _updateBinding(binding, opts) {\n    const {sourceTextures, targetTexture} = opts;\n    if (!binding) {\n      binding = {\n        sourceTextures: {},\n        targetTexture: null\n      };\n    }\n    Object.assign(binding.sourceTextures, sourceTextures);\n    if (targetTexture) {\n      binding.targetTexture = targetTexture;\n\n      const {width, height} = targetTexture;\n      const {framebuffer} = binding;\n      if (framebuffer) {\n        // First update texture without re-sizing attachments\n        framebuffer.update({\n          attachments: {[GL.COLOR_ATTACHMENT0]: targetTexture},\n          resizeAttachments: false\n        });\n        // Resize to new taget texture size\n        framebuffer.resize({width, height});\n      } else {\n        binding.framebuffer = new Framebuffer(this.gl, {\n          id: `${this.id || 'transform'}-framebuffer`,\n          width,\n          height,\n          attachments: {\n            [GL.COLOR_ATTACHMENT0]: targetTexture\n          }\n        });\n      }\n    }\n    return binding;\n  }\n\n  // set texture filtering parameters on source textures.\n  _setSourceTextureParameters() {\n    const index = this.currentIndex;\n    const {sourceTextures} = this.bindings[index];\n    for (const name in sourceTextures) {\n      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);\n    }\n  }\n\n  _swapTextures(opts) {\n    if (!this._swapTexture) {\n      return null;\n    }\n    const sourceTextures = Object.assign({}, opts.sourceTextures);\n    sourceTextures[this._swapTexture] = opts.targetTexture;\n\n    const targetTexture = opts.sourceTextures[this._swapTexture];\n\n    return {sourceTextures, targetTexture};\n  }\n\n  // Create a buffer and add to list of buffers to be deleted.\n  _createNewTexture(refTexture) {\n    const texture = cloneTextureFrom(refTexture, {\n      parameters: {\n        [GL.TEXTURE_MIN_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_MAG_FILTER]: GL.NEAREST,\n        [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\n        [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE\n      },\n      pixelStore: {\n        [GL.UNPACK_FLIP_Y_WEBGL]: false\n      }\n    });\n\n    // thre can only be one target texture\n    if (this.ownTexture) {\n      this.ownTexture.delete();\n    }\n    this.ownTexture = texture;\n\n    return texture;\n  }\n\n  _getNextIndex() {\n    return (this.currentIndex + 1) % 2;\n  }\n\n  // build and return shader releated parameters\n  _processVertexShader(props = {}) {\n    const {sourceTextures, targetTexture} = this.bindings[this.currentIndex];\n    const {vs, uniforms, targetTextureType, inject, samplerTextureMap} = updateForTextures({\n      vs: props.vs,\n      sourceTextureMap: sourceTextures,\n      targetTextureVarying: this.targetTextureVarying,\n      targetTexture\n    });\n    const combinedInject = combineInjects([props.inject || {}, inject]);\n    this.targetTextureType = targetTextureType;\n    this.samplerTextureMap = samplerTextureMap;\n    const fs =\n      props._fs ||\n      getPassthroughFS({\n        version: getShaderVersion(vs),\n        input: this.targetTextureVarying,\n        inputType: targetTextureType,\n        output: FS_OUTPUT_VARIABLE\n      });\n    const modules =\n      this.hasSourceTextures || this.targetTextureVarying\n        ? [transformModule].concat(props.modules || [])\n        : props.modules;\n    return {vs, fs, modules, uniforms, inject: combinedInject};\n  }\n}\n"],"file":"texture-transform.js"}