{"version":3,"sources":["../../../src/lib/shader-cache.js"],"names":["VertexShader","FragmentShader","Program","assert","ShaderCache","gl","_cachePrograms","vertexShaders","fragmentShaders","programs","source","_compareContexts","shader","opts","vs","fs","id","cacheKey","_getProgramKey","program","_resetProgram","_createNewProgram","_checkProgramProp","_isCached","varyings","vertexShader","getVertexShader","fragmentShader","getFragmentShader","Object","assign","reset","gl1","gl2"],"mappings":"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","sourcesContent":["import {VertexShader, FragmentShader, Program} from '@luma.gl/webgl';\nimport {assert} from '../utils';\n\nexport default class ShaderCache {\n  /**\n   * A cache of compiled shaders, keyed by shader source strings.\n   * Compilation of long shaders can be time consuming.\n   * By using this class, the application can ensure that each shader\n   * is only compiled once.\n   */\n  constructor({gl, _cachePrograms = false} = {}) {\n    assert(gl);\n    this.gl = gl;\n    this.vertexShaders = {};\n    this.fragmentShaders = {};\n    this.programs = {};\n    this._cachePrograms = _cachePrograms;\n  }\n\n  /**\n   * Deletes shader references\n   * @return {ShaderCache} - returns this for chaining\n   */\n  delete() {\n    // TODO - requires reference counting to avoid deleting shaders in use\n    return this;\n  }\n\n  /**\n   * Returns a compiled `VertexShader` object corresponding to the supplied\n   * GLSL source code string, if possible from cache.\n   *\n   * @param {WebGLRenderingContext} gl - gl context\n   * @param {String} source - Source code for shader\n   * @return {VertexShader} - a compiled vertex shader\n   */\n  getVertexShader(gl, source) {\n    assert(typeof source === 'string');\n    assert(this._compareContexts(gl, this.gl));\n\n    let shader = this.vertexShaders[source];\n    if (!shader) {\n      shader = new VertexShader(gl, source);\n      this.vertexShaders[source] = shader;\n    }\n    return shader;\n  }\n\n  /**\n   * Returns a compiled `VertexShader` object corresponding to the supplied\n   * GLSL source code string, if possible from cache.\n   * @param {WebGLRenderingContext} gl - gl context\n   * @param {String} source - Source code for shader\n   * @return {FragmentShader} - a compiled fragment shader, possibly from chache\n   */\n  getFragmentShader(gl, source) {\n    assert(typeof source === 'string');\n    assert(this._compareContexts(gl, this.gl));\n\n    let shader = this.fragmentShaders[source];\n    if (!shader) {\n      shader = new FragmentShader(gl, source);\n      this.fragmentShaders[source] = shader;\n    }\n    return shader;\n  }\n\n  // Retrive Shaders from cache if exists, otherwise create new instance.\n  getProgram(gl, opts) {\n    assert(this._compareContexts(gl, this.gl));\n    assert(typeof opts.vs === 'string');\n    assert(typeof opts.fs === 'string');\n    assert(typeof opts.id === 'string');\n\n    const cacheKey = this._getProgramKey(opts);\n    let program = this.programs[cacheKey];\n    if (program) {\n      this._resetProgram(program);\n      return program;\n    }\n\n    program = this._createNewProgram(gl, opts);\n\n    // Check if program can be cached\n    // Program caching is experimental and expects\n    // each Model to have a unique-id (wich is used in key generation)\n    if (this._cachePrograms && this._checkProgramProp(program)) {\n      program._isCached = true;\n      this.programs[cacheKey] = program;\n    }\n\n    return program;\n  }\n\n  _getProgramKey(opts) {\n    return `${opts.id}-${opts.vs}-${opts.fs}`;\n  }\n\n  _checkProgramProp(program) {\n    // Check for transform feedback props (varyings, etc), we can't key such programs for now\n    return !program.varyings;\n  }\n\n  _createNewProgram(gl, opts) {\n    const {vs, fs} = opts;\n    const vertexShader = this.getVertexShader(gl, vs);\n    const fragmentShader = this.getFragmentShader(gl, fs);\n    return new Program(\n      this.gl,\n      Object.assign({}, opts, {\n        vs: vertexShader,\n        fs: fragmentShader\n      })\n    );\n  }\n\n  _resetProgram(program, opts) {\n    program.reset();\n  }\n\n  // Handle debug contexts\n  _compareContexts(gl1, gl2) {\n    return (gl1.gl || gl1) === (gl2.gl || gl2);\n  }\n}\n"],"file":"shader-cache.js"}