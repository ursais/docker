(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./bundle.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js":
/*!********************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!
  \********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayWithHoles; });
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!***********************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \***********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _arrayWithoutHoles; });
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
      arr2[i] = arr[i];
    }

    return arr2;
  }
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!***************************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \***************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _assertThisInitialized; });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!********************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _classCallCheck; });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/construct.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/construct.js ***!
  \***************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _construct; });
/* harmony import */ var _setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");


function isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) Object(_setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__["default"])(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!*****************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \*****************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _createClass; });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!********************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _defineProperty; });
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!********************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _getPrototypeOf; });
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \**************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _inherits; });
/* harmony import */ var _setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object(_setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__["default"])(subClass, superClass);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js":
/*!**********************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js ***!
  \**********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _isNativeFunction; });
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!*********************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \*********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _iterableToArray; });
function _iterableToArray(iter) {
  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js":
/*!**************************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!
  \**************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _iterableToArrayLimit; });
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js":
/*!*********************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!
  \*********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _nonIterableRest; });
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!***********************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \***********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _nonIterableSpread; });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance");
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":
/*!*******************************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \*******************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _possibleConstructorReturn; });
/* harmony import */ var _helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../helpers/esm/typeof */ "../../node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized */ "../../node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js");


function _possibleConstructorReturn(self, call) {
  if (call && (Object(_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(call) === "object" || typeof call === "function")) {
    return call;
  }

  return Object(_assertThisInitialized__WEBPACK_IMPORTED_MODULE_1__["default"])(self);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!********************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _setPrototypeOf; });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!
  \*******************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _slicedToArray; });
/* harmony import */ var _arrayWithHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithHoles */ "../../node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js");
/* harmony import */ var _iterableToArrayLimit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArrayLimit */ "../../node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js");
/* harmony import */ var _nonIterableRest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nonIterableRest */ "../../node_modules/@babel/runtime/helpers/esm/nonIterableRest.js");



function _slicedToArray(arr, i) {
  return Object(_arrayWithHoles__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || Object(_iterableToArrayLimit__WEBPACK_IMPORTED_MODULE_1__["default"])(arr, i) || Object(_nonIterableRest__WEBPACK_IMPORTED_MODULE_2__["default"])();
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!***********************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \***********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _toConsumableArray; });
/* harmony import */ var _arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles */ "../../node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _iterableToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray */ "../../node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _nonIterableSpread__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nonIterableSpread */ "../../node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");



function _toConsumableArray(arr) {
  return Object(_arrayWithoutHoles__WEBPACK_IMPORTED_MODULE_0__["default"])(arr) || Object(_iterableToArray__WEBPACK_IMPORTED_MODULE_1__["default"])(arr) || Object(_nonIterableSpread__WEBPACK_IMPORTED_MODULE_2__["default"])();
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _typeof; });
function _typeof2(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof2 = function _typeof2(obj) { return typeof obj; }; } else { _typeof2 = function _typeof2(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof2(obj); }

function _typeof(obj) {
  if (typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol") {
    _typeof = function _typeof(obj) {
      return _typeof2(obj);
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj);
    };
  }

  return _typeof(obj);
}

/***/ }),

/***/ "../../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js":
/*!*********************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js ***!
  \*********************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _wrapNativeSuper; });
/* harmony import */ var _getPrototypeOf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _setPrototypeOf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js");
/* harmony import */ var _isNativeFunction__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isNativeFunction */ "../../node_modules/@babel/runtime/helpers/esm/isNativeFunction.js");
/* harmony import */ var _construct__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./construct */ "../../node_modules/@babel/runtime/helpers/esm/construct.js");




function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !Object(_isNativeFunction__WEBPACK_IMPORTED_MODULE_2__["default"])(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return Object(_construct__WEBPACK_IMPORTED_MODULE_3__["default"])(Class, arguments, Object(_getPrototypeOf__WEBPACK_IMPORTED_MODULE_0__["default"])(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return Object(_setPrototypeOf__WEBPACK_IMPORTED_MODULE_1__["default"])(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/common.js":
/*!***********************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/gl-matrix/esm/common.js ***!
  \***********************************************************************************************************/
/*! exports provided: EPSILON, ARRAY_TYPE, RANDOM, setMatrixArrayType, toRadian, equals */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EPSILON", function() { return EPSILON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ARRAY_TYPE", function() { return ARRAY_TYPE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RANDOM", function() { return RANDOM; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setMatrixArrayType", function() { return setMatrixArrayType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadian", function() { return toRadian; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/**
 * Common utilities
 * @module glMatrix
 */
// Configuration Constants
var EPSILON = 0.000001;
var ARRAY_TYPE = typeof Float32Array !== 'undefined' ? Float32Array : Array;
var RANDOM = Math.random;
/**
 * Sets the type of array used when creating new vectors and matrices
 *
 * @param {Type} type Array type, such as Float32Array or Array
 */

function setMatrixArrayType(type) {
  ARRAY_TYPE = type;
}
var degree = Math.PI / 180;
/**
 * Convert Degree To Radian
 *
 * @param {Number} a Angle in Degrees
 */

function toRadian(a) {
  return a * degree;
}
/**
 * Tests whether or not the arguments have approximately the same value, within an absolute
 * or relative tolerance of glMatrix.EPSILON (an absolute tolerance is used for values less
 * than or equal to 1.0, and a relative tolerance is used for larger values)
 *
 * @param {Number} a The first number to test.
 * @param {Number} b The second number to test.
 * @returns {Boolean} True if the numbers are approximately equal, false otherwise.
 */

function equals(a, b) {
  return Math.abs(a - b) <= EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
}

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/mat3.js":
/*!*********************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/gl-matrix/esm/mat3.js ***!
  \*********************************************************************************************************/
/*! exports provided: create, fromMat4, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, rotate, scale, fromTranslation, fromRotation, fromScaling, fromMat2d, fromQuat, normalFromMat4, projection, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat4", function() { return fromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat2d", function() { return fromMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalFromMat4", function() { return normalFromMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "projection", function() { return projection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");

/**
 * 3x3 Matrix
 * @module mat3
 */

/**
 * Creates a new identity mat3
 *
 * @returns {mat3} a new 3x3 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[5] = 0;
    out[6] = 0;
    out[7] = 0;
  }

  out[0] = 1;
  out[4] = 1;
  out[8] = 1;
  return out;
}
/**
 * Copies the upper-left 3x3 values into the given mat3.
 *
 * @param {mat3} out the receiving 3x3 matrix
 * @param {mat4} a   the source 4x4 matrix
 * @returns {mat3} out
 */

function fromMat4(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[4];
  out[4] = a[5];
  out[5] = a[6];
  out[6] = a[8];
  out[7] = a[9];
  out[8] = a[10];
  return out;
}
/**
 * Creates a new mat3 initialized with values from an existing matrix
 *
 * @param {mat3} a matrix to clone
 * @returns {mat3} a new 3x3 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Copy the values from one mat3 to another
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Create a new mat3 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} A new mat3
 */

function fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](9);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set the components of a mat3 to the given values
 *
 * @param {mat3} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m10 Component in column 1, row 0 position (index 3)
 * @param {Number} m11 Component in column 1, row 1 position (index 4)
 * @param {Number} m12 Component in column 1, row 2 position (index 5)
 * @param {Number} m20 Component in column 2, row 0 position (index 6)
 * @param {Number} m21 Component in column 2, row 1 position (index 7)
 * @param {Number} m22 Component in column 2, row 2 position (index 8)
 * @returns {mat3} out
 */

function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m10;
  out[4] = m11;
  out[5] = m12;
  out[6] = m20;
  out[7] = m21;
  out[8] = m22;
  return out;
}
/**
 * Set a mat3 to the identity matrix
 *
 * @param {mat3} out the receiving matrix
 * @returns {mat3} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Transpose the values of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a12 = a[5];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a01;
    out[5] = a[7];
    out[6] = a02;
    out[7] = a12;
  } else {
    out[0] = a[0];
    out[1] = a[3];
    out[2] = a[6];
    out[3] = a[1];
    out[4] = a[4];
    out[5] = a[7];
    out[6] = a[2];
    out[7] = a[5];
    out[8] = a[8];
  }

  return out;
}
/**
 * Inverts a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20; // Calculate the determinant

  var det = a00 * b01 + a01 * b11 + a02 * b21;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the source matrix
 * @returns {mat3} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  out[0] = a11 * a22 - a12 * a21;
  out[1] = a02 * a21 - a01 * a22;
  out[2] = a01 * a12 - a02 * a11;
  out[3] = a12 * a20 - a10 * a22;
  out[4] = a00 * a22 - a02 * a20;
  out[5] = a02 * a10 - a00 * a12;
  out[6] = a10 * a21 - a11 * a20;
  out[7] = a01 * a20 - a00 * a21;
  out[8] = a00 * a11 - a01 * a10;
  return out;
}
/**
 * Calculates the determinant of a mat3
 *
 * @param {mat3} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
}
/**
 * Multiplies two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2];
  var a10 = a[3],
      a11 = a[4],
      a12 = a[5];
  var a20 = a[6],
      a21 = a[7],
      a22 = a[8];
  var b00 = b[0],
      b01 = b[1],
      b02 = b[2];
  var b10 = b[3],
      b11 = b[4],
      b12 = b[5];
  var b20 = b[6],
      b21 = b[7],
      b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
/**
 * Translate a mat3 by the given vector
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to translate
 * @param {vec2} v vector to translate by
 * @returns {mat3} out
 */

function translate(out, a, v) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      x = v[0],
      y = v[1];
  out[0] = a00;
  out[1] = a01;
  out[2] = a02;
  out[3] = a10;
  out[4] = a11;
  out[5] = a12;
  out[6] = x * a00 + y * a10 + a20;
  out[7] = x * a01 + y * a11 + a21;
  out[8] = x * a02 + y * a12 + a22;
  return out;
}
/**
 * Rotates a mat3 by the given angle
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function rotate(out, a, rad) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a10 = a[3],
      a11 = a[4],
      a12 = a[5],
      a20 = a[6],
      a21 = a[7],
      a22 = a[8],
      s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c * a00 + s * a10;
  out[1] = c * a01 + s * a11;
  out[2] = c * a02 + s * a12;
  out[3] = c * a10 - s * a00;
  out[4] = c * a11 - s * a01;
  out[5] = c * a12 - s * a02;
  out[6] = a20;
  out[7] = a21;
  out[8] = a22;
  return out;
}
;
/**
 * Scales the mat3 by the dimensions in the given vec2
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to rotate
 * @param {vec2} v the vec2 to scale the matrix by
 * @returns {mat3} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1];
  out[0] = x * a[0];
  out[1] = x * a[1];
  out[2] = x * a[2];
  out[3] = y * a[3];
  out[4] = y * a[4];
  out[5] = y * a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.translate(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Translation vector
 * @returns {mat3} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.rotate(dest, dest, rad);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat3} out
 */

function fromRotation(out, rad) {
  var s = Math.sin(rad),
      c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat3.identity(dest);
 *     mat3.scale(dest, dest, vec);
 *
 * @param {mat3} out mat3 receiving operation result
 * @param {vec2} v Scaling vector
 * @returns {mat3} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
/**
 * Copies the values from a mat2d into a mat3
 *
 * @param {mat3} out the receiving matrix
 * @param {mat2d} a the matrix to copy
 * @returns {mat3} out
 **/

function fromMat2d(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = 0;
  out[3] = a[2];
  out[4] = a[3];
  out[5] = 0;
  out[6] = a[4];
  out[7] = a[5];
  out[8] = 1;
  return out;
}
/**
* Calculates a 3x3 matrix from the given quaternion
*
* @param {mat3} out mat3 receiving operation result
* @param {quat} q Quaternion to create matrix from
*
* @returns {mat3} out
*/

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[3] = yx - wz;
  out[6] = zx + wy;
  out[1] = yx + wz;
  out[4] = 1 - xx - zz;
  out[7] = zy - wx;
  out[2] = zx - wy;
  out[5] = zy + wx;
  out[8] = 1 - xx - yy;
  return out;
}
/**
* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
*
* @param {mat3} out mat3 receiving operation result
* @param {mat4} a Mat4 to derive the normal matrix from
*
* @returns {mat3} out
*/

function normalFromMat4(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  return out;
}
/**
 * Generates a 2D projection matrix with the given bounds
 *
 * @param {mat3} out mat3 frustum matrix will be written into
 * @param {number} width Width of your gl context
 * @param {number} height Height of gl context
 * @returns {mat3} out
 */

function projection(out, width, height) {
  out[0] = 2 / width;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = -2 / height;
  out[5] = 0;
  out[6] = -1;
  out[7] = 1;
  out[8] = 1;
  return out;
}
/**
 * Returns a string representation of a mat3
 *
 * @param {mat3} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ')';
}
/**
 * Returns Frobenius norm of a mat3
 *
 * @param {mat3} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2));
}
/**
 * Adds two mat3's
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @returns {mat3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat3} out the receiving matrix
 * @param {mat3} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat3} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  return out;
}
/**
 * Adds two mat3's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat3} out the receiving vector
 * @param {mat3} a the first operand
 * @param {mat3} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat3} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat3} a The first matrix.
 * @param {mat3} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3],
      a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7],
      a8 = a[8];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3],
      b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7],
      b8 = b[8];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8));
}
/**
 * Alias for {@link mat3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat3.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/mat4.js":
/*!*********************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/gl-matrix/esm/mat4.js ***!
  \*********************************************************************************************************/
/*! exports provided: create, clone, copy, fromValues, set, identity, transpose, invert, adjoint, determinant, multiply, translate, scale, rotate, rotateX, rotateY, rotateZ, fromTranslation, fromScaling, fromRotation, fromXRotation, fromYRotation, fromZRotation, fromRotationTranslation, fromQuat2, getTranslation, getScaling, getRotation, fromRotationTranslationScale, fromRotationTranslationScaleOrigin, fromQuat, frustum, perspective, perspectiveFromFieldOfView, ortho, lookAt, targetTo, str, frob, add, subtract, multiplyScalar, multiplyScalarAndAdd, exactEquals, equals, mul, sub */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transpose", function() { return transpose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "adjoint", function() { return adjoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determinant", function() { return determinant; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translate", function() { return translate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromTranslation", function() { return fromTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromScaling", function() { return fromScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotation", function() { return fromRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromXRotation", function() { return fromXRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromYRotation", function() { return fromYRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromZRotation", function() { return fromZRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslation", function() { return fromRotationTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat2", function() { return fromQuat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTranslation", function() { return getTranslation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScaling", function() { return getScaling; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getRotation", function() { return getRotation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScale", function() { return fromRotationTranslationScale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromRotationTranslationScaleOrigin", function() { return fromRotationTranslationScaleOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromQuat", function() { return fromQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frustum", function() { return frustum; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspective", function() { return perspective; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "perspectiveFromFieldOfView", function() { return perspectiveFromFieldOfView; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ortho", function() { return ortho; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lookAt", function() { return lookAt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "targetTo", function() { return targetTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "frob", function() { return frob; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalar", function() { return multiplyScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiplyScalarAndAdd", function() { return multiplyScalarAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");

/**
 * 4x4 Matrix<br>Format: column-major, when typed out it looks like row-major<br>The matrices are being post multiplied.
 * @module mat4
 */

/**
 * Creates a new identity mat4
 *
 * @returns {mat4} a new 4x4 matrix
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
  }

  out[0] = 1;
  out[5] = 1;
  out[10] = 1;
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 initialized with values from an existing matrix
 *
 * @param {mat4} a matrix to clone
 * @returns {mat4} a new 4x4 matrix
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Copy the values from one mat4 to another
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  out[4] = a[4];
  out[5] = a[5];
  out[6] = a[6];
  out[7] = a[7];
  out[8] = a[8];
  out[9] = a[9];
  out[10] = a[10];
  out[11] = a[11];
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Create a new mat4 with the given values
 *
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} A new mat4
 */

function fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](16);
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set the components of a mat4 to the given values
 *
 * @param {mat4} out the receiving matrix
 * @param {Number} m00 Component in column 0, row 0 position (index 0)
 * @param {Number} m01 Component in column 0, row 1 position (index 1)
 * @param {Number} m02 Component in column 0, row 2 position (index 2)
 * @param {Number} m03 Component in column 0, row 3 position (index 3)
 * @param {Number} m10 Component in column 1, row 0 position (index 4)
 * @param {Number} m11 Component in column 1, row 1 position (index 5)
 * @param {Number} m12 Component in column 1, row 2 position (index 6)
 * @param {Number} m13 Component in column 1, row 3 position (index 7)
 * @param {Number} m20 Component in column 2, row 0 position (index 8)
 * @param {Number} m21 Component in column 2, row 1 position (index 9)
 * @param {Number} m22 Component in column 2, row 2 position (index 10)
 * @param {Number} m23 Component in column 2, row 3 position (index 11)
 * @param {Number} m30 Component in column 3, row 0 position (index 12)
 * @param {Number} m31 Component in column 3, row 1 position (index 13)
 * @param {Number} m32 Component in column 3, row 2 position (index 14)
 * @param {Number} m33 Component in column 3, row 3 position (index 15)
 * @returns {mat4} out
 */

function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
  out[0] = m00;
  out[1] = m01;
  out[2] = m02;
  out[3] = m03;
  out[4] = m10;
  out[5] = m11;
  out[6] = m12;
  out[7] = m13;
  out[8] = m20;
  out[9] = m21;
  out[10] = m22;
  out[11] = m23;
  out[12] = m30;
  out[13] = m31;
  out[14] = m32;
  out[15] = m33;
  return out;
}
/**
 * Set a mat4 to the identity matrix
 *
 * @param {mat4} out the receiving matrix
 * @returns {mat4} out
 */

function identity(out) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Transpose the values of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function transpose(out, a) {
  // If we are transposing ourselves we can skip a few steps but have to cache some values
  if (out === a) {
    var a01 = a[1],
        a02 = a[2],
        a03 = a[3];
    var a12 = a[6],
        a13 = a[7];
    var a23 = a[11];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a01;
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a02;
    out[9] = a12;
    out[11] = a[14];
    out[12] = a03;
    out[13] = a13;
    out[14] = a23;
  } else {
    out[0] = a[0];
    out[1] = a[4];
    out[2] = a[8];
    out[3] = a[12];
    out[4] = a[1];
    out[5] = a[5];
    out[6] = a[9];
    out[7] = a[13];
    out[8] = a[2];
    out[9] = a[6];
    out[10] = a[10];
    out[11] = a[14];
    out[12] = a[3];
    out[13] = a[7];
    out[14] = a[11];
    out[15] = a[15];
  }

  return out;
}
/**
 * Inverts a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function invert(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  var det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

  if (!det) {
    return null;
  }

  det = 1.0 / det;
  out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
  out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
  out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
  out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
  out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
  out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
  out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
  out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
  out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
  out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
  out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
  out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
  out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
  out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
  out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
  out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
  return out;
}
/**
 * Calculates the adjugate of a mat4
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the source matrix
 * @returns {mat4} out
 */

function adjoint(out, a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  out[0] = a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22);
  out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
  out[2] = a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12);
  out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
  out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
  out[5] = a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22);
  out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
  out[7] = a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12);
  out[8] = a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21);
  out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
  out[10] = a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11);
  out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
  out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
  out[13] = a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21);
  out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
  out[15] = a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11);
  return out;
}
/**
 * Calculates the determinant of a mat4
 *
 * @param {mat4} a the source matrix
 * @returns {Number} determinant of a
 */

function determinant(a) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15];
  var b00 = a00 * a11 - a01 * a10;
  var b01 = a00 * a12 - a02 * a10;
  var b02 = a00 * a13 - a03 * a10;
  var b03 = a01 * a12 - a02 * a11;
  var b04 = a01 * a13 - a03 * a11;
  var b05 = a02 * a13 - a03 * a12;
  var b06 = a20 * a31 - a21 * a30;
  var b07 = a20 * a32 - a22 * a30;
  var b08 = a20 * a33 - a23 * a30;
  var b09 = a21 * a32 - a22 * a31;
  var b10 = a21 * a33 - a23 * a31;
  var b11 = a22 * a33 - a23 * a32; // Calculate the determinant

  return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
}
/**
 * Multiplies two mat4s
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function multiply(out, a, b) {
  var a00 = a[0],
      a01 = a[1],
      a02 = a[2],
      a03 = a[3];
  var a10 = a[4],
      a11 = a[5],
      a12 = a[6],
      a13 = a[7];
  var a20 = a[8],
      a21 = a[9],
      a22 = a[10],
      a23 = a[11];
  var a30 = a[12],
      a31 = a[13],
      a32 = a[14],
      a33 = a[15]; // Cache only the current line of the second matrix

  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[4];
  b1 = b[5];
  b2 = b[6];
  b3 = b[7];
  out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[8];
  b1 = b[9];
  b2 = b[10];
  b3 = b[11];
  out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  b0 = b[12];
  b1 = b[13];
  b2 = b[14];
  b3 = b[15];
  out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
  out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
  out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
  out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
  return out;
}
/**
 * Translate a mat4 by the given vector
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to translate
 * @param {vec3} v vector to translate by
 * @returns {mat4} out
 */

function translate(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;

  if (a === out) {
    out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
    out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
    out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
    out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
  } else {
    a00 = a[0];
    a01 = a[1];
    a02 = a[2];
    a03 = a[3];
    a10 = a[4];
    a11 = a[5];
    a12 = a[6];
    a13 = a[7];
    a20 = a[8];
    a21 = a[9];
    a22 = a[10];
    a23 = a[11];
    out[0] = a00;
    out[1] = a01;
    out[2] = a02;
    out[3] = a03;
    out[4] = a10;
    out[5] = a11;
    out[6] = a12;
    out[7] = a13;
    out[8] = a20;
    out[9] = a21;
    out[10] = a22;
    out[11] = a23;
    out[12] = a00 * x + a10 * y + a20 * z + a[12];
    out[13] = a01 * x + a11 * y + a21 * z + a[13];
    out[14] = a02 * x + a12 * y + a22 * z + a[14];
    out[15] = a03 * x + a13 * y + a23 * z + a[15];
  }

  return out;
}
/**
 * Scales the mat4 by the dimensions in the given vec3 not using vectorization
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {vec3} v the vec3 to scale the matrix by
 * @returns {mat4} out
 **/

function scale(out, a, v) {
  var x = v[0],
      y = v[1],
      z = v[2];
  out[0] = a[0] * x;
  out[1] = a[1] * x;
  out[2] = a[2] * x;
  out[3] = a[3] * x;
  out[4] = a[4] * y;
  out[5] = a[5] * y;
  out[6] = a[6] * y;
  out[7] = a[7] * y;
  out[8] = a[8] * z;
  out[9] = a[9] * z;
  out[10] = a[10] * z;
  out[11] = a[11] * z;
  out[12] = a[12];
  out[13] = a[13];
  out[14] = a[14];
  out[15] = a[15];
  return out;
}
/**
 * Rotates a mat4 by the given angle around the given axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function rotate(out, a, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s, c, t;
  var a00, a01, a02, a03;
  var a10, a11, a12, a13;
  var a20, a21, a22, a23;
  var b00, b01, b02;
  var b10, b11, b12;
  var b20, b21, b22;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c;
  a00 = a[0];
  a01 = a[1];
  a02 = a[2];
  a03 = a[3];
  a10 = a[4];
  a11 = a[5];
  a12 = a[6];
  a13 = a[7];
  a20 = a[8];
  a21 = a[9];
  a22 = a[10];
  a23 = a[11]; // Construct the elements of the rotation matrix

  b00 = x * x * t + c;
  b01 = y * x * t + z * s;
  b02 = z * x * t - y * s;
  b10 = x * y * t - z * s;
  b11 = y * y * t + c;
  b12 = z * y * t + x * s;
  b20 = x * z * t + y * s;
  b21 = y * z * t - x * s;
  b22 = z * z * t + c; // Perform rotation-specific matrix multiplication

  out[0] = a00 * b00 + a10 * b01 + a20 * b02;
  out[1] = a01 * b00 + a11 * b01 + a21 * b02;
  out[2] = a02 * b00 + a12 * b01 + a22 * b02;
  out[3] = a03 * b00 + a13 * b01 + a23 * b02;
  out[4] = a00 * b10 + a10 * b11 + a20 * b12;
  out[5] = a01 * b10 + a11 * b11 + a21 * b12;
  out[6] = a02 * b10 + a12 * b11 + a22 * b12;
  out[7] = a03 * b10 + a13 * b11 + a23 * b12;
  out[8] = a00 * b20 + a10 * b21 + a20 * b22;
  out[9] = a01 * b20 + a11 * b21 + a21 * b22;
  out[10] = a02 * b20 + a12 * b21 + a22 * b22;
  out[11] = a03 * b20 + a13 * b21 + a23 * b22;

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  }

  return out;
}
/**
 * Rotates a matrix by the given angle around the X axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateX(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[4] = a10 * c + a20 * s;
  out[5] = a11 * c + a21 * s;
  out[6] = a12 * c + a22 * s;
  out[7] = a13 * c + a23 * s;
  out[8] = a20 * c - a10 * s;
  out[9] = a21 * c - a11 * s;
  out[10] = a22 * c - a12 * s;
  out[11] = a23 * c - a13 * s;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Y axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateY(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a20 = a[8];
  var a21 = a[9];
  var a22 = a[10];
  var a23 = a[11];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged rows
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c - a20 * s;
  out[1] = a01 * c - a21 * s;
  out[2] = a02 * c - a22 * s;
  out[3] = a03 * c - a23 * s;
  out[8] = a00 * s + a20 * c;
  out[9] = a01 * s + a21 * c;
  out[10] = a02 * s + a22 * c;
  out[11] = a03 * s + a23 * c;
  return out;
}
/**
 * Rotates a matrix by the given angle around the Z axis
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to rotate
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function rotateZ(out, a, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad);
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a03 = a[3];
  var a10 = a[4];
  var a11 = a[5];
  var a12 = a[6];
  var a13 = a[7];

  if (a !== out) {
    // If the source and destination differ, copy the unchanged last row
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
  } // Perform axis-specific matrix multiplication


  out[0] = a00 * c + a10 * s;
  out[1] = a01 * c + a11 * s;
  out[2] = a02 * c + a12 * s;
  out[3] = a03 * c + a13 * s;
  out[4] = a10 * c - a00 * s;
  out[5] = a11 * c - a01 * s;
  out[6] = a12 * c - a02 * s;
  out[7] = a13 * c - a03 * s;
  return out;
}
/**
 * Creates a matrix from a vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */

function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a vector scaling
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.scale(dest, dest, vec);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {vec3} v Scaling vector
 * @returns {mat4} out
 */

function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = v[1];
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = v[2];
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a given angle around a given axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotate(dest, dest, rad, axis);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @param {vec3} axis the axis to rotate around
 * @returns {mat4} out
 */

function fromRotation(out, rad, axis) {
  var x = axis[0],
      y = axis[1],
      z = axis[2];
  var len = Math.sqrt(x * x + y * y + z * z);
  var s, c, t;

  if (len < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return null;
  }

  len = 1 / len;
  x *= len;
  y *= len;
  z *= len;
  s = Math.sin(rad);
  c = Math.cos(rad);
  t = 1 - c; // Perform rotation-specific matrix multiplication

  out[0] = x * x * t + c;
  out[1] = y * x * t + z * s;
  out[2] = z * x * t - y * s;
  out[3] = 0;
  out[4] = x * y * t - z * s;
  out[5] = y * y * t + c;
  out[6] = z * y * t + x * s;
  out[7] = 0;
  out[8] = x * z * t + y * s;
  out[9] = y * z * t - x * s;
  out[10] = z * z * t + c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the X axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateX(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromXRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = c;
  out[6] = s;
  out[7] = 0;
  out[8] = 0;
  out[9] = -s;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Y axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateY(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromYRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = 0;
  out[2] = -s;
  out[3] = 0;
  out[4] = 0;
  out[5] = 1;
  out[6] = 0;
  out[7] = 0;
  out[8] = s;
  out[9] = 0;
  out[10] = c;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from the given angle around the Z axis
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.rotateZ(dest, dest, rad);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {Number} rad the angle to rotate the matrix by
 * @returns {mat4} out
 */

function fromZRotation(out, rad) {
  var s = Math.sin(rad);
  var c = Math.cos(rad); // Perform axis-specific matrix multiplication

  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = 0;
  out[4] = -s;
  out[5] = c;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 1;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation and vector translation
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @returns {mat4} out
 */

function fromRotationTranslation(out, q, v) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - (yy + zz);
  out[1] = xy + wz;
  out[2] = xz - wy;
  out[3] = 0;
  out[4] = xy - wz;
  out[5] = 1 - (xx + zz);
  out[6] = yz + wx;
  out[7] = 0;
  out[8] = xz + wy;
  out[9] = yz - wx;
  out[10] = 1 - (xx + yy);
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a new mat4 from a dual quat.
 *
 * @param {mat4} out Matrix
 * @param {quat2} a Dual Quaternion
 * @returns {mat4} mat4 receiving operation result
 */

function fromQuat2(out, a) {
  var translation = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  var bx = -a[0],
      by = -a[1],
      bz = -a[2],
      bw = a[3],
      ax = a[4],
      ay = a[5],
      az = a[6],
      aw = a[7];
  var magnitude = bx * bx + by * by + bz * bz + bw * bw; //Only scale if it makes sense

  if (magnitude > 0) {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
  } else {
    translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
    translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
    translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
  }

  fromRotationTranslation(out, a, translation);
  return out;
}
/**
 * Returns the translation vector component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslation,
 *  the returned vector will be the same as the translation vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive translation component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getTranslation(out, mat) {
  out[0] = mat[12];
  out[1] = mat[13];
  out[2] = mat[14];
  return out;
}
/**
 * Returns the scaling factor component of a transformation
 *  matrix. If a matrix is built with fromRotationTranslationScale
 *  with a normalized Quaternion paramter, the returned vector will be
 *  the same as the scaling vector
 *  originally supplied.
 * @param  {vec3} out Vector to receive scaling factor component
 * @param  {mat4} mat Matrix to be decomposed (input)
 * @return {vec3} out
 */

function getScaling(out, mat) {
  var m11 = mat[0];
  var m12 = mat[1];
  var m13 = mat[2];
  var m21 = mat[4];
  var m22 = mat[5];
  var m23 = mat[6];
  var m31 = mat[8];
  var m32 = mat[9];
  var m33 = mat[10];
  out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
  out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
  out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
  return out;
}
/**
 * Returns a quaternion representing the rotational component
 *  of a transformation matrix. If a matrix is built with
 *  fromRotationTranslation, the returned quaternion will be the
 *  same as the quaternion originally supplied.
 * @param {quat} out Quaternion to receive the rotation component
 * @param {mat4} mat Matrix to be decomposed (input)
 * @return {quat} out
 */

function getRotation(out, mat) {
  // Algorithm taken from http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
  var trace = mat[0] + mat[5] + mat[10];
  var S = 0;

  if (trace > 0) {
    S = Math.sqrt(trace + 1.0) * 2;
    out[3] = 0.25 * S;
    out[0] = (mat[6] - mat[9]) / S;
    out[1] = (mat[8] - mat[2]) / S;
    out[2] = (mat[1] - mat[4]) / S;
  } else if (mat[0] > mat[5] && mat[0] > mat[10]) {
    S = Math.sqrt(1.0 + mat[0] - mat[5] - mat[10]) * 2;
    out[3] = (mat[6] - mat[9]) / S;
    out[0] = 0.25 * S;
    out[1] = (mat[1] + mat[4]) / S;
    out[2] = (mat[8] + mat[2]) / S;
  } else if (mat[5] > mat[10]) {
    S = Math.sqrt(1.0 + mat[5] - mat[0] - mat[10]) * 2;
    out[3] = (mat[8] - mat[2]) / S;
    out[0] = (mat[1] + mat[4]) / S;
    out[1] = 0.25 * S;
    out[2] = (mat[6] + mat[9]) / S;
  } else {
    S = Math.sqrt(1.0 + mat[10] - mat[0] - mat[5]) * 2;
    out[3] = (mat[1] - mat[4]) / S;
    out[0] = (mat[8] + mat[2]) / S;
    out[1] = (mat[6] + mat[9]) / S;
    out[2] = 0.25 * S;
  }

  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @returns {mat4} out
 */

function fromRotationTranslationScale(out, q, v, s) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  out[0] = (1 - (yy + zz)) * sx;
  out[1] = (xy + wz) * sx;
  out[2] = (xz - wy) * sx;
  out[3] = 0;
  out[4] = (xy - wz) * sy;
  out[5] = (1 - (xx + zz)) * sy;
  out[6] = (yz + wx) * sy;
  out[7] = 0;
  out[8] = (xz + wy) * sz;
  out[9] = (yz - wx) * sz;
  out[10] = (1 - (xx + yy)) * sz;
  out[11] = 0;
  out[12] = v[0];
  out[13] = v[1];
  out[14] = v[2];
  out[15] = 1;
  return out;
}
/**
 * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
 * This is equivalent to (but much faster than):
 *
 *     mat4.identity(dest);
 *     mat4.translate(dest, vec);
 *     mat4.translate(dest, origin);
 *     let quatMat = mat4.create();
 *     quat4.toMat4(quat, quatMat);
 *     mat4.multiply(dest, quatMat);
 *     mat4.scale(dest, scale)
 *     mat4.translate(dest, negativeOrigin);
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat4} q Rotation quaternion
 * @param {vec3} v Translation vector
 * @param {vec3} s Scaling vector
 * @param {vec3} o The origin vector around which to scale and rotate
 * @returns {mat4} out
 */

function fromRotationTranslationScaleOrigin(out, q, v, s, o) {
  // Quaternion math
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var xy = x * y2;
  var xz = x * z2;
  var yy = y * y2;
  var yz = y * z2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  var sx = s[0];
  var sy = s[1];
  var sz = s[2];
  var ox = o[0];
  var oy = o[1];
  var oz = o[2];
  var out0 = (1 - (yy + zz)) * sx;
  var out1 = (xy + wz) * sx;
  var out2 = (xz - wy) * sx;
  var out4 = (xy - wz) * sy;
  var out5 = (1 - (xx + zz)) * sy;
  var out6 = (yz + wx) * sy;
  var out8 = (xz + wy) * sz;
  var out9 = (yz - wx) * sz;
  var out10 = (1 - (xx + yy)) * sz;
  out[0] = out0;
  out[1] = out1;
  out[2] = out2;
  out[3] = 0;
  out[4] = out4;
  out[5] = out5;
  out[6] = out6;
  out[7] = 0;
  out[8] = out8;
  out[9] = out9;
  out[10] = out10;
  out[11] = 0;
  out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
  out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
  out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
  out[15] = 1;
  return out;
}
/**
 * Calculates a 4x4 matrix from the given quaternion
 *
 * @param {mat4} out mat4 receiving operation result
 * @param {quat} q Quaternion to create matrix from
 *
 * @returns {mat4} out
 */

function fromQuat(out, q) {
  var x = q[0],
      y = q[1],
      z = q[2],
      w = q[3];
  var x2 = x + x;
  var y2 = y + y;
  var z2 = z + z;
  var xx = x * x2;
  var yx = y * x2;
  var yy = y * y2;
  var zx = z * x2;
  var zy = z * y2;
  var zz = z * z2;
  var wx = w * x2;
  var wy = w * y2;
  var wz = w * z2;
  out[0] = 1 - yy - zz;
  out[1] = yx + wz;
  out[2] = zx - wy;
  out[3] = 0;
  out[4] = yx - wz;
  out[5] = 1 - xx - zz;
  out[6] = zy + wx;
  out[7] = 0;
  out[8] = zx + wy;
  out[9] = zy - wx;
  out[10] = 1 - xx - yy;
  out[11] = 0;
  out[12] = 0;
  out[13] = 0;
  out[14] = 0;
  out[15] = 1;
  return out;
}
/**
 * Generates a frustum matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Number} left Left bound of the frustum
 * @param {Number} right Right bound of the frustum
 * @param {Number} bottom Bottom bound of the frustum
 * @param {Number} top Top bound of the frustum
 * @param {Number} near Near bound of the frustum
 * @param {Number} far Far bound of the frustum
 * @returns {mat4} out
 */

function frustum(out, left, right, bottom, top, near, far) {
  var rl = 1 / (right - left);
  var tb = 1 / (top - bottom);
  var nf = 1 / (near - far);
  out[0] = near * 2 * rl;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = near * 2 * tb;
  out[6] = 0;
  out[7] = 0;
  out[8] = (right + left) * rl;
  out[9] = (top + bottom) * tb;
  out[10] = (far + near) * nf;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[14] = far * near * 2 * nf;
  out[15] = 0;
  return out;
}
/**
 * Generates a perspective projection matrix with the given bounds.
 * Passing null/undefined/no value for far will generate infinite projection matrix.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} fovy Vertical field of view in radians
 * @param {number} aspect Aspect ratio. typically viewport width/height
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum, can be null or Infinity
 * @returns {mat4} out
 */

function perspective(out, fovy, aspect, near, far) {
  var f = 1.0 / Math.tan(fovy / 2),
      nf;
  out[0] = f / aspect;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = f;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[11] = -1;
  out[12] = 0;
  out[13] = 0;
  out[15] = 0;

  if (far != null && far !== Infinity) {
    nf = 1 / (near - far);
    out[10] = (far + near) * nf;
    out[14] = 2 * far * near * nf;
  } else {
    out[10] = -1;
    out[14] = -2 * near;
  }

  return out;
}
/**
 * Generates a perspective projection matrix with the given field of view.
 * This is primarily useful for generating projection matrices to be used
 * with the still experiemental WebVR API.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {Object} fov Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function perspectiveFromFieldOfView(out, fov, near, far) {
  var upTan = Math.tan(fov.upDegrees * Math.PI / 180.0);
  var downTan = Math.tan(fov.downDegrees * Math.PI / 180.0);
  var leftTan = Math.tan(fov.leftDegrees * Math.PI / 180.0);
  var rightTan = Math.tan(fov.rightDegrees * Math.PI / 180.0);
  var xScale = 2.0 / (leftTan + rightTan);
  var yScale = 2.0 / (upTan + downTan);
  out[0] = xScale;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  out[4] = 0.0;
  out[5] = yScale;
  out[6] = 0.0;
  out[7] = 0.0;
  out[8] = -((leftTan - rightTan) * xScale * 0.5);
  out[9] = (upTan - downTan) * yScale * 0.5;
  out[10] = far / (near - far);
  out[11] = -1.0;
  out[12] = 0.0;
  out[13] = 0.0;
  out[14] = far * near / (near - far);
  out[15] = 0.0;
  return out;
}
/**
 * Generates a orthogonal projection matrix with the given bounds
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {number} left Left bound of the frustum
 * @param {number} right Right bound of the frustum
 * @param {number} bottom Bottom bound of the frustum
 * @param {number} top Top bound of the frustum
 * @param {number} near Near bound of the frustum
 * @param {number} far Far bound of the frustum
 * @returns {mat4} out
 */

function ortho(out, left, right, bottom, top, near, far) {
  var lr = 1 / (left - right);
  var bt = 1 / (bottom - top);
  var nf = 1 / (near - far);
  out[0] = -2 * lr;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 0;
  out[5] = -2 * bt;
  out[6] = 0;
  out[7] = 0;
  out[8] = 0;
  out[9] = 0;
  out[10] = 2 * nf;
  out[11] = 0;
  out[12] = (left + right) * lr;
  out[13] = (top + bottom) * bt;
  out[14] = (far + near) * nf;
  out[15] = 1;
  return out;
}
/**
 * Generates a look-at matrix with the given eye position, focal point, and up axis.
 * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */

function lookAt(out, eye, center, up) {
  var x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  var eyex = eye[0];
  var eyey = eye[1];
  var eyez = eye[2];
  var upx = up[0];
  var upy = up[1];
  var upz = up[2];
  var centerx = center[0];
  var centery = center[1];
  var centerz = center[2];

  if (Math.abs(eyex - centerx) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyey - centery) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] && Math.abs(eyez - centerz) < _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    return identity(out);
  }

  z0 = eyex - centerx;
  z1 = eyey - centery;
  z2 = eyez - centerz;
  len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
  z0 *= len;
  z1 *= len;
  z2 *= len;
  x0 = upy * z2 - upz * z1;
  x1 = upz * z0 - upx * z2;
  x2 = upx * z1 - upy * z0;
  len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);

  if (!len) {
    x0 = 0;
    x1 = 0;
    x2 = 0;
  } else {
    len = 1 / len;
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  y0 = z1 * x2 - z2 * x1;
  y1 = z2 * x0 - z0 * x2;
  y2 = z0 * x1 - z1 * x0;
  len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);

  if (!len) {
    y0 = 0;
    y1 = 0;
    y2 = 0;
  } else {
    len = 1 / len;
    y0 *= len;
    y1 *= len;
    y2 *= len;
  }

  out[0] = x0;
  out[1] = y0;
  out[2] = z0;
  out[3] = 0;
  out[4] = x1;
  out[5] = y1;
  out[6] = z1;
  out[7] = 0;
  out[8] = x2;
  out[9] = y2;
  out[10] = z2;
  out[11] = 0;
  out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
  out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
  out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
  out[15] = 1;
  return out;
}
/**
 * Generates a matrix that makes something look at something else.
 *
 * @param {mat4} out mat4 frustum matrix will be written into
 * @param {vec3} eye Position of the viewer
 * @param {vec3} center Point the viewer is looking at
 * @param {vec3} up vec3 pointing up
 * @returns {mat4} out
 */

function targetTo(out, eye, target, up) {
  var eyex = eye[0],
      eyey = eye[1],
      eyez = eye[2],
      upx = up[0],
      upy = up[1],
      upz = up[2];
  var z0 = eyex - target[0],
      z1 = eyey - target[1],
      z2 = eyez - target[2];
  var len = z0 * z0 + z1 * z1 + z2 * z2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    z0 *= len;
    z1 *= len;
    z2 *= len;
  }

  var x0 = upy * z2 - upz * z1,
      x1 = upz * z0 - upx * z2,
      x2 = upx * z1 - upy * z0;
  len = x0 * x0 + x1 * x1 + x2 * x2;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
    x0 *= len;
    x1 *= len;
    x2 *= len;
  }

  out[0] = x0;
  out[1] = x1;
  out[2] = x2;
  out[3] = 0;
  out[4] = z1 * x2 - z2 * x1;
  out[5] = z2 * x0 - z0 * x2;
  out[6] = z0 * x1 - z1 * x0;
  out[7] = 0;
  out[8] = z0;
  out[9] = z1;
  out[10] = z2;
  out[11] = 0;
  out[12] = eyex;
  out[13] = eyey;
  out[14] = eyez;
  out[15] = 1;
  return out;
}
;
/**
 * Returns a string representation of a mat4
 *
 * @param {mat4} a matrix to represent as a string
 * @returns {String} string representation of the matrix
 */

function str(a) {
  return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' + a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' + a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' + a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
}
/**
 * Returns Frobenius norm of a mat4
 *
 * @param {mat4} a the matrix to calculate Frobenius norm of
 * @returns {Number} Frobenius norm
 */

function frob(a) {
  return Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2));
}
/**
 * Adds two mat4's
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  out[4] = a[4] + b[4];
  out[5] = a[5] + b[5];
  out[6] = a[6] + b[6];
  out[7] = a[7] + b[7];
  out[8] = a[8] + b[8];
  out[9] = a[9] + b[9];
  out[10] = a[10] + b[10];
  out[11] = a[11] + b[11];
  out[12] = a[12] + b[12];
  out[13] = a[13] + b[13];
  out[14] = a[14] + b[14];
  out[15] = a[15] + b[15];
  return out;
}
/**
 * Subtracts matrix b from matrix a
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @returns {mat4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  out[4] = a[4] - b[4];
  out[5] = a[5] - b[5];
  out[6] = a[6] - b[6];
  out[7] = a[7] - b[7];
  out[8] = a[8] - b[8];
  out[9] = a[9] - b[9];
  out[10] = a[10] - b[10];
  out[11] = a[11] - b[11];
  out[12] = a[12] - b[12];
  out[13] = a[13] - b[13];
  out[14] = a[14] - b[14];
  out[15] = a[15] - b[15];
  return out;
}
/**
 * Multiply each element of the matrix by a scalar.
 *
 * @param {mat4} out the receiving matrix
 * @param {mat4} a the matrix to scale
 * @param {Number} b amount to scale the matrix's elements by
 * @returns {mat4} out
 */

function multiplyScalar(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  out[4] = a[4] * b;
  out[5] = a[5] * b;
  out[6] = a[6] * b;
  out[7] = a[7] * b;
  out[8] = a[8] * b;
  out[9] = a[9] * b;
  out[10] = a[10] * b;
  out[11] = a[11] * b;
  out[12] = a[12] * b;
  out[13] = a[13] * b;
  out[14] = a[14] * b;
  out[15] = a[15] * b;
  return out;
}
/**
 * Adds two mat4's after multiplying each element of the second operand by a scalar value.
 *
 * @param {mat4} out the receiving vector
 * @param {mat4} a the first operand
 * @param {mat4} b the second operand
 * @param {Number} scale the amount to scale b's elements by before adding
 * @returns {mat4} out
 */

function multiplyScalarAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  out[4] = a[4] + b[4] * scale;
  out[5] = a[5] + b[5] * scale;
  out[6] = a[6] + b[6] * scale;
  out[7] = a[7] + b[7] * scale;
  out[8] = a[8] + b[8] * scale;
  out[9] = a[9] + b[9] * scale;
  out[10] = a[10] + b[10] * scale;
  out[11] = a[11] + b[11] * scale;
  out[12] = a[12] + b[12] * scale;
  out[13] = a[13] + b[13] * scale;
  out[14] = a[14] + b[14] * scale;
  out[15] = a[15] + b[15] * scale;
  return out;
}
/**
 * Returns whether or not the matrices have exactly the same elements in the same position (when compared with ===)
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
}
/**
 * Returns whether or not the matrices have approximately the same elements in the same position.
 *
 * @param {mat4} a The first matrix.
 * @param {mat4} b The second matrix.
 * @returns {Boolean} True if the matrices are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var a4 = a[4],
      a5 = a[5],
      a6 = a[6],
      a7 = a[7];
  var a8 = a[8],
      a9 = a[9],
      a10 = a[10],
      a11 = a[11];
  var a12 = a[12],
      a13 = a[13],
      a14 = a[14],
      a15 = a[15];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  var b4 = b[4],
      b5 = b[5],
      b6 = b[6],
      b7 = b[7];
  var b8 = b[8],
      b9 = b[9],
      b10 = b[10],
      b11 = b[11];
  var b12 = b[12],
      b13 = b[13],
      b14 = b[14],
      b15 = b[15];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a15), Math.abs(b15));
}
/**
 * Alias for {@link mat4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link mat4.subtract}
 * @function
 */

var sub = subtract;

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/quat.js":
/*!*********************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/gl-matrix/esm/quat.js ***!
  \*********************************************************************************************************/
/*! exports provided: create, identity, setAxisAngle, getAxisAngle, multiply, rotateX, rotateY, rotateZ, calculateW, slerp, random, invert, conjugate, fromMat3, fromEuler, str, clone, fromValues, copy, set, add, mul, scale, dot, lerp, length, len, squaredLength, sqrLen, normalize, exactEquals, equals, rotationTo, sqlerp, setAxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "identity", function() { return identity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxisAngle", function() { return setAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAxisAngle", function() { return getAxisAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "calculateW", function() { return calculateW; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "slerp", function() { return slerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "invert", function() { return invert; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "conjugate", function() { return conjugate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromMat3", function() { return fromMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromEuler", function() { return fromEuler; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotationTo", function() { return rotationTo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqlerp", function() { return sqlerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setAxes", function() { return setAxes; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");
/* harmony import */ var _mat3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mat3.js */ "../../node_modules/gl-matrix/esm/mat3.js");
/* harmony import */ var _vec3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./vec3.js */ "../../node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _vec4_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vec4.js */ "../../node_modules/gl-matrix/esm/vec4.js");




/**
 * Quaternion
 * @module quat
 */

/**
 * Creates a new identity quat
 *
 * @returns {quat} a new quaternion
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  out[3] = 1;
  return out;
}
/**
 * Set a quat to the identity quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function identity(out) {
  out[0] = 0;
  out[1] = 0;
  out[2] = 0;
  out[3] = 1;
  return out;
}
/**
 * Sets a quat from the given angle and rotation axis,
 * then returns it.
 *
 * @param {quat} out the receiving quaternion
 * @param {vec3} axis the axis around which to rotate
 * @param {Number} rad the angle in radians
 * @returns {quat} out
 **/

function setAxisAngle(out, axis, rad) {
  rad = rad * 0.5;
  var s = Math.sin(rad);
  out[0] = s * axis[0];
  out[1] = s * axis[1];
  out[2] = s * axis[2];
  out[3] = Math.cos(rad);
  return out;
}
/**
 * Gets the rotation axis and angle for a given
 *  quaternion. If a quaternion is created with
 *  setAxisAngle, this method will return the same
 *  values as providied in the original parameter list
 *  OR functionally equivalent values.
 * Example: The quaternion formed by axis [0, 0, 1] and
 *  angle -90 is the same as the quaternion formed by
 *  [0, 0, 1] and 270. This method favors the latter.
 * @param  {vec3} out_axis  Vector receiving the axis of rotation
 * @param  {quat} q     Quaternion to be decomposed
 * @return {Number}     Angle, in radians, of the rotation
 */

function getAxisAngle(out_axis, q) {
  var rad = Math.acos(q[3]) * 2.0;
  var s = Math.sin(rad / 2.0);

  if (s > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    out_axis[0] = q[0] / s;
    out_axis[1] = q[1] / s;
    out_axis[2] = q[2] / s;
  } else {
    // If s is zero, return any axis (no rotation - axis does not matter)
    out_axis[0] = 1;
    out_axis[1] = 0;
    out_axis[2] = 0;
  }

  return rad;
}
/**
 * Multiplies two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 */

function multiply(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  out[0] = ax * bw + aw * bx + ay * bz - az * by;
  out[1] = ay * bw + aw * by + az * bx - ax * bz;
  out[2] = az * bw + aw * bz + ax * by - ay * bx;
  out[3] = aw * bw - ax * bx - ay * by - az * bz;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the X axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateX(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + aw * bx;
  out[1] = ay * bw + az * bx;
  out[2] = az * bw - ay * bx;
  out[3] = aw * bw - ax * bx;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Y axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateY(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var by = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw - az * by;
  out[1] = ay * bw + aw * by;
  out[2] = az * bw + ax * by;
  out[3] = aw * bw - ay * by;
  return out;
}
/**
 * Rotates a quaternion by the given angle about the Z axis
 *
 * @param {quat} out quat receiving operation result
 * @param {quat} a quat to rotate
 * @param {number} rad angle (in radians) to rotate
 * @returns {quat} out
 */

function rotateZ(out, a, rad) {
  rad *= 0.5;
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bz = Math.sin(rad),
      bw = Math.cos(rad);
  out[0] = ax * bw + ay * bz;
  out[1] = ay * bw - ax * bz;
  out[2] = az * bw + aw * bz;
  out[3] = aw * bw - az * bz;
  return out;
}
/**
 * Calculates the W component of a quat from the X, Y, and Z components.
 * Assumes that quaternion is 1 unit in length.
 * Any existing W component will be ignored.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate W component of
 * @returns {quat} out
 */

function calculateW(out, a) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
  return out;
}
/**
 * Performs a spherical linear interpolation between two quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

function slerp(out, a, b, t) {
  // benchmarks:
  //    http://jsperf.com/quaternion-slerp-implementations
  var ax = a[0],
      ay = a[1],
      az = a[2],
      aw = a[3];
  var bx = b[0],
      by = b[1],
      bz = b[2],
      bw = b[3];
  var omega, cosom, sinom, scale0, scale1; // calc cosine

  cosom = ax * bx + ay * by + az * bz + aw * bw; // adjust signs (if necessary)

  if (cosom < 0.0) {
    cosom = -cosom;
    bx = -bx;
    by = -by;
    bz = -bz;
    bw = -bw;
  } // calculate coefficients


  if (1.0 - cosom > _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"]) {
    // standard case (slerp)
    omega = Math.acos(cosom);
    sinom = Math.sin(omega);
    scale0 = Math.sin((1.0 - t) * omega) / sinom;
    scale1 = Math.sin(t * omega) / sinom;
  } else {
    // "from" and "to" quaternions are very close
    //  ... so we can do a linear interpolation
    scale0 = 1.0 - t;
    scale1 = t;
  } // calculate final values


  out[0] = scale0 * ax + scale1 * bx;
  out[1] = scale0 * ay + scale1 * by;
  out[2] = scale0 * az + scale1 * bz;
  out[3] = scale0 * aw + scale1 * bw;
  return out;
}
/**
 * Generates a random quaternion
 *
 * @param {quat} out the receiving quaternion
 * @returns {quat} out
 */

function random(out) {
  // Implementation of http://planning.cs.uiuc.edu/node198.html
  // TODO: Calling random 3 times is probably not the fastest solution
  var u1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var u3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]();
  var sqrt1MinusU1 = Math.sqrt(1 - u1);
  var sqrtU1 = Math.sqrt(u1);
  out[0] = sqrt1MinusU1 * Math.sin(2.0 * Math.PI * u2);
  out[1] = sqrt1MinusU1 * Math.cos(2.0 * Math.PI * u2);
  out[2] = sqrtU1 * Math.sin(2.0 * Math.PI * u3);
  out[3] = sqrtU1 * Math.cos(2.0 * Math.PI * u3);
  return out;
}
/**
 * Calculates the inverse of a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate inverse of
 * @returns {quat} out
 */

function invert(out, a) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;
  var invDot = dot ? 1.0 / dot : 0; // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

  out[0] = -a0 * invDot;
  out[1] = -a1 * invDot;
  out[2] = -a2 * invDot;
  out[3] = a3 * invDot;
  return out;
}
/**
 * Calculates the conjugate of a quat
 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quat to calculate conjugate of
 * @returns {quat} out
 */

function conjugate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a quaternion from the given 3x3 rotation matrix.
 *
 * NOTE: The resultant quaternion is not normalized, so you should be sure
 * to renormalize the quaternion yourself where necessary.
 *
 * @param {quat} out the receiving quaternion
 * @param {mat3} m rotation matrix
 * @returns {quat} out
 * @function
 */

function fromMat3(out, m) {
  // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
  // article "Quaternion Calculus and Fast Animation".
  var fTrace = m[0] + m[4] + m[8];
  var fRoot;

  if (fTrace > 0.0) {
    // |w| > 1/2, may as well choose w > 1/2
    fRoot = Math.sqrt(fTrace + 1.0); // 2w

    out[3] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot; // 1/(4w)

    out[0] = (m[5] - m[7]) * fRoot;
    out[1] = (m[6] - m[2]) * fRoot;
    out[2] = (m[1] - m[3]) * fRoot;
  } else {
    // |w| <= 1/2
    var i = 0;
    if (m[4] > m[0]) i = 1;
    if (m[8] > m[i * 3 + i]) i = 2;
    var j = (i + 1) % 3;
    var k = (i + 2) % 3;
    fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);
    out[i] = 0.5 * fRoot;
    fRoot = 0.5 / fRoot;
    out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;
    out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;
    out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;
  }

  return out;
}
/**
 * Creates a quaternion from the given euler angle x, y, z.
 *
 * @param {quat} out the receiving quaternion
 * @param {x} Angle to rotate around X axis in degrees.
 * @param {y} Angle to rotate around Y axis in degrees.
 * @param {z} Angle to rotate around Z axis in degrees.
 * @returns {quat} out
 * @function
 */

function fromEuler(out, x, y, z) {
  var halfToRad = 0.5 * Math.PI / 180.0;
  x *= halfToRad;
  y *= halfToRad;
  z *= halfToRad;
  var sx = Math.sin(x);
  var cx = Math.cos(x);
  var sy = Math.sin(y);
  var cy = Math.cos(y);
  var sz = Math.sin(z);
  var cz = Math.cos(z);
  out[0] = sx * cy * cz - cx * sy * sz;
  out[1] = cx * sy * cz + sx * cy * sz;
  out[2] = cx * cy * sz - sx * sy * cz;
  out[3] = cx * cy * cz + sx * sy * sz;
  return out;
}
/**
 * Returns a string representation of a quatenion
 *
 * @param {quat} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Creates a new quat initialized with values from an existing quaternion
 *
 * @param {quat} a quaternion to clone
 * @returns {quat} a new quaternion
 * @function
 */

var clone = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["clone"];
/**
 * Creates a new quat initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} a new quaternion
 * @function
 */

var fromValues = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["fromValues"];
/**
 * Copy the values from one quat to another
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the source quaternion
 * @returns {quat} out
 * @function
 */

var copy = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["copy"];
/**
 * Set the components of a quat to the given values
 *
 * @param {quat} out the receiving quaternion
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {quat} out
 * @function
 */

var set = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["set"];
/**
 * Adds two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {quat} out
 * @function
 */

var add = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["add"];
/**
 * Alias for {@link quat.multiply}
 * @function
 */

var mul = multiply;
/**
 * Scales a quat by a scalar number
 *
 * @param {quat} out the receiving vector
 * @param {quat} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {quat} out
 * @function
 */

var scale = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["scale"];
/**
 * Calculates the dot product of two quat's
 *
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @returns {Number} dot product of a and b
 * @function
 */

var dot = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["dot"];
/**
 * Performs a linear interpolation between two quat's
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 * @function
 */

var lerp = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["lerp"];
/**
 * Calculates the length of a quat
 *
 * @param {quat} a vector to calculate length of
 * @returns {Number} length of a
 */

var length = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["length"];
/**
 * Alias for {@link quat.length}
 * @function
 */

var len = length;
/**
 * Calculates the squared length of a quat
 *
 * @param {quat} a vector to calculate squared length of
 * @returns {Number} squared length of a
 * @function
 */

var squaredLength = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["squaredLength"];
/**
 * Alias for {@link quat.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Normalize a quat
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a quaternion to normalize
 * @returns {quat} out
 * @function
 */

var normalize = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["normalize"];
/**
 * Returns whether or not the quaternions have exactly the same elements in the same position (when compared with ===)
 *
 * @param {quat} a The first quaternion.
 * @param {quat} b The second quaternion.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var exactEquals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["exactEquals"];
/**
 * Returns whether or not the quaternions have approximately the same elements in the same position.
 *
 * @param {quat} a The first vector.
 * @param {quat} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

var equals = _vec4_js__WEBPACK_IMPORTED_MODULE_3__["equals"];
/**
 * Sets a quaternion to represent the shortest rotation from one
 * vector to another.
 *
 * Both vectors are assumed to be unit length.
 *
 * @param {quat} out the receiving quaternion.
 * @param {vec3} a the initial vector
 * @param {vec3} b the destination vector
 * @returns {quat} out
 */

var rotationTo = function () {
  var tmpvec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["create"]();
  var xUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](1, 0, 0);
  var yUnitVec3 = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["fromValues"](0, 1, 0);
  return function (out, a, b) {
    var dot = _vec3_js__WEBPACK_IMPORTED_MODULE_2__["dot"](a, b);

    if (dot < -0.999999) {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, xUnitVec3, a);
      if (_vec3_js__WEBPACK_IMPORTED_MODULE_2__["len"](tmpvec3) < 0.000001) _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, yUnitVec3, a);
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["normalize"](tmpvec3, tmpvec3);
      setAxisAngle(out, tmpvec3, Math.PI);
      return out;
    } else if (dot > 0.999999) {
      out[0] = 0;
      out[1] = 0;
      out[2] = 0;
      out[3] = 1;
      return out;
    } else {
      _vec3_js__WEBPACK_IMPORTED_MODULE_2__["cross"](tmpvec3, a, b);
      out[0] = tmpvec3[0];
      out[1] = tmpvec3[1];
      out[2] = tmpvec3[2];
      out[3] = 1 + dot;
      return normalize(out, out);
    }
  };
}();
/**
 * Performs a spherical linear interpolation with two control points
 *
 * @param {quat} out the receiving quaternion
 * @param {quat} a the first operand
 * @param {quat} b the second operand
 * @param {quat} c the third operand
 * @param {quat} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {quat} out
 */

var sqlerp = function () {
  var temp1 = create();
  var temp2 = create();
  return function (out, a, b, c, d, t) {
    slerp(temp1, a, d, t);
    slerp(temp2, b, c, t);
    slerp(out, temp1, temp2, 2 * t * (1 - t));
    return out;
  };
}();
/**
 * Sets the specified quaternion with values corresponding to the given
 * axes. Each axis is a vec3 and is expected to be unit length and
 * perpendicular to all other specified axes.
 *
 * @param {vec3} view  the vector representing the viewing direction
 * @param {vec3} right the vector representing the local "right" direction
 * @param {vec3} up    the vector representing the local "up" direction
 * @returns {quat} out
 */

var setAxes = function () {
  var matr = _mat3_js__WEBPACK_IMPORTED_MODULE_1__["create"]();
  return function (out, view, right, up) {
    matr[0] = right[0];
    matr[3] = right[1];
    matr[6] = right[2];
    matr[1] = up[0];
    matr[4] = up[1];
    matr[7] = up[2];
    matr[2] = -view[0];
    matr[5] = -view[1];
    matr[8] = -view[2];
    return normalize(out, fromMat3(out, matr));
  };
}();

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/vec2.js":
/*!*********************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/gl-matrix/esm/vec2.js ***!
  \*********************************************************************************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat2, transformMat2d, transformMat3, transformMat4, rotate, angle, zero, str, exactEquals, equals, len, sub, mul, div, dist, sqrDist, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2", function() { return transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat2d", function() { return transformMat2d; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotate", function() { return rotate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");

/**
 * 2 Dimensional Vector
 * @module vec2
 */

/**
 * Creates a new, empty vec2
 *
 * @returns {vec2} a new 2D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }

  return out;
}
/**
 * Creates a new vec2 initialized with values from an existing vector
 *
 * @param {vec2} a vector to clone
 * @returns {vec2} a new 2D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Creates a new vec2 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} a new 2D vector
 */

function fromValues(x, y) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](2);
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Copy the values from one vec2 to another
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the source vector
 * @returns {vec2} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  return out;
}
/**
 * Set the components of a vec2 to the given values
 *
 * @param {vec2} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @returns {vec2} out
 */

function set(out, x, y) {
  out[0] = x;
  out[1] = y;
  return out;
}
/**
 * Adds two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
/**
 * Multiplies two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  return out;
}
/**
 * Divides two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  return out;
}
/**
 * Math.ceil the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to ceil
 * @returns {vec2} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  return out;
}
/**
 * Math.floor the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to floor
 * @returns {vec2} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  return out;
}
/**
 * Returns the minimum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
/**
 * Returns the maximum of two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec2} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
/**
 * Math.round the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to round
 * @returns {vec2} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  return out;
}
/**
 * Scales a vec2 by a scalar number
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec2} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
/**
 * Adds two vec2's after scaling the second operand by a scalar value
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec2} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return Math.sqrt(x * x + y * y);
}
/**
 * Calculates the squared euclidian distance between two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0],
      y = b[1] - a[1];
  return x * x + y * y;
}
/**
 * Calculates the length of a vec2
 *
 * @param {vec2} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0],
      y = a[1];
  return Math.sqrt(x * x + y * y);
}
/**
 * Calculates the squared length of a vec2
 *
 * @param {vec2} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0],
      y = a[1];
  return x * x + y * y;
}
/**
 * Negates the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to negate
 * @returns {vec2} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  return out;
}
/**
 * Returns the inverse of the components of a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to invert
 * @returns {vec2} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  return out;
}
/**
 * Normalize a vec2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a vector to normalize
 * @returns {vec2} out
 */

function normalize(out, a) {
  var x = a[0],
      y = a[1];
  var len = x * x + y * y;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
/**
 * Calculates the dot product of two vec2's
 *
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
/**
 * Computes the cross product of two vec2's
 * Note that the cross product must by definition produce a 3D vector
 *
 * @param {vec3} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var z = a[0] * b[1] - a[1] * b[0];
  out[0] = out[1] = 0;
  out[2] = z;
  return out;
}
/**
 * Performs a linear interpolation between two vec2's
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the first operand
 * @param {vec2} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec2} out
 */

function lerp(out, a, b, t) {
  var ax = a[0],
      ay = a[1];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec2} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec2} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  out[0] = Math.cos(r) * scale;
  out[1] = Math.sin(r) * scale;
  return out;
}
/**
 * Transforms the vec2 with a mat2
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  return out;
}
/**
 * Transforms the vec2 with a mat2d
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat2d} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat2d(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[2] * y + m[4];
  out[1] = m[1] * x + m[3] * y + m[5];
  return out;
}
/**
 * Transforms the vec2 with a mat3
 * 3rd vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat3} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
/**
 * Transforms the vec2 with a mat4
 * 3rd vector component is implicitly '0'
 * 4th vector component is implicitly '1'
 *
 * @param {vec2} out the receiving vector
 * @param {vec2} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec2} out
 */

function transformMat4(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[4] * y + m[12];
  out[1] = m[1] * x + m[5] * y + m[13];
  return out;
}
/**
 * Rotate a 2D vector
 * @param {vec2} out The receiving vec2
 * @param {vec2} a The vec2 point to rotate
 * @param {vec2} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec2} out
 */

function rotate(out, a, b, c) {
  //Translate point to the origin
  var p0 = a[0] - b[0],
      p1 = a[1] - b[1],
      sinC = Math.sin(c),
      cosC = Math.cos(c); //perform rotation and translate to correct position

  out[0] = p0 * cosC - p1 * sinC + b[0];
  out[1] = p0 * sinC + p1 * cosC + b[1];
  return out;
}
/**
 * Get the angle between two 2D vectors
 * @param {vec2} a The first operand
 * @param {vec2} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var x1 = a[0],
      y1 = a[1],
      x2 = b[0],
      y2 = b[1];
  var len1 = x1 * x1 + y1 * y1;

  if (len1 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len1 = 1 / Math.sqrt(len1);
  }

  var len2 = x2 * x2 + y2 * y2;

  if (len2 > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len2 = 1 / Math.sqrt(len2);
  }

  var cosine = (x1 * x2 + y1 * y2) * len1 * len2;

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec2 to zero
 *
 * @param {vec2} out the receiving vector
 * @returns {vec2} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec2} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec2(' + a[0] + ', ' + a[1] + ')';
}
/**
 * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec2} a The first vector.
 * @param {vec2} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1];
  var b0 = b[0],
      b1 = b[1];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1));
}
/**
 * Alias for {@link vec2.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec2.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec2.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec2.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec2.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec2.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec2.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec2s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 2;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }

    return a;
  };
}();

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/vec3.js":
/*!*********************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/gl-matrix/esm/vec3.js ***!
  \*********************************************************************************************************/
/*! exports provided: create, clone, length, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, squaredLength, negate, inverse, normalize, dot, cross, lerp, hermite, bezier, random, transformMat4, transformMat3, transformQuat, rotateX, rotateY, rotateZ, angle, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hermite", function() { return hermite; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "bezier", function() { return bezier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat3", function() { return transformMat3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateX", function() { return rotateX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateY", function() { return rotateY; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotateZ", function() { return rotateZ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "angle", function() { return angle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");

/**
 * 3 Dimensional Vector
 * @module vec3
 */

/**
 * Creates a new, empty vec3
 *
 * @returns {vec3} a new 3D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }

  return out;
}
/**
 * Creates a new vec3 initialized with values from an existing vector
 *
 * @param {vec3} a vector to clone
 * @returns {vec3} a new 3D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Calculates the length of a vec3
 *
 * @param {vec3} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return Math.sqrt(x * x + y * y + z * z);
}
/**
 * Creates a new vec3 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} a new 3D vector
 */

function fromValues(x, y, z) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](3);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Copy the values from one vec3 to another
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the source vector
 * @returns {vec3} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  return out;
}
/**
 * Set the components of a vec3 to the given values
 *
 * @param {vec3} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @returns {vec3} out
 */

function set(out, x, y, z) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  return out;
}
/**
 * Adds two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  return out;
}
/**
 * Multiplies two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  return out;
}
/**
 * Divides two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  return out;
}
/**
 * Math.ceil the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to ceil
 * @returns {vec3} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  return out;
}
/**
 * Math.floor the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to floor
 * @returns {vec3} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  return out;
}
/**
 * Returns the minimum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  return out;
}
/**
 * Returns the maximum of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  return out;
}
/**
 * Math.round the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to round
 * @returns {vec3} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  return out;
}
/**
 * Scales a vec3 by a scalar number
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec3} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  return out;
}
/**
 * Adds two vec3's after scaling the second operand by a scalar value
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec3} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return Math.sqrt(x * x + y * y + z * z);
}
/**
 * Calculates the squared euclidian distance between two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  return x * x + y * y + z * z;
}
/**
 * Calculates the squared length of a vec3
 *
 * @param {vec3} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  return x * x + y * y + z * z;
}
/**
 * Negates the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to negate
 * @returns {vec3} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  return out;
}
/**
 * Returns the inverse of the components of a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to invert
 * @returns {vec3} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  return out;
}
/**
 * Normalize a vec3
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a vector to normalize
 * @returns {vec3} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var len = x * x + y * y + z * z;

  if (len > 0) {
    //TODO: evaluate use of glm_invsqrt here?
    len = 1 / Math.sqrt(len);
  }

  out[0] = a[0] * len;
  out[1] = a[1] * len;
  out[2] = a[2] * len;
  return out;
}
/**
 * Calculates the dot product of two vec3's
 *
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}
/**
 * Computes the cross product of two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @returns {vec3} out
 */

function cross(out, a, b) {
  var ax = a[0],
      ay = a[1],
      az = a[2];
  var bx = b[0],
      by = b[1],
      bz = b[2];
  out[0] = ay * bz - az * by;
  out[1] = az * bx - ax * bz;
  out[2] = ax * by - ay * bx;
  return out;
}
/**
 * Performs a linear interpolation between two vec3's
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  return out;
}
/**
 * Performs a hermite interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function hermite(out, a, b, c, d, t) {
  var factorTimes2 = t * t;
  var factor1 = factorTimes2 * (2 * t - 3) + 1;
  var factor2 = factorTimes2 * (t - 2) + t;
  var factor3 = factorTimes2 * (t - 1);
  var factor4 = factorTimes2 * (3 - 2 * t);
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Performs a bezier interpolation with two control points
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the first operand
 * @param {vec3} b the second operand
 * @param {vec3} c the third operand
 * @param {vec3} d the fourth operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec3} out
 */

function bezier(out, a, b, c, d, t) {
  var inverseFactor = 1 - t;
  var inverseFactorTimesTwo = inverseFactor * inverseFactor;
  var factorTimes2 = t * t;
  var factor1 = inverseFactorTimesTwo * inverseFactor;
  var factor2 = 3 * t * inverseFactorTimesTwo;
  var factor3 = 3 * factorTimes2 * inverseFactor;
  var factor4 = factorTimes2 * t;
  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec3} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec3} out
 */

function random(out, scale) {
  scale = scale || 1.0;
  var r = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 * Math.PI;
  var z = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2.0 - 1.0;
  var zScale = Math.sqrt(1.0 - z * z) * scale;
  out[0] = Math.cos(r) * zScale;
  out[1] = Math.sin(r) * zScale;
  out[2] = z * scale;
  return out;
}
/**
 * Transforms the vec3 with a mat4.
 * 4th vector component is implicitly '1'
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec3} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z + m[15];
  w = w || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
  return out;
}
/**
 * Transforms the vec3 with a mat3.
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {mat3} m the 3x3 matrix to transform with
 * @returns {vec3} out
 */

function transformMat3(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
/**
 * Transforms the vec3 with a quat
 * Can also be used for dual quaternions. (Multiply it with the real part)
 *
 * @param {vec3} out the receiving vector
 * @param {vec3} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec3} out
 */

function transformQuat(out, a, q) {
  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3];
  var x = a[0],
      y = a[1],
      z = a[2]; // var qvec = [qx, qy, qz];
  // var uv = vec3.cross([], qvec, a);

  var uvx = qy * z - qz * y,
      uvy = qz * x - qx * z,
      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);

  var uuvx = qy * uvz - qz * uvy,
      uuvy = qz * uvx - qx * uvz,
      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);

  var w2 = qw * 2;
  uvx *= w2;
  uvy *= w2;
  uvz *= w2; // vec3.scale(uuv, uuv, 2);

  uuvx *= 2;
  uuvy *= 2;
  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));

  out[0] = x + uvx + uuvx;
  out[1] = y + uvy + uuvy;
  out[2] = z + uvz + uuvz;
  return out;
}
/**
 * Rotate a 3D vector around the x-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateX(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0];
  r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);
  r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the y-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateY(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);
  r[1] = p[1];
  r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c); //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Rotate a 3D vector around the z-axis
 * @param {vec3} out The receiving vec3
 * @param {vec3} a The vec3 point to rotate
 * @param {vec3} b The origin of the rotation
 * @param {Number} c The angle of rotation
 * @returns {vec3} out
 */

function rotateZ(out, a, b, c) {
  var p = [],
      r = []; //Translate point to the origin

  p[0] = a[0] - b[0];
  p[1] = a[1] - b[1];
  p[2] = a[2] - b[2]; //perform rotation

  r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);
  r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);
  r[2] = p[2]; //translate to correct position

  out[0] = r[0] + b[0];
  out[1] = r[1] + b[1];
  out[2] = r[2] + b[2];
  return out;
}
/**
 * Get the angle between two 3D vectors
 * @param {vec3} a The first operand
 * @param {vec3} b The second operand
 * @returns {Number} The angle in radians
 */

function angle(a, b) {
  var tempA = fromValues(a[0], a[1], a[2]);
  var tempB = fromValues(b[0], b[1], b[2]);
  normalize(tempA, tempA);
  normalize(tempB, tempB);
  var cosine = dot(tempA, tempB);

  if (cosine > 1.0) {
    return 0;
  } else if (cosine < -1.0) {
    return Math.PI;
  } else {
    return Math.acos(cosine);
  }
}
/**
 * Set the components of a vec3 to zero
 *
 * @param {vec3} out the receiving vector
 * @returns {vec3} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec3} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec3} a The first vector.
 * @param {vec3} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2));
}
/**
 * Alias for {@link vec3.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec3.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec3.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec3.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec3.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec3.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec3.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec3s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 3;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }

    return a;
  };
}();

/***/ }),

/***/ "../../node_modules/gl-matrix/esm/vec4.js":
/*!*********************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/gl-matrix/esm/vec4.js ***!
  \*********************************************************************************************************/
/*! exports provided: create, clone, fromValues, copy, set, add, subtract, multiply, divide, ceil, floor, min, max, round, scale, scaleAndAdd, distance, squaredDistance, length, squaredLength, negate, inverse, normalize, dot, cross, lerp, random, transformMat4, transformQuat, zero, str, exactEquals, equals, sub, mul, div, dist, sqrDist, len, sqrLen, forEach */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "create", function() { return create; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromValues", function() { return fromValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copy", function() { return copy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "set", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "add", function() { return add; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "subtract", function() { return subtract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "multiply", function() { return multiply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "divide", function() { return divide; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ceil", function() { return ceil; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "floor", function() { return floor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "min", function() { return min; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "max", function() { return max; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "round", function() { return round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scale", function() { return scale; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scaleAndAdd", function() { return scaleAndAdd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distance", function() { return distance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredDistance", function() { return squaredDistance; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "length", function() { return length; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "squaredLength", function() { return squaredLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "negate", function() { return negate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inverse", function() { return inverse; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dot", function() { return dot; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cross", function() { return cross; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformMat4", function() { return transformMat4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformQuat", function() { return transformQuat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zero", function() { return zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "str", function() { return str; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sub", function() { return sub; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mul", function() { return mul; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "div", function() { return div; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dist", function() { return dist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrDist", function() { return sqrDist; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "len", function() { return len; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sqrLen", function() { return sqrLen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "forEach", function() { return forEach; });
/* harmony import */ var _common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common.js */ "../../node_modules/gl-matrix/esm/common.js");

/**
 * 4 Dimensional Vector
 * @module vec4
 */

/**
 * Creates a new, empty vec4
 *
 * @returns {vec4} a new 4D vector
 */

function create() {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);

  if (_common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"] != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
  }

  return out;
}
/**
 * Creates a new vec4 initialized with values from an existing vector
 *
 * @param {vec4} a vector to clone
 * @returns {vec4} a new 4D vector
 */

function clone(a) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Creates a new vec4 initialized with the given values
 *
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} a new 4D vector
 */

function fromValues(x, y, z, w) {
  var out = new _common_js__WEBPACK_IMPORTED_MODULE_0__["ARRAY_TYPE"](4);
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Copy the values from one vec4 to another
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the source vector
 * @returns {vec4} out
 */

function copy(out, a) {
  out[0] = a[0];
  out[1] = a[1];
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to the given values
 *
 * @param {vec4} out the receiving vector
 * @param {Number} x X component
 * @param {Number} y Y component
 * @param {Number} z Z component
 * @param {Number} w W component
 * @returns {vec4} out
 */

function set(out, x, y, z, w) {
  out[0] = x;
  out[1] = y;
  out[2] = z;
  out[3] = w;
  return out;
}
/**
 * Adds two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  out[2] = a[2] + b[2];
  out[3] = a[3] + b[3];
  return out;
}
/**
 * Subtracts vector b from vector a
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  out[2] = a[2] - b[2];
  out[3] = a[3] - b[3];
  return out;
}
/**
 * Multiplies two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function multiply(out, a, b) {
  out[0] = a[0] * b[0];
  out[1] = a[1] * b[1];
  out[2] = a[2] * b[2];
  out[3] = a[3] * b[3];
  return out;
}
/**
 * Divides two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function divide(out, a, b) {
  out[0] = a[0] / b[0];
  out[1] = a[1] / b[1];
  out[2] = a[2] / b[2];
  out[3] = a[3] / b[3];
  return out;
}
/**
 * Math.ceil the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to ceil
 * @returns {vec4} out
 */

function ceil(out, a) {
  out[0] = Math.ceil(a[0]);
  out[1] = Math.ceil(a[1]);
  out[2] = Math.ceil(a[2]);
  out[3] = Math.ceil(a[3]);
  return out;
}
/**
 * Math.floor the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to floor
 * @returns {vec4} out
 */

function floor(out, a) {
  out[0] = Math.floor(a[0]);
  out[1] = Math.floor(a[1]);
  out[2] = Math.floor(a[2]);
  out[3] = Math.floor(a[3]);
  return out;
}
/**
 * Returns the minimum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function min(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  out[2] = Math.min(a[2], b[2]);
  out[3] = Math.min(a[3], b[3]);
  return out;
}
/**
 * Returns the maximum of two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {vec4} out
 */

function max(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  out[2] = Math.max(a[2], b[2]);
  out[3] = Math.max(a[3], b[3]);
  return out;
}
/**
 * Math.round the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to round
 * @returns {vec4} out
 */

function round(out, a) {
  out[0] = Math.round(a[0]);
  out[1] = Math.round(a[1]);
  out[2] = Math.round(a[2]);
  out[3] = Math.round(a[3]);
  return out;
}
/**
 * Scales a vec4 by a scalar number
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to scale
 * @param {Number} b amount to scale the vector by
 * @returns {vec4} out
 */

function scale(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  out[2] = a[2] * b;
  out[3] = a[3] * b;
  return out;
}
/**
 * Adds two vec4's after scaling the second operand by a scalar value
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} scale the amount to scale b by before adding
 * @returns {vec4} out
 */

function scaleAndAdd(out, a, b, scale) {
  out[0] = a[0] + b[0] * scale;
  out[1] = a[1] + b[1] * scale;
  out[2] = a[2] + b[2] * scale;
  out[3] = a[3] + b[3] * scale;
  return out;
}
/**
 * Calculates the euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} distance between a and b
 */

function distance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}
/**
 * Calculates the squared euclidian distance between two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} squared distance between a and b
 */

function squaredDistance(a, b) {
  var x = b[0] - a[0];
  var y = b[1] - a[1];
  var z = b[2] - a[2];
  var w = b[3] - a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Calculates the length of a vec4
 *
 * @param {vec4} a vector to calculate length of
 * @returns {Number} length of a
 */

function length(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return Math.sqrt(x * x + y * y + z * z + w * w);
}
/**
 * Calculates the squared length of a vec4
 *
 * @param {vec4} a vector to calculate squared length of
 * @returns {Number} squared length of a
 */

function squaredLength(a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  return x * x + y * y + z * z + w * w;
}
/**
 * Negates the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to negate
 * @returns {vec4} out
 */

function negate(out, a) {
  out[0] = -a[0];
  out[1] = -a[1];
  out[2] = -a[2];
  out[3] = -a[3];
  return out;
}
/**
 * Returns the inverse of the components of a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to invert
 * @returns {vec4} out
 */

function inverse(out, a) {
  out[0] = 1.0 / a[0];
  out[1] = 1.0 / a[1];
  out[2] = 1.0 / a[2];
  out[3] = 1.0 / a[3];
  return out;
}
/**
 * Normalize a vec4
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a vector to normalize
 * @returns {vec4} out
 */

function normalize(out, a) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = a[3];
  var len = x * x + y * y + z * z + w * w;

  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }

  out[0] = x * len;
  out[1] = y * len;
  out[2] = z * len;
  out[3] = w * len;
  return out;
}
/**
 * Calculates the dot product of two vec4's
 *
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @returns {Number} dot product of a and b
 */

function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
}
/**
 * Returns the cross-product of three vectors in a 4-dimensional space
 *
 * @param {vec4} result the receiving vector
 * @param {vec4} U the first vector
 * @param {vec4} V the second vector
 * @param {vec4} W the third vector
 * @returns {vec4} result
 */

function cross(out, u, v, w) {
  var A = v[0] * w[1] - v[1] * w[0],
      B = v[0] * w[2] - v[2] * w[0],
      C = v[0] * w[3] - v[3] * w[0],
      D = v[1] * w[2] - v[2] * w[1],
      E = v[1] * w[3] - v[3] * w[1],
      F = v[2] * w[3] - v[3] * w[2];
  var G = u[0];
  var H = u[1];
  var I = u[2];
  var J = u[3];
  out[0] = H * F - I * E + J * D;
  out[1] = -(G * F) + I * C - J * B;
  out[2] = G * E - H * C + J * A;
  out[3] = -(G * D) + H * B - I * A;
  return out;
}
;
/**
 * Performs a linear interpolation between two vec4's
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the first operand
 * @param {vec4} b the second operand
 * @param {Number} t interpolation amount, in the range [0-1], between the two inputs
 * @returns {vec4} out
 */

function lerp(out, a, b, t) {
  var ax = a[0];
  var ay = a[1];
  var az = a[2];
  var aw = a[3];
  out[0] = ax + t * (b[0] - ax);
  out[1] = ay + t * (b[1] - ay);
  out[2] = az + t * (b[2] - az);
  out[3] = aw + t * (b[3] - aw);
  return out;
}
/**
 * Generates a random vector with the given scale
 *
 * @param {vec4} out the receiving vector
 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
 * @returns {vec4} out
 */

function random(out, scale) {
  scale = scale || 1.0; // Marsaglia, George. Choosing a Point from the Surface of a
  // Sphere. Ann. Math. Statist. 43 (1972), no. 2, 645--646.
  // http://projecteuclid.org/euclid.aoms/1177692644;

  var v1, v2, v3, v4;
  var s1, s2;

  do {
    v1 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v2 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s1 = v1 * v1 + v2 * v2;
  } while (s1 >= 1);

  do {
    v3 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    v4 = _common_js__WEBPACK_IMPORTED_MODULE_0__["RANDOM"]() * 2 - 1;
    s2 = v3 * v3 + v4 * v4;
  } while (s2 >= 1);

  var d = Math.sqrt((1 - s1) / s2);
  out[0] = scale * v1;
  out[1] = scale * v2;
  out[2] = scale * v3 * d;
  out[3] = scale * v4 * d;
  return out;
}
/**
 * Transforms the vec4 with a mat4.
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {mat4} m matrix to transform with
 * @returns {vec4} out
 */

function transformMat4(out, a, m) {
  var x = a[0],
      y = a[1],
      z = a[2],
      w = a[3];
  out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
  out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
  out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
  out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
  return out;
}
/**
 * Transforms the vec4 with a quat
 *
 * @param {vec4} out the receiving vector
 * @param {vec4} a the vector to transform
 * @param {quat} q quaternion to transform with
 * @returns {vec4} out
 */

function transformQuat(out, a, q) {
  var x = a[0],
      y = a[1],
      z = a[2];
  var qx = q[0],
      qy = q[1],
      qz = q[2],
      qw = q[3]; // calculate quat * vec

  var ix = qw * x + qy * z - qz * y;
  var iy = qw * y + qz * x - qx * z;
  var iz = qw * z + qx * y - qy * x;
  var iw = -qx * x - qy * y - qz * z; // calculate result * inverse quat

  out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
  out[3] = a[3];
  return out;
}
/**
 * Set the components of a vec4 to zero
 *
 * @param {vec4} out the receiving vector
 * @returns {vec4} out
 */

function zero(out) {
  out[0] = 0.0;
  out[1] = 0.0;
  out[2] = 0.0;
  out[3] = 0.0;
  return out;
}
/**
 * Returns a string representation of a vector
 *
 * @param {vec4} a vector to represent as a string
 * @returns {String} string representation of the vector
 */

function str(a) {
  return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
}
/**
 * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3];
}
/**
 * Returns whether or not the vectors have approximately the same elements in the same position.
 *
 * @param {vec4} a The first vector.
 * @param {vec4} b The second vector.
 * @returns {Boolean} True if the vectors are equal, false otherwise.
 */

function equals(a, b) {
  var a0 = a[0],
      a1 = a[1],
      a2 = a[2],
      a3 = a[3];
  var b0 = b[0],
      b1 = b[1],
      b2 = b[2],
      b3 = b[3];
  return Math.abs(a0 - b0) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= _common_js__WEBPACK_IMPORTED_MODULE_0__["EPSILON"] * Math.max(1.0, Math.abs(a3), Math.abs(b3));
}
/**
 * Alias for {@link vec4.subtract}
 * @function
 */

var sub = subtract;
/**
 * Alias for {@link vec4.multiply}
 * @function
 */

var mul = multiply;
/**
 * Alias for {@link vec4.divide}
 * @function
 */

var div = divide;
/**
 * Alias for {@link vec4.distance}
 * @function
 */

var dist = distance;
/**
 * Alias for {@link vec4.squaredDistance}
 * @function
 */

var sqrDist = squaredDistance;
/**
 * Alias for {@link vec4.length}
 * @function
 */

var len = length;
/**
 * Alias for {@link vec4.squaredLength}
 * @function
 */

var sqrLen = squaredLength;
/**
 * Perform some operation over an array of vec4s.
 *
 * @param {Array} a the array of vectors to iterate over
 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
 * @param {Number} offset Number of elements to skip at the beginning of the array
 * @param {Number} count Number of vec4s to iterate over. If 0 iterates over entire array
 * @param {Function} fn Function to call for each vector in the array
 * @param {Object} [arg] additional argument to pass to fn
 * @returns {Array} a
 * @function
 */

var forEach = function () {
  var vec = create();
  return function (a, stride, offset, count, fn, arg) {
    var i, l;

    if (!stride) {
      stride = 4;
    }

    if (!offset) {
      offset = 0;
    }

    if (count) {
      l = Math.min(count * stride + offset, a.length);
    } else {
      l = a.length;
    }

    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      vec[3] = a[i + 3];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
      a[i + 3] = vec[3];
    }

    return a;
  };
}();

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/addons/polygon.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/addons/polygon.js ***!
  \**********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Polygon; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");




var Polygon = function () {
  function Polygon(points) {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Polygon);

    this.points = points;
    this.isClosed = Object(_lib_common__WEBPACK_IMPORTED_MODULE_2__["equals"])(this.points[this.points.length - 1], this.points[0]);
    Object.freeze(this);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Polygon, [{
    key: "getSignedArea",
    value: function getSignedArea() {
      var area = 0;
      this.forEachSegment(function (p1, p2) {
        area += (p1[0] + p2[0]) * (p1[1] - p2[1]);
      });
      return area / 2;
    }
  }, {
    key: "getArea",
    value: function getArea() {
      return Math.abs(this.getSignedArea());
    }
  }, {
    key: "getWindingDirection",
    value: function getWindingDirection() {
      return Math.sign(this.getSignedArea());
    }
  }, {
    key: "forEachSegment",
    value: function forEachSegment(visitor) {
      var length = this.points.length;

      for (var i = 0; i < length - 1; i++) {
        visitor(this.points[i], this.points[i + 1], i, i + 1);
      }

      if (!this.isClosed) {
        visitor(this.points[length - 1], this.points[0], length - 1, 0);
      }
    }
  }]);

  return Polygon;
}();


//# sourceMappingURL=polygon.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/base/math-array.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/classes/base/math-array.js ***!
  \*******************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MathArray; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/wrapNativeSuper */ "../../node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");








var MathArray = function (_Array) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(MathArray, _Array);

  function MathArray() {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, MathArray);

    return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(MathArray).apply(this, arguments));
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(MathArray, [{
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "from",
    value: function from(arrayOrObject) {
      return Array.isArray(arrayOrObject) ? this.copy(arrayOrObject) : this.fromObject(arrayOrObject);
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = array[i + offset];
      }

      return this.check();
    }
  }, {
    key: "to",
    value: function to(arrayOrObject) {
      if (arrayOrObject === this) {
        return this;
      }

      return Object(_lib_common__WEBPACK_IMPORTED_MODULE_6__["isArray"])(arrayOrObject) ? this.toArray(arrayOrObject) : this.toObject(arrayOrObject);
    }
  }, {
    key: "toTarget",
    value: function toTarget(target) {
      return target ? this.to(target) : this;
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        array[offset + i] = this[i];
      }

      return array;
    }
  }, {
    key: "toFloat32Array",
    value: function toFloat32Array() {
      return new Float32Array(this);
    }
  }, {
    key: "toString",
    value: function toString() {
      return this.formatString(_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"]);
    }
  }, {
    key: "formatString",
    value: function formatString(opts) {
      var string = '';

      for (var i = 0; i < this.ELEMENTS; ++i) {
        string += (i > 0 ? ', ' : '') + Object(_lib_common__WEBPACK_IMPORTED_MODULE_6__["formatValue"])(this[i], opts);
      }

      return "".concat(opts.printTypes ? this.constructor.name : '', "[").concat(string, "]");
    }
  }, {
    key: "equals",
    value: function equals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        if (!Object(_lib_common__WEBPACK_IMPORTED_MODULE_6__["equals"])(this[i], array[i])) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "exactEquals",
    value: function exactEquals(array) {
      if (!array || this.length !== array.length) {
        return false;
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        if (this[i] !== array[i]) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "negate",
    value: function negate() {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = -this[i];
      }

      return this.check();
    }
  }, {
    key: "lerp",
    value: function lerp(a, b, t) {
      if (t === undefined) {
        t = b;
        b = a;
        a = this;
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        var ai = a[i];
        this[i] = ai + t * (b[i] - ai);
      }

      return this.check();
    }
  }, {
    key: "min",
    value: function min(vector) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(vector[i], this[i]);
      }

      return this.check();
    }
  }, {
    key: "max",
    value: function max(vector) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.max(vector[i], this[i]);
      }

      return this.check();
    }
  }, {
    key: "clamp",
    value: function clamp(minVector, maxVector) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], minVector[i]), maxVector[i]);
      }

      return this.check();
    }
  }, {
    key: "add",
    value: function add() {
      for (var _len = arguments.length, vectors = new Array(_len), _key = 0; _key < _len; _key++) {
        vectors[_key] = arguments[_key];
      }

      for (var _i = 0, _vectors = vectors; _i < _vectors.length; _i++) {
        var vector = _vectors[_i];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] += vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "subtract",
    value: function subtract() {
      for (var _len2 = arguments.length, vectors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        vectors[_key2] = arguments[_key2];
      }

      for (var _i2 = 0, _vectors2 = vectors; _i2 < _vectors2.length; _i2++) {
        var vector = _vectors2[_i2];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] -= vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(_scale) {
      if (Array.isArray(_scale)) {
        return this.multiply(_scale);
      }

      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= _scale;
      }

      return this.check();
    }
  }, {
    key: "sub",
    value: function sub(a) {
      return this.subtract(a);
    }
  }, {
    key: "setScalar",
    value: function setScalar(a) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = a;
      }

      return this.check();
    }
  }, {
    key: "addScalar",
    value: function addScalar(a) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] += a;
      }

      return this.check();
    }
  }, {
    key: "subScalar",
    value: function subScalar(a) {
      return this.addScalar(-a);
    }
  }, {
    key: "multiplyScalar",
    value: function multiplyScalar(scalar) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] *= scalar;
      }

      return this.check();
    }
  }, {
    key: "divideScalar",
    value: function divideScalar(a) {
      return this.scale(1 / a);
    }
  }, {
    key: "clampScalar",
    value: function clampScalar(min, max) {
      for (var i = 0; i < this.ELEMENTS; ++i) {
        this[i] = Math.min(Math.max(this[i], min), max);
      }

      return this.check();
    }
  }, {
    key: "multiplyByScalar",
    value: function multiplyByScalar(scalar) {
      return this.scale(scalar);
    }
  }, {
    key: "check",
    value: function check() {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"].debug && !this.validate(this)) {
        throw new Error("math.gl: ".concat(this.constructor.name, " some fields set to invalid numbers'"));
      }

      return this;
    }
  }, {
    key: "validate",
    value: function validate() {
      var valid = this.length === this.ELEMENTS;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        valid = valid && Number.isFinite(this[i]);
      }

      return valid;
    }
  }, {
    key: "elements",
    get: function get() {
      return this;
    }
  }]);

  return MathArray;
}(Object(_babel_runtime_helpers_esm_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_5__["default"])(Array));


//# sourceMappingURL=math-array.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/base/matrix.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/classes/base/matrix.js ***!
  \***************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Matrix; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _math_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./math-array */ "../../node_modules/math.gl/dist/esm/classes/base/math-array.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");









var Matrix = function (_MathArray) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Matrix, _MathArray);

  function Matrix() {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Matrix);

    return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Matrix).apply(this, arguments));
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Matrix, [{
    key: "toString",
    value: function toString() {
      var string = '[';

      if (_lib_common__WEBPACK_IMPORTED_MODULE_7__["config"].printRowMajor) {
        string += 'row-major:';

        for (var row = 0; row < this.RANK; ++row) {
          for (var col = 0; col < this.RANK; ++col) {
            string += " ".concat(this[col * this.RANK + row]);
          }
        }
      } else {
        string += 'column-major:';

        for (var i = 0; i < this.ELEMENTS; ++i) {
          string += " ".concat(this[i]);
        }
      }

      string += ']';
      return string;
    }
  }, {
    key: "getElementIndex",
    value: function getElementIndex(row, col) {
      return col * this.RANK + row;
    }
  }, {
    key: "getElement",
    value: function getElement(row, col) {
      return this[col * this.RANK + row];
    }
  }, {
    key: "setElement",
    value: function setElement(row, col, value) {
      this[col * this.RANK + row] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(value);
      return this;
    }
  }, {
    key: "getColumn",
    value: function getColumn(columnIndex) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Array(this.RANK).fill(-0);
      var firstIndex = columnIndex * this.RANK;

      for (var i = 0; i < this.RANK; ++i) {
        result[i] = this[firstIndex + i];
      }

      return result;
    }
  }, {
    key: "setColumn",
    value: function setColumn(columnIndex, columnVector) {
      var firstIndex = columnIndex * this.RANK;

      for (var i = 0; i < this.RANK; ++i) {
        this[firstIndex + i] = columnVector[i];
      }

      return this;
    }
  }]);

  return Matrix;
}(_math_array__WEBPACK_IMPORTED_MODULE_5__["default"]);


//# sourceMappingURL=matrix.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/base/vector.js":
/*!***************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/classes/base/vector.js ***!
  \***************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _math_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./math-array */ "../../node_modules/math.gl/dist/esm/classes/base/math-array.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var _lib_assert__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../lib/assert */ "../../node_modules/math.gl/dist/esm/lib/assert.js");









var Vector = function (_MathArray) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Vector, _MathArray);

  function Vector() {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Vector);

    return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Vector).apply(this, arguments));
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Vector, [{
    key: "len",
    value: function len() {
      return Math.sqrt(this.lengthSquared());
    }
  }, {
    key: "magnitude",
    value: function magnitude() {
      return this.len();
    }
  }, {
    key: "lengthSquared",
    value: function lengthSquared() {
      var length = 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        length += this[i] * this[i];
      }

      return length;
    }
  }, {
    key: "magnitudeSquared",
    value: function magnitudeSquared() {
      return this.lengthSquared();
    }
  }, {
    key: "distance",
    value: function distance(mathArray) {
      return Math.sqrt(this.distanceSquared(mathArray));
    }
  }, {
    key: "distanceSquared",
    value: function distanceSquared(mathArray) {
      var length = 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        var dist = this[i] - mathArray[i];
        length += dist * dist;
      }

      return Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(length);
    }
  }, {
    key: "dot",
    value: function dot(mathArray) {
      var product = 0;

      for (var i = 0; i < this.ELEMENTS; ++i) {
        product += this[i] * mathArray[i];
      }

      return Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(product);
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var length = this.magnitude();

      if (length !== 0) {
        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] /= length;
        }
      }

      return this.check();
    }
  }, {
    key: "multiply",
    value: function multiply() {
      for (var _len = arguments.length, vectors = new Array(_len), _key = 0; _key < _len; _key++) {
        vectors[_key] = arguments[_key];
      }

      for (var _i = 0, _vectors = vectors; _i < _vectors.length; _i++) {
        var vector = _vectors[_i];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] *= vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "divide",
    value: function divide() {
      for (var _len2 = arguments.length, vectors = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        vectors[_key2] = arguments[_key2];
      }

      for (var _i2 = 0, _vectors2 = vectors; _i2 < _vectors2.length; _i2++) {
        var vector = _vectors2[_i2];

        for (var i = 0; i < this.ELEMENTS; ++i) {
          this[i] /= vector[i];
        }
      }

      return this.check();
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.lengthSquared();
    }
  }, {
    key: "distanceTo",
    value: function distanceTo(vector) {
      return this.distance(vector);
    }
  }, {
    key: "distanceToSquared",
    value: function distanceToSquared(vector) {
      return this.distanceSquared(vector);
    }
  }, {
    key: "getComponent",
    value: function getComponent(i) {
      Object(_lib_assert__WEBPACK_IMPORTED_MODULE_7__["default"])(i >= 0 && i < this.ELEMENTS, 'index is out of range');
      return Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(this[i]);
    }
  }, {
    key: "setComponent",
    value: function setComponent(i, value) {
      Object(_lib_assert__WEBPACK_IMPORTED_MODULE_7__["default"])(i >= 0 && i < this.ELEMENTS, 'index is out of range');
      this[i] = value;
      return this.check();
    }
  }, {
    key: "addVectors",
    value: function addVectors(a, b) {
      return this.copy(a).add(b);
    }
  }, {
    key: "subVectors",
    value: function subVectors(a, b) {
      return this.copy(a).subtract(b);
    }
  }, {
    key: "multiplyVectors",
    value: function multiplyVectors(a, b) {
      return this.copy(a).multiply(b);
    }
  }, {
    key: "addScaledVector",
    value: function addScaledVector(a, b) {
      return this.add(new this.constructor(a).multiplyScalar(b));
    }
  }, {
    key: "x",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(value);
    }
  }, {
    key: "y",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(value);
    }
  }]);

  return Vector;
}(_math_array__WEBPACK_IMPORTED_MODULE_5__["default"]);


//# sourceMappingURL=vector.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/euler.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/classes/euler.js ***!
  \*********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Euler; });
/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ "../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _base_math_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./base/math-array */ "../../node_modules/math.gl/dist/esm/classes/base/math-array.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var _quaternion__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./quaternion */ "../../node_modules/math.gl/dist/esm/classes/quaternion.js");










var ERR_UNKNOWN_ORDER = 'Unknown Euler angle order';
var ALMOST_ONE = 0.99999;

function validateOrder(value) {
  return value >= 0 && value < 6;
}

function checkOrder(value) {
  if (value < 0 && value >= 6) {
    throw new Error(ERR_UNKNOWN_ORDER);
  }

  return value;
}

var Euler = function (_MathArray) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__["default"])(Euler, _MathArray);

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(Euler, [{
    key: "ELEMENTS",
    get: function get() {
      return 4;
    }
  }], [{
    key: "rotationOrder",
    value: function rotationOrder(order) {
      return Euler.RotationOrders[order];
    }
  }, {
    key: "ZYX",
    get: function get() {
      return 0;
    }
  }, {
    key: "YXZ",
    get: function get() {
      return 1;
    }
  }, {
    key: "XZY",
    get: function get() {
      return 2;
    }
  }, {
    key: "ZXY",
    get: function get() {
      return 3;
    }
  }, {
    key: "YZX",
    get: function get() {
      return 4;
    }
  }, {
    key: "XYZ",
    get: function get() {
      return 5;
    }
  }, {
    key: "RollPitchYaw",
    get: function get() {
      return 0;
    }
  }, {
    key: "DefaultOrder",
    get: function get() {
      return Euler.ZYX;
    }
  }, {
    key: "RotationOrders",
    get: function get() {
      return ['ZYX', 'YXZ', 'XZY', 'ZXY', 'YZX', 'XYZ'];
    }
  }]);

  function Euler() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Euler.DefaultOrder;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, Euler);

    _this = Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Euler).call(this, -0, -0, -0, -0));

    if (arguments.length > 0 && Array.isArray(arguments[0])) {
      var _this2;

      (_this2 = _this).fromVector3.apply(_this2, arguments);
    } else {
      _this.set(x, y, z, order);
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(Euler, [{
    key: "fromQuaternion",
    value: function fromQuaternion(quaternion) {
      var _quaternion = Object(_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(quaternion, 4),
          x = _quaternion[0],
          y = _quaternion[1],
          z = _quaternion[2],
          w = _quaternion[3];

      var ysqr = y * y;
      var t0 = -2.0 * (ysqr + z * z) + 1.0;
      var t1 = +2.0 * (x * y + w * z);
      var t2 = -2.0 * (x * z - w * y);
      var t3 = +2.0 * (y * z + w * x);
      var t4 = -2.0 * (x * x + ysqr) + 1.0;
      t2 = t2 > 1.0 ? 1.0 : t2;
      t2 = t2 < -1.0 ? -1.0 : t2;
      var roll = Math.atan2(t3, t4);
      var pitch = Math.asin(t2);
      var yaw = Math.atan2(t1, t0);
      return new Euler(roll, pitch, yaw, Euler.RollPitchYaw);
    }
  }, {
    key: "copy",
    value: function copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = Number.isFinite(array[3]) || this.order;
      return this.check();
    }
  }, {
    key: "set",
    value: function set() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var order = arguments.length > 3 ? arguments[3] : undefined;
      this[0] = x;
      this[1] = y;
      this[2] = z;
      this[3] = Number.isFinite(order) ? order : this[3];
      return this.check();
    }
  }, {
    key: "validate",
    value: function validate() {
      return validateOrder(this[3]) && Number.isFinite(this[0]) && Number.isFinite(this[1]) && Number.isFinite(this[2]);
    }
  }, {
    key: "toArray",
    value: function toArray() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this[0];
      array[offset + 1] = this[1];
      array[offset + 2] = this[2];
      return array;
    }
  }, {
    key: "toArray4",
    value: function toArray4() {
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      array[offset] = this[0];
      array[offset + 1] = this[1];
      array[offset + 2] = this[2];
      array[offset + 3] = this[3];
      return array;
    }
  }, {
    key: "toVector3",
    value: function toVector3() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [-0, -0, -0];
      result[0] = this[0];
      result[1] = this[1];
      result[2] = this[2];
      return result;
    }
  }, {
    key: "fromVector3",
    value: function fromVector3(v, order) {
      return this.set(v[0], v[1], v[2], Number.isFinite(order) ? order : this[3]);
    }
  }, {
    key: "fromArray",
    value: function fromArray(array) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      this[0] = array[0 + offset];
      this[1] = array[1 + offset];
      this[2] = array[2 + offset];

      if (array[3] !== undefined) {
        this[3] = array[3];
      }

      return this.check();
    }
  }, {
    key: "fromRollPitchYaw",
    value: function fromRollPitchYaw(roll, pitch, yaw) {
      return this.set(roll, pitch, yaw, Euler.ZYX);
    }
  }, {
    key: "fromRotationMatrix",
    value: function fromRotationMatrix(m) {
      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Euler.DefaultOrder;

      this._fromRotationMatrix(m, order);

      return this.check();
    }
  }, {
    key: "getRotationMatrix",
    value: function getRotationMatrix(m) {
      return this._getRotationMatrix(m);
    }
  }, {
    key: "getQuaternion",
    value: function getQuaternion() {
      var q = new _quaternion__WEBPACK_IMPORTED_MODULE_9__["default"]();

      switch (this[4]) {
        case Euler.XYZ:
          return q.rotateX(this[0]).rotateY(this[1]).rotateZ(this[2]);

        case Euler.YXZ:
          return q.rotateY(this[0]).rotateX(this[1]).rotateZ(this[2]);

        case Euler.ZXY:
          return q.rotateZ(this[0]).rotateX(this[1]).rotateY(this[2]);

        case Euler.ZYX:
          return q.rotateZ(this[0]).rotateY(this[1]).rotateX(this[2]);

        case Euler.YZX:
          return q.rotateY(this[0]).rotateZ(this[1]).rotateX(this[2]);

        case Euler.XZY:
          return q.rotateX(this[0]).rotateZ(this[1]).rotateY(this[2]);

        default:
          throw new Error(ERR_UNKNOWN_ORDER);
      }
    }
  }, {
    key: "_fromRotationMatrix",
    value: function _fromRotationMatrix(m) {
      var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Euler.DefaultOrder;
      var te = m.elements;
      var m11 = te[0],
          m12 = te[4],
          m13 = te[8];
      var m21 = te[1],
          m22 = te[5],
          m23 = te[9];
      var m31 = te[2],
          m32 = te[6],
          m33 = te[10];
      order = order || this[3];

      switch (order) {
        case Euler.XYZ:
          this[1] = Math.asin(Object(_lib_common__WEBPACK_IMPORTED_MODULE_7__["clamp"])(m13, -1, 1));

          if (Math.abs(m13) < ALMOST_ONE) {
            this[0] = Math.atan2(-m23, m33);
            this[2] = Math.atan2(-m12, m11);
          } else {
            this[0] = Math.atan2(m32, m22);
            this[2] = 0;
          }

          break;

        case Euler.YXZ:
          this[0] = Math.asin(-Object(_lib_common__WEBPACK_IMPORTED_MODULE_7__["clamp"])(m23, -1, 1));

          if (Math.abs(m23) < ALMOST_ONE) {
            this[1] = Math.atan2(m13, m33);
            this[2] = Math.atan2(m21, m22);
          } else {
            this[1] = Math.atan2(-m31, m11);
            this[2] = 0;
          }

          break;

        case Euler.ZXY:
          this[0] = Math.asin(Object(_lib_common__WEBPACK_IMPORTED_MODULE_7__["clamp"])(m32, -1, 1));

          if (Math.abs(m32) < ALMOST_ONE) {
            this[1] = Math.atan2(-m31, m33);
            this[2] = Math.atan2(-m12, m22);
          } else {
            this[1] = 0;
            this[2] = Math.atan2(m21, m11);
          }

          break;

        case Euler.ZYX:
          this[1] = Math.asin(-Object(_lib_common__WEBPACK_IMPORTED_MODULE_7__["clamp"])(m31, -1, 1));

          if (Math.abs(m31) < ALMOST_ONE) {
            this[0] = Math.atan2(m32, m33);
            this[2] = Math.atan2(m21, m11);
          } else {
            this[0] = 0;
            this[2] = Math.atan2(-m12, m22);
          }

          break;

        case Euler.YZX:
          this[2] = Math.asin(Object(_lib_common__WEBPACK_IMPORTED_MODULE_7__["clamp"])(m21, -1, 1));

          if (Math.abs(m21) < ALMOST_ONE) {
            this[0] = Math.atan2(-m23, m22);
            this[1] = Math.atan2(-m31, m11);
          } else {
            this[0] = 0;
            this[1] = Math.atan2(m13, m33);
          }

          break;

        case Euler.XZY:
          this[2] = Math.asin(-Object(_lib_common__WEBPACK_IMPORTED_MODULE_7__["clamp"])(m12, -1, 1));

          if (Math.abs(m12) < ALMOST_ONE) {
            this[0] = Math.atan2(m32, m22);
            this[1] = Math.atan2(m13, m11);
          } else {
            this[0] = Math.atan2(-m23, m33);
            this[1] = 0;
          }

          break;

        default:
          throw new Error(ERR_UNKNOWN_ORDER);
      }

      this[3] = order;
      return this;
    }
  }, {
    key: "_getRotationMatrix",
    value: function _getRotationMatrix(result) {
      var te = result || [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      var x = this.x,
          y = this.y,
          z = this.z;
      var a = Math.cos(x);
      var c = Math.cos(y);
      var e = Math.cos(z);
      var b = Math.sin(x);
      var d = Math.sin(y);
      var f = Math.sin(z);

      switch (this[3]) {
        case Euler.XYZ:
          {
            var ae = a * e,
                af = a * f,
                be = b * e,
                bf = b * f;
            te[0] = c * e;
            te[4] = -c * f;
            te[8] = d;
            te[1] = af + be * d;
            te[5] = ae - bf * d;
            te[9] = -b * c;
            te[2] = bf - ae * d;
            te[6] = be + af * d;
            te[10] = a * c;
            break;
          }

        case Euler.YXZ:
          {
            var ce = c * e,
                cf = c * f,
                de = d * e,
                df = d * f;
            te[0] = ce + df * b;
            te[4] = de * b - cf;
            te[8] = a * d;
            te[1] = a * f;
            te[5] = a * e;
            te[9] = -b;
            te[2] = cf * b - de;
            te[6] = df + ce * b;
            te[10] = a * c;
            break;
          }

        case Euler.ZXY:
          {
            var _ce = c * e,
                _cf = c * f,
                _de = d * e,
                _df = d * f;

            te[0] = _ce - _df * b;
            te[4] = -a * f;
            te[8] = _de + _cf * b;
            te[1] = _cf + _de * b;
            te[5] = a * e;
            te[9] = _df - _ce * b;
            te[2] = -a * d;
            te[6] = b;
            te[10] = a * c;
            break;
          }

        case Euler.ZYX:
          {
            var _ae = a * e,
                _af = a * f,
                _be = b * e,
                _bf = b * f;

            te[0] = c * e;
            te[4] = _be * d - _af;
            te[8] = _ae * d + _bf;
            te[1] = c * f;
            te[5] = _bf * d + _ae;
            te[9] = _af * d - _be;
            te[2] = -d;
            te[6] = b * c;
            te[10] = a * c;
            break;
          }

        case Euler.YZX:
          {
            var ac = a * c,
                ad = a * d,
                bc = b * c,
                bd = b * d;
            te[0] = c * e;
            te[4] = bd - ac * f;
            te[8] = bc * f + ad;
            te[1] = f;
            te[5] = a * e;
            te[9] = -b * e;
            te[2] = -d * e;
            te[6] = ad * f + bc;
            te[10] = ac - bd * f;
            break;
          }

        case Euler.XZY:
          {
            var _ac = a * c,
                _ad = a * d,
                _bc = b * c,
                _bd = b * d;

            te[0] = c * e;
            te[4] = -f;
            te[8] = d * e;
            te[1] = _ac * f + _bd;
            te[5] = a * e;
            te[9] = _ad * f - _bc;
            te[2] = _bc * f - _ad;
            te[6] = b * e;
            te[10] = _bd * f + _ac;
            break;
          }

        default:
          throw new Error(ERR_UNKNOWN_ORDER);
      }

      te[3] = 0;
      te[7] = 0;
      te[11] = 0;
      te[12] = 0;
      te[13] = 0;
      te[14] = 0;
      te[15] = 1;
      return te;
    }
  }, {
    key: "toQuaternion",
    value: function toQuaternion() {
      var cy = Math.cos(this.yaw * 0.5);
      var sy = Math.sin(this.yaw * 0.5);
      var cr = Math.cos(this.roll * 0.5);
      var sr = Math.sin(this.roll * 0.5);
      var cp = Math.cos(this.pitch * 0.5);
      var sp = Math.sin(this.pitch * 0.5);
      var w = cy * cr * cp + sy * sr * sp;
      var x = cy * sr * cp - sy * cr * sp;
      var y = cy * cr * sp + sy * sr * cp;
      var z = sy * cr * cp - cy * sr * sp;
      return new _quaternion__WEBPACK_IMPORTED_MODULE_9__["default"](x, y, z, w);
    }
  }, {
    key: "x",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "y",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "alpha",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "beta",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "gamma",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "phi",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "theta",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "psi",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "roll",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "pitch",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "yaw",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"])(value);
    }
  }, {
    key: "order",
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = checkOrder(value);
    }
  }]);

  return Euler;
}(_base_math_array__WEBPACK_IMPORTED_MODULE_6__["default"]);


//# sourceMappingURL=euler.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/matrix3.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/classes/matrix3.js ***!
  \***********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Matrix3; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _base_matrix__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base/matrix */ "../../node_modules/math.gl/dist/esm/classes/base/matrix.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "../../node_modules/math.gl/dist/esm/lib/gl-matrix-extras.js");
/* harmony import */ var gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gl-matrix/mat3 */ "../../node_modules/gl-matrix/esm/mat3.js");
/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gl-matrix/vec2 */ "../../node_modules/gl-matrix/esm/vec2.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");











var IDENTITY = Object.freeze([1, 0, 0, 0, 1, 0, 0, 0, 1]);
var ZERO = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0]);
var INDICES = Object.freeze({
  COL0ROW0: 0,
  COL0ROW1: 1,
  COL0ROW2: 2,
  COL1ROW0: 3,
  COL1ROW1: 4,
  COL1ROW2: 5,
  COL2ROW0: 6,
  COL2ROW1: 7,
  COL2ROW2: 8
});
var constants = {};

var Matrix3 = function (_Matrix) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Matrix3, _Matrix);

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(Matrix3, [{
    key: "ELEMENTS",
    get: function get() {
      return 9;
    }
  }, {
    key: "RANK",
    get: function get() {
      return 3;
    }
  }, {
    key: "INDICES",
    get: function get() {
      return INDICES;
    }
  }], [{
    key: "IDENTITY",
    get: function get() {
      constants.IDENTITY = constants.IDENTITY || Object.freeze(new Matrix3(IDENTITY));
      return constants.IDENTITY;
    }
  }, {
    key: "ZERO",
    get: function get() {
      constants.ZERO = constants.ZERO || Object.freeze(new Matrix3(ZERO));
      return constants.ZERO;
    }
  }]);

  function Matrix3(array) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Matrix3);

    _this = Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2__["default"])(Matrix3).call(this, -0, -0, -0, -0, -0, -0, -0, -0, -0));

    if (arguments.length === 1 && Array.isArray(array)) {
      _this.copy(array);
    } else {
      _this.identity();
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_3__["default"])(Matrix3, [{
    key: "copy",
    value: function copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      return this.check();
    }
  }, {
    key: "set",
    value: function set(m00, m10, m20, m01, m11, m21, m02, m12, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
  }, {
    key: "setRowMajor",
    value: function setRowMajor(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m01;
      this[4] = m11;
      this[5] = m21;
      this[6] = m02;
      this[7] = m12;
      this[8] = m22;
      return this.check();
    }
  }, {
    key: "determinant",
    value: function determinant() {
      return gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["determinant"](this);
    }
  }, {
    key: "identity",
    value: function identity() {
      return this.copy(IDENTITY);
    }
  }, {
    key: "fromQuaternion",
    value: function fromQuaternion(q) {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["fromQuat"](this, q);
      return this.check();
    }
  }, {
    key: "transpose",
    value: function transpose() {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["transpose"](this, this);
      return this.check();
    }
  }, {
    key: "invert",
    value: function invert() {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["invert"](this, this);
      return this.check();
    }
  }, {
    key: "multiplyLeft",
    value: function multiplyLeft(a) {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["multiply"](this, a, this);
      return this.check();
    }
  }, {
    key: "multiplyRight",
    value: function multiplyRight(a) {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["multiply"](this, this, a);
      return this.check();
    }
  }, {
    key: "rotate",
    value: function rotate(radians) {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["rotate"](this, this, radians);
      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(factor) {
      if (Array.isArray(factor)) {
        gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["scale"](this, this, factor);
      } else {
        gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["scale"](this, this, [factor, factor, factor]);
      }

      return this.check();
    }
  }, {
    key: "translate",
    value: function translate(vec) {
      gl_matrix_mat3__WEBPACK_IMPORTED_MODULE_8__["translate"](this, this, vec);
      return this.check();
    }
  }, {
    key: "transform",
    value: function transform(vector, result) {
      switch (vector.length) {
        case 2:
          result = gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_9__["transformMat3"](result || [-0, -0], vector, this);
          break;

        case 3:
          result = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_10__["transformMat3"](result || [-0, -0, -0], vector, this);
          break;

        case 4:
          result = Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_7__["vec4_transformMat3"])(result || [-0, -0, -0, -0], vector, this);
          break;

        default:
          throw new Error('Illegal vector');
      }

      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkVector"])(result, vector.length);
      return result;
    }
  }, {
    key: "transformVector",
    value: function transformVector(vector, result) {
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["deprecated"])('Matrix3.transformVector');
      return this.transform(vector, result);
    }
  }, {
    key: "transformVector2",
    value: function transformVector2(vector, result) {
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["deprecated"])('Matrix3.transformVector');
      return this.transform(vector, result);
    }
  }, {
    key: "transformVector3",
    value: function transformVector3(vector, result) {
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["deprecated"])('Matrix3.transformVector');
      return this.transform(vector, result);
    }
  }]);

  return Matrix3;
}(_base_matrix__WEBPACK_IMPORTED_MODULE_5__["default"]);


//# sourceMappingURL=matrix3.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/matrix4.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/classes/matrix4.js ***!
  \***********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Matrix4; });
/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ "../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var _base_matrix__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base/matrix */ "../../node_modules/math.gl/dist/esm/classes/base/matrix.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "../../node_modules/math.gl/dist/esm/lib/gl-matrix-extras.js");
/* harmony import */ var gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gl-matrix/mat4 */ "../../node_modules/gl-matrix/esm/mat4.js");
/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! gl-matrix/vec2 */ "../../node_modules/gl-matrix/esm/vec2.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! gl-matrix/vec4 */ "../../node_modules/gl-matrix/esm/vec4.js");













var IDENTITY = Object.freeze([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
var ZERO = Object.freeze([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
var INDICES = Object.freeze({
  COL0ROW0: 0,
  COL0ROW1: 1,
  COL0ROW2: 2,
  COL0ROW3: 3,
  COL1ROW0: 4,
  COL1ROW1: 5,
  COL1ROW2: 6,
  COL1ROW3: 7,
  COL2ROW0: 8,
  COL2ROW1: 9,
  COL2ROW2: 10,
  COL2ROW3: 11,
  COL3ROW0: 12,
  COL3ROW1: 13,
  COL3ROW2: 14,
  COL3ROW3: 15
});
var constants = {};

var Matrix4 = function (_Matrix) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__["default"])(Matrix4, _Matrix);

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(Matrix4, [{
    key: "INDICES",
    get: function get() {
      return INDICES;
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 16;
    }
  }, {
    key: "RANK",
    get: function get() {
      return 4;
    }
  }], [{
    key: "IDENTITY",
    get: function get() {
      constants.IDENTITY = constants.IDENTITY || Object.freeze(new Matrix4(IDENTITY));
      return constants.IDENTITY;
    }
  }, {
    key: "ZERO",
    get: function get() {
      constants.ZERO = constants.ZERO || Object.freeze(new Matrix4(ZERO));
      return constants.ZERO;
    }
  }]);

  function Matrix4(array) {
    var _this;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, Matrix4);

    _this = Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Matrix4).call(this, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0));

    if (arguments.length === 1 && Array.isArray(array)) {
      _this.copy(array);
    } else {
      _this.identity();
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(Matrix4, [{
    key: "copy",
    value: function copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      this[4] = array[4];
      this[5] = array[5];
      this[6] = array[6];
      this[7] = array[7];
      this[8] = array[8];
      this[9] = array[9];
      this[10] = array[10];
      this[11] = array[11];
      this[12] = array[12];
      this[13] = array[13];
      this[14] = array[14];
      this[15] = array[15];
      return this.check();
    }
  }, {
    key: "set",
    value: function set(m00, m10, m20, m30, m01, m11, m21, m31, m02, m12, m22, m32, m03, m13, m23, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
  }, {
    key: "setRowMajor",
    value: function setRowMajor(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
      this[0] = m00;
      this[1] = m10;
      this[2] = m20;
      this[3] = m30;
      this[4] = m01;
      this[5] = m11;
      this[6] = m21;
      this[7] = m31;
      this[8] = m02;
      this[9] = m12;
      this[10] = m22;
      this[11] = m32;
      this[12] = m03;
      this[13] = m13;
      this[14] = m23;
      this[15] = m33;
      return this.check();
    }
  }, {
    key: "toRowMajor",
    value: function toRowMajor(result) {
      result[0] = this[0];
      result[1] = this[4];
      result[2] = this[8];
      result[3] = this[12];
      result[4] = this[1];
      result[5] = this[5];
      result[6] = this[9];
      result[7] = this[13];
      result[8] = this[2];
      result[9] = this[6];
      result[10] = this[10];
      result[11] = this[14];
      result[12] = this[3];
      result[13] = this[7];
      result[14] = this[11];
      result[15] = this[15];
      return result;
    }
  }, {
    key: "identity",
    value: function identity() {
      return this.copy(IDENTITY);
    }
  }, {
    key: "fromQuaternion",
    value: function fromQuaternion(q) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["fromQuat"](this, q);
      return this.check();
    }
  }, {
    key: "frustum",
    value: function frustum(_ref) {
      var left = _ref.left,
          right = _ref.right,
          bottom = _ref.bottom,
          top = _ref.top,
          near = _ref.near,
          far = _ref.far;

      if (far === Infinity) {
        Matrix4._computeInfinitePerspectiveOffCenter(this, left, right, bottom, top, near);
      } else {
        gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["frustum"](this, left, right, bottom, top, near, far);
      }

      return this.check();
    }
  }, {
    key: "lookAt",
    value: function lookAt(eye, center, up) {
      if (arguments.length === 1) {
        var _eye = eye;
        eye = _eye.eye;
        center = _eye.center;
        up = _eye.up;
      }

      center = center || [0, 0, 0];
      up = up || [0, 1, 0];
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["lookAt"](this, eye, center, up);
      return this.check();
    }
  }, {
    key: "ortho",
    value: function ortho(_ref2) {
      var left = _ref2.left,
          right = _ref2.right,
          bottom = _ref2.bottom,
          top = _ref2.top,
          _ref2$near = _ref2.near,
          near = _ref2$near === void 0 ? 0.1 : _ref2$near,
          _ref2$far = _ref2.far,
          far = _ref2$far === void 0 ? 500 : _ref2$far;
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["ortho"](this, left, right, bottom, top, near, far);
      return this.check();
    }
  }, {
    key: "orthographic",
    value: function orthographic(_ref3) {
      var _ref3$fovy = _ref3.fovy,
          fovy = _ref3$fovy === void 0 ? 45 * Math.PI / 180 : _ref3$fovy,
          _ref3$aspect = _ref3.aspect,
          aspect = _ref3$aspect === void 0 ? 1 : _ref3$aspect,
          _ref3$focalDistance = _ref3.focalDistance,
          focalDistance = _ref3$focalDistance === void 0 ? 1 : _ref3$focalDistance,
          _ref3$near = _ref3.near,
          near = _ref3$near === void 0 ? 0.1 : _ref3$near,
          _ref3$far = _ref3.far,
          far = _ref3$far === void 0 ? 500 : _ref3$far;

      if (fovy > Math.PI * 2) {
        throw Error('radians');
      }

      var halfY = fovy / 2;
      var top = focalDistance * Math.tan(halfY);
      var right = top * aspect;
      return new Matrix4().ortho({
        left: -right,
        right: right,
        bottom: -top,
        top: top,
        near: near,
        far: far
      });
    }
  }, {
    key: "perspective",
    value: function perspective() {
      var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          fovy = _ref4.fovy,
          _ref4$fov = _ref4.fov,
          fov = _ref4$fov === void 0 ? 45 * Math.PI / 180 : _ref4$fov,
          _ref4$aspect = _ref4.aspect,
          aspect = _ref4$aspect === void 0 ? 1 : _ref4$aspect,
          _ref4$near = _ref4.near,
          near = _ref4$near === void 0 ? 0.1 : _ref4$near,
          _ref4$far = _ref4.far,
          far = _ref4$far === void 0 ? 500 : _ref4$far;

      fovy = fovy || fov;

      if (fovy > Math.PI * 2) {
        throw Error('radians');
      }

      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["perspective"](this, fovy, aspect, near, far);
      return this.check();
    }
  }, {
    key: "determinant",
    value: function determinant() {
      return gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["determinant"](this);
    }
  }, {
    key: "getScale",
    value: function getScale() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [-0, -0, -0];
      result[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]);
      result[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]);
      result[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]);
      return result;
    }
  }, {
    key: "getTranslation",
    value: function getTranslation() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [-0, -0, -0];
      result[0] = this[12];
      result[1] = this[13];
      result[2] = this[14];
      return result;
    }
  }, {
    key: "getRotation",
    value: function getRotation() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0];
      var scaleResult = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var scale = this.getScale(scaleResult || [-0, -0, -0]);
      var inverseScale0 = 1 / scale[0];
      var inverseScale1 = 1 / scale[1];
      var inverseScale2 = 1 / scale[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = 0;
      result[4] = this[4] * inverseScale0;
      result[5] = this[5] * inverseScale1;
      result[6] = this[6] * inverseScale2;
      result[7] = 0;
      result[8] = this[8] * inverseScale0;
      result[9] = this[9] * inverseScale1;
      result[10] = this[10] * inverseScale2;
      result[11] = 0;
      result[12] = 0;
      result[13] = 0;
      result[14] = 0;
      result[15] = 1;
      return result;
    }
  }, {
    key: "getRotationMatrix3",
    value: function getRotationMatrix3() {
      var result = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [-0, -0, -0, -0, -0, -0, -0, -0, -0];
      var scaleResult = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var scale = this.getScale(scaleResult || [-0, -0, -0]);
      var inverseScale0 = 1 / scale[0];
      var inverseScale1 = 1 / scale[1];
      var inverseScale2 = 1 / scale[2];
      result[0] = this[0] * inverseScale0;
      result[1] = this[1] * inverseScale1;
      result[2] = this[2] * inverseScale2;
      result[3] = this[4] * inverseScale0;
      result[4] = this[5] * inverseScale1;
      result[5] = this[6] * inverseScale2;
      result[6] = this[8] * inverseScale0;
      result[7] = this[9] * inverseScale1;
      result[8] = this[10] * inverseScale2;
      return result;
    }
  }, {
    key: "transpose",
    value: function transpose() {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["transpose"](this, this);
      return this.check();
    }
  }, {
    key: "invert",
    value: function invert() {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["invert"](this, this);
      return this.check();
    }
  }, {
    key: "multiplyLeft",
    value: function multiplyLeft(a) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["multiply"](this, a, this);
      return this.check();
    }
  }, {
    key: "multiplyRight",
    value: function multiplyRight(a) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["multiply"](this, this, a);
      return this.check();
    }
  }, {
    key: "rotateX",
    value: function rotateX(radians) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["rotateX"](this, this, radians);
      return this.check();
    }
  }, {
    key: "rotateY",
    value: function rotateY(radians) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["rotateY"](this, this, radians);
      return this.check();
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(radians) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["rotateZ"](this, this, radians);
      return this.check();
    }
  }, {
    key: "rotateXYZ",
    value: function rotateXYZ(_ref5) {
      var _ref6 = Object(_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_ref5, 3),
          rx = _ref6[0],
          ry = _ref6[1],
          rz = _ref6[2];

      return this.rotateX(rx).rotateY(ry).rotateZ(rz);
    }
  }, {
    key: "rotateAxis",
    value: function rotateAxis(radians, axis) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["rotate"](this, this, radians, axis);
      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(factor) {
      if (Array.isArray(factor)) {
        gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["scale"](this, this, factor);
      } else {
        gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["scale"](this, this, [factor, factor, factor]);
      }

      return this.check();
    }
  }, {
    key: "translate",
    value: function translate(vec) {
      gl_matrix_mat4__WEBPACK_IMPORTED_MODULE_9__["translate"](this, this, vec);
      return this.check();
    }
  }, {
    key: "transform",
    value: function transform(vector, result) {
      if (vector.length === 4) {
        result = gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_12__["transformMat4"](result || [-0, -0, -0, -0], vector, this);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkVector"])(result, 4);
        return result;
      }

      return this.transformAsPoint(vector, result);
    }
  }, {
    key: "transformAsPoint",
    value: function transformAsPoint(vector, result) {
      var length = vector.length;

      switch (length) {
        case 2:
          result = gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_10__["transformMat4"](result || [-0, -0], vector, this);
          break;

        case 3:
          result = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_11__["transformMat4"](result || [-0, -0, -0], vector, this);
          break;

        default:
          throw new Error('Illegal vector');
      }

      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkVector"])(result, vector.length);
      return result;
    }
  }, {
    key: "transformAsVector",
    value: function transformAsVector(vector, result) {
      switch (vector.length) {
        case 2:
          result = Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_8__["vec2_transformMat4AsVector"])(result || [-0, -0], vector, this);
          break;

        case 3:
          result = Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_8__["vec3_transformMat4AsVector"])(result || [-0, -0, -0], vector, this);
          break;

        default:
          throw new Error('Illegal vector');
      }

      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkVector"])(result, vector.length);
      return result;
    }
  }, {
    key: "makeRotationX",
    value: function makeRotationX(radians) {
      return this.identity().rotateX(radians);
    }
  }, {
    key: "makeTranslation",
    value: function makeTranslation(x, y, z) {
      return this.identity().translate([x, y, z]);
    }
  }, {
    key: "transformPoint",
    value: function transformPoint(vector, result) {
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["deprecated"])('Matrix4.transformPoint', '3.0');
      return this.transformAsPoint(vector, result);
    }
  }, {
    key: "transformVector",
    value: function transformVector(vector, result) {
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["deprecated"])('Matrix4.transformVector', '3.0');
      return this.transformAsPoint(vector, result);
    }
  }, {
    key: "transformDirection",
    value: function transformDirection(vector, result) {
      Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["deprecated"])('Matrix4.transformDirection', '3.0');
      return this.transformAsVector(vector, result);
    }
  }], [{
    key: "_computeInfinitePerspectiveOffCenter",
    value: function _computeInfinitePerspectiveOffCenter(result, left, right, bottom, top, near) {
      var column0Row0 = 2.0 * near / (right - left);
      var column1Row1 = 2.0 * near / (top - bottom);
      var column2Row0 = (right + left) / (right - left);
      var column2Row1 = (top + bottom) / (top - bottom);
      var column2Row2 = -1.0;
      var column2Row3 = -1.0;
      var column3Row2 = -2.0 * near;
      result[0] = column0Row0;
      result[1] = 0.0;
      result[2] = 0.0;
      result[3] = 0.0;
      result[4] = 0.0;
      result[5] = column1Row1;
      result[6] = 0.0;
      result[7] = 0.0;
      result[8] = column2Row0;
      result[9] = column2Row1;
      result[10] = column2Row2;
      result[11] = column2Row3;
      result[12] = 0.0;
      result[13] = 0.0;
      result[14] = column3Row2;
      result[15] = 0.0;
      return result;
    }
  }]);

  return Matrix4;
}(_base_matrix__WEBPACK_IMPORTED_MODULE_7__["default"]);


//# sourceMappingURL=matrix4.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/pose.js":
/*!********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/classes/pose.js ***!
  \********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Pose; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _matrix4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./matrix4 */ "../../node_modules/math.gl/dist/esm/classes/matrix4.js");
/* harmony import */ var _vector3__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vector3 */ "../../node_modules/math.gl/dist/esm/classes/vector3.js");
/* harmony import */ var _euler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./euler */ "../../node_modules/math.gl/dist/esm/classes/euler.js");






var Pose = function () {
  function Pose() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        _ref$x = _ref.x,
        x = _ref$x === void 0 ? 0 : _ref$x,
        _ref$y = _ref.y,
        y = _ref$y === void 0 ? 0 : _ref$y,
        _ref$z = _ref.z,
        z = _ref$z === void 0 ? 0 : _ref$z,
        _ref$roll = _ref.roll,
        roll = _ref$roll === void 0 ? 0 : _ref$roll,
        _ref$pitch = _ref.pitch,
        pitch = _ref$pitch === void 0 ? 0 : _ref$pitch,
        _ref$yaw = _ref.yaw,
        yaw = _ref$yaw === void 0 ? 0 : _ref$yaw,
        position = _ref.position,
        orientation = _ref.orientation;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Pose);

    if (Array.isArray(position) && position.length === 3) {
      this.position = new _vector3__WEBPACK_IMPORTED_MODULE_3__["default"](position);
    } else {
      this.position = new _vector3__WEBPACK_IMPORTED_MODULE_3__["default"](x, y, z);
    }

    if (Array.isArray(orientation) && orientation.length === 4) {
      this.orientation = new _euler__WEBPACK_IMPORTED_MODULE_4__["default"](orientation, orientation[3]);
    } else {
      this.orientation = new _euler__WEBPACK_IMPORTED_MODULE_4__["default"](roll, pitch, yaw, _euler__WEBPACK_IMPORTED_MODULE_4__["default"].RollPitchYaw);
    }
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Pose, [{
    key: "getPosition",
    value: function getPosition() {
      return this.position;
    }
  }, {
    key: "getOrientation",
    value: function getOrientation() {
      return this.orientation;
    }
  }, {
    key: "equals",
    value: function equals(pose) {
      if (!pose) {
        return false;
      }

      return this.position.equals(pose.position) && this.orientation.equals(pose.orientation);
    }
  }, {
    key: "exactEquals",
    value: function exactEquals(pose) {
      if (!pose) {
        return false;
      }

      return this.position.exactEquals(pose.position) && this.orientation.exactEquals(pose.orientation);
    }
  }, {
    key: "getTransformationMatrix",
    value: function getTransformationMatrix() {
      var sr = Math.sin(this.roll);
      var sp = Math.sin(this.pitch);
      var sw = Math.sin(this.yaw);
      var cr = Math.cos(this.roll);
      var cp = Math.cos(this.pitch);
      var cw = Math.cos(this.yaw);
      var matrix = new _matrix4__WEBPACK_IMPORTED_MODULE_2__["default"]().setRowMajor(cw * cp, -sw * cr + cw * sp * sr, sw * sr + cw * sp * cr, this.x, sw * cp, cw * cr + sw * sp * sr, -cw * sr + sw * sp * cr, this.y, -sp, cp * sr, cp * cr, this.z, 0, 0, 0, 1);
      return matrix;
    }
  }, {
    key: "getTransformationMatrixFromPose",
    value: function getTransformationMatrixFromPose(pose) {
      return new _matrix4__WEBPACK_IMPORTED_MODULE_2__["default"]().multiplyRight(this.getTransformationMatrix()).multiplyRight(pose.getTransformationMatrix().invert());
    }
  }, {
    key: "getTransformationMatrixToPose",
    value: function getTransformationMatrixToPose(pose) {
      return new _matrix4__WEBPACK_IMPORTED_MODULE_2__["default"]().multiplyRight(pose.getTransformationMatrix()).multiplyRight(this.getTransformationMatrix().invert());
    }
  }, {
    key: "x",
    get: function get() {
      return this.position.x;
    },
    set: function set(value) {
      return this.position.x = value;
    }
  }, {
    key: "y",
    get: function get() {
      return this.position.y;
    },
    set: function set(value) {
      return this.position.y = value;
    }
  }, {
    key: "z",
    get: function get() {
      return this.position.z;
    },
    set: function set(value) {
      return this.position.z = value;
    }
  }, {
    key: "roll",
    get: function get() {
      return this.orientation.roll;
    },
    set: function set(value) {
      return this.orientation.roll = value;
    }
  }, {
    key: "pitch",
    get: function get() {
      return this.orientation.pitch;
    },
    set: function set(value) {
      return this.orientation.pitch = value;
    }
  }, {
    key: "yaw",
    get: function get() {
      return this.orientation.yaw;
    },
    set: function set(value) {
      return this.orientation.yaw = value;
    }
  }]);

  return Pose;
}();


//# sourceMappingURL=pose.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/quaternion.js":
/*!**************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/classes/quaternion.js ***!
  \**************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Quaternion; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _base_math_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base/math-array */ "../../node_modules/math.gl/dist/esm/classes/base/math-array.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var _lib_assert__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/assert */ "../../node_modules/math.gl/dist/esm/lib/assert.js");
/* harmony import */ var gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gl-matrix/quat */ "../../node_modules/gl-matrix/esm/quat.js");
/* harmony import */ var gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! gl-matrix/vec4 */ "../../node_modules/gl-matrix/esm/vec4.js");










var IDENTITY_QUATERNION = [0, 0, 0, 1];

var Quaternion = function (_MathArray) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Quaternion, _MathArray);

  function Quaternion() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Quaternion);

    _this = Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Quaternion).call(this, -0, -0, -0, -0));

    if (Array.isArray(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      _this.set(x, y, z, w);
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Quaternion, [{
    key: "copy",
    value: function copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
  }, {
    key: "set",
    value: function set(x, y, z, w) {
      this[0] = x;
      this[1] = y;
      this[2] = z;
      this[3] = w;
      return this.check();
    }
  }, {
    key: "fromMatrix3",
    value: function fromMatrix3(m) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["fromMat3"](this, m);
      return this.check();
    }
  }, {
    key: "identity",
    value: function identity() {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["identity"](this);
      return this.check();
    }
  }, {
    key: "fromAxisRotation",
    value: function fromAxisRotation(axis, rad) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["setAxisAngle"](this, axis, rad);
      return this.check();
    }
  }, {
    key: "setAxisAngle",
    value: function setAxisAngle(axis, rad) {
      return this.fromAxisRotation(axis, rad);
    }
  }, {
    key: "len",
    value: function len() {
      return gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["length"](this);
    }
  }, {
    key: "lengthSquared",
    value: function lengthSquared(a) {
      return gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["squaredLength"](this);
    }
  }, {
    key: "dot",
    value: function dot(a, b) {
      if (b !== undefined) {
        throw new Error('Quaternion.dot only takes one argument');
      }

      return gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["dot"](this, a);
    }
  }, {
    key: "rotationTo",
    value: function rotationTo(vectorA, vectorB) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["rotationTo"](this, vectorA, vectorB);
      return this.check();
    }
  }, {
    key: "add",
    value: function add(a, b) {
      if (b !== undefined) {
        throw new Error('Quaternion.add only takes one argument');
      }

      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["add"](this, this, a);
      return this.check();
    }
  }, {
    key: "calculateW",
    value: function calculateW() {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["calculateW"](this, this);
      return this.check();
    }
  }, {
    key: "conjugate",
    value: function conjugate() {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["conjugate"](this, this);
      return this.check();
    }
  }, {
    key: "invert",
    value: function invert() {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["invert"](this, this);
      return this.check();
    }
  }, {
    key: "lerp",
    value: function lerp(a, b, t) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["lerp"](this, a, b, t);
      return this.check();
    }
  }, {
    key: "multiplyRight",
    value: function multiplyRight(a, b) {
      Object(_lib_assert__WEBPACK_IMPORTED_MODULE_7__["default"])(!b);
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["multiply"](this, this, a);
      return this.check();
    }
  }, {
    key: "multiplyLeft",
    value: function multiplyLeft(a, b) {
      Object(_lib_assert__WEBPACK_IMPORTED_MODULE_7__["default"])(!b);
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["multiply"](this, a, this);
      return this.check();
    }
  }, {
    key: "normalize",
    value: function normalize() {
      var length = this.len();
      var l = length > 0 ? 1 / length : 0;
      this[0] = this[0] * l;
      this[1] = this[1] * l;
      this[2] = this[2] * l;
      this[3] = this[3] * l;

      if (length === 0) {
        this[3] = 1;
      }

      return this.check();
    }
  }, {
    key: "rotateX",
    value: function rotateX(rad) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["rotateX"](this, this, rad);
      return this.check();
    }
  }, {
    key: "rotateY",
    value: function rotateY(rad) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["rotateY"](this, this, rad);
      return this.check();
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(rad) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["rotateZ"](this, this, rad);
      return this.check();
    }
  }, {
    key: "scale",
    value: function scale(b) {
      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["scale"](this, this, b);
      return this.check();
    }
  }, {
    key: "slerp",
    value: function slerp(start, target, ratio) {
      switch (arguments.length) {
        case 1:
          var _arguments$ = arguments[0];
          var _arguments$$start = _arguments$.start;
          start = _arguments$$start === void 0 ? IDENTITY_QUATERNION : _arguments$$start;
          target = _arguments$.target;
          ratio = _arguments$.ratio;
          break;

        case 2:
          var _arguments = Array.prototype.slice.call(arguments);

          target = _arguments[0];
          ratio = _arguments[1];
          start = this;
          break;

        default:
      }

      gl_matrix_quat__WEBPACK_IMPORTED_MODULE_8__["slerp"](this, start, target, ratio);
      return this.check();
    }
  }, {
    key: "transformVector4",
    value: function transformVector4(vector) {
      var result = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : vector;
      gl_matrix_vec4__WEBPACK_IMPORTED_MODULE_9__["transformQuat"](result, vector, this);
      return Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkVector"])(result, 4);
    }
  }, {
    key: "lengthSq",
    value: function lengthSq() {
      return this.lengthSquared();
    }
  }, {
    key: "setFromAxisAngle",
    value: function setFromAxisAngle(axis, rad) {
      return this.setAxisAngle(axis, rad);
    }
  }, {
    key: "premultiply",
    value: function premultiply(a, b) {
      return this.multiplyLeft(a, b);
    }
  }, {
    key: "multiply",
    value: function multiply(a, b) {
      return this.multiplyRight(a, b);
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 4;
    }
  }, {
    key: "x",
    get: function get() {
      return this[0];
    },
    set: function set(value) {
      return this[0] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(value);
    }
  }, {
    key: "y",
    get: function get() {
      return this[1];
    },
    set: function set(value) {
      return this[1] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(value);
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(value);
    }
  }, {
    key: "w",
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_6__["checkNumber"])(value);
    }
  }]);

  return Quaternion;
}(_base_math_array__WEBPACK_IMPORTED_MODULE_5__["default"]);


//# sourceMappingURL=quaternion.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/spherical-coordinates.js":
/*!*************************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/classes/spherical-coordinates.js ***!
  \*************************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SphericalCoordinates; });
/* harmony import */ var _babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/slicedToArray */ "../../node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");
/* harmony import */ var _vector3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vector3 */ "../../node_modules/math.gl/dist/esm/classes/vector3.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");







var EPSILON = 0.000001;
var EARTH_RADIUS_METERS = 6.371e6;

var SphericalCoordinates = function () {
  function SphericalCoordinates() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        phi = _ref.phi,
        theta = _ref.theta,
        radius = _ref.radius,
        bearing = _ref.bearing,
        pitch = _ref.pitch,
        altitude = _ref.altitude,
        _ref$radiusScale = _ref.radiusScale,
        radiusScale = _ref$radiusScale === void 0 ? EARTH_RADIUS_METERS : _ref$radiusScale;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_1__["default"])(this, SphericalCoordinates);

    if (arguments.length === 0) {
      this.phi = 0;
      this.theta = 0;
      this.radius = 1;
    } else if (Number.isFinite(phi) || Number.isFinite(theta)) {
      this.phi = phi || 0;
      this.theta = theta || 0;
    } else if (Number.isFinite(bearing) || Number.isFinite(pitch)) {
      this.bearing = bearing || 0;
      this.pitch = pitch || 0;
    }

    this.radius = radius || 1;
    this.radiusScale = radiusScale || 1;
    this.check();
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_2__["default"])(SphericalCoordinates, [{
    key: "toString",
    value: function toString() {
      return this.formatString(_lib_common__WEBPACK_IMPORTED_MODULE_3__["config"]);
    }
  }, {
    key: "formatString",
    value: function formatString(_ref2) {
      var printTypes = _ref2.printTypes,
          printDegrees = _ref2.printDegrees;
      var f = _lib_common__WEBPACK_IMPORTED_MODULE_3__["formatValue"];
      return "".concat(printTypes ? 'Spherical' : '', "[rho:").concat(f(this.radius), ",theta:").concat(f(this.theta), ",phi:").concat(f(this.phi), "]");
    }
  }, {
    key: "equals",
    value: function equals(other) {
      return Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["equals"])(this.radius, other.radius) && Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["equals"])(this.theta, other.theta) && Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["equals"])(this.phi, other.phi);
    }
  }, {
    key: "exactEquals",
    value: function exactEquals(other) {
      return this.radius === other.radius && this.theta === other.theta && this.phi === other.phi;
    }
  }, {
    key: "set",
    value: function set(radius, phi, theta) {
      this.radius = radius;
      this.phi = phi;
      this.theta = theta;
      return this.check();
    }
  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor().copy(this);
    }
  }, {
    key: "copy",
    value: function copy(other) {
      this.radius = other.radius;
      this.phi = other.phi;
      this.theta = other.theta;
      return this.check();
    }
  }, {
    key: "fromLngLatZ",
    value: function fromLngLatZ(_ref3) {
      var _ref4 = Object(_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_0__["default"])(_ref3, 3),
          lng = _ref4[0],
          lat = _ref4[1],
          z = _ref4[2];

      this.radius = 1 + z / this.radiusScale;
      this.phi = Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["radians"])(lat);
      this.theta = Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["radians"])(lng);
    }
  }, {
    key: "fromVector3",
    value: function fromVector3(v) {
      this.radius = gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_5__["length"](v);

      if (this.radius > 0) {
        this.theta = Math.atan2(v[0], v[1]);
        this.phi = Math.acos(Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["clamp"])(v[2] / this.radius, -1, 1));
      }

      return this.check();
    }
  }, {
    key: "toVector3",
    value: function toVector3() {
      return new _vector3__WEBPACK_IMPORTED_MODULE_4__["default"](0, 0, this.radius).rotateX({
        radians: this.theta
      }).rotateZ({
        radians: this.phi
      });
    }
  }, {
    key: "makeSafe",
    value: function makeSafe() {
      this.phi = Math.max(EPSILON, Math.min(Math.PI - EPSILON, this.phi));
    }
  }, {
    key: "check",
    value: function check() {
      if (!Number.isFinite(this.phi) || !Number.isFinite(this.theta) || !(this.radius > 0)) {
        throw new Error('SphericalCoordinates: some fields set to invalid numbers');
      }

      return this;
    }
  }, {
    key: "bearing",
    get: function get() {
      return 180 - Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["degrees"])(this.phi);
    },
    set: function set(v) {
      this.phi = Math.PI - Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["radians"])(v);
    }
  }, {
    key: "pitch",
    get: function get() {
      return Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["degrees"])(this.theta);
    },
    set: function set(v) {
      this.theta = Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["radians"])(v);
    }
  }, {
    key: "longitude",
    get: function get() {
      return Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["degrees"])(this.phi);
    }
  }, {
    key: "latitude",
    get: function get() {
      return Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["degrees"])(this.theta);
    }
  }, {
    key: "lng",
    get: function get() {
      return Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["degrees"])(this.phi);
    }
  }, {
    key: "lat",
    get: function get() {
      return Object(_lib_common__WEBPACK_IMPORTED_MODULE_3__["degrees"])(this.theta);
    }
  }, {
    key: "z",
    get: function get() {
      return (this.radius - 1) * this.radiusScale;
    }
  }]);

  return SphericalCoordinates;
}();


//# sourceMappingURL=spherical-coordinates.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/vector2.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/classes/vector2.js ***!
  \***********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector2; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _base_vector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base/vector */ "../../node_modules/math.gl/dist/esm/classes/base/vector.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gl-matrix/vec2 */ "../../node_modules/gl-matrix/esm/vec2.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "../../node_modules/math.gl/dist/esm/lib/gl-matrix-extras.js");











var Vector2 = function (_Vector) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Vector2, _Vector);

  function Vector2() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Vector2);

    _this = Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Vector2).call(this, 2));

    if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_6__["isArray"])(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"].debug) {
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(x);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(y);
      }

      _this[0] = x;
      _this[1] = y;
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Vector2, [{
    key: "set",
    value: function set(x, y, z) {
      this[0] = x;
      this[1] = y;
      return this.check();
    }
  }, {
    key: "copy",
    value: function copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      return this.check();
    }
  }, {
    key: "fromObject",
    value: function fromObject(object) {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"].debug) {
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.x);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.y);
      }

      this[0] = object.x;
      this[1] = object.y;
      return this.check();
    }
  }, {
    key: "toObject",
    value: function toObject(object) {
      object.x = this[0];
      object.y = this[1];
      return object;
    }
  }, {
    key: "horizontalAngle",
    value: function horizontalAngle() {
      return Math.atan2(this.y, this.x);
    }
  }, {
    key: "verticalAngle",
    value: function verticalAngle() {
      return Math.atan2(this.x, this.y);
    }
  }, {
    key: "transform",
    value: function transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
  }, {
    key: "transformAsPoint",
    value: function transformAsPoint(matrix4) {
      gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_8__["transformMat4"](this, this, matrix4);
      return this.check();
    }
  }, {
    key: "transformAsVector",
    value: function transformAsVector(matrix4) {
      Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__["vec2_transformMat4AsVector"])(this, this, matrix4);
      return this.check();
    }
  }, {
    key: "transformByMatrix3",
    value: function transformByMatrix3(matrix3) {
      gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_8__["transformMat3"](this, this, matrix3);
      return this.check();
    }
  }, {
    key: "transformByMatrix2x3",
    value: function transformByMatrix2x3(matrix2x3) {
      gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_8__["transformMat2d"](this, this, matrix2x3);
      return this.check();
    }
  }, {
    key: "transformByMatrix2",
    value: function transformByMatrix2(matrix2) {
      gl_matrix_vec2__WEBPACK_IMPORTED_MODULE_8__["transformMat2"](this, this, matrix2);
      return this.check();
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 2;
    }
  }]);

  return Vector2;
}(_base_vector__WEBPACK_IMPORTED_MODULE_5__["default"]);


//# sourceMappingURL=vector2.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/vector3.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/classes/vector3.js ***!
  \***********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector3; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _base_vector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base/vector */ "../../node_modules/math.gl/dist/esm/classes/base/vector.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "../../node_modules/math.gl/dist/esm/lib/gl-matrix-extras.js");










var ORIGIN = [0, 0, 0];

var Vector3 = function (_Vector) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Vector3, _Vector);

  function Vector3() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Vector3);

    _this = Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Vector3).call(this, -0, -0, -0));

    if (arguments.length === 1 && Object(_lib_common__WEBPACK_IMPORTED_MODULE_6__["isArray"])(x)) {
      _this.copy(x);
    } else {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"].debug) {
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(x);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(y);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(z);
      }

      _this[0] = x;
      _this[1] = y;
      _this[2] = z;
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Vector3, [{
    key: "set",
    value: function set(x, y, z) {
      this[0] = x;
      this[1] = y;
      this[2] = z;
      return this.check();
    }
  }, {
    key: "copy",
    value: function copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      return this.check();
    }
  }, {
    key: "fromObject",
    value: function fromObject(object) {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"].debug) {
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.x);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.y);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.z);
      }

      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      return this.check();
    }
  }, {
    key: "toObject",
    value: function toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      return object;
    }
  }, {
    key: "angle",
    value: function angle(vector) {
      return gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["angle"](this, vector);
    }
  }, {
    key: "cross",
    value: function cross(vector) {
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["cross"](this, this, vector);
      return this.check();
    }
  }, {
    key: "rotateX",
    value: function rotateX(_ref) {
      var radians = _ref.radians,
          _ref$origin = _ref.origin,
          origin = _ref$origin === void 0 ? ORIGIN : _ref$origin;
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["rotateX"](this, this, origin, radians);
      return this.check();
    }
  }, {
    key: "rotateY",
    value: function rotateY(_ref2) {
      var radians = _ref2.radians,
          _ref2$origin = _ref2.origin,
          origin = _ref2$origin === void 0 ? ORIGIN : _ref2$origin;
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["rotateY"](this, this, origin, radians);
      return this.check();
    }
  }, {
    key: "rotateZ",
    value: function rotateZ(_ref3) {
      var radians = _ref3.radians,
          _ref3$origin = _ref3.origin,
          origin = _ref3$origin === void 0 ? ORIGIN : _ref3$origin;
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["rotateZ"](this, this, origin, radians);
      return this.check();
    }
  }, {
    key: "transform",
    value: function transform(matrix4) {
      return this.transformAsPoint(matrix4);
    }
  }, {
    key: "transformAsPoint",
    value: function transformAsPoint(matrix4) {
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["transformMat4"](this, this, matrix4);
      return this.check();
    }
  }, {
    key: "transformAsVector",
    value: function transformAsVector(matrix4) {
      Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__["vec3_transformMat4AsVector"])(this, this, matrix4);
      return this.check();
    }
  }, {
    key: "transformByMatrix3",
    value: function transformByMatrix3(matrix3) {
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["transformMat3"](this, this, matrix3);
      return this.check();
    }
  }, {
    key: "transformByMatrix2",
    value: function transformByMatrix2(matrix2) {
      Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__["vec3_transformMat2"])(this, this, matrix2);
      return this.check();
    }
  }, {
    key: "transformByQuaternion",
    value: function transformByQuaternion(quaternion) {
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["transformQuat"](this, this, quaternion);
      return this.check();
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 3;
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(value);
    }
  }]);

  return Vector3;
}(_base_vector__WEBPACK_IMPORTED_MODULE_5__["default"]);


//# sourceMappingURL=vector3.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/classes/vector4.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/classes/vector4.js ***!
  \***********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Vector4; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ "../../node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js");
/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ "../../node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js");
/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ "../../node_modules/@babel/runtime/helpers/esm/inherits.js");
/* harmony import */ var _base_vector__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./base/vector */ "../../node_modules/math.gl/dist/esm/classes/base/vector.js");
/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");
/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony import */ var gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! gl-matrix/vec3 */ "../../node_modules/gl-matrix/esm/vec3.js");
/* harmony import */ var _lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../lib/gl-matrix-extras */ "../../node_modules/math.gl/dist/esm/lib/gl-matrix-extras.js");











var Vector4 = function (_Vector) {
  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__["default"])(Vector4, _Vector);

  function Vector4() {
    var _this;

    var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Vector4);

    _this = Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__["default"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__["default"])(Vector4).call(this, -0, -0, -0, -0));

    if (Object(_lib_common__WEBPACK_IMPORTED_MODULE_6__["isArray"])(x) && arguments.length === 1) {
      _this.copy(x);
    } else {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"].debug) {
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(x);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(y);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(z);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(w);
      }

      _this[0] = x;
      _this[1] = y;
      _this[2] = z;
      _this[3] = w;
    }

    return _this;
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Vector4, [{
    key: "set",
    value: function set(x, y, z, w) {
      this[0] = x;
      this[1] = y;
      this[2] = z;
      this[3] = w;
      return this.check();
    }
  }, {
    key: "copy",
    value: function copy(array) {
      this[0] = array[0];
      this[1] = array[1];
      this[2] = array[2];
      this[3] = array[3];
      return this.check();
    }
  }, {
    key: "fromObject",
    value: function fromObject(object) {
      if (_lib_common__WEBPACK_IMPORTED_MODULE_6__["config"].debug) {
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.x);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.y);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.z);
        Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(object.w);
      }

      this[0] = object.x;
      this[1] = object.y;
      this[2] = object.z;
      this[3] = object.w;
      return this;
    }
  }, {
    key: "toObject",
    value: function toObject(object) {
      object.x = this[0];
      object.y = this[1];
      object.z = this[2];
      object.w = this[3];
      return object;
    }
  }, {
    key: "transform",
    value: function transform(matrix4) {
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["transformMat4"](this, this, matrix4);
      return this.check();
    }
  }, {
    key: "transformByMatrix3",
    value: function transformByMatrix3(matrix3) {
      Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__["vec4_transformMat3"])(this, this, matrix3);
      return this.check();
    }
  }, {
    key: "transformByMatrix2",
    value: function transformByMatrix2(matrix2) {
      Object(_lib_gl_matrix_extras__WEBPACK_IMPORTED_MODULE_9__["vec4_transformMat2"])(this, this, matrix2);
      return this.check();
    }
  }, {
    key: "transformByQuaternion",
    value: function transformByQuaternion(quaternion) {
      gl_matrix_vec3__WEBPACK_IMPORTED_MODULE_8__["transformQuat"](this, this, quaternion);
      return this.check();
    }
  }, {
    key: "applyMatrix4",
    value: function applyMatrix4(m) {
      m.transform(this, this);
      return this;
    }
  }, {
    key: "ELEMENTS",
    get: function get() {
      return 4;
    }
  }, {
    key: "z",
    get: function get() {
      return this[2];
    },
    set: function set(value) {
      return this[2] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(value);
    }
  }, {
    key: "w",
    get: function get() {
      return this[3];
    },
    set: function set(value) {
      return this[3] = Object(_lib_validators__WEBPACK_IMPORTED_MODULE_7__["checkNumber"])(value);
    }
  }]);

  return Vector4;
}(_base_vector__WEBPACK_IMPORTED_MODULE_5__["default"]);


//# sourceMappingURL=vector4.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/index.js":
/*!*************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/index.js ***!
  \*************************************************************************************************************/
/*! exports provided: Vector2, Vector3, Vector4, Matrix3, Matrix4, Quaternion, config, configure, formatValue, isArray, clone, equals, exactEquals, toRadians, toDegrees, radians, degrees, sin, cos, tan, asin, acos, atan, clamp, lerp, _withEpsilon, checkNumber, _MathUtils, _SphericalCoordinates, _Pose, _Euler, _Polygon, assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _classes_vector2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/vector2 */ "../../node_modules/math.gl/dist/esm/classes/vector2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector2", function() { return _classes_vector2__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _classes_vector3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/vector3 */ "../../node_modules/math.gl/dist/esm/classes/vector3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return _classes_vector3__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _classes_vector4__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./classes/vector4 */ "../../node_modules/math.gl/dist/esm/classes/vector4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return _classes_vector4__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _classes_matrix3__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./classes/matrix3 */ "../../node_modules/math.gl/dist/esm/classes/matrix3.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return _classes_matrix3__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _classes_matrix4__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./classes/matrix4 */ "../../node_modules/math.gl/dist/esm/classes/matrix4.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return _classes_matrix4__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _classes_quaternion__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./classes/quaternion */ "../../node_modules/math.gl/dist/esm/classes/quaternion.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return _classes_quaternion__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _lib_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/common */ "../../node_modules/math.gl/dist/esm/lib/common.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "config", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["config"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "configure", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["configure"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatValue", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["formatValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["isArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["clone"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["equals"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["exactEquals"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toRadians", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["toRadians"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toDegrees", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["toDegrees"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["radians"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["degrees"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["sin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["cos"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["tan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["asin"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["acos"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["atan"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["clamp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["lerp"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_withEpsilon", function() { return _lib_common__WEBPACK_IMPORTED_MODULE_7__["withEpsilon"]; });

/* harmony import */ var _lib_validators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/validators */ "../../node_modules/math.gl/dist/esm/lib/validators.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "checkNumber", function() { return _lib_validators__WEBPACK_IMPORTED_MODULE_8__["checkNumber"]; });

/* harmony import */ var _lib_math_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/math-utils */ "../../node_modules/math.gl/dist/esm/lib/math-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MathUtils", function() { return _lib_math_utils__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _classes_spherical_coordinates__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./classes/spherical-coordinates */ "../../node_modules/math.gl/dist/esm/classes/spherical-coordinates.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_SphericalCoordinates", function() { return _classes_spherical_coordinates__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _classes_pose__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./classes/pose */ "../../node_modules/math.gl/dist/esm/classes/pose.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_Pose", function() { return _classes_pose__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _classes_euler__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./classes/euler */ "../../node_modules/math.gl/dist/esm/classes/euler.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_Euler", function() { return _classes_euler__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _addons_polygon__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./addons/polygon */ "../../node_modules/math.gl/dist/esm/addons/polygon.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_Polygon", function() { return _addons_polygon__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _lib_assert__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./lib/assert */ "../../node_modules/math.gl/dist/esm/lib/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _lib_assert__WEBPACK_IMPORTED_MODULE_14__["default"]; });
















var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global
};
var global_ = globals.global || globals.self || globals.window;
global_.mathgl = {
  config: math_gl__WEBPACK_IMPORTED_MODULE_0__["config"]
};
//# sourceMappingURL=index.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/lib/assert.js":
/*!******************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/lib/assert.js ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error("math.gl assertion ".concat(message));
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/lib/common.js":
/*!******************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/lib/common.js ***!
  \******************************************************************************************************************/
/*! exports provided: config, configure, formatValue, isArray, clone, toRadians, toDegrees, radians, degrees, sin, cos, tan, asin, acos, atan, clamp, lerp, equals, exactEquals, withEpsilon */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "config", function() { return config; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "configure", function() { return configure; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatValue", function() { return formatValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isArray", function() { return isArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clone", function() { return clone; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toRadians", function() { return toRadians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toDegrees", function() { return toDegrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "radians", function() { return radians; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degrees", function() { return degrees; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sin", function() { return sin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cos", function() { return cos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "tan", function() { return tan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "asin", function() { return asin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "acos", function() { return acos; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "atan", function() { return atan; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lerp", function() { return lerp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "equals", function() { return equals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exactEquals", function() { return exactEquals; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withEpsilon", function() { return withEpsilon; });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "../../node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _babel_runtime_helpers_esm_construct__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/construct */ "../../node_modules/@babel/runtime/helpers/esm/construct.js");
/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ "../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./assert */ "../../node_modules/math.gl/dist/esm/lib/assert.js");




var RADIANS_TO_DEGREES = 1 / Math.PI * 180;
var DEGREES_TO_RADIANS = 1 / 180 * Math.PI;
var config = {};
config.EPSILON = 1e-12;
config.debug = false;
config.precision = 4;
config.printTypes = false;
config.printDegrees = false;
config.printRowMajor = true;

function configure() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  for (var key in options) {
    Object(_assert__WEBPACK_IMPORTED_MODULE_3__["default"])(key in config);
    config[key] = options[key];
  }

  return config;
}

function round(value) {
  return Math.round(value / config.EPSILON) * config.EPSILON;
}

function formatValue(value) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$precision = _ref.precision,
      precision = _ref$precision === void 0 ? config.precision || 4 : _ref$precision;

  value = round(value);
  return "".concat(parseFloat(value.toPrecision(precision)));
}
function isArray(value) {
  return Array.isArray(value) || ArrayBuffer.isView(value) && value.length !== undefined;
}

function duplicateArray(array) {
  return array.clone ? array.clone() : new Array(array.length);
}

function clone(array) {
  return array.clone ? array.clone() : Object(_babel_runtime_helpers_esm_construct__WEBPACK_IMPORTED_MODULE_1__["default"])(Array, Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_2__["default"])(array));
}

function map(value, func, result) {
  if (isArray(value)) {
    result = result || duplicateArray(value);

    for (var i = 0; i < result.length && i < value.length; ++i) {
      result[i] = func(value[i], i, result);
    }

    return result;
  }

  return func(value);
}

function toRadians(degrees) {
  return radians(degrees);
}
function toDegrees(radians) {
  return degrees(radians);
}
function radians(degrees, result) {
  return map(degrees, function (degrees) {
    return degrees * DEGREES_TO_RADIANS;
  }, result);
}
function degrees(radians, result) {
  return map(radians, function (radians) {
    return radians * RADIANS_TO_DEGREES;
  }, result);
}
function sin(radians) {
  return map(radians, function (angle) {
    return Math.sin(angle);
  });
}
function cos(radians) {
  return map(radians, function (angle) {
    return Math.cos(angle);
  });
}
function tan(radians) {
  return map(radians, function (angle) {
    return Math.tan(angle);
  });
}
function asin(radians) {
  return map(radians, function (angle) {
    return Math.asin(angle);
  });
}
function acos(radians) {
  return map(radians, function (angle) {
    return Math.acos(angle);
  });
}
function atan(radians) {
  return map(radians, function (angle) {
    return Math.atan(angle);
  });
}
function clamp(value, min, max) {
  return map(value, function (value) {
    return Math.max(min, Math.min(max, value));
  });
}
function lerp(a, b, t) {
  if (isArray(a)) {
    return a.map(function (ai, i) {
      return lerp(ai, b[i], t);
    });
  }

  return t * b + (1 - t) * a;
}
function equals(a, b, epsilon) {
  var oldEpsilon = config.EPSILON;

  if (epsilon) {
    config.EPSILON = epsilon;
  }

  try {
    if (a === b) {
      return true;
    }

    if (isArray(a) && isArray(b)) {
      if (a.length !== b.length) {
        return false;
      }

      for (var i = 0; i < a.length; ++i) {
        if (!equals(a[i], b[i])) {
          return false;
        }
      }

      return true;
    }

    if (a && Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(a) === 'object' && a.equals) {
      return a.equals(b);
    }

    if (b && Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(b) === 'object' && b.equals) {
      return b.equals(a);
    }

    return Math.abs(a - b) <= config.EPSILON * Math.max(1.0, Math.abs(a), Math.abs(b));
  } finally {
    config.EPSILON = oldEpsilon;
  }
}
function exactEquals(a, b) {
  if (a === b) {
    return true;
  }

  if (a && Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(a) === 'object' && b && Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(b) === 'object') {
    if (a.constructor !== b.constructor) {
      return false;
    }

    if (a.exactEquals) {
      return a.exactEquals(b);
    }
  }

  if (isArray(a) && isArray(b)) {
    if (a.length !== b.length) {
      return false;
    }

    for (var i = 0; i < a.length; ++i) {
      if (!exactEquals(a[i], b[i])) {
        return false;
      }
    }

    return true;
  }

  return false;
}
function withEpsilon(EPSILON, func) {
  var oldPrecision = config.EPSILON;
  config.EPSILON = EPSILON;
  var value;

  try {
    value = func();
  } finally {
    config.EPSILON = oldPrecision;
  }

  return value;
}
//# sourceMappingURL=common.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/lib/gl-matrix-extras.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/lib/gl-matrix-extras.js ***!
  \****************************************************************************************************************************/
/*! exports provided: vec2_transformMat4AsVector, vec3_transformMat4AsVector, vec3_transformMat2, vec4_transformMat2, vec4_transformMat3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec2_transformMat4AsVector", function() { return vec2_transformMat4AsVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec3_transformMat4AsVector", function() { return vec3_transformMat4AsVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec3_transformMat2", function() { return vec3_transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec4_transformMat2", function() { return vec4_transformMat2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "vec4_transformMat3", function() { return vec4_transformMat3; });
function vec2_transformMat4AsVector(out, a, m) {
  var x = a[0];
  var y = a[1];
  var w = m[3] * x + m[7] * y || 1.0;
  out[0] = (m[0] * x + m[4] * y) / w;
  out[1] = (m[1] * x + m[5] * y) / w;
  return out;
}
function vec3_transformMat4AsVector(out, a, m) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  var w = m[3] * x + m[7] * y + m[11] * z || 1.0;
  out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;
  out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;
  out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;
  return out;
}
function vec3_transformMat2(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  return out;
}
function vec4_transformMat2(out, a, m) {
  var x = a[0];
  var y = a[1];
  out[0] = m[0] * x + m[2] * y;
  out[1] = m[1] * x + m[3] * y;
  out[2] = a[2];
  out[3] = a[3];
  return out;
}
function vec4_transformMat3(out, a, m) {
  var x = a[0];
  var y = a[1];
  var z = a[2];
  out[0] = m[0] * x + m[3] * y + m[6] * z;
  out[1] = m[1] * x + m[4] * y + m[7] * z;
  out[2] = m[2] * x + m[5] * y + m[8] * z;
  out[3] = a[3];
  return out;
}
//# sourceMappingURL=gl-matrix-extras.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/lib/math-utils.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/lib/math-utils.js ***!
  \**********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
  EPSILON1: 1e-1,
  EPSILON2: 1e-2,
  EPSILON3: 1e-3,
  EPSILON4: 1e-4,
  EPSILON5: 1e-5,
  EPSILON6: 1e-6,
  EPSILON7: 1e-7,
  EPSILON8: 1e-8,
  EPSILON9: 1e-9,
  EPSILON10: 1e-10,
  EPSILON11: 1e-11,
  EPSILON12: 1e-12,
  EPSILON13: 1e-13,
  EPSILON14: 1e-14,
  EPSILON15: 1e-15,
  EPSILON16: 1e-16,
  EPSILON17: 1e-17,
  EPSILON18: 1e-18,
  EPSILON19: 1e-19,
  EPSILON20: 1e-20,
  PI_OVER_TWO: Math.PI / 2,
  PI_OVER_FOUR: Math.PI / 4,
  PI_OVER_SIX: Math.PI / 6,
  TWO_PI: Math.PI * 2
});
//# sourceMappingURL=math-utils.js.map

/***/ }),

/***/ "../../node_modules/math.gl/dist/esm/lib/validators.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/math.gl/dist/esm/lib/validators.js ***!
  \**********************************************************************************************************************/
/*! exports provided: validateVector, checkNumber, checkVector, deprecated */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "validateVector", function() { return validateVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkNumber", function() { return checkNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkVector", function() { return checkVector; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deprecated", function() { return deprecated; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common */ "../../node_modules/math.gl/dist/esm/lib/common.js");

function validateVector(v, length) {
  if (v.length !== length) {
    return false;
  }

  for (var i = 0; i < v.length; ++i) {
    if (!Number.isFinite(v[i])) {
      return false;
    }
  }

  return true;
}
function checkNumber(value) {
  if (!Number.isFinite(value)) {
    throw new Error("Invalid number ".concat(value));
  }

  return value;
}
function checkVector(v, length, callerName) {
  if (_common__WEBPACK_IMPORTED_MODULE_0__["config"].debug && !validateVector(v, length)) {
    throw new Error("math.gl: ".concat(callerName | '', " some fields set to invalid numbers'"));
  }

  return v;
}
var map = {};
function deprecated(method, version) {
  if (!map[method]) {
    map[method] = true;
    console.warn("".concat(method, " has been removed in version ").concat(version, ", see upgrade guide for more information"));
  }
}
//# sourceMappingURL=validators.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/env/get-browser.js":
/*!************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/env/get-browser.js ***!
  \************************************************************************************************************************/
/*! exports provided: isMobile, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMobile", function() { return isMobile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getBrowser; });
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ "../../node_modules/probe.gl/dist/esm/env/globals.js");
/* harmony import */ var _is_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-browser */ "../../node_modules/probe.gl/dist/esm/env/is-browser.js");
/* harmony import */ var _is_electron__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is-electron */ "../../node_modules/probe.gl/dist/esm/env/is-electron.js");



function isMobile() {
  return typeof _globals__WEBPACK_IMPORTED_MODULE_0__["window"].orientation !== 'undefined';
}
function getBrowser(mockUserAgent) {
  if (!mockUserAgent && !Object(_is_browser__WEBPACK_IMPORTED_MODULE_1__["default"])()) {
    return 'Node';
  }

  if (Object(_is_electron__WEBPACK_IMPORTED_MODULE_2__["default"])(mockUserAgent)) {
    return 'Electron';
  }

  var navigator_ = typeof navigator !== 'undefined' ? navigator : {};
  var userAgent = mockUserAgent || navigator_.userAgent || '';

  if (userAgent.indexOf('Edge') > -1) {
    return 'Edge';
  }

  var isMSIE = userAgent.indexOf('MSIE ') !== -1;
  var isTrident = userAgent.indexOf('Trident/') !== -1;

  if (isMSIE || isTrident) {
    return 'IE';
  }

  if (_globals__WEBPACK_IMPORTED_MODULE_0__["window"].chrome) {
    return 'Chrome';
  }

  if (_globals__WEBPACK_IMPORTED_MODULE_0__["window"].safari) {
    return 'Safari';
  }

  if (_globals__WEBPACK_IMPORTED_MODULE_0__["window"].mozInnerScreenX) {
    return 'Firefox';
  }

  return 'Unknown';
}
//# sourceMappingURL=get-browser.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/env/globals.js":
/*!********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/env/globals.js ***!
  \********************************************************************************************************************/
/*! exports provided: self, window, global, document, process, console */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global, process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "process", function() { return process_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "console", function() { return console_; });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "../../node_modules/@babel/runtime/helpers/esm/typeof.js");

var globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document,
  process: (typeof process === "undefined" ? "undefined" : Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(process)) === 'object' && process
};
var self_ = globals.self || globals.window || globals.global;
var window_ = globals.window || globals.self || globals.global;
var global_ = globals.global || globals.self || globals.window;
var document_ = globals.document || {};
var process_ = globals.process || {};
var console_ = console;

//# sourceMappingURL=globals.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/env/is-browser.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/env/is-browser.js ***!
  \***********************************************************************************************************************/
/*! exports provided: default, isBrowserMainThread */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isBrowser; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowserMainThread", function() { return isBrowserMainThread; });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "../../node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _is_electron__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is-electron */ "../../node_modules/probe.gl/dist/esm/env/is-electron.js");


function isBrowser() {
  var isNode = (typeof process === "undefined" ? "undefined" : Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(process)) === 'object' && String(process) === '[object process]' && !process.browser;
  return !isNode || Object(_is_electron__WEBPACK_IMPORTED_MODULE_1__["default"])();
}
function isBrowserMainThread() {
  return isBrowser() && typeof document !== 'undefined';
}
//# sourceMappingURL=is-browser.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/env/is-electron.js":
/*!************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/env/is-electron.js ***!
  \************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isElectron; });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "../../node_modules/@babel/runtime/helpers/esm/typeof.js");

function isElectron(mockUserAgent) {
  if (typeof window !== 'undefined' && Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(window.process) === 'object' && window.process.type === 'renderer') {
    return true;
  }

  if (typeof process !== 'undefined' && Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(process.versions) === 'object' && Boolean(process.versions.electron)) {
    return true;
  }

  var realUserAgent = (typeof navigator === "undefined" ? "undefined" : Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(navigator)) === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent;
  var userAgent = mockUserAgent || realUserAgent;

  if (userAgent && userAgent.indexOf('Electron') >= 0) {
    return true;
  }

  return false;
}
//# sourceMappingURL=is-electron.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/index.js":
/*!**************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/index.js ***!
  \**************************************************************************************************************/
/*! exports provided: VERSION, self, window, global, document, process, console, isBrowser, isBrowserMainThread, getBrowser, isMobile, isElectron, assert, Stats, Stat, Log, COLOR, default, addColor, leftPad, rightPad, autobind, LocalStorage, getHiResTimestamp */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init */ "../../node_modules/probe.gl/dist/esm/init.js");
/* harmony import */ var _lib_log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/log */ "../../node_modules/probe.gl/dist/esm/lib/log.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/globals */ "../../node_modules/probe.gl/dist/esm/utils/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_2__["VERSION"]; });

/* harmony import */ var _env_globals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./env/globals */ "../../node_modules/probe.gl/dist/esm/env/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["document"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "process", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["process"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "console", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_3__["console"]; });

/* harmony import */ var _env_is_browser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./env/is-browser */ "../../node_modules/probe.gl/dist/esm/env/is-browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _env_is_browser__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowserMainThread", function() { return _env_is_browser__WEBPACK_IMPORTED_MODULE_4__["isBrowserMainThread"]; });

/* harmony import */ var _env_get_browser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./env/get-browser */ "../../node_modules/probe.gl/dist/esm/env/get-browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getBrowser", function() { return _env_get_browser__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isMobile", function() { return _env_get_browser__WEBPACK_IMPORTED_MODULE_5__["isMobile"]; });

/* harmony import */ var _env_is_electron__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./env/is-electron */ "../../node_modules/probe.gl/dist/esm/env/is-electron.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isElectron", function() { return _env_is_electron__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/assert */ "../../node_modules/probe.gl/dist/esm/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _utils_assert__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _lib_stats__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/stats */ "../../node_modules/probe.gl/dist/esm/lib/stats.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stats", function() { return _lib_stats__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _lib_stat__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/stat */ "../../node_modules/probe.gl/dist/esm/lib/stat.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Stat", function() { return _lib_stat__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Log", function() { return _lib_log__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _utils_color__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/color */ "../../node_modules/probe.gl/dist/esm/utils/color.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "COLOR", function() { return _utils_color__WEBPACK_IMPORTED_MODULE_10__["COLOR"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "addColor", function() { return _utils_color__WEBPACK_IMPORTED_MODULE_10__["addColor"]; });

/* harmony import */ var _utils_formatters__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/formatters */ "../../node_modules/probe.gl/dist/esm/utils/formatters.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "leftPad", function() { return _utils_formatters__WEBPACK_IMPORTED_MODULE_11__["leftPad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "rightPad", function() { return _utils_formatters__WEBPACK_IMPORTED_MODULE_11__["rightPad"]; });

/* harmony import */ var _utils_autobind__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/autobind */ "../../node_modules/probe.gl/dist/esm/utils/autobind.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "autobind", function() { return _utils_autobind__WEBPACK_IMPORTED_MODULE_12__["autobind"]; });

/* harmony import */ var _utils_local_storage__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/local-storage */ "../../node_modules/probe.gl/dist/esm/utils/local-storage.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LocalStorage", function() { return _utils_local_storage__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils/hi-res-timestamp */ "../../node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getHiResTimestamp", function() { return _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_14__["default"]; });













/* harmony default export */ __webpack_exports__["default"] = (new _lib_log__WEBPACK_IMPORTED_MODULE_1__["default"]({
  id: 'probe.gl'
}));





//# sourceMappingURL=index.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/init.js":
/*!*************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/init.js ***!
  \*************************************************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/globals */ "../../node_modules/probe.gl/dist/esm/utils/globals.js");

_utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"].probe = {};
//# sourceMappingURL=init.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/lib/log.js":
/*!****************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/lib/log.js ***!
  \****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Log; });
/* harmony import */ var _babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/typeof */ "../../node_modules/@babel/runtime/helpers/esm/typeof.js");
/* harmony import */ var _babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/toConsumableArray */ "../../node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var _babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/defineProperty */ "../../node_modules/@babel/runtime/helpers/esm/defineProperty.js");
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/globals */ "../../node_modules/probe.gl/dist/esm/utils/globals.js");
/* harmony import */ var _utils_local_storage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/local-storage */ "../../node_modules/probe.gl/dist/esm/utils/local-storage.js");
/* harmony import */ var _utils_formatters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/formatters */ "../../node_modules/probe.gl/dist/esm/utils/formatters.js");
/* harmony import */ var _utils_color__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils/color */ "../../node_modules/probe.gl/dist/esm/utils/color.js");
/* harmony import */ var _utils_autobind__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils/autobind */ "../../node_modules/probe.gl/dist/esm/utils/autobind.js");
/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils/assert */ "../../node_modules/probe.gl/dist/esm/utils/assert.js");
/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../utils/hi-res-timestamp */ "../../node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js");












var originalConsole = {
  debug: _utils_globals__WEBPACK_IMPORTED_MODULE_5__["isBrowser"] ? console.debug || console.log : console.log,
  log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error
};
var DEFAULT_SETTINGS = {
  enabled: false,
  priority: 0
};

function noop() {}

var cache = {};

function getTableHeader(table) {
  for (var key in table) {
    for (var title in table[key]) {
      return title || 'untitled';
    }
  }

  return 'empty';
}

var Log = function () {
  function Log() {
    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        id = _ref.id;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_3__["default"])(this, Log);

    this.id = id;
    this.VERSION = _utils_globals__WEBPACK_IMPORTED_MODULE_5__["VERSION"];
    this._startTs = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_11__["default"])();
    this._deltaTs = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_11__["default"])();
    this.LOG_THROTTLE_TIMEOUT = 0;
    this._storage = new _utils_local_storage__WEBPACK_IMPORTED_MODULE_6__["default"]("__probe-".concat(this.id, "__"), DEFAULT_SETTINGS);
    this.userData = {};
    this.timeStamp("".concat(this.id, " started"));
    Object(_utils_autobind__WEBPACK_IMPORTED_MODULE_9__["autobind"])(this);
    Object.seal(this);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_4__["default"])(Log, [{
    key: "isEnabled",
    value: function isEnabled() {
      return this._storage.config.enabled;
    }
  }, {
    key: "getPriority",
    value: function getPriority() {
      return this._storage.config.priority;
    }
  }, {
    key: "getLevel",
    value: function getLevel() {
      return this._storage.config.priority;
    }
  }, {
    key: "getTotal",
    value: function getTotal() {
      return Number((Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_11__["default"])() - this._startTs).toPrecision(10));
    }
  }, {
    key: "getDelta",
    value: function getDelta() {
      return Number((Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_11__["default"])() - this._deltaTs).toPrecision(10));
    }
  }, {
    key: "enable",
    value: function enable() {
      var enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

      this._storage.updateConfiguration({
        enabled: enabled
      });

      return this;
    }
  }, {
    key: "setLevel",
    value: function setLevel(level) {
      this._storage.updateConfiguration({
        priority: level
      });

      return this;
    }
  }, {
    key: "assert",
    value: function assert(condition, message) {
      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_10__["default"])(condition, message);
    }
  }, {
    key: "warn",
    value: function warn(message) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return this._getLogFunction({
        message: message,
        args: args,
        method: originalConsole.warn,
        once: true
      });
    }
  }, {
    key: "error",
    value: function error(message) {
      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return this._getLogFunction({
        message: message,
        args: args,
        method: originalConsole.error
      });
    }
  }, {
    key: "deprecated",
    value: function deprecated(oldUsage, newUsage) {
      return this.warn("`".concat(oldUsage, "` is deprecated and will be removed in a later version. Use `").concat(newUsage, "` instead"));
    }
  }, {
    key: "removed",
    value: function removed(oldUsage, newUsage) {
      return this.error("`".concat(oldUsage, "` has been removed. Use `").concat(newUsage, "` instead"));
    }
  }, {
    key: "probe",
    value: function probe(priority, message) {
      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
        args[_key3 - 2] = arguments[_key3];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: originalConsole.log,
        time: true,
        once: true
      });
    }
  }, {
    key: "log",
    value: function log(priority, message) {
      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {
        args[_key4 - 2] = arguments[_key4];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: originalConsole.debug
      });
    }
  }, {
    key: "info",
    value: function info(priority, message) {
      for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {
        args[_key5 - 2] = arguments[_key5];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: console.info
      });
    }
  }, {
    key: "once",
    value: function once(priority, message) {
      for (var _len6 = arguments.length, args = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {
        args[_key6 - 2] = arguments[_key6];
      }

      return this._getLogFunction({
        priority: priority,
        message: message,
        args: args,
        method: originalConsole.debug || originalConsole.info,
        once: true
      });
    }
  }, {
    key: "table",
    value: function table(priority, _table, columns) {
      if (_table) {
        var tag = getTableHeader(_table);
        return this._getLogFunction({
          priority: priority,
          message: _table,
          args: columns && [columns],
          tag: tag,
          method: console.table || noop
        });
      }

      return noop;
    }
  }, {
    key: "image",
    value: function image(_ref2) {
      var priority = _ref2.priority,
          _image = _ref2.image,
          _ref2$message = _ref2.message,
          message = _ref2$message === void 0 ? '' : _ref2$message,
          _ref2$scale = _ref2.scale,
          scale = _ref2$scale === void 0 ? 1 : _ref2$scale;

      if (priority > this.getPriority()) {
        return noop;
      }

      return _utils_globals__WEBPACK_IMPORTED_MODULE_5__["isBrowser"] ? this._logImageInBrowser({
        image: _image,
        message: message,
        scale: scale
      }) : this._logImageInNode({
        image: _image,
        message: message,
        scale: scale
      });
    }
  }, {
    key: "settings",
    value: function settings() {
      if (console.table) {
        console.table(this._storage.config);
      } else {
        console.log(this._storage.config);
      }
    }
  }, {
    key: "get",
    value: function get(setting) {
      return this._storage.config[setting];
    }
  }, {
    key: "set",
    value: function set(setting, value) {
      this._storage.updateConfiguration(Object(_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_2__["default"])({}, setting, value));
    }
  }, {
    key: "_logImageInNode",
    value: function _logImageInNode(_ref3) {
      var image = _ref3.image,
          _ref3$message = _ref3.message,
          message = _ref3$message === void 0 ? '' : _ref3$message,
          _ref3$scale = _ref3.scale,
          scale = _ref3$scale === void 0 ? 1 : _ref3$scale;
      var asciify = null;

      try {
        asciify = __webpack_require__(/*! asciify-image */ 0);
      } catch (error) {}

      if (asciify) {
        return function () {
          return asciify(image, {
            fit: 'box',
            width: "".concat(Math.round(80 * scale), "%")
          }).then(function (data) {
            return console.log(data);
          });
        };
      }

      return noop;
    }
  }, {
    key: "_logImageInBrowser",
    value: function _logImageInBrowser(_ref4) {
      var image = _ref4.image,
          _ref4$message = _ref4.message,
          message = _ref4$message === void 0 ? '' : _ref4$message,
          _ref4$scale = _ref4.scale,
          scale = _ref4$scale === void 0 ? 1 : _ref4$scale;

      if (typeof image === 'string') {
        var img = new Image();

        img.onload = function () {
          var _console;

          var args = Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_7__["formatImage"])(img, message, scale);

          (_console = console).log.apply(_console, Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(args));
        };

        img.src = image;
        return noop;
      }

      var element = image.nodeName || '';

      if (element.toLowerCase() === 'img') {
        var _console2;

        (_console2 = console).log.apply(_console2, Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_7__["formatImage"])(image, message, scale)));

        return noop;
      }

      if (element.toLowerCase() === 'canvas') {
        var _img = new Image();

        _img.onload = function () {
          var _console3;

          return (_console3 = console).log.apply(_console3, Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_7__["formatImage"])(_img, message, scale)));
        };

        _img.src = image.toDataURL();
        return noop;
      }

      return noop;
    }
  }, {
    key: "time",
    value: function time(priority, message) {
      return this._getLogFunction({
        priority: priority,
        message: message,
        method: console.time ? console.time : console.info
      });
    }
  }, {
    key: "timeEnd",
    value: function timeEnd(priority, message) {
      return this._getLogFunction({
        priority: priority,
        message: message,
        method: console.timeEnd ? console.timeEnd : console.info
      });
    }
  }, {
    key: "timeStamp",
    value: function timeStamp(priority, message) {
      return this._getLogFunction({
        priority: priority,
        message: message,
        method: console.timeStamp || noop
      });
    }
  }, {
    key: "group",
    value: function group(priority, message) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
        collapsed: false
      };
      opts = this._normalizeArguments({
        priority: priority,
        message: message,
        opts: opts
      });
      var _opts = opts,
          collapsed = _opts.collapsed;
      return this._getLogFunction({
        priority: priority,
        message: message,
        opts: opts,
        method: (collapsed ? console.groupCollapsed : console.group) || console.info
      });
    }
  }, {
    key: "groupCollapsed",
    value: function groupCollapsed(priority, message) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      return this.group(priority, message, Object.assign({}, opts, {
        collapsed: true
      }));
    }
  }, {
    key: "groupEnd",
    value: function groupEnd(priority) {
      return this._getLogFunction({
        priority: priority,
        message: '',
        method: console.groupEnd || noop
      });
    }
  }, {
    key: "withGroup",
    value: function withGroup(priority, message, func) {
      var opts = this._normalizeArguments({
        priority: priority,
        message: message
      });

      this.group(opts);

      try {
        func();
      } finally {
        this.groupEnd(opts.message);
      }
    }
  }, {
    key: "trace",
    value: function trace() {
      if (console.trace) {
        console.trace();
      }
    }
  }, {
    key: "_shouldLog",
    value: function _shouldLog(priority) {
      priority = this._normalizePriority(priority);
      return priority === 0 || this.isEnabled() && this.getPriority() >= priority;
    }
  }, {
    key: "_getElapsedTime",
    value: function _getElapsedTime() {
      var total = this.getTotal();
      var delta = this.getDelta();
      this._deltaTs = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_11__["default"])();
      return {
        total: total,
        delta: delta
      };
    }
  }, {
    key: "_getLogFunction",
    value: function _getLogFunction(opts) {
      if (this._shouldLog(opts.priority)) {
        var _opts2 = opts,
            method = _opts2.method;
        opts = this._parseArguments(opts);

        Object(_utils_assert__WEBPACK_IMPORTED_MODULE_10__["default"])(method);

        var _opts3 = opts,
            message = _opts3.message;
        var tag = opts.tag || opts.message;

        if (opts.once) {
          if (!cache[tag]) {
            cache[tag] = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_11__["default"])();
          } else {
            return noop;
          }
        }

        message = this._decorateMessage(message, opts);
        return method.bind.apply(method, [console, message].concat(Object(_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_1__["default"])(opts.args)));
      }

      return noop;
    }
  }, {
    key: "_parseArguments",
    value: function _parseArguments(options) {
      var normOpts = this._normalizeArguments(options);

      var _this$_getElapsedTime = this._getElapsedTime(),
          delta = _this$_getElapsedTime.delta,
          total = _this$_getElapsedTime.total;

      return Object.assign(options, normOpts, {
        delta: delta,
        total: total
      });
    }
  }, {
    key: "_normalizePriority",
    value: function _normalizePriority(priority) {
      var resolvedPriority;

      switch (Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(priority)) {
        case 'number':
          resolvedPriority = priority;
          break;

        case 'object':
          resolvedPriority = priority.priority || 0;
          break;

        default:
          resolvedPriority = 0;
      }

      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_10__["default"])(Number.isFinite(resolvedPriority) && resolvedPriority >= 0);

      return resolvedPriority;
    }
  }, {
    key: "_normalizeArguments",
    value: function _normalizeArguments(_ref5) {
      var priority = _ref5.priority,
          message = _ref5.message,
          _ref5$args = _ref5.args,
          args = _ref5$args === void 0 ? [] : _ref5$args,
          opts = _ref5.opts;
      var newOpts = {
        priority: this._normalizePriority(priority),
        message: message,
        args: args
      };

      switch (Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(priority)) {
        case 'string':
        case 'function':
          if (message !== undefined) {
            args.unshift(message);
          }

          Object.assign(newOpts, {
            message: priority
          });
          break;

        case 'object':
          Object.assign(newOpts, priority);
          break;

        default:
      }

      if (typeof newOpts.message === 'function') {
        newOpts.message = this._shouldLog(newOpts.priority) ? newOpts.message() : '';
      }

      Object(_utils_assert__WEBPACK_IMPORTED_MODULE_10__["default"])(typeof newOpts.message === 'string' || Object(_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__["default"])(newOpts.message) === 'object');

      return Object.assign(newOpts, opts);
    }
  }, {
    key: "_decorateMessage",
    value: function _decorateMessage(message, opts) {
      if (typeof message === 'string') {
        var time = '';

        if (opts.time) {
          var _this$_getElapsedTime2 = this._getElapsedTime(),
              total = _this$_getElapsedTime2.total;

          time = Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_7__["leftPad"])(Object(_utils_formatters__WEBPACK_IMPORTED_MODULE_7__["formatTime"])(total));
        }

        message = opts.time ? "".concat(this.id, ": ").concat(time, "  ").concat(message) : "".concat(this.id, ": ").concat(message);
        message = Object(_utils_color__WEBPACK_IMPORTED_MODULE_8__["addColor"])(message, opts.color, opts.background);
      }

      return message;
    }
  }, {
    key: "priority",
    set: function set(newPriority) {
      this._storage.updateConfiguration({
        priority: newPriority
      });

      return this;
    },
    get: function get() {
      return this._storage.config.priority;
    }
  }]);

  return Log;
}();


Log.VERSION = _utils_globals__WEBPACK_IMPORTED_MODULE_5__["VERSION"];
//# sourceMappingURL=log.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/lib/stat.js":
/*!*****************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/lib/stat.js ***!
  \*****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Stat; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/hi-res-timestamp */ "../../node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js");




var Stat = function () {
  function Stat(name, type) {
    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Stat);

    this.name = name;
    this.type = type;
    this.sampleSize = 1;
    this.reset();
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Stat, [{
    key: "setSampleSize",
    value: function setSampleSize(samples) {
      this.sampleSize = samples;
      return this;
    }
  }, {
    key: "incrementCount",
    value: function incrementCount() {
      this.addCount(1);
      return this;
    }
  }, {
    key: "decrementCount",
    value: function decrementCount() {
      this.subtractCount(1);
      return this;
    }
  }, {
    key: "addCount",
    value: function addCount(value) {
      this._count += value;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "subtractCount",
    value: function subtractCount(value) {
      this._count -= value;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "addTime",
    value: function addTime(time) {
      this._time += time;
      this.lastTiming = time;
      this._samples++;

      this._checkSampling();

      return this;
    }
  }, {
    key: "timeStart",
    value: function timeStart() {
      this._startTime = Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__["default"])();
      this._timerPending = true;
      return this;
    }
  }, {
    key: "timeEnd",
    value: function timeEnd() {
      if (!this._timerPending) {
        return this;
      }

      this.addTime(Object(_utils_hi_res_timestamp__WEBPACK_IMPORTED_MODULE_2__["default"])() - this._startTime);
      this._timerPending = false;

      this._checkSampling();

      return this;
    }
  }, {
    key: "getSampleAverageCount",
    value: function getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
  }, {
    key: "getSampleAverageTime",
    value: function getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
  }, {
    key: "getSampleHz",
    value: function getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1000) : 0;
    }
  }, {
    key: "getAverageCount",
    value: function getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
  }, {
    key: "getAverageTime",
    value: function getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
  }, {
    key: "getHz",
    value: function getHz() {
      return this.time > 0 ? this.samples / (this.time / 1000) : 0;
    }
  }, {
    key: "reset",
    value: function reset() {
      this.time = 0;
      this.count = 0;
      this.samples = 0;
      this.lastTiming = 0;
      this.lastSampleTime = 0;
      this.lastSampleCount = 0;
      this._count = 0;
      this._time = 0;
      this._samples = 0;
      this._startTime = 0;
      this._timerPending = false;
      return this;
    }
  }, {
    key: "_checkSampling",
    value: function _checkSampling() {
      if (this._samples === this.sampleSize) {
        this.lastSampleTime = this._time;
        this.lastSampleCount = this._count;
        this.count += this._count;
        this.time += this._time;
        this.samples += this._samples;
        this._time = 0;
        this._count = 0;
        this._samples = 0;
      }
    }
  }]);

  return Stat;
}();


//# sourceMappingURL=stat.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/lib/stats.js":
/*!******************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/lib/stats.js ***!
  \******************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Stats; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");
/* harmony import */ var _stat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stat */ "../../node_modules/probe.gl/dist/esm/lib/stat.js");




var Stats = function () {
  function Stats(_ref) {
    var id = _ref.id,
        stats = _ref.stats;

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, Stats);

    this.id = id;
    this.stats = {};

    this._initializeStats(stats);

    Object.seal(this);
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(Stats, [{
    key: "get",
    value: function get(name) {
      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'count';
      return this._getOrCreate({
        name: name,
        type: type
      });
    }
  }, {
    key: "reset",
    value: function reset() {
      for (var key in this.stats) {
        this.stats[key].reset();
      }

      return this;
    }
  }, {
    key: "forEach",
    value: function forEach(fn) {
      for (var key in this.stats) {
        fn(this.stats[key]);
      }
    }
  }, {
    key: "getTable",
    value: function getTable() {
      var table = {};
      this.forEach(function (stat) {
        table[stat.name] = {
          time: stat.time || 0,
          count: stat.count || 0,
          average: stat.getAverageTime() || 0,
          hz: stat.getHz() || 0
        };
      });
      return table;
    }
  }, {
    key: "_initializeStats",
    value: function _initializeStats() {
      var _this = this;

      var stats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      stats.forEach(function (stat) {
        return _this._getOrCreate(stat);
      });
    }
  }, {
    key: "_getOrCreate",
    value: function _getOrCreate(stat) {
      if (!stat || !stat.name) {
        return null;
      }

      var name = stat.name,
          type = stat.type;

      if (!this.stats[name]) {
        if (stat instanceof _stat__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          this.stats[name] = stat;
        } else {
          this.stats[name] = new _stat__WEBPACK_IMPORTED_MODULE_2__["default"](name, type);
        }
      }

      return this.stats[name];
    }
  }, {
    key: "size",
    get: function get() {
      return Object.keys(this.stats).length;
    }
  }]);

  return Stats;
}();


//# sourceMappingURL=stats.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/assert.js":
/*!*********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/utils/assert.js ***!
  \*********************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'Assertion failed');
  }
}
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/autobind.js":
/*!***********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/utils/autobind.js ***!
  \***********************************************************************************************************************/
/*! exports provided: autobind */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "autobind", function() { return autobind; });
function autobind(obj) {
  var predefined = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ['constructor'];
  var proto = Object.getPrototypeOf(obj);
  var propNames = Object.getOwnPropertyNames(proto);
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    var _loop = function _loop() {
      var key = _step.value;

      if (typeof obj[key] === 'function') {
        if (!predefined.find(function (name) {
          return key === name;
        })) {
          obj[key] = obj[key].bind(obj);
        }
      }
    };

    for (var _iterator = propNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      _loop();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"] != null) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }
}
//# sourceMappingURL=autobind.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/color.js":
/*!********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/utils/color.js ***!
  \********************************************************************************************************************/
/*! exports provided: COLOR, addColor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "COLOR", function() { return COLOR; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addColor", function() { return addColor; });
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ "../../node_modules/probe.gl/dist/esm/utils/globals.js");

var COLOR = {
  BLACK: 30,
  RED: 31,
  GREEN: 32,
  YELLOW: 33,
  BLUE: 34,
  MAGENTA: 35,
  CYAN: 36,
  WHITE: 37,
  BRIGHT_BLACK: 90,
  BRIGHT_RED: 91,
  BRIGHT_GREEN: 92,
  BRIGHT_YELLOW: 93,
  BRIGHT_BLUE: 94,
  BRIGHT_MAGENTA: 95,
  BRIGHT_CYAN: 96,
  BRIGHT_WHITE: 97
};

function getColor(color) {
  return typeof color === 'string' ? COLOR[color.toUpperCase()] || COLOR.WHITE : color;
}

function addColor(string, color, background) {
  if (!_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] && typeof string === 'string') {
    if (color) {
      color = getColor(color);
      string = "\x1B[".concat(color, "m").concat(string, "\x1B[39m");
    }

    if (background) {
      color = getColor(background);
      string = "\x1B[".concat(background + 10, "m").concat(string, "\x1B[49m");
    }
  }

  return string;
}
//# sourceMappingURL=color.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/formatters.js":
/*!*************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/utils/formatters.js ***!
  \*************************************************************************************************************************/
/*! exports provided: formatTime, leftPad, rightPad, formatValue, formatImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatTime", function() { return formatTime; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "leftPad", function() { return leftPad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rightPad", function() { return rightPad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatValue", function() { return formatValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatImage", function() { return formatImage; });
function formatTime(ms) {
  var formatted;

  if (ms < 10) {
    formatted = "".concat(ms.toFixed(2), "ms");
  } else if (ms < 100) {
    formatted = "".concat(ms.toFixed(1), "ms");
  } else if (ms < 1000) {
    formatted = "".concat(ms.toFixed(0), "ms");
  } else {
    formatted = "".concat((ms / 1000).toFixed(2), "s");
  }

  return formatted;
}
function leftPad(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var padLength = Math.max(length - string.length, 0);
  return "".concat(' '.repeat(padLength)).concat(string);
}
function rightPad(string) {
  var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 8;
  var padLength = Math.max(length - string.length, 0);
  return "".concat(string).concat(' '.repeat(padLength));
}
function formatValue(v) {
  var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var EPSILON = 1e-16;
  var _opts$isInteger = opts.isInteger,
      isInteger = _opts$isInteger === void 0 ? false : _opts$isInteger;

  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }

  if (!Number.isFinite(v)) {
    return String(v);
  }

  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }

  if (isInteger) {
    return v.toFixed(0);
  }

  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }

  var string = v.toPrecision(2);
  var decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}

function formatArrayValue(v, opts) {
  var _opts$maxElts = opts.maxElts,
      maxElts = _opts$maxElts === void 0 ? 16 : _opts$maxElts,
      _opts$size = opts.size,
      size = _opts$size === void 0 ? 1 : _opts$size;
  var string = '[';

  for (var i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += ",".concat(i % size === 0 ? ' ' : '');
    }

    string += formatValue(v[i], opts);
  }

  var terminator = v.length > maxElts ? '...' : ']';
  return "".concat(string).concat(terminator);
}

function formatImage(image, message, scale) {
  var maxWidth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 600;
  var imageUrl = image.src.replace(/\(/g, '%28').replace(/\)/g, '%29');

  if (image.width > maxWidth) {
    scale = Math.min(scale, maxWidth / image.width);
  }

  var width = image.width * scale;
  var height = image.height * scale;
  var style = ['font-size:1px;', "padding:".concat(Math.floor(height / 2), "px ").concat(Math.floor(width / 2), "px;"), "line-height:".concat(height, "px;"), "background:url(".concat(imageUrl, ");"), "background-size:".concat(width, "px ").concat(height, "px;"), 'color:transparent;'].join('');
  return ["".concat(message, " %c+"), style];
}
//# sourceMappingURL=formatters.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/globals.js":
/*!**********************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/utils/globals.js ***!
  \**********************************************************************************************************************/
/*! exports provided: self, window, global, document, process, console, VERSION, isBrowser */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERSION", function() { return VERSION; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return isBrowser; });
/* harmony import */ var _env_is_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env/is-browser */ "../../node_modules/probe.gl/dist/esm/env/is-browser.js");
/* harmony import */ var _env_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../env/globals */ "../../node_modules/probe.gl/dist/esm/env/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["document"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "process", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["process"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "console", function() { return _env_globals__WEBPACK_IMPORTED_MODULE_1__["console"]; });



var VERSION =  true ? "7.3.1" : undefined;
var isBrowser = Object(_env_is_browser__WEBPACK_IMPORTED_MODULE_0__["default"])();
//# sourceMappingURL=globals.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js":
/*!*******************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/utils/hi-res-timestamp.js ***!
  \*******************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getHiResTimestamp; });
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ "../../node_modules/probe.gl/dist/esm/utils/globals.js");

function getHiResTimestamp() {
  var timestamp;

  if (_globals__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] && _globals__WEBPACK_IMPORTED_MODULE_0__["window"].performance) {
    timestamp = _globals__WEBPACK_IMPORTED_MODULE_0__["window"].performance.now();
  } else if (_globals__WEBPACK_IMPORTED_MODULE_0__["process"].hrtime) {
    var timeParts = _globals__WEBPACK_IMPORTED_MODULE_0__["process"].hrtime();
    timestamp = timeParts[0] * 1000 + timeParts[1] / 1e6;
  } else {
    timestamp = Date.now();
  }

  return timestamp;
}
//# sourceMappingURL=hi-res-timestamp.js.map

/***/ }),

/***/ "../../node_modules/probe.gl/dist/esm/utils/local-storage.js":
/*!****************************************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/probe.gl/dist/esm/utils/local-storage.js ***!
  \****************************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LocalStorage; });
/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ "../../node_modules/@babel/runtime/helpers/esm/classCallCheck.js");
/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ "../../node_modules/@babel/runtime/helpers/esm/createClass.js");



function getStorage(type) {
  try {
    var storage = window[type];
    var x = '__storage_test__';
    storage.setItem(x, x);
    storage.removeItem(x);
    return storage;
  } catch (e) {
    return null;
  }
}

var LocalStorage = function () {
  function LocalStorage(id, defaultSettings) {
    var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'sessionStorage';

    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__["default"])(this, LocalStorage);

    this.storage = getStorage(type);
    this.id = id;
    this.config = {};
    Object.assign(this.config, defaultSettings);

    this._loadConfiguration();
  }

  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__["default"])(LocalStorage, [{
    key: "getConfiguration",
    value: function getConfiguration() {
      return this.config;
    }
  }, {
    key: "setConfiguration",
    value: function setConfiguration(configuration) {
      this.config = {};
      return this.updateConfiguration(configuration);
    }
  }, {
    key: "updateConfiguration",
    value: function updateConfiguration(configuration) {
      Object.assign(this.config, configuration);

      if (this.storage) {
        var serialized = JSON.stringify(this.config);
        this.storage.setItem(this.id, serialized);
      }

      return this;
    }
  }, {
    key: "_loadConfiguration",
    value: function _loadConfiguration() {
      var configuration = {};

      if (this.storage) {
        var serializedConfiguration = this.storage.getItem(this.id);
        configuration = serializedConfiguration ? JSON.parse(serializedConfiguration) : {};
      }

      Object.assign(this.config, configuration);
      return this;
    }
  }]);

  return LocalStorage;
}();


//# sourceMappingURL=local-storage.js.map

/***/ }),

/***/ "../../node_modules/process/browser.js":
/*!******************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/process/browser.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../node_modules/seer/dist/index.js":
/*!******************************************************************************************************!*\
  !*** /Users/raviakkenapally/Documents/Source/DataViz/_repos/luma.gl/node_modules/seer/dist/index.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

var isBrowser = typeof window !== 'undefined' && window.addEventListener;

var timers = new Map();

/**
 * Ready check for Seer initialization
 *
 * @returns {Boolean}
 */
var isReady = function isReady() {
  return isBrowser && window.__SEER_INITIALIZED__;
};

/**
 * Utility method allowing to throttle a user action based on a key and a minimun delay.
 *
 * @param key {String} A unique key
 * @param delay {Number} The minimal delay to throttle
 * @returns {Boolean}
 */
var throttle = function throttle(key, delay) {
  var time = timers.get(key);
  var now = Date.now();
  if (time && now - time < delay) {
    return true;
  }
  timers.set(key, now);
  return false;
};

var replacer = function replacer(seen) {
  return function (key, value) {
    if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && seen.has(value)) {
      return;
    }
    seen.add(value);
    var isArray = Object.prototype.toString.call(value).slice(8, -1).includes('Array');
    if (isArray) {
      return Array.prototype.slice.call(value, 0, 20);
    }
    return value;
  };
};

/**
 * Low-level api leveraging window.postMessage
 *
 * @param type {String} The action type
 * @param payload {Any} The action payload
 */
var send = function send(type) {
  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!isBrowser || !isReady()) {
    return;
  }

  var seen = new Set();
  var payload = JSON.stringify(data, replacer(seen));

  try {
    window.postMessage({ type: type, payload: payload, source: 'seer-agent' }, '*');
  } catch (e) {
    if (throttle('seer-log', 2E3)) {
      return;
    }
    console.log(e); // eslint-disable-line
  }
};

var listeners = new Map();

var listener = function listener(message) {
  if (!message || !message.data || message.data.source !== 'seer-core') {
    return;
  }
  var _message$data = message.data,
      type = _message$data.type,
      payload = _message$data.payload;


  var typeListeners = listeners.get(type);
  if (typeListeners) {
    typeListeners.forEach(function (cb) {
      return cb(payload);
    });
  }
};

/**
 * Initilize window listener. There will be only one for the whole process
 * to prevent too many registrations.
 *
 * This method will be called automatically if you use the `listenFor` method.
 */
var init = function init() {
  if (!isBrowser || window.__SEER_LISTENER__) {
    return;
  }
  window.addEventListener('message', listener);
  window.__SEER_LISTENER__ = true;
};

/**
 * Clean listener. Can be useful in case you want to unregister upcoming events
 * or liberate memory.
 */
var clean = function clean() {
  if (!isBrowser || !window.__SEER_LISTENER__) {
    return;
  }
  window.removeEventListener('message', listener);
  delete window.__SEER_LISTENER__;
};

/**
 * Create a listener that will be called upon events of the given key.
 *
 * @param key {String} The unique tab key
 * @param cb {Function} A callback that will receive the message payload
 */
var listenFor = function listenFor(type, cb) {
  if (!isBrowser) {
    return;
  }
  if (!type || !cb) {
    throw new Error('Please provide a type and callback');
  }
  if (!listeners.has(type)) {
    listeners.set(type, []);
  }
  if (!window.__SEER_LISTENER__) {
    init();
  }
  listeners.get(type).push(cb);
};

/**
 * Remove an identity listener
 *
 * @param cb {Function} The callback to remove
 */
var removeListener = function removeListener(cb) {
  listeners.forEach(function (typeListeners, key) {
    listeners.set(key, typeListeners.filter(function (l) {
      return l !== cb;
    }));
  });
};

/**
 * Creates a new indexed list.
 * It works by index to get O(1) accessing and performance.
 *
 * @param key {String} The key of the tab
 * @param data {Object} The indexed object
 */
var list = function list(key, data) {
  return send('LIST', { key: key, data: data });
};

/**
 * Creates an element in the indexed list, based on the itemKey.
 *
 * @param key {String} The key of the tab
 * @param itemKey {String} The key of the item
 * @param data {Any} The value of the item
 */
var listItem = function listItem(key, itemKey) {
  var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  return send('LIST_ITEM', { key: key, itemKey: itemKey, data: data });
};

/**
 * Update an item property, can be deeply nested.
 *
 * @param key {String} The key of the tab
 * @param itemKey {String} The key of the item
 * @param path {String} The path of the variable you want to update
 * @param data {Object} The new value
 */
var updateItem = function updateItem(key, itemKey, path, data) {
  return send('UPDATE_ITEM', { key: key, itemKey: itemKey, path: path, data: data });
};

/**
 * Similar to updateItem, but allows to pass an array with {path,data} pairs for
 * multiple update of the same item without having to send multiple messages.
 *
 * @param key {String} The key of the tab
 * @param itemKey {String} The key of the item
 * @param array {Array} The array of updates
 * @param array.path {String} The path for this update
 * @param array.data {Object} The value of this update
 */
var multiUpdate = function multiUpdate(key, itemKey, array) {
  return send('MULTI_UPDATE_ITEM', { key: key, itemKey: itemKey, array: array });
};

/**
 * Remove a specific item in a specific tab.
 *
 * @param key {String} They key of the tab
 * @param itemKey {String} The key of the item
 */
var deleteItem = function deleteItem(key, itemKey) {
  return send('DELETE_ITEM', { key: key, itemKey: itemKey });
};

/**
 * Will create a log message to an item, that will be displayde with the current time.
 *
 * @param key {String} The key of the tab
 * @param itemKey {String} The key of the item
 * @param msg {String} The message to display
 */
var addLog = function addLog(key, itemKey, msg) {
  return send('ADD_LOG', { key: key, itemKey: itemKey, msg: msg });
};

exports.default = {

  send: send,
  throttle: throttle,
  isReady: isReady,

  list: list,
  listItem: listItem,
  updateItem: updateItem,
  multiUpdate: multiUpdate,
  deleteItem: deleteItem,
  addLog: addLog,

  listeners: listeners,
  listenFor: listenFor,
  removeListener: removeListener,
  init: init,
  clean: clean

};


/***/ }),

/***/ "../../node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../../node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "../constants/src/index.js":
/*!*********************************!*\
  !*** ../constants/src/index.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

// GL constants, copied from Mozilla documentation
// https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Constants

// Standard WebGL 1 constants
// These constants are defined on the WebGLRenderingContext interface.

/* eslint-disable key-spacing, max-len, no-inline-comments, camelcase */
// eslint-disable-next-line
module.exports = {
  // Clearing buffers
  // Constants passed to clear() to clear buffer masks.

  DEPTH_BUFFER_BIT: 0x00000100,
  STENCIL_BUFFER_BIT: 0x00000400,
  COLOR_BUFFER_BIT: 0x00004000,

  // Rendering primitives
  // Constants passed to drawElements() or drawArrays() to specify what kind of primitive to render.

  POINTS: 0x0000,
  LINES: 0x0001,
  LINE_LOOP: 0x0002,
  LINE_STRIP: 0x0003,
  TRIANGLES: 0x0004,
  TRIANGLE_STRIP: 0x0005,
  TRIANGLE_FAN: 0x0006,

  // Blending modes
  // Constants passed to blendFunc() or blendFuncSeparate() to specify the blending mode (for both, RBG and alpha, or separately).

  ZERO: 0,
  ONE: 1,
  SRC_COLOR: 0x0300,
  ONE_MINUS_SRC_COLOR: 0x0301,
  SRC_ALPHA: 0x0302,
  ONE_MINUS_SRC_ALPHA: 0x0303,
  DST_ALPHA: 0x0304,
  ONE_MINUS_DST_ALPHA: 0x0305,
  DST_COLOR: 0x0306,
  ONE_MINUS_DST_COLOR: 0x0307,
  SRC_ALPHA_SATURATE: 0x0308,
  CONSTANT_COLOR: 0x8001,
  ONE_MINUS_CONSTANT_COLOR: 0x8002,
  CONSTANT_ALPHA: 0x8003,
  ONE_MINUS_CONSTANT_ALPHA: 0x8004,

  // Blending equations
  // Constants passed to blendEquation() or blendEquationSeparate() to control
  // how the blending is calculated (for both, RBG and alpha, or separately).

  FUNC_ADD: 0x8006,
  FUNC_SUBTRACT: 0x800a,
  FUNC_REVERSE_SUBTRACT: 0x800b,

  // Getting GL parameter information
  // Constants passed to getParameter() to specify what information to return.

  BLEND_EQUATION: 0x8009,
  BLEND_EQUATION_RGB: 0x8009,
  BLEND_EQUATION_ALPHA: 0x883d,
  BLEND_DST_RGB: 0x80c8,
  BLEND_SRC_RGB: 0x80c9,
  BLEND_DST_ALPHA: 0x80ca,
  BLEND_SRC_ALPHA: 0x80cb,
  BLEND_COLOR: 0x8005,
  ARRAY_BUFFER_BINDING: 0x8894,
  ELEMENT_ARRAY_BUFFER_BINDING: 0x8895,
  LINE_WIDTH: 0x0b21,
  ALIASED_POINT_SIZE_RANGE: 0x846d,
  ALIASED_LINE_WIDTH_RANGE: 0x846e,
  CULL_FACE_MODE: 0x0b45,
  FRONT_FACE: 0x0b46,
  DEPTH_RANGE: 0x0b70,
  DEPTH_WRITEMASK: 0x0b72,
  DEPTH_CLEAR_VALUE: 0x0b73,
  DEPTH_FUNC: 0x0b74,
  STENCIL_CLEAR_VALUE: 0x0b91,
  STENCIL_FUNC: 0x0b92,
  STENCIL_FAIL: 0x0b94,
  STENCIL_PASS_DEPTH_FAIL: 0x0b95,
  STENCIL_PASS_DEPTH_PASS: 0x0b96,
  STENCIL_REF: 0x0b97,
  STENCIL_VALUE_MASK: 0x0b93,
  STENCIL_WRITEMASK: 0x0b98,
  STENCIL_BACK_FUNC: 0x8800,
  STENCIL_BACK_FAIL: 0x8801,
  STENCIL_BACK_PASS_DEPTH_FAIL: 0x8802,
  STENCIL_BACK_PASS_DEPTH_PASS: 0x8803,
  STENCIL_BACK_REF: 0x8ca3,
  STENCIL_BACK_VALUE_MASK: 0x8ca4,
  STENCIL_BACK_WRITEMASK: 0x8ca5,
  VIEWPORT: 0x0ba2,
  SCISSOR_BOX: 0x0c10,
  COLOR_CLEAR_VALUE: 0x0c22,
  COLOR_WRITEMASK: 0x0c23,
  UNPACK_ALIGNMENT: 0x0cf5,
  PACK_ALIGNMENT: 0x0d05,
  MAX_TEXTURE_SIZE: 0x0d33,
  MAX_VIEWPORT_DIMS: 0x0d3a,
  SUBPIXEL_BITS: 0x0d50,
  RED_BITS: 0x0d52,
  GREEN_BITS: 0x0d53,
  BLUE_BITS: 0x0d54,
  ALPHA_BITS: 0x0d55,
  DEPTH_BITS: 0x0d56,
  STENCIL_BITS: 0x0d57,
  POLYGON_OFFSET_UNITS: 0x2a00,
  POLYGON_OFFSET_FACTOR: 0x8038,
  TEXTURE_BINDING_2D: 0x8069,
  SAMPLE_BUFFERS: 0x80a8,
  SAMPLES: 0x80a9,
  SAMPLE_COVERAGE_VALUE: 0x80aa,
  SAMPLE_COVERAGE_INVERT: 0x80ab,
  COMPRESSED_TEXTURE_FORMATS: 0x86a3,
  VENDOR: 0x1f00,
  RENDERER: 0x1f01,
  VERSION: 0x1f02,
  IMPLEMENTATION_COLOR_READ_TYPE: 0x8b9a,
  IMPLEMENTATION_COLOR_READ_FORMAT: 0x8b9b,
  BROWSER_DEFAULT_WEBGL: 0x9244,

  // Buffers
  // Constants passed to bufferData(), bufferSubData(), bindBuffer(), or
  // getBufferParameter().

  STATIC_DRAW: 0x88e4,
  STREAM_DRAW: 0x88e0,
  DYNAMIC_DRAW: 0x88e8,
  ARRAY_BUFFER: 0x8892,
  ELEMENT_ARRAY_BUFFER: 0x8893,
  BUFFER_SIZE: 0x8764,
  BUFFER_USAGE: 0x8765,

  // Vertex attributes
  // Constants passed to getVertexAttrib().

  CURRENT_VERTEX_ATTRIB: 0x8626,
  VERTEX_ATTRIB_ARRAY_ENABLED: 0x8622,
  VERTEX_ATTRIB_ARRAY_SIZE: 0x8623,
  VERTEX_ATTRIB_ARRAY_STRIDE: 0x8624,
  VERTEX_ATTRIB_ARRAY_TYPE: 0x8625,
  VERTEX_ATTRIB_ARRAY_NORMALIZED: 0x886a,
  VERTEX_ATTRIB_ARRAY_POINTER: 0x8645,
  VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: 0x889f,

  // Culling
  // Constants passed to cullFace().

  CULL_FACE: 0x0b44,
  FRONT: 0x0404,
  BACK: 0x0405,
  FRONT_AND_BACK: 0x0408,

  // Enabling and disabling
  // Constants passed to enable() or disable().

  BLEND: 0x0be2,
  DEPTH_TEST: 0x0b71,
  DITHER: 0x0bd0,
  POLYGON_OFFSET_FILL: 0x8037,
  SAMPLE_ALPHA_TO_COVERAGE: 0x809e,
  SAMPLE_COVERAGE: 0x80a0,
  SCISSOR_TEST: 0x0c11,
  STENCIL_TEST: 0x0b90,

  // Errors
  // Constants returned from getError().

  NO_ERROR: 0,
  INVALID_ENUM: 0x0500,
  INVALID_VALUE: 0x0501,
  INVALID_OPERATION: 0x0502,
  OUT_OF_MEMORY: 0x0505,
  CONTEXT_LOST_WEBGL: 0x9242,

  // Front face directions
  // Constants passed to frontFace().

  CW: 0x0900,
  CCW: 0x0901,

  // Hints
  // Constants passed to hint()

  DONT_CARE: 0x1100,
  FASTEST: 0x1101,
  NICEST: 0x1102,
  GENERATE_MIPMAP_HINT: 0x8192,

  // Data types

  BYTE: 0x1400,
  UNSIGNED_BYTE: 0x1401,
  SHORT: 0x1402,
  UNSIGNED_SHORT: 0x1403,
  INT: 0x1404,
  UNSIGNED_INT: 0x1405,
  FLOAT: 0x1406,
  DOUBLE: 0x140a,

  // Pixel formats

  DEPTH_COMPONENT: 0x1902,
  ALPHA: 0x1906,
  RGB: 0x1907,
  RGBA: 0x1908,
  LUMINANCE: 0x1909,
  LUMINANCE_ALPHA: 0x190a,

  // Pixel types

  // UNSIGNED_BYTE: 0x1401,
  UNSIGNED_SHORT_4_4_4_4: 0x8033,
  UNSIGNED_SHORT_5_5_5_1: 0x8034,
  UNSIGNED_SHORT_5_6_5: 0x8363,

  // Shaders
  // Constants passed to createShader() or getShaderParameter()

  FRAGMENT_SHADER: 0x8b30,
  VERTEX_SHADER: 0x8b31,
  COMPILE_STATUS: 0x8b81,
  DELETE_STATUS: 0x8b80,
  LINK_STATUS: 0x8b82,
  VALIDATE_STATUS: 0x8b83,
  ATTACHED_SHADERS: 0x8b85,
  ACTIVE_ATTRIBUTES: 0x8b89,
  ACTIVE_UNIFORMS: 0x8b86,
  MAX_VERTEX_ATTRIBS: 0x8869,
  MAX_VERTEX_UNIFORM_VECTORS: 0x8dfb,
  MAX_VARYING_VECTORS: 0x8dfc,
  MAX_COMBINED_TEXTURE_IMAGE_UNITS: 0x8b4d,
  MAX_VERTEX_TEXTURE_IMAGE_UNITS: 0x8b4c,
  MAX_TEXTURE_IMAGE_UNITS: 0x8872,
  MAX_FRAGMENT_UNIFORM_VECTORS: 0x8dfd,
  SHADER_TYPE: 0x8b4f,
  SHADING_LANGUAGE_VERSION: 0x8b8c,
  CURRENT_PROGRAM: 0x8b8d,

  // Depth or stencil tests
  // Constants passed to depthFunc() or stencilFunc().

  NEVER: 0x0200,
  ALWAYS: 0x0207,
  LESS: 0x0201,
  EQUAL: 0x0202,
  LEQUAL: 0x0203,
  GREATER: 0x0204,
  GEQUAL: 0x0206,
  NOTEQUAL: 0x0205,

  // Stencil actions
  // Constants passed to stencilOp().

  KEEP: 0x1e00,
  REPLACE: 0x1e01,
  INCR: 0x1e02,
  DECR: 0x1e03,
  INVERT: 0x150a,
  INCR_WRAP: 0x8507,
  DECR_WRAP: 0x8508,

  // Textures
  // Constants passed to texParameteri(),
  // texParameterf(), bindTexture(), texImage2D(), and others.

  NEAREST: 0x2600,
  LINEAR: 0x2601,
  NEAREST_MIPMAP_NEAREST: 0x2700,
  LINEAR_MIPMAP_NEAREST: 0x2701,
  NEAREST_MIPMAP_LINEAR: 0x2702,
  LINEAR_MIPMAP_LINEAR: 0x2703,
  TEXTURE_MAG_FILTER: 0x2800,
  TEXTURE_MIN_FILTER: 0x2801,
  TEXTURE_WRAP_S: 0x2802,
  TEXTURE_WRAP_T: 0x2803,
  TEXTURE_2D: 0x0de1,
  TEXTURE: 0x1702,
  TEXTURE_CUBE_MAP: 0x8513,
  TEXTURE_BINDING_CUBE_MAP: 0x8514,
  TEXTURE_CUBE_MAP_POSITIVE_X: 0x8515,
  TEXTURE_CUBE_MAP_NEGATIVE_X: 0x8516,
  TEXTURE_CUBE_MAP_POSITIVE_Y: 0x8517,
  TEXTURE_CUBE_MAP_NEGATIVE_Y: 0x8518,
  TEXTURE_CUBE_MAP_POSITIVE_Z: 0x8519,
  TEXTURE_CUBE_MAP_NEGATIVE_Z: 0x851a,
  MAX_CUBE_MAP_TEXTURE_SIZE: 0x851c,
  // TEXTURE0 - 31 0x84C0 - 0x84DF A texture unit.
  TEXTURE0: 0x84c0,
  ACTIVE_TEXTURE: 0x84e0,
  REPEAT: 0x2901,
  CLAMP_TO_EDGE: 0x812f,
  MIRRORED_REPEAT: 0x8370,

  // Emulation
  TEXTURE_WIDTH: 0x1000,
  TEXTURE_HEIGHT: 0x1001,

  // Uniform types

  FLOAT_VEC2: 0x8b50,
  FLOAT_VEC3: 0x8b51,
  FLOAT_VEC4: 0x8b52,
  INT_VEC2: 0x8b53,
  INT_VEC3: 0x8b54,
  INT_VEC4: 0x8b55,
  BOOL: 0x8b56,
  BOOL_VEC2: 0x8b57,
  BOOL_VEC3: 0x8b58,
  BOOL_VEC4: 0x8b59,
  FLOAT_MAT2: 0x8b5a,
  FLOAT_MAT3: 0x8b5b,
  FLOAT_MAT4: 0x8b5c,
  SAMPLER_2D: 0x8b5e,
  SAMPLER_CUBE: 0x8b60,

  // Shader precision-specified types

  LOW_FLOAT: 0x8df0,
  MEDIUM_FLOAT: 0x8df1,
  HIGH_FLOAT: 0x8df2,
  LOW_INT: 0x8df3,
  MEDIUM_INT: 0x8df4,
  HIGH_INT: 0x8df5,

  // Framebuffers and renderbuffers

  FRAMEBUFFER: 0x8d40,
  RENDERBUFFER: 0x8d41,
  RGBA4: 0x8056,
  RGB5_A1: 0x8057,
  RGB565: 0x8d62,
  DEPTH_COMPONENT16: 0x81a5,
  STENCIL_INDEX: 0x1901,
  STENCIL_INDEX8: 0x8d48,
  DEPTH_STENCIL: 0x84f9,
  RENDERBUFFER_WIDTH: 0x8d42,
  RENDERBUFFER_HEIGHT: 0x8d43,
  RENDERBUFFER_INTERNAL_FORMAT: 0x8d44,
  RENDERBUFFER_RED_SIZE: 0x8d50,
  RENDERBUFFER_GREEN_SIZE: 0x8d51,
  RENDERBUFFER_BLUE_SIZE: 0x8d52,
  RENDERBUFFER_ALPHA_SIZE: 0x8d53,
  RENDERBUFFER_DEPTH_SIZE: 0x8d54,
  RENDERBUFFER_STENCIL_SIZE: 0x8d55,
  FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: 0x8cd0,
  FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: 0x8cd1,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: 0x8cd2,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: 0x8cd3,
  COLOR_ATTACHMENT0: 0x8ce0,
  DEPTH_ATTACHMENT: 0x8d00,
  STENCIL_ATTACHMENT: 0x8d20,
  DEPTH_STENCIL_ATTACHMENT: 0x821a,
  NONE: 0,
  FRAMEBUFFER_COMPLETE: 0x8cd5,
  FRAMEBUFFER_INCOMPLETE_ATTACHMENT: 0x8cd6,
  FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: 0x8cd7,
  FRAMEBUFFER_INCOMPLETE_DIMENSIONS: 0x8cd9,
  FRAMEBUFFER_UNSUPPORTED: 0x8cdd,
  FRAMEBUFFER_BINDING: 0x8ca6,
  RENDERBUFFER_BINDING: 0x8ca7,
  READ_FRAMEBUFFER: 0x8ca8,
  DRAW_FRAMEBUFFER: 0x8ca9,
  MAX_RENDERBUFFER_SIZE: 0x84e8,
  INVALID_FRAMEBUFFER_OPERATION: 0x0506,

  // Pixel storage modes
  // Constants passed to pixelStorei().

  UNPACK_FLIP_Y_WEBGL: 0x9240,
  UNPACK_PREMULTIPLY_ALPHA_WEBGL: 0x9241,
  UNPACK_COLORSPACE_CONVERSION_WEBGL: 0x9243,

  // /////////////////////////////////////////////////////
  // Additional constants defined WebGL 2
  // These constants are defined on the WebGL2RenderingContext interface.
  // All WebGL 1 constants are also available in a WebGL 2 context.
  // /////////////////////////////////////////////////////

  // Getting GL parameter information
  // Constants passed to getParameter()
  // to specify what information to return.

  READ_BUFFER: 0x0c02,
  UNPACK_ROW_LENGTH: 0x0cf2,
  UNPACK_SKIP_ROWS: 0x0cf3,
  UNPACK_SKIP_PIXELS: 0x0cf4,
  PACK_ROW_LENGTH: 0x0d02,
  PACK_SKIP_ROWS: 0x0d03,
  PACK_SKIP_PIXELS: 0x0d04,
  TEXTURE_BINDING_3D: 0x806a,
  UNPACK_SKIP_IMAGES: 0x806d,
  UNPACK_IMAGE_HEIGHT: 0x806e,
  MAX_3D_TEXTURE_SIZE: 0x8073,
  MAX_ELEMENTS_VERTICES: 0x80e8,
  MAX_ELEMENTS_INDICES: 0x80e9,
  MAX_TEXTURE_LOD_BIAS: 0x84fd,
  MAX_FRAGMENT_UNIFORM_COMPONENTS: 0x8b49,
  MAX_VERTEX_UNIFORM_COMPONENTS: 0x8b4a,
  MAX_ARRAY_TEXTURE_LAYERS: 0x88ff,
  MIN_PROGRAM_TEXEL_OFFSET: 0x8904,
  MAX_PROGRAM_TEXEL_OFFSET: 0x8905,
  MAX_VARYING_COMPONENTS: 0x8b4b,
  FRAGMENT_SHADER_DERIVATIVE_HINT: 0x8b8b,
  RASTERIZER_DISCARD: 0x8c89,
  VERTEX_ARRAY_BINDING: 0x85b5,
  MAX_VERTEX_OUTPUT_COMPONENTS: 0x9122,
  MAX_FRAGMENT_INPUT_COMPONENTS: 0x9125,
  MAX_SERVER_WAIT_TIMEOUT: 0x9111,
  MAX_ELEMENT_INDEX: 0x8d6b,

  // Textures
  // Constants passed to texParameteri(),
  // texParameterf(), bindTexture(), texImage2D(), and others.

  RED: 0x1903,
  RGB8: 0x8051,
  RGBA8: 0x8058,
  RGB10_A2: 0x8059,
  TEXTURE_3D: 0x806f,
  TEXTURE_WRAP_R: 0x8072,
  TEXTURE_MIN_LOD: 0x813a,
  TEXTURE_MAX_LOD: 0x813b,
  TEXTURE_BASE_LEVEL: 0x813c,
  TEXTURE_MAX_LEVEL: 0x813d,
  TEXTURE_COMPARE_MODE: 0x884c,
  TEXTURE_COMPARE_FUNC: 0x884d,
  SRGB: 0x8c40,
  SRGB8: 0x8c41,
  SRGB8_ALPHA8: 0x8c43,
  COMPARE_REF_TO_TEXTURE: 0x884e,
  RGBA32F: 0x8814,
  RGB32F: 0x8815,
  RGBA16F: 0x881a,
  RGB16F: 0x881b,
  TEXTURE_2D_ARRAY: 0x8c1a,
  TEXTURE_BINDING_2D_ARRAY: 0x8c1d,
  R11F_G11F_B10F: 0x8c3a,
  RGB9_E5: 0x8c3d,
  RGBA32UI: 0x8d70,
  RGB32UI: 0x8d71,
  RGBA16UI: 0x8d76,
  RGB16UI: 0x8d77,
  RGBA8UI: 0x8d7c,
  RGB8UI: 0x8d7d,
  RGBA32I: 0x8d82,
  RGB32I: 0x8d83,
  RGBA16I: 0x8d88,
  RGB16I: 0x8d89,
  RGBA8I: 0x8d8e,
  RGB8I: 0x8d8f,
  RED_INTEGER: 0x8d94,
  RGB_INTEGER: 0x8d98,
  RGBA_INTEGER: 0x8d99,
  R8: 0x8229,
  RG8: 0x822b,
  R16F: 0x822d,
  R32F: 0x822e,
  RG16F: 0x822f,
  RG32F: 0x8230,
  R8I: 0x8231,
  R8UI: 0x8232,
  R16I: 0x8233,
  R16UI: 0x8234,
  R32I: 0x8235,
  R32UI: 0x8236,
  RG8I: 0x8237,
  RG8UI: 0x8238,
  RG16I: 0x8239,
  RG16UI: 0x823a,
  RG32I: 0x823b,
  RG32UI: 0x823c,
  R8_SNORM: 0x8f94,
  RG8_SNORM: 0x8f95,
  RGB8_SNORM: 0x8f96,
  RGBA8_SNORM: 0x8f97,
  RGB10_A2UI: 0x906f,

  /* covered by extension
  COMPRESSED_R11_EAC : 0x9270,
  COMPRESSED_SIGNED_R11_EAC: 0x9271,
  COMPRESSED_RG11_EAC: 0x9272,
  COMPRESSED_SIGNED_RG11_EAC : 0x9273,
  COMPRESSED_RGB8_ETC2 : 0x9274,
  COMPRESSED_SRGB8_ETC2: 0x9275,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 : 0x9276,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC : 0x9277,
  COMPRESSED_RGBA8_ETC2_EAC: 0x9278,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : 0x9279,
  */
  TEXTURE_IMMUTABLE_FORMAT: 0x912f,
  TEXTURE_IMMUTABLE_LEVELS: 0x82df,

  // Pixel types

  UNSIGNED_INT_2_10_10_10_REV: 0x8368,
  UNSIGNED_INT_10F_11F_11F_REV: 0x8c3b,
  UNSIGNED_INT_5_9_9_9_REV: 0x8c3e,
  FLOAT_32_UNSIGNED_INT_24_8_REV: 0x8dad,
  UNSIGNED_INT_24_8: 0x84fa,
  HALF_FLOAT: 0x140b,
  RG: 0x8227,
  RG_INTEGER: 0x8228,
  INT_2_10_10_10_REV: 0x8d9f,

  // Queries

  CURRENT_QUERY: 0x8865,
  QUERY_RESULT: 0x8866,
  QUERY_RESULT_AVAILABLE: 0x8867,
  ANY_SAMPLES_PASSED: 0x8c2f,
  ANY_SAMPLES_PASSED_CONSERVATIVE: 0x8d6a,

  // Draw buffers

  MAX_DRAW_BUFFERS: 0x8824,
  DRAW_BUFFER0: 0x8825,
  DRAW_BUFFER1: 0x8826,
  DRAW_BUFFER2: 0x8827,
  DRAW_BUFFER3: 0x8828,
  DRAW_BUFFER4: 0x8829,
  DRAW_BUFFER5: 0x882a,
  DRAW_BUFFER6: 0x882b,
  DRAW_BUFFER7: 0x882c,
  DRAW_BUFFER8: 0x882d,
  DRAW_BUFFER9: 0x882e,
  DRAW_BUFFER10: 0x882f,
  DRAW_BUFFER11: 0x8830,
  DRAW_BUFFER12: 0x8831,
  DRAW_BUFFER13: 0x8832,
  DRAW_BUFFER14: 0x8833,
  DRAW_BUFFER15: 0x8834,
  MAX_COLOR_ATTACHMENTS: 0x8cdf,
  COLOR_ATTACHMENT1: 0x8ce1,
  COLOR_ATTACHMENT2: 0x8ce2,
  COLOR_ATTACHMENT3: 0x8ce3,
  COLOR_ATTACHMENT4: 0x8ce4,
  COLOR_ATTACHMENT5: 0x8ce5,
  COLOR_ATTACHMENT6: 0x8ce6,
  COLOR_ATTACHMENT7: 0x8ce7,
  COLOR_ATTACHMENT8: 0x8ce8,
  COLOR_ATTACHMENT9: 0x8ce9,
  COLOR_ATTACHMENT10: 0x8cea,
  COLOR_ATTACHMENT11: 0x8ceb,
  COLOR_ATTACHMENT12: 0x8cec,
  COLOR_ATTACHMENT13: 0x8ced,
  COLOR_ATTACHMENT14: 0x8cee,
  COLOR_ATTACHMENT15: 0x8cef,

  // Samplers

  SAMPLER_3D: 0x8b5f,
  SAMPLER_2D_SHADOW: 0x8b62,
  SAMPLER_2D_ARRAY: 0x8dc1,
  SAMPLER_2D_ARRAY_SHADOW: 0x8dc4,
  SAMPLER_CUBE_SHADOW: 0x8dc5,
  INT_SAMPLER_2D: 0x8dca,
  INT_SAMPLER_3D: 0x8dcb,
  INT_SAMPLER_CUBE: 0x8dcc,
  INT_SAMPLER_2D_ARRAY: 0x8dcf,
  UNSIGNED_INT_SAMPLER_2D: 0x8dd2,
  UNSIGNED_INT_SAMPLER_3D: 0x8dd3,
  UNSIGNED_INT_SAMPLER_CUBE: 0x8dd4,
  UNSIGNED_INT_SAMPLER_2D_ARRAY: 0x8dd7,
  MAX_SAMPLES: 0x8d57,
  SAMPLER_BINDING: 0x8919,

  // Buffers

  PIXEL_PACK_BUFFER: 0x88eb,
  PIXEL_UNPACK_BUFFER: 0x88ec,
  PIXEL_PACK_BUFFER_BINDING: 0x88ed,
  PIXEL_UNPACK_BUFFER_BINDING: 0x88ef,
  COPY_READ_BUFFER: 0x8f36,
  COPY_WRITE_BUFFER: 0x8f37,
  COPY_READ_BUFFER_BINDING: 0x8f36,
  COPY_WRITE_BUFFER_BINDING: 0x8f37,

  // Data types

  FLOAT_MAT2x3: 0x8b65,
  FLOAT_MAT2x4: 0x8b66,
  FLOAT_MAT3x2: 0x8b67,
  FLOAT_MAT3x4: 0x8b68,
  FLOAT_MAT4x2: 0x8b69,
  FLOAT_MAT4x3: 0x8b6a,
  UNSIGNED_INT_VEC2: 0x8dc6,
  UNSIGNED_INT_VEC3: 0x8dc7,
  UNSIGNED_INT_VEC4: 0x8dc8,
  UNSIGNED_NORMALIZED: 0x8c17,
  SIGNED_NORMALIZED: 0x8f9c,

  // Vertex attributes

  VERTEX_ATTRIB_ARRAY_INTEGER: 0x88fd,
  VERTEX_ATTRIB_ARRAY_DIVISOR: 0x88fe,

  // Transform feedback

  TRANSFORM_FEEDBACK_BUFFER_MODE: 0x8c7f,
  MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS: 0x8c80,
  TRANSFORM_FEEDBACK_VARYINGS: 0x8c83,
  TRANSFORM_FEEDBACK_BUFFER_START: 0x8c84,
  TRANSFORM_FEEDBACK_BUFFER_SIZE: 0x8c85,
  TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN: 0x8c88,
  MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS: 0x8c8a,
  MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS: 0x8c8b,
  INTERLEAVED_ATTRIBS: 0x8c8c,
  SEPARATE_ATTRIBS: 0x8c8d,
  TRANSFORM_FEEDBACK_BUFFER: 0x8c8e,
  TRANSFORM_FEEDBACK_BUFFER_BINDING: 0x8c8f,
  TRANSFORM_FEEDBACK: 0x8e22,
  TRANSFORM_FEEDBACK_PAUSED: 0x8e23,
  TRANSFORM_FEEDBACK_ACTIVE: 0x8e24,
  TRANSFORM_FEEDBACK_BINDING: 0x8e25,

  // Framebuffers and renderbuffers

  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING: 0x8210,
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: 0x8211,
  FRAMEBUFFER_ATTACHMENT_RED_SIZE: 0x8212,
  FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: 0x8213,
  FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: 0x8214,
  FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: 0x8215,
  FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: 0x8216,
  FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: 0x8217,
  FRAMEBUFFER_DEFAULT: 0x8218,
  // DEPTH_STENCIL_ATTACHMENT : 0x821A,
  // DEPTH_STENCIL: 0x84F9,
  DEPTH24_STENCIL8: 0x88f0,
  DRAW_FRAMEBUFFER_BINDING: 0x8ca6,
  READ_FRAMEBUFFER_BINDING: 0x8caa,
  RENDERBUFFER_SAMPLES: 0x8cab,
  FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: 0x8cd4,
  FRAMEBUFFER_INCOMPLETE_MULTISAMPLE: 0x8d56,

  // Uniforms

  UNIFORM_BUFFER: 0x8a11,
  UNIFORM_BUFFER_BINDING: 0x8a28,
  UNIFORM_BUFFER_START: 0x8a29,
  UNIFORM_BUFFER_SIZE: 0x8a2a,
  MAX_VERTEX_UNIFORM_BLOCKS: 0x8a2b,
  MAX_FRAGMENT_UNIFORM_BLOCKS: 0x8a2d,
  MAX_COMBINED_UNIFORM_BLOCKS: 0x8a2e,
  MAX_UNIFORM_BUFFER_BINDINGS: 0x8a2f,
  MAX_UNIFORM_BLOCK_SIZE: 0x8a30,
  MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS: 0x8a31,
  MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS: 0x8a33,
  UNIFORM_BUFFER_OFFSET_ALIGNMENT: 0x8a34,
  ACTIVE_UNIFORM_BLOCKS: 0x8a36,
  UNIFORM_TYPE: 0x8a37,
  UNIFORM_SIZE: 0x8a38,
  UNIFORM_BLOCK_INDEX: 0x8a3a,
  UNIFORM_OFFSET: 0x8a3b,
  UNIFORM_ARRAY_STRIDE: 0x8a3c,
  UNIFORM_MATRIX_STRIDE: 0x8a3d,
  UNIFORM_IS_ROW_MAJOR: 0x8a3e,
  UNIFORM_BLOCK_BINDING: 0x8a3f,
  UNIFORM_BLOCK_DATA_SIZE: 0x8a40,
  UNIFORM_BLOCK_ACTIVE_UNIFORMS: 0x8a42,
  UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES: 0x8a43,
  UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER: 0x8a44,
  UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER: 0x8a46,

  // Sync objects

  OBJECT_TYPE: 0x9112,
  SYNC_CONDITION: 0x9113,
  SYNC_STATUS: 0x9114,
  SYNC_FLAGS: 0x9115,
  SYNC_FENCE: 0x9116,
  SYNC_GPU_COMMANDS_COMPLETE: 0x9117,
  UNSIGNALED: 0x9118,
  SIGNALED: 0x9119,
  ALREADY_SIGNALED: 0x911a,
  TIMEOUT_EXPIRED: 0x911b,
  CONDITION_SATISFIED: 0x911c,
  WAIT_FAILED: 0x911d,
  SYNC_FLUSH_COMMANDS_BIT: 0x00000001,

  // Miscellaneous constants

  COLOR: 0x1800,
  DEPTH: 0x1801,
  STENCIL: 0x1802,
  MIN: 0x8007,
  MAX: 0x8008,
  DEPTH_COMPONENT24: 0x81a6,
  STREAM_READ: 0x88e1,
  STREAM_COPY: 0x88e2,
  STATIC_READ: 0x88e5,
  STATIC_COPY: 0x88e6,
  DYNAMIC_READ: 0x88e9,
  DYNAMIC_COPY: 0x88ea,
  DEPTH_COMPONENT32F: 0x8cac,
  DEPTH32F_STENCIL8: 0x8cad,
  INVALID_INDEX: 0xffffffff,
  TIMEOUT_IGNORED: -1,
  MAX_CLIENT_WAIT_TIMEOUT_WEBGL: 0x9247,

  // Constants defined in WebGL extensions

  // ANGLE_instanced_arrays

  VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 0x88fe,

  // WEBGL_debug_renderer_info

  UNMASKED_VENDOR_WEBGL: 0x9245,
  UNMASKED_RENDERER_WEBGL: 0x9246,

  // EXT_texture_filter_anisotropic

  MAX_TEXTURE_MAX_ANISOTROPY_EXT: 0x84ff,
  TEXTURE_MAX_ANISOTROPY_EXT: 0x84fe,

  // WEBGL_compressed_texture_s3tc

  COMPRESSED_RGB_S3TC_DXT1_EXT: 0x83f0,
  COMPRESSED_RGBA_S3TC_DXT1_EXT: 0x83f1,
  COMPRESSED_RGBA_S3TC_DXT3_EXT: 0x83f2,
  COMPRESSED_RGBA_S3TC_DXT5_EXT: 0x83f3,

  // WEBGL_compressed_texture_es3

  COMPRESSED_R11_EAC: 0x9270,
  COMPRESSED_SIGNED_R11_EAC: 0x9271,
  COMPRESSED_RG11_EAC: 0x9272,
  COMPRESSED_SIGNED_RG11_EAC: 0x9273,
  COMPRESSED_RGB8_ETC2: 0x9274,
  COMPRESSED_RGBA8_ETC2_EAC: 0x9275,
  COMPRESSED_SRGB8_ETC2: 0x9276,
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: 0x9277,
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9278,
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: 0x9279,

  // WEBGL_compressed_texture_pvrtc

  COMPRESSED_RGB_PVRTC_4BPPV1_IMG: 0x8c00,
  COMPRESSED_RGBA_PVRTC_4BPPV1_IMG: 0x8c02,
  COMPRESSED_RGB_PVRTC_2BPPV1_IMG: 0x8c01,
  COMPRESSED_RGBA_PVRTC_2BPPV1_IMG: 0x8c03,

  // WEBGL_compressed_texture_etc1

  COMPRESSED_RGB_ETC1_WEBGL: 0x8d64,

  // WEBGL_compressed_texture_atc

  COMPRESSED_RGB_ATC_WEBGL: 0x8c92,
  COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL: 0x8c92,
  COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL: 0x87ee,

  // WEBGL_depth_texture

  UNSIGNED_INT_24_8_WEBGL: 0x84fa,

  // OES_texture_half_float

  HALF_FLOAT_OES: 0x8d61,

  // WEBGL_color_buffer_float

  RGBA32F_EXT: 0x8814,
  RGB32F_EXT: 0x8815,
  FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE_EXT: 0x8211,
  UNSIGNED_NORMALIZED_EXT: 0x8c17,

  // EXT_blend_minmax

  MIN_EXT: 0x8007,
  MAX_EXT: 0x8008,

  // EXT_sRGB

  SRGB_EXT: 0x8c40,
  SRGB_ALPHA_EXT: 0x8c42,
  SRGB8_ALPHA8_EXT: 0x8c43,
  FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING_EXT: 0x8210,

  // OES_standard_derivatives

  FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 0x8b8b,

  // WEBGL_draw_buffers

  COLOR_ATTACHMENT0_WEBGL: 0x8ce0,
  COLOR_ATTACHMENT1_WEBGL: 0x8ce1,
  COLOR_ATTACHMENT2_WEBGL: 0x8ce2,
  COLOR_ATTACHMENT3_WEBGL: 0x8ce3,
  COLOR_ATTACHMENT4_WEBGL: 0x8ce4,
  COLOR_ATTACHMENT5_WEBGL: 0x8ce5,
  COLOR_ATTACHMENT6_WEBGL: 0x8ce6,
  COLOR_ATTACHMENT7_WEBGL: 0x8ce7,
  COLOR_ATTACHMENT8_WEBGL: 0x8ce8,
  COLOR_ATTACHMENT9_WEBGL: 0x8ce9,
  COLOR_ATTACHMENT10_WEBGL: 0x8cea,
  COLOR_ATTACHMENT11_WEBGL: 0x8ceb,
  COLOR_ATTACHMENT12_WEBGL: 0x8cec,
  COLOR_ATTACHMENT13_WEBGL: 0x8ced,
  COLOR_ATTACHMENT14_WEBGL: 0x8cee,
  COLOR_ATTACHMENT15_WEBGL: 0x8cef,
  DRAW_BUFFER0_WEBGL: 0x8825,
  DRAW_BUFFER1_WEBGL: 0x8826,
  DRAW_BUFFER2_WEBGL: 0x8827,
  DRAW_BUFFER3_WEBGL: 0x8828,
  DRAW_BUFFER4_WEBGL: 0x8829,
  DRAW_BUFFER5_WEBGL: 0x882a,
  DRAW_BUFFER6_WEBGL: 0x882b,
  DRAW_BUFFER7_WEBGL: 0x882c,
  DRAW_BUFFER8_WEBGL: 0x882d,
  DRAW_BUFFER9_WEBGL: 0x882e,
  DRAW_BUFFER10_WEBGL: 0x882f,
  DRAW_BUFFER11_WEBGL: 0x8830,
  DRAW_BUFFER12_WEBGL: 0x8831,
  DRAW_BUFFER13_WEBGL: 0x8832,
  DRAW_BUFFER14_WEBGL: 0x8833,
  DRAW_BUFFER15_WEBGL: 0x8834,
  MAX_COLOR_ATTACHMENTS_WEBGL: 0x8cdf,
  MAX_DRAW_BUFFERS_WEBGL: 0x8824,

  // OES_vertex_array_object

  VERTEX_ARRAY_BINDING_OES: 0x85b5,

  // EXT_disjoint_timer_query

  QUERY_COUNTER_BITS_EXT: 0x8864,
  CURRENT_QUERY_EXT: 0x8865,
  QUERY_RESULT_EXT: 0x8866,
  QUERY_RESULT_AVAILABLE_EXT: 0x8867,
  TIME_ELAPSED_EXT: 0x88bf,
  TIMESTAMP_EXT: 0x8e28,
  GPU_DISJOINT_EXT: 0x8fbb // A Boolean indicating whether or not the GPU performed any disjoint operation.
};


/***/ }),

/***/ "../shadertools/src/index.js":
/*!***********************************!*\
  !*** ../shadertools/src/index.js ***!
  \***********************************/
/*! exports provided: registerShaderModules, setDefaultShaderModules, getDefaultShaderModules, assembleShaders, createShaderHook, createModuleInjection, resetGlobalShaderHooks, combineInjects, normalizeShaderModule, getQualifierDetails, getPassthroughFS, typeToChannelSuffix, typeToChannelCount, convertToVec4, MODULAR_SHADERS, fp32, fp64, project, fog, lights, dirlight, picking, diffuse, gouraudlighting, phonglighting, pbr, _transform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MODULAR_SHADERS", function() { return MODULAR_SHADERS; });
/* harmony import */ var _shaders_modular_vertex_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shaders/modular-vertex.glsl */ "../shadertools/src/shaders/modular-vertex.glsl.js");
/* harmony import */ var _shaders_modular_fragment_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaders/modular-fragment.glsl */ "../shadertools/src/shaders/modular-fragment.glsl.js");
/* harmony import */ var _lib_resolve_modules__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/resolve-modules */ "../shadertools/src/lib/resolve-modules.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerShaderModules", function() { return _lib_resolve_modules__WEBPACK_IMPORTED_MODULE_2__["registerShaderModules"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setDefaultShaderModules", function() { return _lib_resolve_modules__WEBPACK_IMPORTED_MODULE_2__["setDefaultShaderModules"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDefaultShaderModules", function() { return _lib_resolve_modules__WEBPACK_IMPORTED_MODULE_2__["getDefaultShaderModules"]; });

/* harmony import */ var _lib_assemble_shaders__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/assemble-shaders */ "../shadertools/src/lib/assemble-shaders.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assembleShaders", function() { return _lib_assemble_shaders__WEBPACK_IMPORTED_MODULE_3__["assembleShaders"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createShaderHook", function() { return _lib_assemble_shaders__WEBPACK_IMPORTED_MODULE_3__["createShaderHook"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createModuleInjection", function() { return _lib_assemble_shaders__WEBPACK_IMPORTED_MODULE_3__["createModuleInjection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resetGlobalShaderHooks", function() { return _lib_assemble_shaders__WEBPACK_IMPORTED_MODULE_3__["resetGlobalShaderHooks"]; });

/* harmony import */ var _lib_inject_shader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/inject-shader */ "../shadertools/src/lib/inject-shader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combineInjects", function() { return _lib_inject_shader__WEBPACK_IMPORTED_MODULE_4__["combineInjects"]; });

/* harmony import */ var _lib_shader_module__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/shader-module */ "../shadertools/src/lib/shader-module.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "normalizeShaderModule", function() { return _lib_shader_module__WEBPACK_IMPORTED_MODULE_5__["normalizeShaderModule"]; });

/* harmony import */ var _utils_shader_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/shader-utils */ "../shadertools/src/utils/shader-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getQualifierDetails", function() { return _utils_shader_utils__WEBPACK_IMPORTED_MODULE_6__["getQualifierDetails"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPassthroughFS", function() { return _utils_shader_utils__WEBPACK_IMPORTED_MODULE_6__["getPassthroughFS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "typeToChannelSuffix", function() { return _utils_shader_utils__WEBPACK_IMPORTED_MODULE_6__["typeToChannelSuffix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "typeToChannelCount", function() { return _utils_shader_utils__WEBPACK_IMPORTED_MODULE_6__["typeToChannelCount"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "convertToVec4", function() { return _utils_shader_utils__WEBPACK_IMPORTED_MODULE_6__["convertToVec4"]; });

/* harmony import */ var _modules__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./modules */ "../shadertools/src/modules/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp32", function() { return _modules__WEBPACK_IMPORTED_MODULE_7__["fp32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp64", function() { return _modules__WEBPACK_IMPORTED_MODULE_7__["fp64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "project", function() { return _modules__WEBPACK_IMPORTED_MODULE_7__["project"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fog", function() { return _modules__WEBPACK_IMPORTED_MODULE_7__["fog"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lights", function() { return _modules__WEBPACK_IMPORTED_MODULE_7__["lights"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dirlight", function() { return _modules__WEBPACK_IMPORTED_MODULE_7__["dirlight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "picking", function() { return _modules__WEBPACK_IMPORTED_MODULE_7__["picking"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "diffuse", function() { return _modules__WEBPACK_IMPORTED_MODULE_7__["diffuse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gouraudlighting", function() { return _modules__WEBPACK_IMPORTED_MODULE_7__["gouraudlighting"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "phonglighting", function() { return _modules__WEBPACK_IMPORTED_MODULE_7__["phonglighting"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pbr", function() { return _modules__WEBPACK_IMPORTED_MODULE_7__["pbr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_transform", function() { return _modules__WEBPACK_IMPORTED_MODULE_7__["_transform"]; });

// shadertools exports

// DEFAULT SHADERS
// A set of base shaders that leverage the shader module system,
// dynamically enabling features depending on which modules are included



// DOCUMENTED APIS



// HELPERS



// UTILS


// SHADER MODULES


const MODULAR_SHADERS = {
  vs: _shaders_modular_vertex_glsl__WEBPACK_IMPORTED_MODULE_0__["default"],
  fs: _shaders_modular_fragment_glsl__WEBPACK_IMPORTED_MODULE_1__["default"],
  uniforms: {}
};


/***/ }),

/***/ "../shadertools/src/lib/assemble-shaders.js":
/*!**************************************************!*\
  !*** ../shadertools/src/lib/assemble-shaders.js ***!
  \**************************************************/
/*! exports provided: createShaderHook, createModuleInjection, resetGlobalShaderHooks, assembleShaders */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createShaderHook", function() { return createShaderHook; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createModuleInjection", function() { return createModuleInjection; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetGlobalShaderHooks", function() { return resetGlobalShaderHooks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assembleShaders", function() { return assembleShaders; });
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ "../shadertools/src/lib/constants.js");
/* harmony import */ var _resolve_modules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resolve-modules */ "../shadertools/src/lib/resolve-modules.js");
/* harmony import */ var _platform_defines__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./platform-defines */ "../shadertools/src/lib/platform-defines.js");
/* harmony import */ var _inject_shader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./inject-shader */ "../shadertools/src/lib/inject-shader.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "../shadertools/src/utils/index.js");





/* eslint-disable max-depth, complexity */

const INJECT_SHADER_DECLARATIONS = `\n\n${_inject_shader__WEBPACK_IMPORTED_MODULE_3__["DECLARATION_INJECT_MARKER"]}\n\n`;

const SHADER_TYPE = {
  [_constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"]]: 'vertex',
  [_constants__WEBPACK_IMPORTED_MODULE_0__["FRAGMENT_SHADER"]]: 'fragment'
};

const HOOK_FUNCTIONS = {
  [_constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"]]: {},
  [_constants__WEBPACK_IMPORTED_MODULE_0__["FRAGMENT_SHADER"]]: {}
};

const MODULE_INJECTIONS = {
  [_constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"]]: {},
  [_constants__WEBPACK_IMPORTED_MODULE_0__["FRAGMENT_SHADER"]]: {}
};

// Precision prologue to inject before functions are injected in shader
// TODO - extract any existing prologue in the fragment source and move it up...
const FRAGMENT_SHADER_PROLOGUE = `\
precision highp float;

`;

function createShaderHook(hook, opts = {}) {
  hook = hook.trim();
  const [stage, signature] = hook.split(':');
  const name = hook.replace(/\(.+/, '');
  HOOK_FUNCTIONS[stage][name] = Object.assign(opts, {signature});
}

function createModuleInjection(moduleName, opts) {
  const {hook, injection, order = 0} = opts;
  const shaderStage = hook.slice(0, 2);

  const moduleInjections = MODULE_INJECTIONS[shaderStage];
  moduleInjections[moduleName] = moduleInjections[moduleName] || {};

  Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(!moduleInjections[moduleName][hook], 'Module injection already created');

  moduleInjections[moduleName][hook] = {
    injection,
    order
  };
}

// Helpful for tests
function resetGlobalShaderHooks() {
  HOOK_FUNCTIONS[_constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"]] = {};
  HOOK_FUNCTIONS[_constants__WEBPACK_IMPORTED_MODULE_0__["FRAGMENT_SHADER"]] = {};

  MODULE_INJECTIONS[_constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"]] = {};
  MODULE_INJECTIONS[_constants__WEBPACK_IMPORTED_MODULE_0__["FRAGMENT_SHADER"]] = {};
}

// Inject a list of modules
function assembleShaders(gl, opts) {
  const {vs, fs} = opts;
  const modules = Object(_resolve_modules__WEBPACK_IMPORTED_MODULE_1__["resolveModules"])(opts.modules || []);
  return {
    gl,
    vs: assembleShader(gl, Object.assign({}, opts, {source: vs, type: _constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"], modules})),
    fs: assembleShader(gl, Object.assign({}, opts, {source: fs, type: _constants__WEBPACK_IMPORTED_MODULE_0__["FRAGMENT_SHADER"], modules})),
    getUniforms: assembleGetUniforms(modules),
    modules: assembleModuleMap(modules)
  };
}

// Pulls together complete source code for either a vertex or a fragment shader
// adding prologues, requested module chunks, and any final injections.
function assembleShader(
  gl,
  {
    id,
    source,
    type,
    modules,
    defines = {},
    hookFunctions = HOOK_FUNCTIONS,
    moduleInjections = MODULE_INJECTIONS,
    inject = {},
    prologue = true,
    log
  }
) {
  Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(typeof source === 'string', 'shader source must be a string');

  // TODO(Tarek): Supporting global hooks, remove when they're removed.
  if (hookFunctions !== HOOK_FUNCTIONS) {
    hookFunctions = {
      [_constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"]]: Object.assign(
        {},
        HOOK_FUNCTIONS[_constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"]],
        hookFunctions[_constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"]]
      ),
      [_constants__WEBPACK_IMPORTED_MODULE_0__["FRAGMENT_SHADER"]]: Object.assign(
        {},
        HOOK_FUNCTIONS[_constants__WEBPACK_IMPORTED_MODULE_0__["FRAGMENT_SHADER"]],
        hookFunctions[_constants__WEBPACK_IMPORTED_MODULE_0__["FRAGMENT_SHADER"]]
      )
    };
  }

  if (moduleInjections !== MODULE_INJECTIONS) {
    moduleInjections = {
      [_constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"]]: Object.assign(
        {},
        MODULE_INJECTIONS[_constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"]],
        moduleInjections[_constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"]]
      ),
      [_constants__WEBPACK_IMPORTED_MODULE_0__["FRAGMENT_SHADER"]]: Object.assign(
        {},
        MODULE_INJECTIONS[_constants__WEBPACK_IMPORTED_MODULE_0__["FRAGMENT_SHADER"]],
        moduleInjections[_constants__WEBPACK_IMPORTED_MODULE_0__["FRAGMENT_SHADER"]]
      )
    };
  }

  const isVertex = type === _constants__WEBPACK_IMPORTED_MODULE_0__["VERTEX_SHADER"];

  const sourceLines = source.split('\n');
  let glslVersion = 100;
  let versionLine = '';
  let coreSource = source;
  // Extract any version directive string from source.
  // TODO : keep all pre-processor statements at the begining of the shader.
  if (sourceLines[0].indexOf('#version ') === 0) {
    glslVersion = 300; // TODO - regexp that matches atual version number
    versionLine = sourceLines[0];
    coreSource = sourceLines.slice(1).join('\n');
  } else {
    versionLine = `#version ${glslVersion}`;
  }

  // Combine Module and Application Defines
  const allDefines = {};
  modules.forEach(module => {
    Object.assign(allDefines, module.getDefines());
  });
  Object.assign(allDefines, defines);

  // Add platform defines (use these to work around platform-specific bugs and limitations)
  // Add common defines (GLSL version compatibility, feature detection)
  // Add precision declaration for fragment shaders
  let assembledSource = prologue
    ? `\
${versionLine}
${getShaderName({id, source, type})}
${getShaderType({type})}
${Object(_platform_defines__WEBPACK_IMPORTED_MODULE_2__["getPlatformShaderDefines"])(gl)}
${Object(_platform_defines__WEBPACK_IMPORTED_MODULE_2__["getVersionDefines"])(gl, glslVersion, !isVertex)}
${getApplicationDefines(allDefines)}
${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}
`
    : `${versionLine}
`;

  // Add source of dependent modules in resolved order
  let injectStandardStubs = false;
  const hookInjections = {};
  const mainInjections = {};

  for (const key in inject) {
    const injection =
      typeof inject[key] === 'string' ? {injection: inject[key], order: 0} : inject[key];
    if (key.match(/^(v|f)s:/)) {
      if (key[3] === '#') {
        mainInjections[key] = [injection];
      } else {
        hookInjections[key] = [injection];
      }
    } else {
      // Regex injection
      mainInjections[key] = [injection];
    }
  }

  for (const module of modules) {
    switch (module.name) {
      case 'inject':
        injectStandardStubs = true;
        break;

      default:
        if (log) {
          module.checkDeprecations(coreSource, log);
        }
        const moduleSource = module.getModuleSource(type, glslVersion);
        // Add the module source, and a #define that declares it presence
        assembledSource += moduleSource;

        if (moduleInjections[type][module.name]) {
          const injections = moduleInjections[type][module.name];
          for (const key in injections) {
            if (key.match(/^(v|f)s:#/)) {
              mainInjections[key] = mainInjections[key] || [];
              mainInjections[key].push(injections[key]);
            } else {
              hookInjections[key] = hookInjections[key] || [];
              hookInjections[key].push(injections[key]);
            }
          }
        }
    }
  }

  // For injectShader
  assembledSource += INJECT_SHADER_DECLARATIONS;

  assembledSource += getHookFunctions(hookFunctions[type], hookInjections);

  // Add the version directive and actual source of this shader
  assembledSource += coreSource;

  // Apply any requested shader injections
  assembledSource = Object(_inject_shader__WEBPACK_IMPORTED_MODULE_3__["default"])(assembledSource, type, mainInjections, injectStandardStubs);

  return assembledSource;
}

// Returns a combined `getUniforms` covering the options for all the modules,
// the created function will pass on options to the inidividual `getUniforms`
// function of each shader module and combine the results into one object that
// can be passed to setUniforms.
function assembleGetUniforms(modules) {
  return function getUniforms(opts) {
    const uniforms = {};
    for (const module of modules) {
      // `modules` is already sorted by dependency level. This guarantees that
      // modules have access to the uniforms that are generated by their dependencies.
      const moduleUniforms = module.getUniforms(opts, uniforms);
      Object.assign(uniforms, moduleUniforms);
    }
    return uniforms;
  };
}

// Returns a map with module names as keys, resolving to their module definitions
// The presence of a key indicates that the module is available in this program,
// whether directly included, or through a dependency of some other module
function assembleModuleMap(modules) {
  const result = {};
  for (const moduleName of modules) {
    const shaderModule = Object(_resolve_modules__WEBPACK_IMPORTED_MODULE_1__["getShaderModule"])(moduleName);
    result[moduleName] = shaderModule;
  }
  return result;
}

function getShaderType({type}) {
  return `
#define SHADER_TYPE_${SHADER_TYPE[type].toUpperCase()}
`;
}

// Generate "glslify-compatible" SHADER_NAME defines
// These are understood by the GLSL error parsing function
// If id is provided and no SHADER_NAME constant is present in source, create one
function getShaderName({id, source, type}) {
  const injectShaderName = id && typeof id === 'string' && source.indexOf('SHADER_NAME') === -1;
  return injectShaderName
    ? `
#define SHADER_NAME ${id}_${SHADER_TYPE[type]}

`
    : '';
}

// Generates application defines from an object
function getApplicationDefines(defines = {}) {
  let count = 0;
  let sourceText = '';
  for (const define in defines) {
    if (count === 0) {
      sourceText += '\n// APPLICATION DEFINES\n';
    }
    count++;

    const value = defines[define];
    if (value || Number.isFinite(value)) {
      sourceText += `#define ${define.toUpperCase()} ${defines[define]}\n`;
    }
  }
  if (count === 0) {
    sourceText += '\n';
  }
  return sourceText;
}

function getHookFunctions(hookFunctions, hookInjections) {
  let result = '';
  for (const hookName in hookFunctions) {
    const hookFunction = hookFunctions[hookName];
    result += `void ${hookFunction.signature} {\n`;
    if (hookFunction.header) {
      result += `  ${hookFunction.header}`;
    }
    if (hookInjections[hookName]) {
      const injections = hookInjections[hookName];
      injections.sort((a, b) => a.order - b.order);
      for (const injection of injections) {
        result += `  ${injection.injection}\n`;
      }
    }
    if (hookFunction.footer) {
      result += `  ${hookFunction.footer}`;
    }
    result += '}\n';
  }

  return result;
}


/***/ }),

/***/ "../shadertools/src/lib/constants.js":
/*!*******************************************!*\
  !*** ../shadertools/src/lib/constants.js ***!
  \*******************************************/
/*! exports provided: VERTEX_SHADER, FRAGMENT_SHADER */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VERTEX_SHADER", function() { return VERTEX_SHADER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAGMENT_SHADER", function() { return FRAGMENT_SHADER; });
const VERTEX_SHADER = 'vs';
const FRAGMENT_SHADER = 'fs';


/***/ }),

/***/ "../shadertools/src/lib/filters/prop-types.js":
/*!****************************************************!*\
  !*** ../shadertools/src/lib/filters/prop-types.js ***!
  \****************************************************/
/*! exports provided: parsePropTypes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePropTypes", function() { return parsePropTypes; });
const TYPE_DEFINITIONS = {
  number: {
    validate(value, propType) {
      return (
        Number.isFinite(value) &&
        (!('max' in propType) || value <= propType.max) &&
        (!('min' in propType) || value >= propType.min)
      );
    }
  },
  array: {
    validate(value, propType) {
      return Array.isArray(value) || ArrayBuffer.isView(value);
    }
  }
};

function parsePropTypes(propDefs) {
  const propTypes = {};
  for (const propName in propDefs) {
    const propDef = propDefs[propName];
    const propType = parsePropType(propDef);
    propTypes[propName] = propType;
  }
  return propTypes;
}

// Parses one property definition entry. Either contains:
// * a valid prop type object ({type, ...})
// * or just a default value, in which case type and name inference is used
function parsePropType(propDef) {
  let type = getTypeOf(propDef);
  if (type === 'object') {
    if (!propDef) {
      return {type: 'object', value: null};
    }
    if ('type' in propDef) {
      return Object.assign({}, propDef, TYPE_DEFINITIONS[propDef.type]);
    }
    if (!('value' in propDef)) {
      // If no type and value this object is likely the value
      return {type: 'object', value: propDef};
    }
    type = getTypeOf(propDef.value);
    return Object.assign({type}, propDef, TYPE_DEFINITIONS[type]);
  }
  return Object.assign({type, value: propDef}, TYPE_DEFINITIONS[type]);
}

// improved version of javascript typeof that can distinguish arrays and null values
function getTypeOf(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return 'array';
  }
  return typeof value;
}


/***/ }),

/***/ "../shadertools/src/lib/inject-shader.js":
/*!***********************************************!*\
  !*** ../shadertools/src/lib/inject-shader.js ***!
  \***********************************************/
/*! exports provided: DECLARATION_INJECT_MARKER, default, combineInjects */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DECLARATION_INJECT_MARKER", function() { return DECLARATION_INJECT_MARKER; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return injectShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "combineInjects", function() { return combineInjects; });
/* harmony import */ var _modules_module_injectors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/module-injectors */ "../shadertools/src/modules/module-injectors.js");
/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./constants */ "../shadertools/src/lib/constants.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "../shadertools/src/utils/index.js");




// TODO - experimental
const MODULE_INJECTORS = {
  [_constants__WEBPACK_IMPORTED_MODULE_1__["VERTEX_SHADER"]]: _modules_module_injectors__WEBPACK_IMPORTED_MODULE_0__["MODULE_INJECTORS_VS"],
  [_constants__WEBPACK_IMPORTED_MODULE_1__["FRAGMENT_SHADER"]]: _modules_module_injectors__WEBPACK_IMPORTED_MODULE_0__["MODULE_INJECTORS_FS"]
};

const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__'; // Uniform/attribute declarations

const REGEX_START_OF_MAIN = /void main\s*\([^)]*\)\s*\{\n?/; // Beginning of main
const REGEX_END_OF_MAIN = /}\n?[^{}]*$/; // End of main, assumes main is last function
const fragments = [];

// A minimal shader injection/templating system.
// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md
/* eslint-disable complexity */
function injectShader(source, type, inject, injectStandardStubs) {
  const isVertex = type === _constants__WEBPACK_IMPORTED_MODULE_1__["VERTEX_SHADER"];

  for (const key in inject) {
    const fragmentData = inject[key];
    fragmentData.sort((a, b) => a.order - b.order);
    fragments.length = fragmentData.length;
    for (let i = 0, len = fragmentData.length; i < len; ++i) {
      fragments[i] = fragmentData[i].injection;
    }
    const fragmentString = `${fragments.join('\n')}\n`;
    switch (key) {
      // declarations are injected before the main function
      case 'vs:#decl':
        if (isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      // main code is injected at the end of main function
      case 'vs:#main-start':
        if (isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);
        }
        break;
      case 'vs:#main-end':
        if (isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);
        }
        break;
      case 'fs:#decl':
        if (!isVertex) {
          source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);
        }
        break;
      case 'fs:#main-start':
        if (!isVertex) {
          source = source.replace(REGEX_START_OF_MAIN, match => match + fragmentString);
        }
        break;
      case 'fs:#main-end':
        if (!isVertex) {
          source = source.replace(REGEX_END_OF_MAIN, match => fragmentString + match);
        }
        break;

      default:
        // TODO(Tarek): I think this usage should be deprecated.

        // inject code after key, leaving key in place
        source = source.replace(key, match => match + fragmentString);
    }
  }

  // Remove if it hasn't already been replaced
  source = source.replace(DECLARATION_INJECT_MARKER, '');

  // Finally, if requested, insert an automatic module injector chunk
  if (injectStandardStubs) {
    source = source.replace(/\}\s*$/, match => match + MODULE_INJECTORS[type]);
  }

  return source;
}

/* eslint-enable complexity */

// Takes an array of inject objects and combines them into one
function combineInjects(injects) {
  const result = {};
  Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(Array.isArray(injects) && injects.length > 1);
  injects.forEach(inject => {
    for (const key in inject) {
      result[key] = result[key] ? `${result[key]}\n${inject[key]}` : inject[key];
    }
  });
  return result;
}


/***/ }),

/***/ "../shadertools/src/lib/platform-defines.js":
/*!**************************************************!*\
  !*** ../shadertools/src/lib/platform-defines.js ***!
  \**************************************************/
/*! exports provided: getPlatformShaderDefines, getVersionDefines */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPlatformShaderDefines", function() { return getPlatformShaderDefines; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVersionDefines", function() { return getVersionDefines; });
/* harmony import */ var _utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/webgl-info */ "../shadertools/src/utils/webgl-info.js");


function getPlatformShaderDefines(gl) {
  const debugInfo = Object(_utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["getContextInfo"])(gl);

  switch (debugInfo.gpuVendor.toLowerCase()) {
    case 'nvidia':
      return `\
#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;

    case 'intel':
      return `\
#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;

    case 'amd':
      // AMD Does not eliminate fp64 code
      return `\
#define AMD_GPU
`;

    default:
      // We don't know what GPU it is, could be that the GPU driver or
      // browser is not implementing UNMASKED_RENDERER constant and not
      // reporting a correct name
      return `\
#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
  }
}

function getVersionDefines(gl, glslVersion, isFragment) {
  // Add shadertools defines to let shaders portably v1/v3 check for features
  let versionDefines = `\
#if (__VERSION__ > 120)

# define FRAG_DEPTH
# define DERIVATIVES
# define DRAW_BUFFERS
# define TEXTURE_LOD

#endif // __VERSION
`;

  if (Object(_utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["hasFeatures"])(gl, _utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].GLSL_FRAG_DEPTH)) {
    versionDefines += `\
// FRAG_DEPTH => gl_FragDepth is available
#ifdef GL_EXT_frag_depth
#extension GL_EXT_frag_depth : enable
# define FRAG_DEPTH
# define gl_FragDepth gl_FragDepthEXT
#endif
`;
  }
  if (
    Object(_utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["hasFeatures"])(gl, _utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].GLSL_DERIVATIVES) &&
    Object(_utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["canCompileGLGSExtension"])(gl, _utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].GLSL_DERIVATIVES)
  ) {
    versionDefines += `\
// DERIVATIVES => dxdF, dxdY and fwidth are available
#ifdef GL_OES_standard_derivatives
#extension GL_OES_standard_derivatives : enable
# define DERIVATIVES
#endif
`;
  }
  if (
    Object(_utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["hasFeatures"])(gl, _utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].GLSL_FRAG_DATA) &&
    Object(_utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["canCompileGLGSExtension"])(gl, _utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].GLSL_FRAG_DATA, {behavior: 'require'})
  ) {
    versionDefines += `\
// DRAW_BUFFERS => gl_FragData[] is available
#ifdef GL_EXT_draw_buffers
#extension GL_EXT_draw_buffers : require
#define DRAW_BUFFERS
#endif
`;
  }
  if (Object(_utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["hasFeatures"])(gl, _utils_webgl_info__WEBPACK_IMPORTED_MODULE_0__["FEATURES"].GLSL_TEXTURE_LOD)) {
    versionDefines += `\
// TEXTURE_LOD => texture2DLod etc are available
#ifdef GL_EXT_shader_texture_lod
#extension GL_EXT_shader_texture_lod : enable
# define TEXTURE_LOD
#define texture2DLod texture2DLodEXT
#define texture2DProjLod texture2DProjLodEXT
#define texture2DProjLod texture2DProjLodEXT
#define textureCubeLod textureCubeLodEXT
#define texture2DGrad texture2DGradEXT
#define texture2DProjGrad texture2DProjGradEXT
#define texture2DProjGrad texture2DProjGradEXT
#define textureCubeGrad textureCubeGradEXT
#endif
`;
  }
  return versionDefines;
}


/***/ }),

/***/ "../shadertools/src/lib/resolve-modules.js":
/*!*************************************************!*\
  !*** ../shadertools/src/lib/resolve-modules.js ***!
  \*************************************************/
/*! exports provided: setDefaultShaderModules, getDefaultShaderModules, registerShaderModules, resolveModules, getShaderModule, TEST_EXPORTS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDefaultShaderModules", function() { return setDefaultShaderModules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultShaderModules", function() { return getDefaultShaderModules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "registerShaderModules", function() { return registerShaderModules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveModules", function() { return resolveModules; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getShaderModule", function() { return getShaderModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEST_EXPORTS", function() { return TEST_EXPORTS; });
/* harmony import */ var _shader_module_registry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader-module-registry */ "../shadertools/src/lib/shader-module-registry.js");


const shaderModuleRegistry = new _shader_module_registry__WEBPACK_IMPORTED_MODULE_0__["default"]();

/**
 * Registers an array of default shader modules. These will be concatenated
 * automatically at the end of any shader module list passed to
 * `assembleShaders` (plus `resolveModules` and `getShaderDependencies`)
 * @param {Object[]} modules - Array of shader modules
 */
function setDefaultShaderModules(modules) {
  shaderModuleRegistry.setDefaultShaderModules(modules);
}

function getDefaultShaderModules() {
  return shaderModuleRegistry.getDefaultShaderModules();
}

/**
 * Registers an array of shader modules
 * @param {Object[]} shaderModuleList - Array of shader modules
 */
function registerShaderModules(
  shaderModuleList,
  {ignoreMultipleRegistrations = false} = {}
) {
  shaderModuleRegistry.registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations});
}

// registers any supplied modules and returns a list of module names
function resolveModules(modules) {
  modules = modules.concat(shaderModuleRegistry.defaultShaderModules);
  modules = shaderModuleRegistry.resolveModules(modules);
  return getShaderDependencies(modules);
}

// Looks up a moduleName among registered modules and returns definition.
// If "inline" module, returns it directly
function getShaderModule(moduleOrName) {
  return shaderModuleRegistry.getShaderModule(moduleOrName);
}

/**
 * Takes a list of shader module names and returns a new list of
 * shader module names that includes all dependencies, sorted so
 * that modules that are dependencies of other modules come first.
 *
 * If the shader glsl code from the returned modules is concatenated
 * in the reverse order, it is guaranteed that all functions be resolved and
 * that all function and variable definitions come before use.
 *
 * @param {String[]} modules - Array of modules (inline modules or module names)
 * @return {String[]} - Array of modules
 */
function getShaderDependencies(modules) {
  const moduleMap = {};
  const moduleDepth = {};
  getDependencyGraph({modules, level: 0, moduleMap, moduleDepth});

  // Return a reverse sort so that dependencies come before the modules that use them
  return Object.keys(moduleDepth)
    .sort((a, b) => moduleDepth[b] - moduleDepth[a])
    .map(name => moduleMap[name]);
}

/**
 * Recursively checks module dpendencies to calculate dependency
 * level of each module.
 *
 * @param {String[]} modules - Array of modules
 * @param {Number} level - Current level
 * @return {result} - Map of module name to its level
 */
// Adds another level of dependencies to the result map
function getDependencyGraph({modules, level, moduleMap, moduleDepth}) {
  if (level >= 5) {
    throw new Error('Possible loop in shader dependency graph');
  }

  // Update level on all current modules
  for (const module of modules) {
    moduleMap[module.name] = module;
    if (moduleDepth[module.name] === undefined || moduleDepth[module.name] < level) {
      moduleDepth[module.name] = level;
    }
  }

  // Recurse
  for (const module of modules) {
    if (module.dependencies) {
      getDependencyGraph({modules: module.dependencies, level: level + 1, moduleMap, moduleDepth});
    }
  }
}

const TEST_EXPORTS = {
  getShaderDependencies,
  getDependencyGraph
};


/***/ }),

/***/ "../shadertools/src/lib/shader-module-registry.js":
/*!********************************************************!*\
  !*** ../shadertools/src/lib/shader-module-registry.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShaderModuleRegistry; });
/* harmony import */ var _shader_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./shader-module */ "../shadertools/src/lib/shader-module.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "../shadertools/src/utils/index.js");



class ShaderModuleRegistry {
  constructor() {
    this.shaderModules = {};
    this.defaultShaderModules = [];
  }

  setDefaultShaderModules(modules) {
    this.defaultShaderModules = this.resolveModules(modules);
  }

  getDefaultShaderModules() {
    return this.defaultShaderModules;
  }

  registerShaderModules(shaderModuleList, {ignoreMultipleRegistrations = false} = {}) {
    for (const shaderModule of shaderModuleList) {
      this._registerShaderModule(shaderModule, ignoreMultipleRegistrations);
    }
  }

  getShaderModule(moduleOrName) {
    // Check if "inline" module, return it
    if (moduleOrName instanceof _shader_module__WEBPACK_IMPORTED_MODULE_0__["default"]) {
      return moduleOrName;
    }

    // Check if module descriptor
    if (typeof moduleOrName !== 'string') {
      return this._registerShaderModule(moduleOrName, true);
    }

    // Module name - Look up module
    const module = this.shaderModules[moduleOrName];
    if (!module) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(false, `Unknown shader module ${moduleOrName}`);
    }
    return module;
  }

  // registers any supplied modules, resolves any names into modules
  // returns a list of modules
  resolveModules(modules) {
    return modules.map(moduleOrName => this.getShaderModule(moduleOrName));
  }

  // PRIVATE API

  _registerShaderModule(module, ignoreMultipleRegistrations = false) {
    // Check if "inline" module, return it
    if (module instanceof _shader_module__WEBPACK_IMPORTED_MODULE_0__["default"]) {
      return module;
    }

    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(module.name, 'shader module has no name');

    if (!this.shaderModules[module.name] || ignoreMultipleRegistrations) {
      // if ignoreMultipleRegistrations = true, we allow module to be re-registered
      module = new _shader_module__WEBPACK_IMPORTED_MODULE_0__["default"](module);
      module.dependencies = this.resolveModules(module.dependencies);
      this.shaderModules[module.name] = module;
    } else {
      // TODO - instead verify that definition is not changing...
      throw new Error(`shader module ${module.name} already registered`);
    }

    return this.shaderModules[module.name];
  }
}


/***/ }),

/***/ "../shadertools/src/lib/shader-module.js":
/*!***********************************************!*\
  !*** ../shadertools/src/lib/shader-module.js ***!
  \***********************************************/
/*! exports provided: default, normalizeShaderModule */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShaderModule; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalizeShaderModule", function() { return normalizeShaderModule; });
/* harmony import */ var _transpile_shader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transpile-shader */ "../shadertools/src/lib/transpile-shader.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "../shadertools/src/utils/index.js");
/* harmony import */ var _filters_prop_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./filters/prop-types */ "../shadertools/src/lib/filters/prop-types.js");




const VERTEX_SHADER = 'vs';
const FRAGMENT_SHADER = 'fs';

class ShaderModule {
  constructor({
    name,
    vs,
    fs,
    dependencies = [],
    uniforms,
    getUniforms,
    deprecations = [],
    defines = {},
    // DEPRECATED
    vertexShader,
    fragmentShader
  }) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(typeof name === 'string');
    this.name = name;
    this.vs = vs || vertexShader;
    this.fs = fs || fragmentShader;
    this.getModuleUniforms = getUniforms;
    this.dependencies = dependencies;
    this.deprecations = this._parseDeprecationDefinitions(deprecations);
    this.defines = defines;

    if (uniforms) {
      this.uniforms = Object(_filters_prop_types__WEBPACK_IMPORTED_MODULE_2__["parsePropTypes"])(uniforms);
    }
  }

  // Extracts the source code chunk for the specified shader type from the named shader module
  getModuleSource(type, targetGLSLVersion) {
    let moduleSource;
    switch (type) {
      case VERTEX_SHADER:
        moduleSource = Object(_transpile_shader__WEBPACK_IMPORTED_MODULE_0__["default"])(this.vs || '', targetGLSLVersion, true);
        break;
      case FRAGMENT_SHADER:
        moduleSource = Object(_transpile_shader__WEBPACK_IMPORTED_MODULE_0__["default"])(this.fs || '', targetGLSLVersion, false);
        break;
      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(false);
    }

    return `\
#define MODULE_${this.name.toUpperCase()}
${moduleSource}\
// END MODULE_${this.name}

`;
  }

  getUniforms(opts, uniforms) {
    if (this.getModuleUniforms) {
      return this.getModuleUniforms(opts, uniforms);
    }
    // Build uniforms from the uniforms array
    if (this.uniforms) {
      return this._defaultGetUniforms(opts);
    }
    return {};
  }

  getDefines() {
    return this.defines;
  }

  // Warn about deprecated uniforms or functions
  checkDeprecations(shaderSource, log) {
    this.deprecations.forEach(def => {
      if (def.regex.test(shaderSource)) {
        if (def.deprecated) {
          log.deprecated(def.old, def.new)();
        } else {
          log.removed(def.old, def.new)();
        }
      }
    });
  }

  _parseDeprecationDefinitions(deprecations) {
    deprecations.forEach(def => {
      switch (def.type) {
        case 'function':
          def.regex = new RegExp(`\\b${def.old}\\(`);
          break;
        default:
          def.regex = new RegExp(`${def.type} ${def.old};`);
      }
    });

    return deprecations;
  }

  _defaultGetUniforms(opts = {}) {
    const uniforms = {};
    const propTypes = this.uniforms;

    for (const key in propTypes) {
      const propDef = propTypes[key];
      if (key in opts && !propDef.private) {
        if (propDef.validate) {
          Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(propDef.validate(opts[key], propDef), `${this.name}: invalid ${key}`);
        }
        uniforms[key] = opts[key];
      } else {
        uniforms[key] = propDef.value;
      }
    }

    return uniforms;
  }
}

// This utility mutates the original module
// Keeping for backward compatibility
// TODO - remove in v8
function normalizeShaderModule(module) {
  if (!module.normalized) {
    module.normalized = true;
    if (module.uniforms && !module.getUniforms) {
      const shaderModule = new ShaderModule(module);
      module.getUniforms = shaderModule.getUniforms.bind(shaderModule);
    }
  }
  return module;
}


/***/ }),

/***/ "../shadertools/src/lib/transpile-shader.js":
/*!**************************************************!*\
  !*** ../shadertools/src/lib/transpile-shader.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return transpileShader; });
// Transpiles shader source code to target GLSL version
// Note: We always run transpiler even if same version e.g. 3.00 => 3.00
// RFC: https://github.com/uber/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md
function transpileShader(source, targetGLSLVersion, isVertex) {
  switch (targetGLSLVersion) {
    case 300:
      return isVertex ? convertVertexShaderTo300(source) : convertFragmentShaderTo300(source);
    case 100:
      return isVertex ? convertVertexShaderTo100(source) : convertFragmentShaderTo100(source);
    default:
      throw new Error(`unknown GLSL version ${targetGLSLVersion}`);
  }
}

function convertVertexShaderTo300(source) {
  return source
    .replace(/attribute\s+/g, 'in ')
    .replace(/varying\s+/g, 'out ')
    .replace(/texture2D\(/g, 'texture(')
    .replace(/textureCube\(+/g, 'texture(')
    .replace(/texture2DLodEXT\(/g, 'textureLod(')
    .replace(/textureCubeLodEXT\(/g, 'textureLod(');
}

function convertFragmentShaderTo300(source) {
  return source
    .replace(/varying\s+/g, 'in ')
    .replace(/texture2D\(/g, 'texture(')
    .replace(/textureCube\(/g, 'texture(')
    .replace(/texture2DLodEXT\(/g, 'textureLod(')
    .replace(/textureCubeLodEXT\(/g, 'textureLod(');

  // Deal with fragColor
  // .replace(/gl_fragColor/g, 'fragColor ');
}

function convertVertexShaderTo100(source) {
  // /gm - treats each line as a string, so that ^ matches after newlines
  return source
    .replace(/^in\s+/gm, 'attribute ')
    .replace(/^out\s+/gm, 'varying ')
    .replace(/texture\(/g, 'texture2D(');
}

function convertFragmentShaderTo100(source) {
  // /gm - treats each line as a string, so that ^ matches after newlines
  return source.replace(/^in\s+/gm, 'varying ').replace(/texture\(/g, 'texture2D(');

  // Deal with fragColor
  // .replace(/^out\s+/g, 'varying ')
}


/***/ }),

/***/ "../shadertools/src/modules/diffuse/diffuse.js":
/*!*****************************************************!*\
  !*** ../shadertools/src/modules/diffuse/diffuse.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Minimal texture (diffuse map) support

/* eslint-disable camelcase */
const DEFAULT_MODULE_OPTIONS = {
  diffuseTexture: null,
  diffuseColor: [0.5, 0.5, 0.5, 1]
};

function getUniforms(opts = DEFAULT_MODULE_OPTIONS) {
  const uniforms = {};
  if (opts.diffuseTexture !== undefined) {
    uniforms.diffuse_uHasTexture = Boolean(opts.diffuseTexture);
    uniforms.diffuse_uTexture = opts.diffuseTexture;
  }
  if (opts.diffuseColor !== undefined) {
    uniforms.diffuse_uColor = opts.diffuseColor;
  }
  return uniforms;
}

const vs = `\
out vec2 diffuse_vTexCoord;

/* Set the UV coordinate from attributes */
void diffuse_setTextureCoordinate(vec2 uv) {
  diffuse_vTexCoord = uv;
}
`;

const fs = `\
uniform vec4 diffuse_uColor;
uniform bool diffuse_uHasTexture;
uniform sampler2D diffuse_uTexture;

in vec2 diffuse_vTexCoord;

// Gets diffuse color of material from uniform
// If we have a standard (diffuse) texture, set color to texture
// return (vec4) - rgba
//
vec4 diffuse_getColor() {
  vec2 texCoord = diffuse_vTexCoord;
  return diffuse_uHasTexture ?
    texture2D(diffuse_uTexture, vec2(texCoord.s, texCoord.t)) :
    diffuse_uColor;
}

vec4 diffuse_filterColor(vec4 color) {
  return diffuse_getColor();
}
`;

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'diffuse',
  getUniforms,
  vs,
  fs
});


/***/ }),

/***/ "../shadertools/src/modules/dirlight/dirlight.js":
/*!*******************************************************!*\
  !*** ../shadertools/src/modules/dirlight/dirlight.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _project_project__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../project/project */ "../shadertools/src/modules/project/project.js");
// Cheap lighting - single directional light, single dot product, one uniform



/* eslint-disable camelcase */
const DEFAULT_LIGHT_DIRECTION = new Float32Array([1, 1, 2]);

const DEFAULT_MODULE_OPTIONS = {
  lightDirection: DEFAULT_LIGHT_DIRECTION
};

function getUniforms(opts = DEFAULT_MODULE_OPTIONS) {
  const uniforms = {};
  if (opts.lightDirection) {
    uniforms.dirlight_uLightDirection = opts.lightDirection;
  }
  return uniforms;
}

// TODO - reuse normal from geometry module
const vs = null;

const fs = `\
uniform vec3 dirlight_uLightDirection;

/*
 * Returns color attenuated by angle from light source
 */
vec4 dirlight_filterColor(vec4 color) {
  vec3 normal = project_getNormal_World();
  float d = abs(dot(normalize(normal), normalize(dirlight_uLightDirection)));
  return vec4(color.rgb * d, color.a);
}
`;

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'dirlight',
  vs,
  fs,
  getUniforms,
  dependencies: [_project_project__WEBPACK_IMPORTED_MODULE_0__["default"]]
});


/***/ }),

/***/ "../shadertools/src/modules/fog/fog.js":
/*!*********************************************!*\
  !*** ../shadertools/src/modules/fog/fog.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* eslint-disable camelcase */
function getUniforms({
  fogEnable = false,
  fogColor = [0.5, 0.5, 0.5],
  fogNear = 1,
  fogFar = 100
} = {}) {
  return {
    fog_uEnable: fogEnable,
    fog_uColor: fogColor,
    fog_uNear: fogNear,
    fog_uFar: fogFar
  };
}

const fs = `\
// fog configuration
uniform bool fog_uEnable;
uniform vec3 fog_uColor;
uniform float fog_uNear;
uniform float fog_uFar;

/*
 * Applies linear fog to a color
 * param - unfogged color
 * return - fogged color
 */
vec4 fog_filterColor(vec4 color) {
  if (fog_uEnable) {
    float depth = gl_FragCoord.z / gl_FragCoord.w;
    float fogFactor = smoothstep(fog_uNear, fog_uFar, depth);
    return mix(color, vec4(fog_uColor, gl_FragColor.w), fogFactor);
  } else {
    return color;
  }
}

// Other fog shaders, exponential etc, see
// http://in2gpu.com/2014/07/22/create-fog-shader/
`;

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'fog',
  getUniforms,
  vs: '',
  fs
});


/***/ }),

/***/ "../shadertools/src/modules/fp32/fp32.js":
/*!***********************************************!*\
  !*** ../shadertools/src/modules/fp32/fp32.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const fp32shader = `\
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND

// All these functions are for substituting tan() function from Intel GPU only
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }

    // 2pi range reduction
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 0.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 0.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`;

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'fp32',
  vs: fp32shader,
  fs: null
});


/***/ }),

/***/ "../shadertools/src/modules/fp64/fp64-arithmetic.glsl.js":
/*!***************************************************************!*\
  !*** ../shadertools/src/modules/fp64/fp64-arithmetic.glsl.js ***!
  \***************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
uniform float ONE;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' from.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * ONE - (t - a);
  float a_lo = a * ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * ONE;
  float err = b - (sum - a) * ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * ONE - a) * ONE;
  float err = (a - (s - v) * ONE) * ONE * ONE * ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * ONE - a) * ONE;
  float err = (a - (s - v) * ONE) * ONE * ONE * ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * ONE + 2.0 * a_fp64.x *
    a_fp64.y * ONE * ONE) + a_fp64.y * a_fp64.y * ONE * ONE * ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`);


/***/ }),

/***/ "../shadertools/src/modules/fp64/fp64-functions.glsl.js":
/*!**************************************************************!*\
  !*** ../shadertools/src/modules/fp64/fp64-functions.glsl.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/* harmony default export */ __webpack_exports__["default"] = (`\
const vec2 E_FP64 = vec2(2.7182817459106445e+00, 8.254840366817007e-08);
const vec2 LOG2_FP64 = vec2(0.6931471824645996e+00, -1.9046542121259336e-09);
const vec2 PI_FP64 = vec2(3.1415927410125732, -8.742278012618954e-8);
const vec2 TWO_PI_FP64 = vec2(6.2831854820251465, -1.7484556025237907e-7);
const vec2 PI_2_FP64 = vec2(1.5707963705062866, -4.371139006309477e-8);
const vec2 PI_4_FP64 = vec2(0.7853981852531433, -2.1855695031547384e-8);
const vec2 PI_16_FP64 = vec2(0.19634954631328583, -5.463923757886846e-9);
const vec2 PI_16_2_FP64 = vec2(0.39269909262657166, -1.0927847515773692e-8);
const vec2 PI_16_3_FP64 = vec2(0.5890486240386963, -1.4906100798128818e-9);
const vec2 PI_180_FP64 = vec2(0.01745329238474369, 1.3519960498364902e-10);

const vec2 SIN_TABLE_0_FP64 = vec2(0.19509032368659973, -1.6704714833615242e-9);
const vec2 SIN_TABLE_1_FP64 = vec2(0.3826834261417389, 6.22335089017767e-9);
const vec2 SIN_TABLE_2_FP64 = vec2(0.5555702447891235, -1.1769521357507529e-8);
const vec2 SIN_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617041793133e-8);

const vec2 COS_TABLE_0_FP64 = vec2(0.9807852506637573, 2.9739473106360492e-8);
const vec2 COS_TABLE_1_FP64 = vec2(0.9238795042037964, 2.8307490351764386e-8);
const vec2 COS_TABLE_2_FP64 = vec2(0.8314695954322815, 1.6870263741530778e-8);
const vec2 COS_TABLE_3_FP64 = vec2(0.7071067690849304, 1.2101617152815436e-8);

const vec2 INVERSE_FACTORIAL_3_FP64 = vec2(1.666666716337204e-01, -4.967053879312289e-09); // 1/3!
const vec2 INVERSE_FACTORIAL_4_FP64 = vec2(4.16666679084301e-02, -1.2417634698280722e-09); // 1/4!
const vec2 INVERSE_FACTORIAL_5_FP64 = vec2(8.333333767950535e-03, -4.34617203337595e-10); // 1/5!
const vec2 INVERSE_FACTORIAL_6_FP64 = vec2(1.3888889225199819e-03, -3.3631094437103215e-11); // 1/6!
const vec2 INVERSE_FACTORIAL_7_FP64 = vec2(1.9841270113829523e-04,  -2.725596874933456e-12); // 1/7!
const vec2 INVERSE_FACTORIAL_8_FP64 = vec2(2.4801587642286904e-05, -3.406996025904184e-13); // 1/8!
const vec2 INVERSE_FACTORIAL_9_FP64 = vec2(2.75573188446287533e-06, 3.7935713937038186e-14); // 1/9!
const vec2 INVERSE_FACTORIAL_10_FP64 = vec2(2.755731998149713e-07, -7.575112367869873e-15); // 1/10!

float nint(float d) {
    if (d == floor(d)) return d;
    return floor(d + 0.5);
}

vec2 nint_fp64(vec2 a) {
    float hi = nint(a.x);
    float lo;
    vec2 tmp;
    if (hi == a.x) {
        lo = nint(a.y);
        tmp = quickTwoSum(hi, lo);
    } else {
        lo = 0.0;
        if (abs(hi - a.x) == 0.5 && a.y < 0.0) {
            hi -= 1.0;
        }
        tmp = vec2(hi, lo);
    }
    return tmp;
}

/* k_power controls how much range reduction we would like to have
Range reduction uses the following method:
assume a = k_power * r + m * log(2), k and m being integers.
Set k_power = 4 (we can choose other k to trade accuracy with performance.
we only need to calculate exp(r) and using exp(a) = 2^m * exp(r)^k_power;
*/

vec2 exp_fp64(vec2 a) {
  // We need to make sure these two numbers match
  // as bit-wise shift is not available in GLSL 1.0
  const int k_power = 4;
  const float k = 16.0;

  const float inv_k = 1.0 / k;

  if (a.x <= -88.0) return vec2(0.0, 0.0);
  if (a.x >= 88.0) return vec2(1.0 / 0.0, 1.0 / 0.0);
  if (a.x == 0.0 && a.y == 0.0) return vec2(1.0, 0.0);
  if (a.x == 1.0 && a.y == 0.0) return E_FP64;

  float m = floor(a.x / LOG2_FP64.x + 0.5);
  vec2 r = sub_fp64(a, mul_fp64(LOG2_FP64, vec2(m, 0.0))) * inv_k;
  vec2 s, t, p;

  p = mul_fp64(r, r);
  s = sum_fp64(r, p * 0.5);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_3_FP64);

  s = sum_fp64(s, t);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_4_FP64);

  s = sum_fp64(s, t);
  p = mul_fp64(p, r);
  t = mul_fp64(p, INVERSE_FACTORIAL_5_FP64);

  // s = sum_fp64(s, t);
  // p = mul_fp64(p, r);
  // t = mul_fp64(p, INVERSE_FACTORIAL_6_FP64);

  // s = sum_fp64(s, t);
  // p = mul_fp64(p, r);
  // t = mul_fp64(p, INVERSE_FACTORIAL_7_FP64);

  s = sum_fp64(s, t);


  // At this point, s = exp(r) - 1; but after following 4 recursions, we will get exp(r) ^ 512 - 1.
  for (int i = 0; i < k_power; i++) {
    s = sum_fp64(s * 2.0, mul_fp64(s, s));
  }

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
  s = sum_fp64(s, vec2(ONE, 0.0));
#else
  s = sum_fp64(s, vec2(1.0, 0.0));
#endif

  return s * pow(2.0, m);
//   return r;
}

vec2 log_fp64(vec2 a)
{
  if (a.x == 1.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x <= 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);
  vec2 x = vec2(log(a.x), 0.0);
  vec2 s;
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
  s = vec2(ONE, 0.0);
#else
  s = vec2(1.0, 0.0);
#endif

  x = sub_fp64(sum_fp64(x, mul_fp64(a, exp_fp64(-x))), s);
  return x;
}

vec2 sin_taylor_fp64(vec2 a) {
  vec2 r, s, t, x;

  if (a.x == 0.0 && a.y == 0.0) {
    return vec2(0.0, 0.0);
  }

  x = -mul_fp64(a, a);
  s = a;
  r = a;

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_3_FP64);
  s = sum_fp64(s, t);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_5_FP64);
  s = sum_fp64(s, t);

  /* keep the following commented code in case we need them
  for extra accuracy from the Taylor expansion*/

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_7_FP64);
  // s = sum_fp64(s, t);

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_9_FP64);
  // s = sum_fp64(s, t);

  return s;
}

vec2 cos_taylor_fp64(vec2 a) {
  vec2 r, s, t, x;

  if (a.x == 0.0 && a.y == 0.0) {
    return vec2(1.0, 0.0);
  }

  x = -mul_fp64(a, a);
  r = x;
  s = sum_fp64(vec2(1.0, 0.0), r * 0.5);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_4_FP64);
  s = sum_fp64(s, t);

  r = mul_fp64(r, x);
  t = mul_fp64(r, INVERSE_FACTORIAL_6_FP64);
  s = sum_fp64(s, t);

  /* keep the following commented code in case we need them
  for extra accuracy from the Taylor expansion*/

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_8_FP64);
  // s = sum_fp64(s, t);

  // r = mul_fp64(r, x);
  // t = mul_fp64(r, INVERSE_FACTORIAL_10_FP64);
  // s = sum_fp64(s, t);

  return s;
}

void sincos_taylor_fp64(vec2 a, out vec2 sin_t, out vec2 cos_t) {
  if (a.x == 0.0 && a.y == 0.0) {
    sin_t = vec2(0.0, 0.0);
    cos_t = vec2(1.0, 0.0);
  }

  sin_t = sin_taylor_fp64(a);
  cos_t = sqrt_fp64(sub_fp64(vec2(1.0, 0.0), mul_fp64(sin_t, sin_t)));
}

vec2 sin_fp64(vec2 a) {
    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(0.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);

    if (k == 0) {
        if (j == 0) {
            return sin_taylor_fp64(t);
        } else if (j == 1) {
            return cos_taylor_fp64(t);
        } else if (j == -1) {
            return -cos_taylor_fp64(t);
        } else {
            return -sin_taylor_fp64(t);
        }
    }

    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }

    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
    if (abs(float(abs_k) - 1.0) < 0.5) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs(float(abs_k) - 2.0) < 0.5) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs(float(abs_k) - 3.0) < 0.5) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs(float(abs_k) - 4.0) < 0.5) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#else
    if (abs_k == 1) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs_k == 2) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs_k == 3) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs_k == 4) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#endif

    vec2 sin_t, cos_t;
    sincos_taylor_fp64(t, sin_t, cos_t);



    vec2 result = vec2(0.0, 0.0);
    if (j == 0) {
        if (k > 0) {
            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        }
    } else if (j == 1) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    } else if (j == -1) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        } else {
            result = -sum_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        }
    } else {
        if (k > 0) {
            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
        }
    }

    return result;
}

vec2 cos_fp64(vec2 a) {
    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(1.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);

    if (k == 0) {
        if (j == 0) {
            return cos_taylor_fp64(t);
        } else if (j == 1) {
            return -sin_taylor_fp64(t);
        } else if (j == -1) {
            return sin_taylor_fp64(t);
        } else {
            return -cos_taylor_fp64(t);
        }
    }

    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }

    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
    if (abs(float(abs_k) - 1.0) < 0.5) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs(float(abs_k) - 2.0) < 0.5) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs(float(abs_k) - 3.0) < 0.5) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs(float(abs_k) - 4.0) < 0.5) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#else
    if (abs_k == 1) {
        u = COS_TABLE_0_FP64;
        v = SIN_TABLE_0_FP64;
    } else if (abs_k == 2) {
        u = COS_TABLE_1_FP64;
        v = SIN_TABLE_1_FP64;
    } else if (abs_k == 3) {
        u = COS_TABLE_2_FP64;
        v = SIN_TABLE_2_FP64;
    } else if (abs_k == 4) {
        u = COS_TABLE_3_FP64;
        v = SIN_TABLE_3_FP64;
    }
#endif

    vec2 sin_t, cos_t;
    sincos_taylor_fp64(t, sin_t, cos_t);

    vec2 result = vec2(0.0, 0.0);
    if (j == 0) {
        if (k > 0) {
            result = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            result = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    } else if (j == 1) {
        if (k > 0) {
            result = -sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(v, cos_t), mul_fp64(u, sin_t));
        }
    } else if (j == -1) {
        if (k > 0) {
            result = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        } else {
            result = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
        }
    } else {
        if (k > 0) {
            result = sub_fp64(mul_fp64(v, sin_t), mul_fp64(u, cos_t));
        } else {
            result = -sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    }

    return result;
}

vec2 tan_fp64(vec2 a) {
    vec2 sin_a;
    vec2 cos_a;

    if (a.x == 0.0 && a.y == 0.0) {
        return vec2(0.0, 0.0);
    }

    // 2pi range reduction
    vec2 z = nint_fp64(div_fp64(a, TWO_PI_FP64));
    vec2 r = sub_fp64(a, mul_fp64(TWO_PI_FP64, z));

    vec2 t;
    float q = floor(r.x / PI_2_FP64.x + 0.5);
    int j = int(q);


    if (j < -2 || j > 2) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    }

    t = sub_fp64(r, mul_fp64(PI_2_FP64, vec2(q, 0.0)));

    q = floor(t.x / PI_16_FP64.x + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    // We just can't get PI/16 * 3.0 very accurately.
    // so let's just store it
    if (abs_k > 4) {
        return vec2(0.0 / 0.0, 0.0 / 0.0);
    } else {
        t = sub_fp64(t, mul_fp64(PI_16_FP64, vec2(q, 0.0)));
    }


    vec2 u = vec2(0.0, 0.0);
    vec2 v = vec2(0.0, 0.0);

    vec2 sin_t, cos_t;
    vec2 s, c;
    sincos_taylor_fp64(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
#if defined(NVIDIA_FP64_WORKAROUND) || defined(INTEL_FP64_WORKAROUND)
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0_FP64;
            v = SIN_TABLE_0_FP64;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1_FP64;
            v = SIN_TABLE_1_FP64;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2_FP64;
            v = SIN_TABLE_2_FP64;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3_FP64;
            v = SIN_TABLE_3_FP64;
        }
#else
        if (abs_k == 1) {
            u = COS_TABLE_0_FP64;
            v = SIN_TABLE_0_FP64;
        } else if (abs_k == 2) {
            u = COS_TABLE_1_FP64;
            v = SIN_TABLE_1_FP64;
        } else if (abs_k == 3) {
            u = COS_TABLE_2_FP64;
            v = SIN_TABLE_2_FP64;
        } else if (abs_k == 4) {
            u = COS_TABLE_3_FP64;
            v = SIN_TABLE_3_FP64;
        }
#endif
        if (k > 0) {
            s = sum_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
            c = sub_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        } else {
            s = sub_fp64(mul_fp64(u, sin_t), mul_fp64(v, cos_t));
            c = sum_fp64(mul_fp64(u, cos_t), mul_fp64(v, sin_t));
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return div_fp64(sin_a, cos_a);
}

vec2 radians_fp64(vec2 degree) {
  return mul_fp64(degree, PI_180_FP64);
}

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

// Vector functions
// vec2 functions
void vec2_sum_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = sum_fp64(a[0], b[0]);
    out_val[1] = sum_fp64(a[1], b[1]);
}

void vec2_sub_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = sub_fp64(a[0], b[0]);
    out_val[1] = sub_fp64(a[1], b[1]);
}

void vec2_mul_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = mul_fp64(a[0], b[0]);
    out_val[1] = mul_fp64(a[1], b[1]);
}

void vec2_div_fp64(vec2 a[2], vec2 b[2], out vec2 out_val[2]) {
    out_val[0] = div_fp64(a[0], b[0]);
    out_val[1] = div_fp64(a[1], b[1]);
}

void vec2_mix_fp64(vec2 x[2], vec2 y[2], float a, out vec2 out_val[2]) {
  vec2 range[2];
  vec2_sub_fp64(y, x, range);
  vec2 portion[2];
  portion[0] = range[0] * a;
  portion[1] = range[1] * a;
  vec2_sum_fp64(x, portion, out_val);
}

vec2 vec2_length_fp64(vec2 x[2]) {
  return sqrt_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])));
}

void vec2_normalize_fp64(vec2 x[2], out vec2 out_val[2]) {
  vec2 length = vec2_length_fp64(x);
  vec2 length_vec2[2];
  length_vec2[0] = length;
  length_vec2[1] = length;

  vec2_div_fp64(x, length_vec2, out_val);
}

vec2 vec2_distance_fp64(vec2 x[2], vec2 y[2]) {
  vec2 diff[2];
  vec2_sub_fp64(x, y, diff);
  return vec2_length_fp64(diff);
}

vec2 vec2_dot_fp64(vec2 a[2], vec2 b[2]) {
  vec2 v[2];

  v[0] = mul_fp64(a[0], b[0]);
  v[1] = mul_fp64(a[1], b[1]);

  return sum_fp64(v[0], v[1]);
}

// vec3 functions
void vec3_sub_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
  for (int i = 0; i < 3; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

void vec3_sum_fp64(vec2 a[3], vec2 b[3], out vec2 out_val[3]) {
  for (int i = 0; i < 3; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

vec2 vec3_length_fp64(vec2 x[3]) {
  return sqrt_fp64(sum_fp64(sum_fp64(mul_fp64(x[0], x[0]), mul_fp64(x[1], x[1])),
    mul_fp64(x[2], x[2])));
}

vec2 vec3_distance_fp64(vec2 x[3], vec2 y[3]) {
  vec2 diff[3];
  vec3_sub_fp64(x, y, diff);
  return vec3_length_fp64(diff);
}

// vec4 functions
void vec4_fp64(vec4 a, out vec2 out_val[4]) {
  out_val[0].x = a[0];
  out_val[0].y = 0.0;

  out_val[1].x = a[1];
  out_val[1].y = 0.0;

  out_val[2].x = a[2];
  out_val[2].y = 0.0;

  out_val[3].x = a[3];
  out_val[3].y = 0.0;
}

void vec4_scalar_mul_fp64(vec2 a[4], vec2 b, out vec2 out_val[4]) {
  out_val[0] = mul_fp64(a[0], b);
  out_val[1] = mul_fp64(a[1], b);
  out_val[2] = mul_fp64(a[2], b);
  out_val[3] = mul_fp64(a[3], b);
}

void vec4_sum_fp64(vec2 a[4], vec2 b[4], out vec2 out_val[4]) {
  for (int i = 0; i < 4; i++) {
    out_val[i] = sum_fp64(a[i], b[i]);
  }
}

void vec4_dot_fp64(vec2 a[4], vec2 b[4], out vec2 out_val) {
  vec2 v[4];

  v[0] = mul_fp64(a[0], b[0]);
  v[1] = mul_fp64(a[1], b[1]);
  v[2] = mul_fp64(a[2], b[2]);
  v[3] = mul_fp64(a[3], b[3]);

  out_val = sum_fp64(sum_fp64(v[0], v[1]), sum_fp64(v[2], v[3]));
}

void mat4_vec4_mul_fp64(vec2 b[16], vec2 a[4], out vec2 out_val[4]) {
  vec2 tmp[4];

  for (int i = 0; i < 4; i++)
  {
    for (int j = 0; j < 4; j++)
    {
      tmp[j] = b[j + i * 4];
    }
    vec4_dot_fp64(a, tmp, out_val[i]);
  }
}
`);


/***/ }),

/***/ "../shadertools/src/modules/fp64/fp64-utils.js":
/*!*****************************************************!*\
  !*** ../shadertools/src/modules/fp64/fp64-utils.js ***!
  \*****************************************************/
/*! exports provided: fp64ify, fp64LowPart, fp64ifyMatrix4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fp64ify", function() { return fp64ify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fp64LowPart", function() { return fp64LowPart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fp64ifyMatrix4", function() { return fp64ifyMatrix4; });
/**
 * Calculate WebGL 64 bit float
 * @param a {number} - the input float number
 * @param out {array, optional} - the output array. If not supplied, a new array is created.
 * @param startIndex {integer, optional} - the index in the output array to fill from. Default 0.
 * @returns {array} - the fp64 representation of the input number
 */
function fp64ify(a, out = [], startIndex = 0) {
  const hiPart = Math.fround(a);
  const loPart = a - hiPart;
  out[startIndex] = hiPart;
  out[startIndex + 1] = loPart;
  return out;
}

/**
 * Calculate the low part of a WebGL 64 bit float
 * @param a {number} - the input float number
 * @returns {number} - the lower 32 bit of the number
 */
function fp64LowPart(a) {
  return a - Math.fround(a);
}

/**
 * Calculate WebGL 64 bit matrix (transposed "Float64Array")
 * @param matrix {Matrix4} - the input matrix
 * @returns {array} - the fp64 representation of the input matrix
 */
function fp64ifyMatrix4(matrix) {
  // Transpose the projection matrix to column major for GLSL.
  const matrixFP64 = new Float32Array(32);
  for (let i = 0; i < 4; ++i) {
    for (let j = 0; j < 4; ++j) {
      const index = i * 4 + j;
      fp64ify(matrix[j * 4 + i], matrixFP64, index * 2);
    }
  }
  return matrixFP64;
}


/***/ }),

/***/ "../shadertools/src/modules/fp64/fp64.js":
/*!***********************************************!*\
  !*** ../shadertools/src/modules/fp64/fp64.js ***!
  \***********************************************/
/*! exports provided: fp64ify, fp64LowPart, fp64ifyMatrix4, default, fp64arithmetic, fp64fs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fp64arithmetic", function() { return fp64arithmetic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fp64fs", function() { return fp64fs; });
/* harmony import */ var _fp64_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fp64-utils */ "../shadertools/src/modules/fp64/fp64-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp64ify", function() { return _fp64_utils__WEBPACK_IMPORTED_MODULE_0__["fp64ify"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp64LowPart", function() { return _fp64_utils__WEBPACK_IMPORTED_MODULE_0__["fp64LowPart"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp64ifyMatrix4", function() { return _fp64_utils__WEBPACK_IMPORTED_MODULE_0__["fp64ifyMatrix4"]; });

/* harmony import */ var _fp64_arithmetic_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fp64-arithmetic.glsl */ "../shadertools/src/modules/fp64/fp64-arithmetic.glsl.js");
/* harmony import */ var _fp64_functions_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fp64-functions.glsl */ "../shadertools/src/modules/fp64/fp64-functions.glsl.js");
// Copyright (c) 2015 - 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.






const fp64shader = `${_fp64_arithmetic_glsl__WEBPACK_IMPORTED_MODULE_1__["default"]}\n${_fp64_functions_glsl__WEBPACK_IMPORTED_MODULE_2__["default"]}`;
const CONST_UNIFORMS = {
  // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND
  ONE: 1.0
};


function getUniforms() {
  return Object.assign({}, CONST_UNIFORMS);
}

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'fp64',
  vs: fp64shader,
  fs: null,
  fp64ify: _fp64_utils__WEBPACK_IMPORTED_MODULE_0__["fp64ify"],
  fp64LowPart: _fp64_utils__WEBPACK_IMPORTED_MODULE_0__["fp64LowPart"],
  fp64ifyMatrix4: _fp64_utils__WEBPACK_IMPORTED_MODULE_0__["fp64ifyMatrix4"],
  getUniforms
});

// Arithmetic only
const fp64arithmetic = {
  name: 'fp64-arithmetic',
  vs: `${_fp64_arithmetic_glsl__WEBPACK_IMPORTED_MODULE_1__["default"]}`,
  fs: null
};

// Fragment shader fp64
const fp64fs = {
  name: 'fp64-fs',
  vs: null,
  fs: fp64shader
};


/***/ }),

/***/ "../shadertools/src/modules/index.js":
/*!*******************************************!*\
  !*** ../shadertools/src/modules/index.js ***!
  \*******************************************/
/*! exports provided: fp32, fp64, project, fog, lights, dirlight, picking, diffuse, gouraudlighting, phonglighting, pbr, _transform */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _fp32_fp32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fp32/fp32 */ "../shadertools/src/modules/fp32/fp32.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp32", function() { return _fp32_fp32__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _fp64_fp64__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fp64/fp64 */ "../shadertools/src/modules/fp64/fp64.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp64", function() { return _fp64_fp64__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _project_project__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./project/project */ "../shadertools/src/modules/project/project.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "project", function() { return _project_project__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _fog_fog__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./fog/fog */ "../shadertools/src/modules/fog/fog.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fog", function() { return _fog_fog__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _lights_lights__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lights/lights */ "../shadertools/src/modules/lights/lights.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lights", function() { return _lights_lights__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _dirlight_dirlight__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dirlight/dirlight */ "../shadertools/src/modules/dirlight/dirlight.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dirlight", function() { return _dirlight_dirlight__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _picking_picking__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./picking/picking */ "../shadertools/src/modules/picking/picking.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "picking", function() { return _picking_picking__WEBPACK_IMPORTED_MODULE_6__["default"]; });

/* harmony import */ var _diffuse_diffuse__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./diffuse/diffuse */ "../shadertools/src/modules/diffuse/diffuse.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "diffuse", function() { return _diffuse_diffuse__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _phong_lighting_phong_lighting__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./phong-lighting/phong-lighting */ "../shadertools/src/modules/phong-lighting/phong-lighting.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gouraudlighting", function() { return _phong_lighting_phong_lighting__WEBPACK_IMPORTED_MODULE_8__["gouraudlighting"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "phonglighting", function() { return _phong_lighting_phong_lighting__WEBPACK_IMPORTED_MODULE_8__["phonglighting"]; });

/* harmony import */ var _pbr_pbr__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./pbr/pbr */ "../shadertools/src/modules/pbr/pbr.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pbr", function() { return _pbr_pbr__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _transform_transform__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./transform/transform */ "../shadertools/src/modules/transform/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_transform", function() { return _transform_transform__WEBPACK_IMPORTED_MODULE_10__["default"]; });












// experimental



/***/ }),

/***/ "../shadertools/src/modules/lights/lights.glsl.js":
/*!********************************************************!*\
  !*** ../shadertools/src/modules/lights/lights.glsl.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`\
#if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))

struct AmbientLight {
 vec3 color;
};

struct PointLight {
 vec3 color;
 vec3 position;

 // Constant-Linear-Exponential
 vec3 attenuation;
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform AmbientLight lighting_uAmbientLight;
uniform PointLight lighting_uPointLight[MAX_LIGHTS];
uniform DirectionalLight lighting_uDirectionalLight[MAX_LIGHTS];
uniform int lighting_uPointLightCount;
uniform int lighting_uDirectionalLightCount;

uniform bool lighting_uEnabled;

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

#endif
`);


/***/ }),

/***/ "../shadertools/src/modules/lights/lights.js":
/*!***************************************************!*\
  !*** ../shadertools/src/modules/lights/lights.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _lights_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lights.glsl */ "../shadertools/src/modules/lights/lights.glsl.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'lights',
  vs: _lights_glsl__WEBPACK_IMPORTED_MODULE_0__["default"],
  fs: _lights_glsl__WEBPACK_IMPORTED_MODULE_0__["default"],
  getUniforms,
  defines: {
    MAX_LIGHTS: 3
  }
});

const INITIAL_MODULE_OPTIONS = {};

// Take color 0-255 and intensity as input and output 0.0-1.0 range
function convertColor({color = [0, 0, 0], intensity = 1.0} = {}) {
  return color.map(component => (component * intensity) / 255.0);
}

function getLightSourceUniforms({ambientLight, pointLights = [], directionalLights = []}) {
  const lightSourceUniforms = {};

  if (ambientLight) {
    lightSourceUniforms['lighting_uAmbientLight.color'] = convertColor(ambientLight);
  } else {
    lightSourceUniforms['lighting_uAmbientLight.color'] = [0, 0, 0];
  }

  pointLights.forEach((pointLight, index) => {
    lightSourceUniforms[`lighting_uPointLight[${index}].color`] = convertColor(pointLight);
    lightSourceUniforms[`lighting_uPointLight[${index}].position`] = pointLight.position;
    lightSourceUniforms[`lighting_uPointLight[${index}].attenuation`] = pointLight.attenuation;
  });
  lightSourceUniforms.lighting_uPointLightCount = pointLights.length;

  directionalLights.forEach((directionalLight, index) => {
    lightSourceUniforms[`lighting_uDirectionalLight[${index}].color`] = convertColor(
      directionalLight
    );
    lightSourceUniforms[`lighting_uDirectionalLight[${index}].direction`] =
      directionalLight.direction;
  });
  lightSourceUniforms.lighting_uDirectionalLightCount = directionalLights.length;

  return lightSourceUniforms;
}

// eslint-disable-next-line complexity
function getUniforms(opts = INITIAL_MODULE_OPTIONS) {
  // Specify lights separately
  if ('lightSources' in opts) {
    const {ambientLight, pointLights, directionalLights} = opts.lightSources || {};
    const hasLights =
      ambientLight ||
      (pointLights && pointLights.length > 0) ||
      (directionalLights && directionalLights.length > 0);

    if (!hasLights) {
      return {lighting_uEnabled: false};
    }

    return Object.assign(
      {},
      getLightSourceUniforms({ambientLight, pointLights, directionalLights}),
      {
        lighting_uEnabled: true
      }
    );
  }

  // Support for array of lights. Type of light is detected by type field
  if ('lights' in opts) {
    const lightSources = {pointLights: [], directionalLights: []};
    for (const light of opts.lights || []) {
      switch (light.type) {
        case 'ambient':
          // Note: Only uses last ambient light
          // TODO - add ambient light sources on CPU?
          lightSources.ambientLight = light;
          break;
        case 'directional':
          lightSources.directionalLights.push(light);
          break;
        case 'point':
          lightSources.pointLights.push(light);
          break;
        default:
        // eslint-disable-next-line
        // console.warn(light.type);
      }
    }

    // Call the `opts.lightSources`` version
    return getUniforms({lightSources});
  }

  return {};
}


/***/ }),

/***/ "../shadertools/src/modules/module-injectors.js":
/*!******************************************************!*\
  !*** ../shadertools/src/modules/module-injectors.js ***!
  \******************************************************/
/*! exports provided: MODULE_INJECTORS_VS, MODULE_INJECTORS_FS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MODULE_INJECTORS_VS", function() { return MODULE_INJECTORS_VS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MODULE_INJECTORS_FS", function() { return MODULE_INJECTORS_FS; });
const MODULE_INJECTORS_VS = `\
#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`;

const MODULE_INJECTORS_FS = `\
#ifdef MODULE_MATERIAL
  gl_FragColor = material_filterColor(gl_FragColor);
#endif

#ifdef MODULE_LIGHTING
  gl_FragColor = lighting_filterColor(gl_FragColor);
#endif

#ifdef MODULE_FOG
  gl_FragColor = fog_filterColor(gl_FragColor);
#endif

#ifdef MODULE_PICKING
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`;


/***/ }),

/***/ "../shadertools/src/modules/pbr/pbr-fragment.glsl.js":
/*!***********************************************************!*\
  !*** ../shadertools/src/modules/pbr/pbr-fragment.glsl.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// This fragment shader defines a reference implementation for Physically Based Shading of
// a microfacet surface material defined by a glTF model.
//
// Attribution:
// MIT license, Copyright (c) 2016-2017 Mohamad Moneimne and Contributors

/* harmony default export */ __webpack_exports__["default"] = (`\
#if (__VERSION__ < 300)
#extension GL_EXT_shader_texture_lod: enable
#extension GL_OES_standard_derivatives : enable
#endif

// WebGL 1.0 does not support non-constant in for loops
// This provides an easy way to handle these cases
// and still take advantage of WebGL 2.0
#if (__VERSION__ < 300)
  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL1COND; INCR)
#else
  #define SMART_FOR(INIT, WEBGL1COND, WEBGL2COND, INCR) for (INIT; WEBGL2COND; INCR)
#endif

precision highp float;

#ifdef USE_IBL
uniform samplerCube u_DiffuseEnvSampler;
uniform samplerCube u_SpecularEnvSampler;
uniform sampler2D u_brdfLUT;
uniform vec2 u_ScaleIBLAmbient;
#endif

#ifdef HAS_BASECOLORMAP
uniform sampler2D u_BaseColorSampler;
#endif
#ifdef HAS_NORMALMAP
uniform sampler2D u_NormalSampler;
uniform float u_NormalScale;
#endif
#ifdef HAS_EMISSIVEMAP
uniform sampler2D u_EmissiveSampler;
uniform vec3 u_EmissiveFactor;
#endif
#ifdef HAS_METALROUGHNESSMAP
uniform sampler2D u_MetallicRoughnessSampler;
#endif
#ifdef HAS_OCCLUSIONMAP
uniform sampler2D u_OcclusionSampler;
uniform float u_OcclusionStrength;
#endif

#ifdef ALPHA_CUTOFF
uniform float u_AlphaCutoff;
#endif

uniform vec2 u_MetallicRoughnessValues;
uniform vec4 u_BaseColorFactor;

uniform vec3 u_Camera;

// debugging flags used for shader output of intermediate PBR variables
#ifdef PBR_DEBUG
uniform vec4 u_ScaleDiffBaseMR;
uniform vec4 u_ScaleFGDSpec;
#endif

varying vec3 pbr_vPosition;

varying vec2 pbr_vUV;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
varying mat3 pbr_vTBN;
#else
varying vec3 pbr_vNormal;
#endif
#endif

// Encapsulate the various inputs used by the various functions in the shading equation
// We store values in this struct to simplify the integration of alternative implementations
// of the shading terms, outlined in the Readme.MD Appendix.
struct PBRInfo
{
  float NdotL;                  // cos angle between normal and light direction
  float NdotV;                  // cos angle between normal and view direction
  float NdotH;                  // cos angle between normal and half vector
  float LdotH;                  // cos angle between light direction and half vector
  float VdotH;                  // cos angle between view direction and half vector
  float perceptualRoughness;    // roughness value, as authored by the model creator (input to shader)
  float metalness;              // metallic value at the surface
  vec3 reflectance0;            // full reflectance color (normal incidence angle)
  vec3 reflectance90;           // reflectance color at grazing angle
  float alphaRoughness;         // roughness mapped to a more linear change in the roughness (proposed by [2])
  vec3 diffuseColor;            // color contribution from diffuse lighting
  vec3 specularColor;           // color contribution from specular lighting
  vec3 n;                       // normal at surface point
  vec3 v;                       // vector from surface point to camera
};

const float M_PI = 3.141592653589793;
const float c_MinRoughness = 0.04;

vec4 SRGBtoLINEAR(vec4 srgbIn)
{
#ifdef MANUAL_SRGB
#ifdef SRGB_FAST_APPROXIMATION
  vec3 linOut = pow(srgbIn.xyz,vec3(2.2));
#else //SRGB_FAST_APPROXIMATION
  vec3 bLess = step(vec3(0.04045),srgbIn.xyz);
  vec3 linOut = mix( srgbIn.xyz/vec3(12.92), pow((srgbIn.xyz+vec3(0.055))/vec3(1.055),vec3(2.4)), bLess );
#endif //SRGB_FAST_APPROXIMATION
  return vec4(linOut,srgbIn.w);;
#else //MANUAL_SRGB
  return srgbIn;
#endif //MANUAL_SRGB
}

// Find the normal for this fragment, pulling either from a predefined normal map
// or from the interpolated mesh normal and tangent attributes.
vec3 getNormal()
{
  // Retrieve the tangent space matrix
#ifndef HAS_TANGENTS
  vec3 pos_dx = dFdx(pbr_vPosition);
  vec3 pos_dy = dFdy(pbr_vPosition);
  vec3 tex_dx = dFdx(vec3(pbr_vUV, 0.0));
  vec3 tex_dy = dFdy(vec3(pbr_vUV, 0.0));
  vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);

#ifdef HAS_NORMALS
  vec3 ng = normalize(pbr_vNormal);
#else
  vec3 ng = cross(pos_dx, pos_dy);
#endif

  t = normalize(t - ng * dot(ng, t));
  vec3 b = normalize(cross(ng, t));
  mat3 tbn = mat3(t, b, ng);
#else // HAS_TANGENTS
  mat3 tbn = pbr_vTBN;
#endif

#ifdef HAS_NORMALMAP
  vec3 n = texture2D(u_NormalSampler, pbr_vUV).rgb;
  n = normalize(tbn * ((2.0 * n - 1.0) * vec3(u_NormalScale, u_NormalScale, 1.0)));
#else
  // The tbn matrix is linearly interpolated, so we need to re-normalize
  vec3 n = normalize(tbn[2].xyz);
#endif

  return n;
}

// Calculation of the lighting contribution from an optional Image Based Light source.
// Precomputed Environment Maps are required uniform inputs and are computed as outlined in [1].
// See our README.md on Environment Maps [3] for additional discussion.
#ifdef USE_IBL
vec3 getIBLContribution(PBRInfo pbrInputs, vec3 n, vec3 reflection)
{
  float mipCount = 9.0; // resolution of 512x512
  float lod = (pbrInputs.perceptualRoughness * mipCount);
  // retrieve a scale and bias to F0. See [1], Figure 3
  vec3 brdf = SRGBtoLINEAR(texture2D(u_brdfLUT,
    vec2(pbrInputs.NdotV, 1.0 - pbrInputs.perceptualRoughness))).rgb;
  vec3 diffuseLight = SRGBtoLINEAR(textureCube(u_DiffuseEnvSampler, n)).rgb;

#ifdef USE_TEX_LOD
  vec3 specularLight = SRGBtoLINEAR(textureCubeLodEXT(u_SpecularEnvSampler, reflection, lod)).rgb;
#else
  vec3 specularLight = SRGBtoLINEAR(textureCube(u_SpecularEnvSampler, reflection)).rgb;
#endif

  vec3 diffuse = diffuseLight * pbrInputs.diffuseColor;
  vec3 specular = specularLight * (pbrInputs.specularColor * brdf.x + brdf.y);

  // For presentation, this allows us to disable IBL terms
  diffuse *= u_ScaleIBLAmbient.x;
  specular *= u_ScaleIBLAmbient.y;

  return diffuse + specular;
}
#endif

// Basic Lambertian diffuse
// Implementation from Lambert's Photometria https://archive.org/details/lambertsphotome00lambgoog
// See also [1], Equation 1
vec3 diffuse(PBRInfo pbrInputs)
{
  return pbrInputs.diffuseColor / M_PI;
}

// The following equation models the Fresnel reflectance term of the spec equation (aka F())
// Implementation of fresnel from [4], Equation 15
vec3 specularReflection(PBRInfo pbrInputs)
{
  return pbrInputs.reflectance0 +
    (pbrInputs.reflectance90 - pbrInputs.reflectance0) *
    pow(clamp(1.0 - pbrInputs.VdotH, 0.0, 1.0), 5.0);
}

// This calculates the specular geometric attenuation (aka G()),
// where rougher material will reflect less light back to the viewer.
// This implementation is based on [1] Equation 4, and we adopt their modifications to
// alphaRoughness as input as originally proposed in [2].
float geometricOcclusion(PBRInfo pbrInputs)
{
  float NdotL = pbrInputs.NdotL;
  float NdotV = pbrInputs.NdotV;
  float r = pbrInputs.alphaRoughness;

  float attenuationL = 2.0 * NdotL / (NdotL + sqrt(r * r + (1.0 - r * r) * (NdotL * NdotL)));
  float attenuationV = 2.0 * NdotV / (NdotV + sqrt(r * r + (1.0 - r * r) * (NdotV * NdotV)));
  return attenuationL * attenuationV;
}

// The following equation(s) model the distribution of microfacet normals across
// the area being drawn (aka D())
// Implementation from "Average Irregularity Representation of a Roughened Surface
// for Ray Reflection" by T. S. Trowbridge, and K. P. Reitz
// Follows the distribution function recommended in the SIGGRAPH 2013 course notes
// from EPIC Games [1], Equation 3.
float microfacetDistribution(PBRInfo pbrInputs)
{
  float roughnessSq = pbrInputs.alphaRoughness * pbrInputs.alphaRoughness;
  float f = (pbrInputs.NdotH * roughnessSq - pbrInputs.NdotH) * pbrInputs.NdotH + 1.0;
  return roughnessSq / (M_PI * f * f);
}

void PBRInfo_setAmbientLight(inout PBRInfo pbrInputs) {
  pbrInputs.NdotL = 1.0;
  pbrInputs.NdotH = 0.0;
  pbrInputs.LdotH = 0.0;
  pbrInputs.VdotH = 1.0;
}

void PBRInfo_setDirectionalLight(inout PBRInfo pbrInputs, vec3 lightDirection) {
  vec3 n = pbrInputs.n;
  vec3 v = pbrInputs.v;
  vec3 l = normalize(lightDirection);             // Vector from surface point to light
  vec3 h = normalize(l+v);                        // Half vector between both l and v

  pbrInputs.NdotL = clamp(dot(n, l), 0.001, 1.0);
  pbrInputs.NdotH = clamp(dot(n, h), 0.0, 1.0);
  pbrInputs.LdotH = clamp(dot(l, h), 0.0, 1.0);
  pbrInputs.VdotH = clamp(dot(v, h), 0.0, 1.0);
}

void PBRInfo_setPointLight(inout PBRInfo pbrInputs, PointLight pointLight) {
  vec3 light_direction = normalize(pointLight.position - pbr_vPosition);
  PBRInfo_setDirectionalLight(pbrInputs, light_direction);
}

vec3 calculateFinalColor(PBRInfo pbrInputs, vec3 lightColor) {
  // Calculate the shading terms for the microfacet specular shading model
  vec3 F = specularReflection(pbrInputs);
  float G = geometricOcclusion(pbrInputs);
  float D = microfacetDistribution(pbrInputs);

  // Calculation of analytical lighting contribution
  vec3 diffuseContrib = (1.0 - F) * diffuse(pbrInputs);
  vec3 specContrib = F * G * D / (4.0 * pbrInputs.NdotL * pbrInputs.NdotV);
  // Obtain final intensity as reflectance (BRDF) scaled by the energy of the light (cosine law)
  return pbrInputs.NdotL * lightColor * (diffuseContrib + specContrib);
}

vec4 pbr_filterColor(vec4 colorUnused)
{
  // Metallic and Roughness material properties are packed together
  // In glTF, these factors can be specified by fixed scalar values
  // or from a metallic-roughness map
  float perceptualRoughness = u_MetallicRoughnessValues.y;
  float metallic = u_MetallicRoughnessValues.x;
#ifdef HAS_METALROUGHNESSMAP
  // Roughness is stored in the 'g' channel, metallic is stored in the 'b' channel.
  // This layout intentionally reserves the 'r' channel for (optional) occlusion map data
  vec4 mrSample = texture2D(u_MetallicRoughnessSampler, pbr_vUV);
  perceptualRoughness = mrSample.g * perceptualRoughness;
  metallic = mrSample.b * metallic;
#endif
  perceptualRoughness = clamp(perceptualRoughness, c_MinRoughness, 1.0);
  metallic = clamp(metallic, 0.0, 1.0);
  // Roughness is authored as perceptual roughness; as is convention,
  // convert to material roughness by squaring the perceptual roughness [2].
  float alphaRoughness = perceptualRoughness * perceptualRoughness;

  // The albedo may be defined from a base texture or a flat color
#ifdef HAS_BASECOLORMAP
  vec4 baseColor = SRGBtoLINEAR(texture2D(u_BaseColorSampler, pbr_vUV)) * u_BaseColorFactor;
#else
  vec4 baseColor = u_BaseColorFactor;
#endif

#ifdef ALPHA_CUTOFF
  if (baseColor.a < u_AlphaCutoff) {
    discard;
  }
#endif

  vec3 f0 = vec3(0.04);
  vec3 diffuseColor = baseColor.rgb * (vec3(1.0) - f0);
  diffuseColor *= 1.0 - metallic;
  vec3 specularColor = mix(f0, baseColor.rgb, metallic);

  // Compute reflectance.
  float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);

  // For typical incident reflectance range (between 4% to 100%) set the grazing
  // reflectance to 100% for typical fresnel effect.
  // For very low reflectance range on highly diffuse objects (below 4%),
  // incrementally reduce grazing reflecance to 0%.
  float reflectance90 = clamp(reflectance * 25.0, 0.0, 1.0);
  vec3 specularEnvironmentR0 = specularColor.rgb;
  vec3 specularEnvironmentR90 = vec3(1.0, 1.0, 1.0) * reflectance90;

  vec3 n = getNormal();                          // normal at surface point
  vec3 v = normalize(u_Camera - pbr_vPosition);  // Vector from surface point to camera

  float NdotV = clamp(abs(dot(n, v)), 0.001, 1.0);
  vec3 reflection = -normalize(reflect(v, n));

  PBRInfo pbrInputs = PBRInfo(
    0.0, // NdotL
    NdotV,
    0.0, // NdotH
    0.0, // LdotH
    0.0, // VdotH
    perceptualRoughness,
    metallic,
    specularEnvironmentR0,
    specularEnvironmentR90,
    alphaRoughness,
    diffuseColor,
    specularColor,
    n,
    v
  );

  vec3 color = vec3(0, 0, 0);

#ifdef USE_LIGHTS
  // Apply ambient light
  PBRInfo_setAmbientLight(pbrInputs);
  color += calculateFinalColor(pbrInputs, lighting_uAmbientLight.color);

  // Apply directional light
  SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uDirectionalLightCount, i++) {
    if (i < lighting_uDirectionalLightCount) {
      PBRInfo_setDirectionalLight(pbrInputs, lighting_uDirectionalLight[i].direction);
      color += calculateFinalColor(pbrInputs, lighting_uDirectionalLight[i].color);
    }
  }

  // Apply point light
  SMART_FOR(int i = 0, i < MAX_LIGHTS, i < lighting_uPointLightCount, i++) {
    if (i < lighting_uPointLightCount) {
      PBRInfo_setPointLight(pbrInputs, lighting_uPointLight[i]);
      float attenuation = getPointLightAttenuation(lighting_uPointLight[i], distance(lighting_uPointLight[i].position, pbr_vPosition));
      color += calculateFinalColor(pbrInputs, lighting_uPointLight[i].color / attenuation);
    }
  }
#endif

  // Calculate lighting contribution from image based lighting source (IBL)
#ifdef USE_IBL
  color += getIBLContribution(pbrInputs, n, reflection);
#endif

  // Apply optional PBR terms for additional (optional) shading
#ifdef HAS_OCCLUSIONMAP
  float ao = texture2D(u_OcclusionSampler, pbr_vUV).r;
  color = mix(color, color * ao, u_OcclusionStrength);
#endif

#ifdef HAS_EMISSIVEMAP
  vec3 emissive = SRGBtoLINEAR(texture2D(u_EmissiveSampler, pbr_vUV)).rgb * u_EmissiveFactor;
  color += emissive;
#endif

  // This section uses mix to override final color for reference app visualization
  // of various parameters in the lighting equation.
#ifdef PBR_DEBUG
  // TODO: Figure out how to debug multiple lights

  // color = mix(color, F, u_ScaleFGDSpec.x);
  // color = mix(color, vec3(G), u_ScaleFGDSpec.y);
  // color = mix(color, vec3(D), u_ScaleFGDSpec.z);
  // color = mix(color, specContrib, u_ScaleFGDSpec.w);

  // color = mix(color, diffuseContrib, u_ScaleDiffBaseMR.x);
  color = mix(color, baseColor.rgb, u_ScaleDiffBaseMR.y);
  color = mix(color, vec3(metallic), u_ScaleDiffBaseMR.z);
  color = mix(color, vec3(perceptualRoughness), u_ScaleDiffBaseMR.w);
#endif

  return vec4(pow(color,vec3(1.0/2.2)), baseColor.a);
}
`);


/***/ }),

/***/ "../shadertools/src/modules/pbr/pbr-vertex.glsl.js":
/*!*********************************************************!*\
  !*** ../shadertools/src/modules/pbr/pbr-vertex.glsl.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`\
varying vec3 pbr_vPosition;
varying vec2 pbr_vUV;

#ifdef HAS_NORMALS
# ifdef HAS_TANGENTS
varying mat3 pbr_vTBN;
# else
varying vec3 pbr_vNormal;
# endif
#endif

void pbr_setPositionNormalTangentUV(vec4 position, vec4 normal, vec4 tangent, vec2 uv)
{
  vec4 pos = u_ModelMatrix * position;
  pbr_vPosition = vec3(pos.xyz) / pos.w;

#ifdef HAS_NORMALS
#ifdef HAS_TANGENTS
  vec3 normalW = normalize(vec3(u_NormalMatrix * vec4(normal.xyz, 0.0)));
  vec3 tangentW = normalize(vec3(u_ModelMatrix * vec4(tangent.xyz, 0.0)));
  vec3 bitangentW = cross(normalW, tangentW) * tangent.w;
  pbr_vTBN = mat3(tangentW, bitangentW, normalW);
#else // HAS_TANGENTS != 1
  pbr_vNormal = normalize(vec3(u_ModelMatrix * vec4(normal.xyz, 0.0)));
#endif
#endif

#ifdef HAS_UV
  pbr_vUV = uv;
#else
  pbr_vUV = vec2(0.,0.);
#endif
}
`);


/***/ }),

/***/ "../shadertools/src/modules/pbr/pbr.js":
/*!*********************************************!*\
  !*** ../shadertools/src/modules/pbr/pbr.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _project2_project2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../project2/project2 */ "../shadertools/src/modules/project2/project2.js");
/* harmony import */ var _lights_lights__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lights/lights */ "../shadertools/src/modules/lights/lights.js");
/* harmony import */ var _pbr_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pbr-vertex.glsl */ "../shadertools/src/modules/pbr/pbr-vertex.glsl.js");
/* harmony import */ var _pbr_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pbr-fragment.glsl */ "../shadertools/src/modules/pbr/pbr-fragment.glsl.js");






/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'pbr',
  vs: _pbr_vertex_glsl__WEBPACK_IMPORTED_MODULE_2__["default"],
  fs: _pbr_fragment_glsl__WEBPACK_IMPORTED_MODULE_3__["default"],
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  dependencies: [_project2_project2__WEBPACK_IMPORTED_MODULE_0__["default"], _lights_lights__WEBPACK_IMPORTED_MODULE_1__["default"]]
});


/***/ }),

/***/ "../shadertools/src/modules/phong-lighting/phong-lighting.glsl.js":
/*!************************************************************************!*\
  !*** ../shadertools/src/modules/phong-lighting/phong-lighting.glsl.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`\

uniform float lighting_uAmbient;
uniform float lighting_uDiffuse;
uniform float lighting_uShininess;
uniform vec3  lighting_uSpecularColor;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
    vec3 halfway_direction = normalize(light_direction + view_direction);
    float lambertian = dot(light_direction, normal_worldspace);
    float specular = 0.0;
    if (lambertian > 0.0) {
      float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
      specular = pow(specular_angle, lighting_uShininess);
    }
    lambertian = max(lambertian, 0.0);
    return (lambertian * lighting_uDiffuse * surfaceColor + specular * lighting_uSpecularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting_uEnabled) {
    vec3 view_direction = normalize(cameraPosition - position_worldspace);
    lightColor = lighting_uAmbient * surfaceColor * lighting_uAmbientLight.color;

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uPointLightCount) {
        break;
      }
      PointLight pointLight = lighting_uPointLight[i];
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uDirectionalLightCount) {
        break;
      }
      DirectionalLight directionalLight = lighting_uDirectionalLight[i];
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
  return lightColor;
}

vec3 lighting_getSpecularLightColor(vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = vec3(0, 0, 0);
  vec3 surfaceColor = vec3(0, 0, 0);

  if (lighting_uEnabled) {
    vec3 view_direction = normalize(cameraPosition - position_worldspace);

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uPointLightCount) {
        break;
      }
      PointLight pointLight = lighting_uPointLight[i];
      vec3 light_position_worldspace = pointLight.position;
      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
    }

    for (int i = 0; i < MAX_LIGHTS; i++) {
      if (i >= lighting_uDirectionalLightCount) {
        break;
      }
      DirectionalLight directionalLight = lighting_uDirectionalLight[i];
      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
    }
  }
  return lightColor;
}
`);


/***/ }),

/***/ "../shadertools/src/modules/phong-lighting/phong-lighting.js":
/*!*******************************************************************!*\
  !*** ../shadertools/src/modules/phong-lighting/phong-lighting.js ***!
  \*******************************************************************/
/*! exports provided: gouraudlighting, phonglighting */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gouraudlighting", function() { return gouraudlighting; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "phonglighting", function() { return phonglighting; });
/* harmony import */ var _lights_lights__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lights/lights */ "../shadertools/src/modules/lights/lights.js");
/* harmony import */ var _phong_lighting_glsl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./phong-lighting.glsl */ "../shadertools/src/modules/phong-lighting/phong-lighting.glsl.js");



const gouraudlighting = {
  name: 'gouraud-lighting',
  dependencies: [_lights_lights__WEBPACK_IMPORTED_MODULE_0__["default"]],
  vs: _phong_lighting_glsl__WEBPACK_IMPORTED_MODULE_1__["default"],
  defines: {
    LIGHTING_VERTEX: 1
  },
  getUniforms
};

const phonglighting = {
  name: 'phong-lighting',
  dependencies: [_lights_lights__WEBPACK_IMPORTED_MODULE_0__["default"]],
  fs: _phong_lighting_glsl__WEBPACK_IMPORTED_MODULE_1__["default"],
  defines: {
    LIGHTING_FRAGMENT: 1
  },
  getUniforms
};

const INITIAL_MODULE_OPTIONS = {};

function getMaterialUniforms(material) {
  const materialUniforms = {};
  materialUniforms.lighting_uAmbient = material.ambient;
  materialUniforms.lighting_uDiffuse = material.diffuse;
  materialUniforms.lighting_uShininess = material.shininess;
  materialUniforms.lighting_uSpecularColor = material.specularColor.map(x => x / 255);
  return materialUniforms;
}

function getUniforms(opts = INITIAL_MODULE_OPTIONS) {
  if (!('material' in opts)) {
    return {};
  }

  const {material} = opts;

  if (!material) {
    return {lighting_uEnabled: false};
  }

  return getMaterialUniforms(material);
}




/***/ }),

/***/ "../shadertools/src/modules/picking/picking.js":
/*!*****************************************************!*\
  !*** ../shadertools/src/modules/picking/picking.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const DEFAULT_HIGHLIGHT_COLOR = new Uint8Array([0, 255, 255, 255]);

const DEFAULT_MODULE_OPTIONS = {
  pickingSelectedColor: null, //  Set to a picking color to visually highlight that item
  pickingHighlightColor: DEFAULT_HIGHLIGHT_COLOR, // Color of visual highlight of "selected" item
  pickingThreshold: 1.0,
  pickingActive: false // Set to true when rendering to off-screen "picking" buffer
};

/* eslint-disable camelcase */
function getUniforms(opts = DEFAULT_MODULE_OPTIONS) {
  const uniforms = {};
  if (opts.pickingSelectedColor !== undefined) {
    if (opts.pickingSelectedColor === null) {
      uniforms.picking_uSelectedColorValid = 0;
    } else {
      const selectedColor = [
        opts.pickingSelectedColor[0],
        opts.pickingSelectedColor[1],
        opts.pickingSelectedColor[2]
      ];
      uniforms.picking_uSelectedColorValid = 1;
      uniforms.picking_uSelectedColor = selectedColor;
    }
  }
  if (opts.pickingHighlightColor !== undefined) {
    uniforms.picking_uHighlightColor = opts.pickingHighlightColor;
  }
  // TODO - major hack - decide on normalization and remove
  if (opts.pickingThreshold !== undefined) {
    uniforms.picking_uThreshold = opts.pickingThreshold;
  }
  if (opts.pickingActive !== undefined) {
    uniforms.picking_uActive = opts.pickingActive ? 1 : 0;
  }
  return uniforms;
}

const vs = `\
uniform vec3 picking_uSelectedColor;
uniform float picking_uThreshold;
uniform bool picking_uSelectedColorValid;

out vec4 picking_vRGBcolor_Aselected;

const float COLOR_SCALE = 1. / 255.;

bool isVertexPicked(vec3 vertexColor) {
  return
    picking_uSelectedColorValid &&
    abs(vertexColor.r - picking_uSelectedColor.r) < picking_uThreshold &&
    abs(vertexColor.g - picking_uSelectedColor.g) < picking_uThreshold &&
    abs(vertexColor.b - picking_uSelectedColor.b) < picking_uThreshold;
}

void picking_setPickingColor(vec3 pickingColor) {
  // Do the comparison with selected item color in vertex shader as it should mean fewer compares
  picking_vRGBcolor_Aselected.a =
    float(isVertexPicked(pickingColor));

  // Stores the picking color so that the fragment shader can render it during picking
  picking_vRGBcolor_Aselected.rgb = pickingColor * COLOR_SCALE;
}
`;

const fs = `\
uniform bool picking_uActive; // true during rendering to offscreen picking buffer
uniform vec3 picking_uSelectedColor;
uniform vec4 picking_uHighlightColor;

in vec4 picking_vRGBcolor_Aselected;

const float COLOR_SCALE = 1. / 255.;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  bool selected = bool(picking_vRGBcolor_Aselected.a);

  if (selected) {
    vec4 highLightColor = picking_uHighlightColor * COLOR_SCALE;

    float highLightAlpha = highLightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  vec3 pickingColor = picking_vRGBcolor_Aselected.rgb;
  if (picking_uActive && length(pickingColor) < 0.001) {
    discard;
  }
  return picking_uActive ? vec4(pickingColor, 1.0) : color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highightColor);
}

`;

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'picking',
  vs,
  fs,
  getUniforms
});


/***/ }),

/***/ "../shadertools/src/modules/project/project.js":
/*!*****************************************************!*\
  !*** ../shadertools/src/modules/project/project.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");


const IDENTITY_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];

const DEFAULT_MODULE_OPTIONS = {
  modelMatrix: IDENTITY_MATRIX,
  viewMatrix: IDENTITY_MATRIX,
  projectionMatrix: IDENTITY_MATRIX,
  cameraPositionWorld: [0, 0, 0]
};

function getUniforms(opts = DEFAULT_MODULE_OPTIONS, prevUniforms = {}) {
  // const viewProjectionInverse = viewProjection.invert();
  // viewInverseMatrix: view.invert(),
  // viewProjectionInverseMatrix: viewProjectionInverse

  const uniforms = {};
  if (opts.modelMatrix !== undefined) {
    uniforms.modelMatrix = opts.modelMatrix;
  }
  if (opts.viewMatrix !== undefined) {
    uniforms.viewMatrix = opts.viewMatrix;
  }
  if (opts.projectionMatrix !== undefined) {
    uniforms.projectionMatrix = opts.projectionMatrix;
  }
  if (opts.cameraPositionWorld !== undefined) {
    uniforms.cameraPositionWorld = opts.cameraPositionWorld;
  }

  // COMPOSITE UNIFORMS
  if (opts.projectionMatrix !== undefined || opts.viewMatrix !== undefined) {
    uniforms.viewProjectionMatrix = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"](opts.projectionMatrix).multiplyRight(
      opts.viewMatrix
    );
  }

  return uniforms;
}

const common = `\
varying vec4 project_vPositionWorld;
varying vec3 project_vNormalWorld;

vec4 project_getPosition_World() {
  return project_vPositionWorld;
}

vec3 project_getNormal_World() {
  return project_vNormalWorld;
}
`;

const vs = `\
${common}

// Unprefixed uniforms
uniform mat4 modelMatrix;
uniform mat4 viewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewProjectionMatrix;
uniform vec3 cameraPositionWorld;

struct World {
  vec3 position;
  vec3 normal;
};

World world;

void project_setPosition(vec4 position) {
  project_vPositionWorld = position;
}

void project_setNormal(vec3 normal) {
  project_vNormalWorld = normal;
}

void project_setPositionAndNormal_World(vec3 position, vec3 normal) {
  world.position = position;
  world.normal = normal;
}

void project_setPositionAndNormal_Model(vec3 position, vec3 normal) {
  world.position = (modelMatrix * vec4(position, 1.)).xyz;
  world.normal = mat3(modelMatrix) * normal;
}

vec4 project_model_to_clipspace(vec4 position) {
  return viewProjectionMatrix * modelMatrix * position;
}

vec4 project_model_to_clipspace(vec3 position) {
  return viewProjectionMatrix * modelMatrix * vec4(position, 1.);
}

vec4 project_world_to_clipspace(vec3 position) {
  return viewProjectionMatrix * vec4(position, 1.);
}

vec4 project_view_to_clipspace(vec3 position) {
  return projectionMatrix * vec4(position, 1.);
}

vec4 project_to_clipspace(vec3 position) {
  return viewProjectionMatrix * vec4(position, 1.);
}
`;

const fs = `
${common}\
`;

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'project',
  getUniforms,
  vs,
  fs
});


/***/ }),

/***/ "../shadertools/src/modules/project2/project2.js":
/*!*******************************************************!*\
  !*** ../shadertools/src/modules/project2/project2.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _project2_vertex_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./project2.vertex.glsl */ "../shadertools/src/modules/project2/project2.vertex.glsl.js");


/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'project2',
  vs: _project2_vertex_glsl__WEBPACK_IMPORTED_MODULE_0__["default"],
  fs: _project2_vertex_glsl__WEBPACK_IMPORTED_MODULE_0__["default"]
});


/***/ }),

/***/ "../shadertools/src/modules/project2/project2.vertex.glsl.js":
/*!*******************************************************************!*\
  !*** ../shadertools/src/modules/project2/project2.vertex.glsl.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`\
uniform mat4 u_MVPMatrix;
uniform mat4 u_ModelMatrix;
uniform mat4 u_NormalMatrix;
`);


/***/ }),

/***/ "../shadertools/src/modules/transform/transform.js":
/*!*********************************************************!*\
  !*** ../shadertools/src/modules/transform/transform.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Private shader module used by `Transform`

const vs = `\
attribute float transform_elementID;

// returns half of pixel size, used to move the pixel position to center of the pixel.
vec2 transform_getPixelSizeHalf(vec2 size) {
  return vec2(1.) / (2. * size);
}

// returns current elements pixel indeces [x, y],
// where x ranges in [0 to texSize-1] and y ranges in [0 to texSize-1]
vec2 transform_getPixelIndices(vec2 texSize, vec2 pixelSizeHalf) {
  // Add safe offset (half of pixel height) before doing floor
  float yIndex = floor((transform_elementID / texSize[0]) + pixelSizeHalf[1]);
  float xIndex = transform_elementID - (yIndex * texSize[0]);
  return vec2(xIndex, yIndex);
}

// returns current elementID's texture co-ordianate
vec2 transform_getTexCoord(vec2 size) {
  vec2 pixelSizeHalf = transform_getPixelSizeHalf(size);
  vec2 indices = transform_getPixelIndices(size, pixelSizeHalf);
  vec2 coord = indices / size + pixelSizeHalf;
  return coord;
}

// returns current elementID's position
vec2 transform_getPos(vec2 size) {
  vec2 texCoord = transform_getTexCoord(size);
  // Change from [0 1] range to [-1 1]
  vec2 pos = (texCoord * (2.0, 2.0)) - (1., 1.);
  return pos;
}

// returns current elementID's pixel value
vec4 transform_getInput(sampler2D texSampler, vec2 size) {
  vec2 texCoord = transform_getTexCoord(size);
  vec4 textureColor = texture2D(texSampler, texCoord);
  return textureColor;
}
`;

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'transform',
  vs,
  fs: null
});


/***/ }),

/***/ "../shadertools/src/shaders/modular-fragment.glsl.js":
/*!***********************************************************!*\
  !*** ../shadertools/src/shaders/modular-fragment.glsl.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME luma-modular-fragment

precision highp float;

// varyings
varying vec4 vColor;

void main(){
  gl_FragColor = vec4(1., 0., 1., 1.);

#ifdef MODULE_DIFFUSE
  gl_FragColor = diffuse_filterColor(gl_FragColor);
#endif

#ifdef MODULE_MATERIAL
  gl_FragColor = material_filterColor(gl_FragColor);
#endif

#ifdef MODULE_LIGHTING
  gl_FragColor = lighting_filterColor(gl_FragColor);
#endif

#ifdef MODULE_FOG
  gl_FragColor = fog_filterColor(gl_FragColor);
#endif

#ifdef MODULE_PICKING
  gl_FragColor = picking_filterHighlightColor(gl_FragColor);
  gl_FragColor = picking_filterPickingColor(gl_FragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth(gl_Position);
#endif
}
`);


/***/ }),

/***/ "../shadertools/src/shaders/modular-vertex.glsl.js":
/*!*********************************************************!*\
  !*** ../shadertools/src/shaders/modular-vertex.glsl.js ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = (`\
#define SHADER_NAME luma_modular_vertex

// object attributes
attribute vec3 positions;
attribute vec3 normals;
attribute vec4 colors;
attribute vec2 texCoords;
attribute vec3 pickingColors;

void main(void) {

  // Set up position
#ifdef MODULE_GEOMETRY
  geometry_setPosition(positions);
  geometry_setNormal(normals);
#endif

#ifdef MODULE_PROJECT
  project_setPositionAndNormal_Model(positions, normals);
  gl_Position = project_model_to_clipspace(positions);
#endif

  // Set up depth
#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif

#ifdef MODULE_DIFFUSE
  diffuse_setTextureCoordinate(texCoords);
#endif

  // Set up color calculations
#ifdef MODULE_MATERIAL
  material_setDiffuseColor(colors);
  material_setDiffuseTextureCoordinates(texCoords);
#endif

#ifdef MODULE_LIGHTING
  lighting_setPositionAndNormal(positions, normals);
  lighting_apply_light(positions);
  lighting_apply_reflection(positions);
#endif

#ifdef MODULE_PICKING
  picking_setPickingColor(pickingColors);
#endif

}
`);


/***/ }),

/***/ "../shadertools/src/utils/assert.js":
/*!******************************************!*\
  !*** ../shadertools/src/utils/assert.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Recommendation is to ignore message but current test suite checks agains the
// message so keep it for now.
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'shadertools: assertion failed.');
  }
}


/***/ }),

/***/ "../shadertools/src/utils/index.js":
/*!*****************************************!*\
  !*** ../shadertools/src/utils/index.js ***!
  \*****************************************/
/*! exports provided: assert */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../shadertools/src/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _assert__WEBPACK_IMPORTED_MODULE_0__["default"]; });




/***/ }),

/***/ "../shadertools/src/utils/is-old-ie.js":
/*!*********************************************!*\
  !*** ../shadertools/src/utils/is-old-ie.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isOldIE; });
/* global window */
// opts allows user agent to be overridden for testing
function isOldIE(opts = {}) {
  const navigator = typeof window !== 'undefined' ? window.navigator || {} : {};
  const userAgent = opts.userAgent || navigator.userAgent || '';
  // We only care about older versions of IE (IE 11 and below). Newer versions of IE (Edge)
  // have much better web standards support.
  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}


/***/ }),

/***/ "../shadertools/src/utils/shader-utils.js":
/*!************************************************!*\
  !*** ../shadertools/src/utils/shader-utils.js ***!
  \************************************************/
/*! exports provided: getQualifierDetails, getPassthroughFS, typeToChannelSuffix, typeToChannelCount, convertToVec4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getQualifierDetails", function() { return getQualifierDetails; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPassthroughFS", function() { return getPassthroughFS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typeToChannelSuffix", function() { return typeToChannelSuffix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "typeToChannelCount", function() { return typeToChannelCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "convertToVec4", function() { return convertToVec4; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../shadertools/src/utils/index.js");

const FS100 = `void main() {gl_FragColor = vec4(0);}`;
const FS_GLES = `\
out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`;
const FS300 = `#version 300 es\n${FS_GLES}`;

// Prase given glsl line and return qualifier details or null
function getQualifierDetails(line, qualifiers) {
  qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];
  const words = line.replace(/^\s+/, '').split(/\s+/);
  // TODO add support for precession qualifiers (highp, mediump and lowp)
  const [qualifier, type, definition] = words;
  if (!qualifiers.includes(qualifier) || !type || !definition) {
    return null;
  }
  const name = definition.split(';')[0];
  return {qualifier, type, name};
}

// Given the shader version, input and output variable names,
// builds and return a pass through fragment shader.
function getPassthroughFS({version = 100, input, inputType, output} = {}) {
  if (!input) {
    if (version === 300) {
      // Fast-path for WebGL 2.0
      return FS300;
    } else if (version > 300) {
      // Use the supplied version for OpenGL/ES 3.2+
      return `#version ${version}\n${FS_GLES}`;
    }
    // Fast-path for WebGL 1.0
    return FS100;
  }
  const outputValue = convertToVec4(input, inputType);
  if (version >= 300) {
    // If version is 300, assume WebGL 2.0
    return `\
#version ${version} ${version === 300 ? 'es' : ''}
in ${inputType} ${input};
out vec4 ${output};
void main() {
  ${output} = ${outputValue};
}`;
  }
  // WebGL 1.0
  return `\
varying ${inputType} ${input};
void main() {
  gl_FragColor = ${outputValue};
}`;
}

// convert glsl type to suffix
function typeToChannelSuffix(type) {
  switch (type) {
    case 'float':
      return 'x';
    case 'vec2':
      return 'xy';
    case 'vec3':
      return 'xyz';
    case 'vec4':
      return 'xyzw';
    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
      return null;
  }
}

// convert glsl type to channel count
function typeToChannelCount(type) {
  switch (type) {
    case 'float':
      return 1;
    case 'vec2':
      return 2;
    case 'vec3':
      return 3;
    case 'vec4':
      return 4;
    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
      return null;
  }
}

// Returns glsl instruction for converting to vec4
function convertToVec4(variable, type) {
  switch (type) {
    case 'float':
      return `vec4(${variable}, 0.0, 0.0, 1.0)`;
    case 'vec2':
      return `vec4(${variable}, 0.0, 1.0)`;
    case 'vec3':
      return `vec4(${variable}, 1.0)`;
    case 'vec4':
      return variable;
    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
      return null;
  }
}


/***/ }),

/***/ "../shadertools/src/utils/webgl-info.js":
/*!**********************************************!*\
  !*** ../shadertools/src/utils/webgl-info.js ***!
  \**********************************************/
/*! exports provided: FEATURES, getContextInfo, canCompileGLGSExtension, hasFeatures */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FEATURES", function() { return FEATURES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContextInfo", function() { return getContextInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "canCompileGLGSExtension", function() { return canCompileGLGSExtension; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasFeatures", function() { return hasFeatures; });
/* harmony import */ var _is_old_ie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-old-ie */ "../shadertools/src/utils/is-old-ie.js");
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assert */ "../shadertools/src/utils/assert.js");
// Feature detection for WebGL
//
// Provides a function that enables simple checking of which WebGL features are
// available in an WebGL1 or WebGL2 environment.

/* eslint-disable no-inline-comments, max-len */



const GL_VENDOR = 0x1f00;
const GL_RENDERER = 0x1f01;
const GL_VERSION = 0x1f02;
const GL_SHADING_LANGUAGE_VERSION = 0x8b8c;

// Defines luma.gl "feature" names and semantics
const WEBGL_FEATURES = {
  // GLSL extensions
  GLSL_FRAG_DATA: ['WEBGL_draw_buffers', true], // TODO - name makes no sense in GLSL 3.00
  GLSL_FRAG_DEPTH: ['EXT_frag_depth', true],
  GLSL_DERIVATIVES: ['OES_standard_derivatives', true],
  GLSL_TEXTURE_LOD: ['EXT_shader_texture_lod', true]
};

// Create a key-mirrored FEATURES array
const FEATURES = {};
Object.keys(WEBGL_FEATURES).forEach(key => {
  FEATURES[key] = key;
});



function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

function getContextInfo(gl) {
  const info = gl.getExtension('WEBGL_debug_renderer_info');
  const vendor = gl.getParameter((info && info.UNMASKED_VENDOR_WEBGL) || GL_VENDOR);
  const renderer = gl.getParameter((info && info.UNMASKED_RENDERER_WEBGL) || GL_RENDERER);
  const gpuVendor = identifyGPUVendor(vendor, renderer);
  const gpuInfo = {
    gpuVendor,
    vendor,
    renderer,
    version: gl.getParameter(GL_VERSION),
    shadingLanguageVersion: gl.getParameter(GL_SHADING_LANGUAGE_VERSION)
  };
  return gpuInfo;
}

function identifyGPUVendor(vendor, renderer) {
  if (vendor.match(/NVIDIA/i) || renderer.match(/NVIDIA/i)) {
    return 'NVIDIA';
  }
  if (vendor.match(/INTEL/i) || renderer.match(/INTEL/i)) {
    return 'INTEL';
  }
  if (
    vendor.match(/AMD/i) ||
    renderer.match(/AMD/i) ||
    vendor.match(/ATI/i) ||
    renderer.match(/ATI/i)
  ) {
    return 'AMD';
  }
  return 'UNKNOWN GPU';
}

const compiledGlslExtensions = {};

// Enables feature detection in IE11 due to a bug where gl.getExtension may return true
// but fail to compile when the extension is enabled in the shader. Specifically,
// the OES_standard_derivatives and WEBGL_draw_buffers extensions fails to compile in IE11 even though its included
// in the list of supported extensions.
// opts allows user agent to be overridden for testing
/*
* Inputs :
*  gl : WebGL context
*  cap : Key of WEBGL_FEATURES object identifying the extension
*  opts :
*   behavior : behavor of extension to be tested, by defualt `enable` is used
* Returns : true, if shader is compiled successfully, false otherwise
*/
function canCompileGLGSExtension(gl, cap, opts = {}) {
  const feature = WEBGL_FEATURES[cap];
  Object(_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(feature, cap);

  if (!Object(_is_old_ie__WEBPACK_IMPORTED_MODULE_0__["default"])(opts)) {
    return true;
  }

  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }

  const extensionName = feature[0];
  const behavior = opts.behavior || 'enable';
  const source = `#extension GL_${extensionName} : ${behavior}\nvoid main(void) {}`;

  const shader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const canCompile = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}

// TODO - cache the value
function getFeature(gl, cap) {
  const feature = WEBGL_FEATURES[cap];
  Object(_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(feature, cap);

  // Get extension name from table
  const extensionName = isWebGL2(gl) ? feature[1] || feature[0] : feature[0];

  // Check if the value is dependent on checking an extension
  const value =
    typeof extensionName === 'string' ? Boolean(gl.getExtension(extensionName)) : extensionName;

  Object(_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(value === false || value === true);

  return value;
}

function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every(feature => getFeature(gl, feature));
}


/***/ }),

/***/ "../webgl-state-tracker/src/index.js":
/*!*******************************************!*\
  !*** ../webgl-state-tracker/src/index.js ***!
  \*******************************************/
/*! exports provided: getParameter, getParameters, setParameter, resetParameters, getModifiedParameters, setParameters, default, trackContextState, pushContextState, popContextState, withParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _unified_parameter_api_unified_parameter_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unified-parameter-api/unified-parameter-api */ "../webgl-state-tracker/src/unified-parameter-api/unified-parameter-api.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getParameter", function() { return _unified_parameter_api_unified_parameter_api__WEBPACK_IMPORTED_MODULE_0__["getParameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getParameters", function() { return _unified_parameter_api_unified_parameter_api__WEBPACK_IMPORTED_MODULE_0__["getParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setParameter", function() { return _unified_parameter_api_unified_parameter_api__WEBPACK_IMPORTED_MODULE_0__["setParameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resetParameters", function() { return _unified_parameter_api_unified_parameter_api__WEBPACK_IMPORTED_MODULE_0__["resetParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getModifiedParameters", function() { return _unified_parameter_api_unified_parameter_api__WEBPACK_IMPORTED_MODULE_0__["getModifiedParameters"]; });

/* harmony import */ var _unified_parameter_api_set_parameters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./unified-parameter-api/set-parameters */ "../webgl-state-tracker/src/unified-parameter-api/set-parameters.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setParameters", function() { return _unified_parameter_api_set_parameters__WEBPACK_IMPORTED_MODULE_1__["setParameters"]; });

/* harmony import */ var _state_tracking_track_context_state__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./state-tracking/track-context-state */ "../webgl-state-tracker/src/state-tracking/track-context-state.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _state_tracking_track_context_state__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "trackContextState", function() { return _state_tracking_track_context_state__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pushContextState", function() { return _state_tracking_track_context_state__WEBPACK_IMPORTED_MODULE_2__["pushContextState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "popContextState", function() { return _state_tracking_track_context_state__WEBPACK_IMPORTED_MODULE_2__["popContextState"]; });

/* harmony import */ var _state_tracking_with_parameters__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./state-tracking/with-parameters */ "../webgl-state-tracker/src/state-tracking/with-parameters.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withParameters", function() { return _state_tracking_with_parameters__WEBPACK_IMPORTED_MODULE_3__["withParameters"]; });

// unified parameter APIs




// state tracking





/***/ }),

/***/ "../webgl-state-tracker/src/state-tracking/track-context-state.js":
/*!************************************************************************!*\
  !*** ../webgl-state-tracker/src/state-tracking/track-context-state.js ***!
  \************************************************************************/
/*! exports provided: default, pushContextState, popContextState */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return trackContextState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pushContextState", function() { return pushContextState; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "popContextState", function() { return popContextState; });
/* harmony import */ var _webgl_function_to_parameters_table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-function-to-parameters-table */ "../webgl-state-tracker/src/state-tracking/webgl-function-to-parameters-table.js");
/* harmony import */ var _unified_parameter_api_webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../unified-parameter-api/webgl-parameter-tables */ "../webgl-state-tracker/src/unified-parameter-api/webgl-parameter-tables.js");
/* harmony import */ var _unified_parameter_api_unified_parameter_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../unified-parameter-api/unified-parameter-api */ "../webgl-state-tracker/src/unified-parameter-api/unified-parameter-api.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "../webgl-state-tracker/src/utils/index.js");
// Support for listening to context state changes and intercepting state queries
//
// NOTE: this system does not handle buffer bindings





// HELPER FUNCTIONS - INSTALL GET/SET INTERCEPTORS (SPYS) ON THE CONTEXT

// Overrides a WebGLRenderingContext state "getter" function
// to return values directly from cache
function installGetterOverride(gl, functionName) {
  // Get the original function from the WebGLRenderingContext
  const originalGetterFunc = gl[functionName].bind(gl);

  // Wrap it with a spy so that we can update our state cache when it gets called
  gl[functionName] = function get(...params) {
    const pname = params[0];

    // WebGL limits are not prepopulated in the cache, we must
    // query first time. They are all primitive (single value)
    if (!(pname in gl.state.cache)) {
      gl.state.cache[pname] = originalGetterFunc(...params);
    }

    // Optionally call the original function to do a "hard" query from the WebGLRenderingContext
    return gl.state.enable
      ? // Call the getter the params so that it can e.g. serve from a cache
        gl.state.cache[pname]
      : // Optionally call the original function to do a "hard" query from the WebGLRenderingContext
        originalGetterFunc(...params);
  };

  // Set the name of this anonymous function to help in debugging and profiling
  Object.defineProperty(gl[functionName], 'name', {
    value: `${functionName}-from-cache`,
    configurable: false
  });
}

// Overrides a WebGLRenderingContext state "setter" function
// to call a setter spy before the actual setter. Allows us to keep a cache
// updated with a copy of the WebGL context state.
function installSetterSpy(gl, functionName, setter) {
  // Get the original function from the WebGLRenderingContext
  const originalSetterFunc = gl[functionName].bind(gl);

  // Wrap it with a spy so that we can update our state cache when it gets called
  gl[functionName] = function set(...params) {
    // Update the value
    // Call the setter with the state cache and the params so that it can store the parameters
    const {valueChanged, oldValue} = setter(gl.state._updateCache, ...params);

    // Call the original WebGLRenderingContext func to make sure the context actually gets updated
    if (valueChanged) {
      gl.state.log(`gl.${functionName}`, ...params); // eslint-disable-line
      originalSetterFunc(...params);
    }

    // Note: if the original function fails to set the value, our state cache will be bad
    // No solution for this at the moment, but assuming that this is unlikely to be a real problem
    // We could call the setter after the originalSetterFunc. Concern is that this would
    // cause different behavior in debug mode, where originalSetterFunc can throw exceptions

    return oldValue;
  };

  // Set the name of this anonymous function to help in debugging and profiling
  Object.defineProperty(gl[functionName], 'name', {
    value: `${functionName}-to-cache`,
    configurable: false
  });
}

// HELPER CLASS - GLState

/* eslint-disable no-shadow */
class GLState {
  constructor(
    gl,
    {
      copyState = false, // Copy cache from params (slow) or initialize from WebGL defaults (fast)
      log = () => {} // Logging function, called when gl parameter change calls are actually issued
    } = {}
  ) {
    this.gl = gl;
    this.stateStack = [];
    this.enable = true;
    this.cache = copyState ? Object(_unified_parameter_api_unified_parameter_api__WEBPACK_IMPORTED_MODULE_2__["getParameters"])(gl) : Object.assign({}, _unified_parameter_api_webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_1__["GL_PARAMETER_DEFAULTS"]);
    this.log = log;

    this._updateCache = this._updateCache.bind(this);
    Object.seal(this);
  }

  push(values = {}) {
    this.stateStack.push({});
  }

  pop() {
    Object(_utils__WEBPACK_IMPORTED_MODULE_3__["assert"])(this.stateStack.length > 0);
    // Use the saved values in the state stack to restore parameters
    const oldValues = this.stateStack[this.stateStack.length - 1];
    Object(_unified_parameter_api_unified_parameter_api__WEBPACK_IMPORTED_MODULE_2__["setParameters"])(this.gl, oldValues, this.cache);
    // Don't pop until we have reset parameters (to make sure other "stack frames" are not affected)
    this.stateStack.pop();
  }

  // interceptor for context set functions - update our cache and our stack
  // values (Object) - the key values for this setter
  _updateCache(values) {
    let valueChanged = false;
    let oldValue; // = undefined

    const oldValues = this.stateStack.length > 0 && this.stateStack[this.stateStack.length - 1];

    for (const key in values) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_3__["assert"])(key !== undefined);
      // Check that value hasn't already been shadowed
      if (!Object(_utils__WEBPACK_IMPORTED_MODULE_3__["deepArrayEqual"])(values[key], this.cache[key])) {
        valueChanged = true;
        oldValue = this.cache[key];

        // First, save current value being shadowed
        // If a state stack frame is active, save the current parameter values for pop
        // but first check that value hasn't already been shadowed and saved
        if (oldValues && !(key in oldValues)) {
          oldValues[key] = this.cache[key];
        }

        // Save current value being shadowed
        this.cache[key] = values[key];
      }
    }

    return {valueChanged, oldValue};
  }
}

// PUBLIC API

/**
 * Initialize WebGL state caching on a context
 * can be called multiple times to enable/disable
 * @param {WebGLRenderingContext} - context
 */
// After calling this function, context state will be cached
// gl.state.push() and gl.state.pop() will be available for saving,
// temporarily modifying, and then restoring state.
function trackContextState(gl, {enable = true, copyState} = {}) {
  Object(_utils__WEBPACK_IMPORTED_MODULE_3__["assert"])(copyState !== undefined);
  if (!gl.state) {
    /* global window, global */
    const global_ = typeof global !== 'undefined' ? global : window;
    if (global_.polyfillContext) {
      global_.polyfillContext(gl);
    }

    // Create a state cache
    gl.state = new GLState(gl, {copyState, enable});

    // intercept all setter functions in the table
    for (const key in _webgl_function_to_parameters_table__WEBPACK_IMPORTED_MODULE_0__["default"]) {
      const setter = _webgl_function_to_parameters_table__WEBPACK_IMPORTED_MODULE_0__["default"][key];
      installSetterSpy(gl, key, setter);
    }

    // intercept all getter functions in the table
    installGetterOverride(gl, 'getParameter');
    installGetterOverride(gl, 'isEnabled');
  }

  gl.state.enable = enable;

  return gl;
}

function pushContextState(gl) {
  if (!gl.state) {
    trackContextState(gl, {copyState: false});
  }
  gl.state.push();
}

function popContextState(gl) {
  Object(_utils__WEBPACK_IMPORTED_MODULE_3__["assert"])(gl.state);
  gl.state.pop();
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../webgl-state-tracker/src/state-tracking/webgl-function-to-parameters-table.js":
/*!***************************************************************************************!*\
  !*** ../webgl-state-tracker/src/state-tracking/webgl-function-to-parameters-table.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
// Replacements for WebGL state setting functions that call supplied 'update'
// function setting the individual parameters.
// i.e. these "setters" map functions to gl parameters

// The 'update' function is used to interceptor WEBGL functions that set
// WebGLRenderingContext state so that state changes can be tracked.

// It also enables checking values against cache and avoid unnecessary WebGL
// set/get operations.



/* harmony default export */ __webpack_exports__["default"] = ({
  // GENERIC SETTERS

  enable: (update, capability) =>
    update({
      [capability]: true
    }),
  disable: (update, capability) =>
    update({
      [capability]: false
    }),
  pixelStorei: (update, pname, value) =>
    update({
      [pname]: value
    }),
  hint: (update, pname, hint) =>
    update({
      [pname]: hint
    }),

  // SPECIFIC SETTERS

  bindFramebuffer: (update, target, framebuffer) => {
    switch (target) {
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER:
        return update({
          [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DRAW_FRAMEBUFFER_BINDING]: framebuffer,
          [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.READ_FRAMEBUFFER_BINDING]: framebuffer
        });
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DRAW_FRAMEBUFFER:
        return update({[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DRAW_FRAMEBUFFER_BINDING]: framebuffer});
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.READ_FRAMEBUFFER:
        return update({[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.READ_FRAMEBUFFER_BINDING]: framebuffer});
      default:
        return null;
    }
  },
  blendColor: (update, r, g, b, a) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_COLOR]: new Float32Array([r, g, b, a])
    }),

  blendEquation: (update, mode) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_EQUATION_RGB]: mode,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_EQUATION_ALPHA]: mode
    }),

  blendEquationSeparate: (update, modeRGB, modeAlpha) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_EQUATION_RGB]: modeRGB,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_EQUATION_ALPHA]: modeAlpha
    }),

  blendFunc: (update, src, dst) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_SRC_RGB]: src,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_DST_RGB]: dst,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_SRC_ALPHA]: src,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_DST_ALPHA]: dst
    }),

  blendFuncSeparate: (update, srcRGB, dstRGB, srcAlpha, dstAlpha) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_SRC_RGB]: srcRGB,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_DST_RGB]: dstRGB,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_SRC_ALPHA]: srcAlpha,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_DST_ALPHA]: dstAlpha
    }),

  clearColor: (update, r, g, b, a) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_CLEAR_VALUE]: new Float32Array([r, g, b, a])
    }),

  clearDepth: (update, depth) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_CLEAR_VALUE]: depth
    }),

  clearStencil: (update, s) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_CLEAR_VALUE]: s
    }),

  colorMask: (update, r, g, b, a) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_WRITEMASK]: [r, g, b, a]
    }),

  cullFace: (update, mode) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CULL_FACE_MODE]: mode
    }),

  depthFunc: (update, func) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_FUNC]: func
    }),

  depthRange: (update, zNear, zFar) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_RANGE]: new Float32Array([zNear, zFar])
    }),

  depthMask: (update, mask) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_WRITEMASK]: mask
    }),

  frontFace: (update, face) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT_FACE]: face
    }),

  lineWidth: (update, width) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINE_WIDTH]: width
    }),

  polygonOffset: (update, factor, units) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POLYGON_OFFSET_FACTOR]: factor,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POLYGON_OFFSET_UNITS]: units
    }),

  sampleCoverage: (update, value, invert) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLE_COVERAGE_VALUE]: value,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLE_COVERAGE_INVERT]: invert
    }),

  scissor: (update, x, y, width, height) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SCISSOR_BOX]: new Int32Array([x, y, width, height])
    }),

  stencilMask: (update, mask) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_WRITEMASK]: mask,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_WRITEMASK]: mask
    }),

  stencilMaskSeparate: (update, face, mask) =>
    update({
      [face === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_WRITEMASK : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_WRITEMASK]: mask
    }),

  stencilFunc: (update, func, ref, mask) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_FUNC]: func,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_REF]: ref,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_VALUE_MASK]: mask,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_FUNC]: func,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_REF]: ref,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_VALUE_MASK]: mask
    }),

  stencilFuncSeparate: (update, face, func, ref, mask) =>
    update({
      [face === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_FUNC : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_FUNC]: func,
      [face === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_REF : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_REF]: ref,
      [face === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_VALUE_MASK : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_VALUE_MASK]: mask
    }),

  stencilOp: (update, fail, zfail, zpass) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_FAIL]: fail,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_PASS_DEPTH_FAIL]: zfail,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_PASS_DEPTH_PASS]: zpass,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_FAIL]: fail,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_PASS_DEPTH_FAIL]: zfail,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_PASS_DEPTH_PASS]: zpass
    }),

  stencilOpSeparate: (update, face, fail, zfail, zpass) =>
    update({
      [face === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_FAIL : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_FAIL]: fail,
      [face === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_PASS_DEPTH_FAIL : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_PASS_DEPTH_FAIL]: zfail,
      [face === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_PASS_DEPTH_PASS : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_PASS_DEPTH_PASS]: zpass
    }),

  viewport: (update, x, y, width, height) =>
    update({
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VIEWPORT]: new Int32Array([x, y, width, height])
    })
});


/***/ }),

/***/ "../webgl-state-tracker/src/state-tracking/with-parameters.js":
/*!********************************************************************!*\
  !*** ../webgl-state-tracker/src/state-tracking/with-parameters.js ***!
  \********************************************************************/
/*! exports provided: withParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "withParameters", function() { return withParameters; });
/* harmony import */ var _track_context_state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./track-context-state */ "../webgl-state-tracker/src/state-tracking/track-context-state.js");
/* harmony import */ var _unified_parameter_api_set_parameters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../unified-parameter-api/set-parameters */ "../webgl-state-tracker/src/unified-parameter-api/set-parameters.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "../webgl-state-tracker/src/utils/index.js");




// Stores current "global" WebGL context settings, changes selected parameters,
// executes function, restores parameters
function withParameters(gl, parameters, func) {
  // assertWebGLContext(gl);

  if (Object(_utils__WEBPACK_IMPORTED_MODULE_2__["isObjectEmpty"])(parameters)) {
    // Avoid setting state if no parameters provided. Just call and return
    return func(gl);
  }

  const {nocatch = true} = parameters;

  // frameBuffer not supported: use framebuffer API
  // TODO - is this still true?
  Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(!parameters.frameBuffer);

  Object(_track_context_state__WEBPACK_IMPORTED_MODULE_0__["pushContextState"])(gl);
  Object(_unified_parameter_api_set_parameters__WEBPACK_IMPORTED_MODULE_1__["setParameters"])(gl, parameters);

  // Setup is done, call the function
  let value;

  if (nocatch) {
    // Avoid try catch to minimize stack size impact for safe execution paths
    value = func(gl);
    Object(_track_context_state__WEBPACK_IMPORTED_MODULE_0__["popContextState"])(gl);
  } else {
    // Wrap in a try-catch to ensure that parameters are restored on exceptions
    try {
      value = func(gl);
    } finally {
      Object(_track_context_state__WEBPACK_IMPORTED_MODULE_0__["popContextState"])(gl);
    }
  }

  return value;
}


/***/ }),

/***/ "../webgl-state-tracker/src/unified-parameter-api/set-parameters.js":
/*!**************************************************************************!*\
  !*** ../webgl-state-tracker/src/unified-parameter-api/set-parameters.js ***!
  \**************************************************************************/
/*! exports provided: setParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setParameters", function() { return setParameters; });
/* harmony import */ var _unified_parameter_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./unified-parameter-api */ "../webgl-state-tracker/src/unified-parameter-api/unified-parameter-api.js");
/* harmony import */ var _webgl_setter_function_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl-setter-function-table */ "../webgl-state-tracker/src/unified-parameter-api/webgl-setter-function-table.js");



// Adds support for using gl function names (in addition to parameter constants)
// as keys in setParameters
//
// Note: Value may be "normalized" (in case a short form is supported).
// In that case the normalized value is returned.

function setParameters(gl, parameters) {
  // Handles any GL parameter keys
  Object(_unified_parameter_api__WEBPACK_IMPORTED_MODULE_0__["setParameters"])(gl, parameters);
  // Check for function style keys
  for (const key in parameters) {
    const setter = _webgl_setter_function_table__WEBPACK_IMPORTED_MODULE_1__["default"][key];
    if (setter) {
      setter(gl, parameters[key], key);
    }
  }
}


/***/ }),

/***/ "../webgl-state-tracker/src/unified-parameter-api/unified-parameter-api.js":
/*!*********************************************************************************!*\
  !*** ../webgl-state-tracker/src/unified-parameter-api/unified-parameter-api.js ***!
  \*********************************************************************************/
/*! exports provided: setParameter, setParameters, getParameter, getParameters, getDefaultParameters, resetParameters, getModifiedParameters */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setParameter", function() { return setParameter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setParameters", function() { return setParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getParameter", function() { return getParameter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getParameters", function() { return getParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultParameters", function() { return getDefaultParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resetParameters", function() { return resetParameters; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getModifiedParameters", function() { return getModifiedParameters; });
/* harmony import */ var _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-parameter-tables */ "../webgl-state-tracker/src/unified-parameter-api/webgl-parameter-tables.js");
/* harmony import */ var _utils_deep_array_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/deep-array-equal */ "../webgl-state-tracker/src/utils/deep-array-equal.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "../webgl-state-tracker/src/utils/index.js");
// Provides a unified API for getting and setting any WebGL parameter
// Also knows default values of all parameters, enabling fast cache initialization
// Provides base functionality for the state caching.





// PUBLIC METHODS

// Sets any single GL parameter regardless of function (gl.getParameter/gl.isEnabled...)
// Returns the previous value
// Note: limited to parameter values
function setParameter(gl, key, value) {
  const getter = _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_GETTERS"][key];
  const prevValue = getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
  const setter = _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_SETTERS"][key];
  Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(typeof setter === 'function');
  setter(gl, value, Number(key));
  return prevValue;
}

// Sets any GL parameter regardless of function (gl.blendMode, ...)
// Note: requires a `cache` object to be set on the context (gl.state.cache)
// This object is used to fill in any missing values for composite setter functions
function setParameters(gl, values) {
  const compositeSetters = {};

  // HANDLE PRIMITIVE SETTERS (and make note of any composite setters)

  for (const key in values) {
    const glConstant = Number(key);
    const setter = _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_SETTERS"][key];
    if (setter) {
      // Composite setters should only be called once, so save them
      if (typeof setter === 'string') {
        compositeSetters[setter] = true;
      } else {
        // if (gl[glConstant] !== undefined) {
        // TODO - added above check since this is being called on WebGL2 values in WebGL1...
        // TODO - deep equal on values? only call setter if value has changed?
        // NOTE - the setter will automatically update this.state
        setter(gl, values[key], glConstant);
      }
    }
  }

  // HANDLE COMPOSITE SETTERS

  // NOTE: any non-provided values needed by composite setters are filled in from state cache
  // The cache parameter is automatically retrieved from the context
  // This depends on `trackContextState`, which is technically a "circular" dependency.
  // But it is too inconvenient to always require a cache parameter here.
  // This is the ONLY external dependency in this module/
  const cache = gl.state && gl.state.cache;
  if (cache) {
    const mergedValues = Object.assign({}, cache, values);

    for (const key in compositeSetters) {
      // TODO - avoid calling composite setters if values have not changed.
      const compositeSetter = _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_COMPOSITE_PARAMETER_SETTERS"][key];
      // Note - if `trackContextState` has been called,
      // the setter will automatically update this.state.cache
      compositeSetter(gl, mergedValues);
    }
  }
  // Add a log for the else case?
}

// Queries any single GL parameter regardless of function (gl.getParameter/gl.isEnabled...)
function getParameter(gl, key) {
  const getter = _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_GETTERS"][key];
  return getter ? getter(gl, Number(key)) : gl.getParameter(Number(key));
}

// Copies the state from a context (gl.getParameter should not be overriden)
// Reads the entire WebGL state from a context
// Caveat: This generates a huge amount of synchronous driver roundtrips and should be
// considered a very slow operation, to be used only if/when a context already manipulated
// by external code needs to be synchronized for the first time
// @return {Object} - a newly created map, with values keyed by GL parameters
function getParameters(gl, parameters) {
  // default to querying all parameters
  parameters = parameters || _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_DEFAULTS"];
  // support both arrays of parameters and objects (keys represent parameters)
  const parameterKeys = Array.isArray(parameters) ? parameters : Object.keys(parameters);

  const state = {};
  for (const key of parameterKeys) {
    state[key] = getParameter(gl, key);
  }
  return state;
}

function getDefaultParameters(gl) {
  // TODO - Query GL.VIEWPORT and GL.SCISSOR_BOX since these are dynamic
  return Object.assign({}, _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_DEFAULTS"], {
    // TODO: For viewport and scissor default values are set at the time of
    // context creation based on canvas size, we can query them here but it will
    // not match with what we have in GL_PARAMETER_DEFAULTS table, we should revisit.
    // [GL.VIEWPORT]: gl.constructor.prototype.getParameter.call(gl, GL.VIEWPORT),
    // [GL.SCISSOR_BOX]: gl.constructor.prototype.getParameter.call(gl, GL.SCISSOR_BOX)
  });
}

// Reset all parameters to a pure context state
function resetParameters(gl) {
  setParameters(gl, getDefaultParameters(gl));
}

// Get all parameters that have been modified from a pure context state
function getModifiedParameters(gl) {
  const values = getParameters(gl, Object.keys(_webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_DEFAULTS"]));
  const modified = {};
  for (const key in _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_DEFAULTS"]) {
    if (!Object(_utils_deep_array_equal__WEBPACK_IMPORTED_MODULE_1__["default"])(values[key], _webgl_parameter_tables__WEBPACK_IMPORTED_MODULE_0__["GL_PARAMETER_DEFAULTS"][key])) {
      modified[key] = values[key];
    }
  }
  return modified;
}


/***/ }),

/***/ "../webgl-state-tracker/src/unified-parameter-api/webgl-parameter-tables.js":
/*!**********************************************************************************!*\
  !*** ../webgl-state-tracker/src/unified-parameter-api/webgl-parameter-tables.js ***!
  \**********************************************************************************/
/*! exports provided: GL_PARAMETER_DEFAULTS, GL_PARAMETER_SETTERS, GL_COMPOSITE_PARAMETER_SETTERS, GL_PARAMETER_GETTERS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_PARAMETER_DEFAULTS", function() { return GL_PARAMETER_DEFAULTS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_PARAMETER_SETTERS", function() { return GL_PARAMETER_SETTERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_COMPOSITE_PARAMETER_SETTERS", function() { return GL_COMPOSITE_PARAMETER_SETTERS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GL_PARAMETER_GETTERS", function() { return GL_PARAMETER_GETTERS; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "../webgl-state-tracker/src/utils/index.js");
// Tables describing WebGL parameters



// DEFAULT SETTINGS - FOR FAST CACHE INITIALIZATION AND CONTEXT RESETS

const GL_PARAMETER_DEFAULTS = {
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_COLOR]: new Float32Array([0, 0, 0, 0]),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_EQUATION_RGB]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FUNC_ADD,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_EQUATION_ALPHA]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FUNC_ADD,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_SRC_RGB]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ONE,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_DST_RGB]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ZERO,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_SRC_ALPHA]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ONE,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_DST_ALPHA]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ZERO,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_CLEAR_VALUE]: new Float32Array([0, 0, 0, 0]), // TBD
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_WRITEMASK]: [true, true, true, true],
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CULL_FACE]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CULL_FACE_MODE]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BACK,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_TEST]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_CLEAR_VALUE]: 1,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_FUNC]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LESS,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_RANGE]: new Float32Array([0, 1]), // TBD
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_WRITEMASK]: true,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DITHER]: true,
  // FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_BINDING]: null,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT_FACE]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CCW,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.GENERATE_MIPMAP_HINT]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DONT_CARE,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINE_WIDTH]: 1,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POLYGON_OFFSET_FILL]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POLYGON_OFFSET_FACTOR]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POLYGON_OFFSET_UNITS]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLE_COVERAGE_VALUE]: 1.0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLE_COVERAGE_INVERT]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SCISSOR_TEST]: false,
  // Note: Dynamic value. If scissor test enabled we expect users to set correct scissor box
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SCISSOR_BOX]: new Int32Array([0, 0, 1024, 1024]),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_TEST]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_CLEAR_VALUE]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_WRITEMASK]: 0xffffffff,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_WRITEMASK]: 0xffffffff,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_FUNC]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ALWAYS,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_REF]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_VALUE_MASK]: 0xffffffff,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_FUNC]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ALWAYS,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_REF]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_VALUE_MASK]: 0xffffffff,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_FAIL]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.KEEP,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_PASS_DEPTH_FAIL]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.KEEP,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_PASS_DEPTH_PASS]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.KEEP,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_FAIL]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.KEEP,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_PASS_DEPTH_FAIL]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.KEEP,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_PASS_DEPTH_PASS]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.KEEP,
  // Dynamic value: We use [0, 0, 1024, 1024] as default, but usually this is updated in each frame.
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VIEWPORT]: new Int32Array([0, 0, 1024, 1024]),
  // WEBGL1 PIXEL PACK/UNPACK MODES
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.PACK_ALIGNMENT]: 4,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_ALIGNMENT]: 4,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_FLIP_Y_WEBGL]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_PREMULTIPLY_ALPHA_WEBGL]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_COLORSPACE_CONVERSION_WEBGL]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BROWSER_DEFAULT_WEBGL,

  // WEBGL2 / EXTENSIONS
  // gl1: 'OES_standard_derivatives'
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAGMENT_SHADER_DERIVATIVE_HINT]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DONT_CARE,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.READ_FRAMEBUFFER_BINDING]: null,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RASTERIZER_DISCARD]: false,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.PACK_ROW_LENGTH]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.PACK_SKIP_PIXELS]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.PACK_SKIP_ROWS]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_ROW_LENGTH]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_IMAGE_HEIGHT]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_SKIP_PIXELS]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_SKIP_ROWS]: 0,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_SKIP_IMAGES]: 0
};

// SETTER TABLES - ENABLES SETTING ANY PARAMETER WITH A COMMON API

const enable = (gl, value, key) => (value ? gl.enable(key) : gl.disable(key));
const hint = (gl, value, key) => gl.hint(key, value);
const pixelStorei = (gl, value, key) => gl.pixelStorei(key, value);

const drawFramebuffer = (gl, value) => {
  const target = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl) ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DRAW_FRAMEBUFFER : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER;
  return gl.bindFramebuffer(target, value);
};
const readFramebuffer = (gl, value) => {
  return gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.READ_FRAMEBUFFER, value);
};

// Map from WebGL parameter names to corresponding WebGL setter functions
// WegGL constants are read by parameter names, but set by function names
// NOTE: When value type is a string, it will be handled by 'GL_COMPOSITE_PARAMETER_SETTERS'
const GL_PARAMETER_SETTERS = {
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_COLOR]: (gl, value) => gl.blendColor(...value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_EQUATION_RGB]: 'blendEquation',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_EQUATION_ALPHA]: 'blendEquation',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_SRC_RGB]: 'blendFunc',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_DST_RGB]: 'blendFunc',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_SRC_ALPHA]: 'blendFunc',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_DST_ALPHA]: 'blendFunc',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_CLEAR_VALUE]: (gl, value) => gl.clearColor(...value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_WRITEMASK]: (gl, value) => gl.colorMask(...value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CULL_FACE]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CULL_FACE_MODE]: (gl, value) => gl.cullFace(value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_TEST]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_CLEAR_VALUE]: (gl, value) => gl.clearDepth(value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_FUNC]: (gl, value) => gl.depthFunc(value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_RANGE]: (gl, value) => gl.depthRange(...value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_WRITEMASK]: (gl, value) => gl.depthMask(value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DITHER]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAGMENT_SHADER_DERIVATIVE_HINT]: hint,
  // NOTE: FRAMEBUFFER_BINDING and DRAW_FRAMEBUFFER_BINDING(WebGL2) refer same state.
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_BINDING]: drawFramebuffer,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT_FACE]: (gl, value) => gl.frontFace(value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.GENERATE_MIPMAP_HINT]: hint,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINE_WIDTH]: (gl, value) => gl.lineWidth(value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POLYGON_OFFSET_FILL]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POLYGON_OFFSET_FACTOR]: 'polygonOffset',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POLYGON_OFFSET_UNITS]: 'polygonOffset',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RASTERIZER_DISCARD]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLE_COVERAGE_VALUE]: 'sampleCoverage',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLE_COVERAGE_INVERT]: 'sampleCoverage',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SCISSOR_TEST]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SCISSOR_BOX]: (gl, value) => gl.scissor(...value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_TEST]: enable,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_CLEAR_VALUE]: (gl, value) => gl.clearStencil(value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_WRITEMASK]: (gl, value) => gl.stencilMaskSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_WRITEMASK]: (gl, value) => gl.stencilMaskSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BACK, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_FUNC]: 'stencilFuncFront',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_REF]: 'stencilFuncFront',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_VALUE_MASK]: 'stencilFuncFront',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_FUNC]: 'stencilFuncBack',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_REF]: 'stencilFuncBack',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_VALUE_MASK]: 'stencilFuncBack',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_FAIL]: 'stencilOpFront',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_PASS_DEPTH_FAIL]: 'stencilOpFront',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_PASS_DEPTH_PASS]: 'stencilOpFront',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_FAIL]: 'stencilOpBack',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_PASS_DEPTH_FAIL]: 'stencilOpBack',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_PASS_DEPTH_PASS]: 'stencilOpBack',
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VIEWPORT]: (gl, value) => gl.viewport(...value),

  // WEBGL1 PIXEL PACK/UNPACK MODES
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.PACK_ALIGNMENT]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_ALIGNMENT]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_FLIP_Y_WEBGL]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_PREMULTIPLY_ALPHA_WEBGL]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_COLORSPACE_CONVERSION_WEBGL]: pixelStorei,

  // WEBGL2 PIXEL PACK/UNPACK MODES
  // RASTERIZER_DISCARD ...
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.PACK_ROW_LENGTH]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.PACK_SKIP_PIXELS]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.PACK_SKIP_ROWS]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.READ_FRAMEBUFFER_BINDING]: readFramebuffer,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_ROW_LENGTH]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_IMAGE_HEIGHT]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_SKIP_PIXELS]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_SKIP_ROWS]: pixelStorei,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_SKIP_IMAGES]: pixelStorei
};

// COMPOSITE_WEBGL_PARAMETER_
const GL_COMPOSITE_PARAMETER_SETTERS = {
  blendEquation: (gl, values) =>
    gl.blendEquationSeparate(values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_EQUATION_RGB], values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_EQUATION_ALPHA]),
  blendFunc: (gl, values) =>
    gl.blendFuncSeparate(
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_SRC_RGB],
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_DST_RGB],
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_SRC_ALPHA],
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND_DST_ALPHA]
    ),
  polygonOffset: (gl, values) =>
    gl.polygonOffset(values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POLYGON_OFFSET_FACTOR], values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POLYGON_OFFSET_UNITS]),
  sampleCoverage: (gl, values) =>
    gl.sampleCoverage(values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLE_COVERAGE_VALUE], values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLE_COVERAGE_INVERT]),
  stencilFuncFront: (gl, values) =>
    gl.stencilFuncSeparate(
      _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT,
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_FUNC],
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_REF],
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_VALUE_MASK]
    ),
  stencilFuncBack: (gl, values) =>
    gl.stencilFuncSeparate(
      _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BACK,
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_FUNC],
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_REF],
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_VALUE_MASK]
    ),
  stencilOpFront: (gl, values) =>
    gl.stencilOpSeparate(
      _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT,
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_FAIL],
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_PASS_DEPTH_FAIL],
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_PASS_DEPTH_PASS]
    ),
  stencilOpBack: (gl, values) =>
    gl.stencilOpSeparate(
      _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BACK,
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_FAIL],
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_PASS_DEPTH_FAIL],
      values[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BACK_PASS_DEPTH_PASS]
    )
};

// GETTER TABLE - FOR READING OUT AN ENTIRE CONTEXT

const isEnabled = (gl, key) => gl.isEnabled(key);

// Exceptions for any keys that cannot be queried by gl.getParameters
const GL_PARAMETER_GETTERS = {
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CULL_FACE]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_TEST]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DITHER]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POLYGON_OFFSET_FILL]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLE_ALPHA_TO_COVERAGE]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLE_COVERAGE]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SCISSOR_TEST]: isEnabled,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_TEST]: isEnabled,

  // WebGL 2
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RASTERIZER_DISCARD]: isEnabled
};


/***/ }),

/***/ "../webgl-state-tracker/src/unified-parameter-api/webgl-setter-function-table.js":
/*!***************************************************************************************!*\
  !*** ../webgl-state-tracker/src/unified-parameter-api/webgl-setter-function-table.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
// map of parameter setter function names, parameter constants, default values and types
// - Uses gl function names, except when setter function exist that are named differently
// - When the WebGL api offers <setter> and <setter>Separate (e.g. blendEquation and
//   blendEquationSeparate, we use non-separate name, but accept both non-separate and
//   separate arguments. Thus, a `getParameter` call will always return all the separate values
//   in an array, in a form that can be accepted by the setter.



// HELPERS

function isArray(array) {
  return Array.isArray(array) || ArrayBuffer.isView(array);
}

/* harmony default export */ __webpack_exports__["default"] = ({
  framebuffer: (gl, framebuffer) => {
    // accepts 1) a WebGLFramebuffer 2) null (default framebuffer), or 3) luma.gl Framebuffer class
    // framebuffer is null when restoring to default framebuffer, otherwise use the WebGL handle.
    const handle = framebuffer && 'handle' in framebuffer ? framebuffer.handle : framebuffer;
    return gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, handle);
  },
  blend: (gl, value) => (value ? gl.enable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND) : gl.disable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BLEND)),
  blendColor: (gl, value) => gl.blendColor(...value),
  blendEquation: (gl, args) => {
    args = isArray(args) ? args : [args, args];
    gl.blendEquationSeparate(...args);
  },
  blendFunc: (gl, args) => {
    args = isArray(args) && args.length === 2 ? [...args, ...args] : args;
    gl.blendFuncSeparate(...args);
  },

  clearColor: (gl, value) => gl.clearColor(...value),
  clearDepth: (gl, value) => gl.clearDepth(value),
  clearStencil: (gl, value) => gl.clearStencil(value),

  colorMask: (gl, value) => gl.colorMask(...value),

  cull: (gl, value) => (value ? gl.enable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CULL_FACE) : gl.disable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CULL_FACE)),
  cullFace: (gl, value) => gl.cullFace(value),

  depthTest: (gl, value) => (value ? gl.enable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_TEST) : gl.disable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_TEST)),
  depthFunc: (gl, value) => gl.depthFunc(value),
  depthMask: (gl, value) => gl.depthMask(value),
  depthRange: (gl, value) => gl.depthRange(...value),

  dither: (gl, value) => (value ? gl.enable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DITHER) : gl.disable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DITHER)),

  derivativeHint: (gl, value) => {
    // gl1: 'OES_standard_derivatives'
    gl.hint(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAGMENT_SHADER_DERIVATIVE_HINT, value);
  },

  frontFace: (gl, value) => gl.frontFace(value),

  mipmapHint: (gl, value) => gl.hint(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.GENERATE_MIPMAP_HINT, value),

  lineWidth: (gl, value) => gl.lineWidth(value),

  polygonOffsetFill: (gl, value) =>
    value ? gl.enable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POLYGON_OFFSET_FILL) : gl.disable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POLYGON_OFFSET_FILL),
  polygonOffset: (gl, value) => gl.polygonOffset(...value),

  sampleCoverage: (gl, value) => gl.sampleCoverage(...value),

  scissorTest: (gl, value) => (value ? gl.enable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SCISSOR_TEST) : gl.disable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SCISSOR_TEST)),
  scissor: (gl, value) => gl.scissor(...value),

  stencilTest: (gl, value) => (value ? gl.enable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_TEST) : gl.disable(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_TEST)),
  stencilMask: (gl, value) => {
    value = isArray(value) ? value : [value, value];
    const [mask, backMask] = value;
    gl.stencilMaskSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT, mask);
    gl.stencilMaskSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BACK, backMask);
  },
  stencilFunc: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [func, ref, mask, backFunc, backRef, backMask] = args;
    gl.stencilFuncSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT, func, ref, mask);
    gl.stencilFuncSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BACK, backFunc, backRef, backMask);
  },
  stencilOp: (gl, args) => {
    args = isArray(args) && args.length === 3 ? [...args, ...args] : args;
    const [sfail, dpfail, dppass, backSfail, backDpfail, backDppass] = args;
    gl.stencilOpSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT, sfail, dpfail, dppass);
    gl.stencilOpSeparate(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BACK, backSfail, backDpfail, backDppass);
  },

  viewport: (gl, value) => gl.viewport(...value)
});


/***/ }),

/***/ "../webgl-state-tracker/src/utils/assert.js":
/*!**************************************************!*\
  !*** ../webgl-state-tracker/src/utils/assert.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Avoid bundling assert polyfill module
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'luma.gl: assertion failed.');
  }
}


/***/ }),

/***/ "../webgl-state-tracker/src/utils/deep-array-equal.js":
/*!************************************************************!*\
  !*** ../webgl-state-tracker/src/utils/deep-array-equal.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return deepArrayEqual; });
function deepArrayEqual(x, y) {
  if (x === y) {
    return true;
  }
  const isArrayX = Array.isArray(x) || ArrayBuffer.isView(x);
  const isArrayY = Array.isArray(y) || ArrayBuffer.isView(y);
  if (isArrayX && isArrayY && x.length === y.length) {
    for (let i = 0; i < x.length; ++i) {
      if (x[i] !== y[i]) {
        return false;
      }
    }
    return true;
  }
  return false;
}


/***/ }),

/***/ "../webgl-state-tracker/src/utils/index.js":
/*!*************************************************!*\
  !*** ../webgl-state-tracker/src/utils/index.js ***!
  \*************************************************/
/*! exports provided: assert, deepArrayEqual, isWebGL2, isObjectEmpty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../webgl-state-tracker/src/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _assert__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _deep_array_equal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./deep-array-equal */ "../webgl-state-tracker/src/utils/deep-array-equal.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deepArrayEqual", function() { return _deep_array_equal__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ "../webgl-state-tracker/src/utils/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWebGL2", function() { return _utils__WEBPACK_IMPORTED_MODULE_2__["isWebGL2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObjectEmpty", function() { return _utils__WEBPACK_IMPORTED_MODULE_2__["isObjectEmpty"]; });






/***/ }),

/***/ "../webgl-state-tracker/src/utils/utils.js":
/*!*************************************************!*\
  !*** ../webgl-state-tracker/src/utils/utils.js ***!
  \*************************************************/
/*! exports provided: isObjectEmpty, isWebGL2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObjectEmpty", function() { return isObjectEmpty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWebGL2", function() { return isWebGL2; });
// Returns true if given object is empty, false otherwise.
function isObjectEmpty(object) {
  for (const key in object) {
    return false;
  }
  return true;
}

// Returns true if WebGL2 context (Heuristic)
function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}


/***/ }),

/***/ "../webgl/src/classes/accessor.js":
/*!****************************************!*\
  !*** ../webgl/src/classes/accessor.js ***!
  \****************************************/
/*! exports provided: default, DEFAULT_ACCESSOR_VALUES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Accessor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DEFAULT_ACCESSOR_VALUES", function() { return DEFAULT_ACCESSOR_VALUES; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");




const DEFAULT_ACCESSOR_VALUES = {
  offset: 0,
  stride: 0,
  type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT,
  size: 1,
  divisor: 0,
  normalized: false,
  integer: false
};

const PROP_CHECKS = {
  deprecatedProps: {
    instanced: 'divisor',
    isInstanced: 'divisor'
  }
};

class Accessor {
  static getBytesPerElement(accessor) {
    // TODO: using `FLOAT` when type is not specified,
    // ensure this assumption is valid or force API to specify type.
    const ArrayType = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["getTypedArrayFromGLType"])(accessor.type || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT);
    return ArrayType.BYTES_PER_ELEMENT;
  }

  static getBytesPerVertex(accessor) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(accessor.size);
    // TODO: using `FLOAT` when type is not specified,
    // ensure this assumption is valid or force API to specify type.
    const ArrayType = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["getTypedArrayFromGLType"])(accessor.type || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT);
    return ArrayType.BYTES_PER_ELEMENT * accessor.size;
  }

  // Combines (merges) a list of accessors. On top of default values
  // Usually [programAccessor, bufferAccessor, appAccessor]
  // All props will be set in the returned object.
  // TODO check for conflicts between values in the supplied accessors
  static resolve(...accessors) {
    return new Accessor(...[DEFAULT_ACCESSOR_VALUES, ...accessors]); // Default values
  }

  constructor(...accessors) {
    accessors.forEach(accessor => this._assign(accessor)); // Merge in sequence
    Object.freeze(this);
  }

  toString() {
    return JSON.stringify(this);
  }

  // ACCESSORS

  // TODO - remove>
  get BYTES_PER_ELEMENT() {
    return Accessor.getBytesPerElement(this);
  }

  get BYTES_PER_VERTEX() {
    return Accessor.getBytesPerVertex(this);
  }

  // PRIVATE

  // eslint-disable-next-line complexity, max-statements
  _assign(props = {}) {
    props = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["checkProps"])('Accessor', props, PROP_CHECKS);

    if (props.type !== undefined) {
      this.type = props.type;

      // Auto-deduce integer type?
      if (props.type === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.INT || props.type === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_INT) {
        this.integer = true;
      }
    }
    if (props.size !== undefined) {
      this.size = props.size;
    }
    if (props.offset !== undefined) {
      this.offset = props.offset;
    }
    if (props.stride !== undefined) {
      this.stride = props.stride;
    }
    if (props.normalized !== undefined) {
      this.normalized = props.normalized;
    }
    if (props.integer !== undefined) {
      this.integer = props.integer;
    }

    // INSTANCE DIVISOR
    if (props.divisor !== undefined) {
      this.divisor = props.divisor;
    }

    // Buffer is optional
    if (props.buffer !== undefined) {
      this.buffer = props.buffer;
    }

    // The binding index (for binding e.g. Transform feedbacks and Uniform buffers)
    // TODO - should this be part of accessor?
    if (props.index !== undefined) {
      if (typeof index === 'boolean') {
        this.index = props.index ? 1 : 0;
      } else {
        this.index = props.index;
      }
    }

    // DEPRECATED
    if (props.instanced !== undefined) {
      this.divisor = props.instanced ? 1 : 0;
    }
    if (props.isInstanced !== undefined) {
      this.divisor = props.isInstanced ? 1 : 0;
    }

    return this;
  }
}

// TEST EXPORTS



/***/ }),

/***/ "../webgl/src/classes/buffer.js":
/*!**************************************!*\
  !*** ../webgl/src/classes/buffer.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Buffer; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resource */ "../webgl/src/classes/resource.js");
/* harmony import */ var _accessor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./accessor */ "../webgl/src/classes/accessor.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");






const DEBUG_DATA_LENGTH = 10;

// Shared prop checks for constructor and setProps
const DEPRECATED_PROPS = {
  offset: 'accessor.offset',
  stride: 'accessor.stride',
  type: 'accessor.type',
  size: 'accessor.size',
  divisor: 'accessor.divisor',
  normalized: 'accessor.normalized',
  integer: 'accessor.integer',
  instanced: 'accessor.divisor',
  isInstanced: 'accessor.divisor'
};

// Prop checks for constructor
const PROP_CHECKS_INITIALIZE = {
  removedProps: {},
  replacedProps: {
    bytes: 'byteLength'
  },
  // new Buffer() with individual accessor props is still used in apps, emit warnings
  deprecatedProps: DEPRECATED_PROPS
};

// Prop checks for setProps
const PROP_CHECKS_SET_PROPS = {
  // Buffer.setProps() with individual accessor props is rare => emit errors
  removedProps: DEPRECATED_PROPS
};

class Buffer extends _resource__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(gl, props = {}) {
    super(gl, props);

    this.stubRemovedMethods('Buffer', 'v6.0', ['layout', 'setLayout', 'getIndexedParameter']);
    // this.stubRemovedMethods('Buffer', 'v7.0', ['updateAccessor']);

    // In WebGL1, need to make sure we use GL.ELEMENT_ARRAY_BUFFER when initializing element buffers
    // otherwise buffer type will lock to generic (non-element) buffer
    // In WebGL2, we can use GL.COPY_READ_BUFFER which avoids locking the type here
    this.target = props.target || (this.gl.webgl2 ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COPY_READ_BUFFER : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ARRAY_BUFFER);

    this.initialize(props);

    Object.seal(this);
  }

  // returns number of elements in the buffer (assuming that the full buffer is used)
  getElementCount(accessor = this.accessor) {
    return Math.round(this.byteLength / _accessor__WEBPACK_IMPORTED_MODULE_2__["default"].getBytesPerElement(accessor));
  }

  // returns number of vertices in the buffer (assuming that the full buffer is used)
  getVertexCount(accessor = this.accessor) {
    return Math.round(this.byteLength / _accessor__WEBPACK_IMPORTED_MODULE_2__["default"].getBytesPerVertex(accessor));
  }

  // Creates and initializes the buffer object's data store.
  // Signature: `new Buffer(gl, {data: new Float32Array(...)})`
  // Signature: `new Buffer(gl, new Float32Array(...))`
  // Signature: `new Buffer(gl, 100)`
  initialize(props = {}) {
    // Signature `new Buffer(gl, new Float32Array(...)`
    if (ArrayBuffer.isView(props)) {
      props = {data: props};
    }

    // Signature: `new Buffer(gl, 100)`
    if (Number.isFinite(props)) {
      props = {byteLength: props};
    }

    props = Object(_utils__WEBPACK_IMPORTED_MODULE_4__["checkProps"])('Buffer', props, PROP_CHECKS_INITIALIZE);

    // Initialize member fields
    this.usage = props.usage || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STATIC_DRAW;
    this.debugData = null;

    // Deprecated: Merge main props and accessor
    this.setAccessor(Object.assign({}, props, props.accessor));

    // Set data: (re)initializes the buffer
    if (props.data) {
      this._setData(props.data);
    } else {
      this._setByteLength(props.byteLength || 0);
    }

    return this;
  }

  setProps(props) {
    props = Object(_utils__WEBPACK_IMPORTED_MODULE_4__["checkProps"])('Buffer', props, PROP_CHECKS_SET_PROPS);

    if ('accessor' in props) {
      this.setAccessor(props.accessor);
    }

    return this;
  }

  // Optionally stores an accessor with the buffer, makes it easier to use it as an attribute later
  // {type, size = 1, offset = 0, stride = 0, normalized = false, integer = false, divisor = 0}
  setAccessor(accessor) {
    // NOTE: From luma.gl v7.0, Accessors have an optional `buffer `field
    // (mainly to support "interleaving")
    // To avoid confusion, ensure `buffer.accessor` does not have a `buffer.accessor.buffer` field:
    accessor = Object.assign({}, accessor);
    delete accessor.buffer;

    // This new statement ensures that an "accessor object" is re-packaged as an Accessor instance
    this.accessor = new _accessor__WEBPACK_IMPORTED_MODULE_2__["default"](accessor);
    return this;
  }

  // Allocate a bigger GPU buffer (if the current buffer is not big enough).
  // If a reallocation is triggered it clears the buffer
  // Returns:
  //  `true`: buffer was reallocated, data was cleared
  //  `false`: buffer was big enough, data is intact
  reallocate(byteLength) {
    if (byteLength > this.byteLength) {
      this._setByteLength(byteLength);
      return true;
    }
    this.bytesUsed = byteLength;
    return false;
  }

  // Update with new data. Reinitializes the buffer
  setData(props) {
    return this.initialize(props);
  }

  // Updates a subset of a buffer object's data store.
  // Data (Typed Array or ArrayBuffer), length is inferred unless provided
  // Offset into buffer
  // WebGL2 only: Offset into srcData
  // WebGL2 only: Number of bytes to be copied
  subData(props) {
    // Signature: buffer.subData(new Float32Array([...]))
    if (ArrayBuffer.isView(props)) {
      props = {data: props};
    }

    const {data, offset = 0, srcOffset = 0} = props;
    const byteLength = props.byteLength || props.length;

    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(data);

    // Create the buffer - binding it here for the first time locks the type
    // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type
    const target = this.gl.webgl2 ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COPY_WRITE_BUFFER : this.target;
    this.gl.bindBuffer(target, this.handle);
    // WebGL2: subData supports additional srcOffset and length parameters
    if (srcOffset !== 0 || byteLength !== undefined) {
      Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["assertWebGL2Context"])(this.gl);
      this.gl.bufferSubData(this.target, offset, data, srcOffset, byteLength);
    } else {
      this.gl.bufferSubData(target, offset, data);
    }
    this.gl.bindBuffer(target, null);

    // TODO - update local `data` if offsets are right
    this.debugData = null;

    this._inferType(data);

    return this;
  }

  // WEBGL2 ONLY: Copies part of the data of another buffer into this buffer
  copyData({sourceBuffer, readOffset = 0, writeOffset = 0, size}) {
    const {gl} = this;
    Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["assertWebGL2Context"])(gl);

    // Use GL.COPY_READ_BUFFER+GL.COPY_WRITE_BUFFER avoid disturbing other targets and locking type
    gl.bindBuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COPY_READ_BUFFER, sourceBuffer.handle);
    gl.bindBuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COPY_WRITE_BUFFER, this.handle);
    gl.copyBufferSubData(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COPY_READ_BUFFER, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COPY_WRITE_BUFFER, readOffset, writeOffset, size);
    gl.bindBuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COPY_READ_BUFFER, null);
    gl.bindBuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COPY_WRITE_BUFFER, null);

    // TODO - update local `data` if offsets are 0
    this.debugData = null;

    return this;
  }

  // WEBGL2 ONLY: Reads data from buffer into an ArrayBufferView or SharedArrayBuffer.
  getData({dstData = null, srcByteOffset = 0, dstOffset = 0, length = 0} = {}) {
    Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["assertWebGL2Context"])(this.gl);

    const ArrayType = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["getTypedArrayFromGLType"])(this.accessor.type || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT, {clamped: false});
    const sourceAvailableElementCount = this._getAvailableElementCount(srcByteOffset);

    const dstElementOffset = dstOffset;

    let dstAvailableElementCount;
    let dstElementCount;
    if (dstData) {
      dstElementCount = dstData.length;
      dstAvailableElementCount = dstElementCount - dstElementOffset;
    } else {
      // Allocate ArrayBufferView with enough size to copy all eligible data.
      dstAvailableElementCount = Math.min(
        sourceAvailableElementCount,
        length || sourceAvailableElementCount
      );
      dstElementCount = dstElementOffset + dstAvailableElementCount;
    }

    const copyElementCount = Math.min(sourceAvailableElementCount, dstAvailableElementCount);
    length = length || copyElementCount;
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(length <= copyElementCount);
    dstData = dstData || new ArrayType(dstElementCount);

    // Use GL.COPY_READ_BUFFER to avoid disturbing other targets and locking type
    this.gl.bindBuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COPY_READ_BUFFER, this.handle);
    this.gl.getBufferSubData(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COPY_READ_BUFFER, srcByteOffset, dstData, dstOffset, length);
    this.gl.bindBuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COPY_READ_BUFFER, null);

    // TODO - update local `data` if offsets are 0
    return dstData;
  }

  /**
   * Binds a buffer to a given binding point (target).
   *   GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER take an index, and optionally a range.
   *   - GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER need an index to affect state
   *   - GL.UNIFORM_BUFFER: `offset` must be aligned to GL.UNIFORM_BUFFER_OFFSET_ALIGNMENT.
   *   - GL.UNIFORM_BUFFER: `size` must be a minimum of GL.UNIFORM_BLOCK_SIZE_DATA.
   */
  bind({
    target = this.target, // target for the bind operation
    index = this.accessor && this.accessor.index, // index = index of target (indexed bind point)
    offset = 0,
    size
  } = {}) {
    // NOTE: While GL.TRANSFORM_FEEDBACK_BUFFER and GL.UNIFORM_BUFFER could
    // be used as direct binding points, they will not affect transform feedback or
    // uniform buffer state. Instead indexed bindings need to be made.
    if (target === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNIFORM_BUFFER || target === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TRANSFORM_FEEDBACK_BUFFER) {
      if (size !== undefined) {
        this.gl.bindBufferRange(target, index, this.handle, offset, size);
      } else {
        Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(offset === 0); // Make sure offset wasn't supplied
        this.gl.bindBufferBase(target, index, this.handle);
      }
    } else {
      this.gl.bindBuffer(target, this.handle);
    }

    return this;
  }

  unbind({target = this.target, index = this.accessor && this.accessor.index} = {}) {
    const isIndexedBuffer = target === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNIFORM_BUFFER || target === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TRANSFORM_FEEDBACK_BUFFER;
    if (isIndexedBuffer) {
      this.gl.bindBufferBase(target, index, null);
    } else {
      this.gl.bindBuffer(target, null);
    }
    return this;
  }

  // PROTECTED METHODS (INTENDED FOR USE BY OTHER FRAMEWORK CODE ONLY)

  // Returns a short initial data array
  getDebugData() {
    if (!this.debugData) {
      this.debugData = this.getData({length: Math.min(DEBUG_DATA_LENGTH, this.byteLength)});
      return {data: this.debugData, changed: true};
    }
    return {data: this.debugData, changed: false};
  }

  invalidateDebugData() {
    this.debugData = null;
  }

  // PRIVATE METHODS

  // Allocate a new buffer and initialize to contents of typed array
  _setData(data, usage = this.usage) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(ArrayBuffer.isView(data));

    this._trackDeallocatedMemory();

    const target = this._getTarget();
    this.gl.bindBuffer(target, this.handle);
    this.gl.bufferData(target, data, usage);
    this.gl.bindBuffer(target, null);

    this.usage = usage;
    this.debugData = data.slice(0, DEBUG_DATA_LENGTH);
    this.bytesUsed = data.byteLength;

    this._trackAllocatedMemory(data.byteLength);

    // infer GL type from supplied typed array
    const type = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["getGLTypeFromTypedArray"])(data);
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(type);
    this.setAccessor(new _accessor__WEBPACK_IMPORTED_MODULE_2__["default"](this.accessor, {type}));
    return this;
  }

  // Allocate a GPU buffer of specified size.
  _setByteLength(byteLength, usage = this.usage) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(byteLength >= 0);

    this._trackDeallocatedMemory();

    // Workaround needed for Safari (#291):
    // gl.bufferData with size equal to 0 crashes. Instead create zero sized array.
    let data = byteLength;
    if (byteLength === 0) {
      data = new Float32Array(0);
    }

    const target = this._getTarget();
    this.gl.bindBuffer(target, this.handle);
    this.gl.bufferData(target, data, usage);
    this.gl.bindBuffer(target, null);

    this.usage = usage;
    this.debugData = null;
    this.bytesUsed = byteLength;

    this._trackAllocatedMemory(byteLength);

    return this;
  }

  // Binding a buffer for the first time locks the type
  // In WebGL2, use GL.COPY_WRITE_BUFFER to avoid locking the type
  _getTarget() {
    return this.gl.webgl2 ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COPY_WRITE_BUFFER : this.target;
  }

  _getAvailableElementCount(srcByteOffset) {
    const ArrayType = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["getTypedArrayFromGLType"])(this.accessor.type || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT, {clamped: false});
    const sourceElementOffset = srcByteOffset / ArrayType.BYTES_PER_ELEMENT;
    return this.getElementCount() - sourceElementOffset;
  }

  // Automatically infers type from typed array passed to setData
  // Note: No longer that useful, since type is now autodeduced from the compiled shaders
  _inferType(data) {
    if (!this.accessor.type) {
      this.setAccessor(new _accessor__WEBPACK_IMPORTED_MODULE_2__["default"](this.accessor, {type: Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["getGLTypeFromTypedArray"])(data)}));
    }
  }

  // RESOURCE METHODS

  _createHandle() {
    return this.gl.createBuffer();
  }

  _deleteHandle() {
    this.gl.deleteBuffer(this.handle);
    this._trackDeallocatedMemory();
  }

  _getParameter(pname) {
    this.gl.bindBuffer(this.target, this.handle);
    const value = this.gl.getBufferParameter(this.target, pname);
    this.gl.bindBuffer(this.target, null);
    return value;
  }

  // DEPRECATIONS - v7.0
  get type() {
    _utils__WEBPACK_IMPORTED_MODULE_4__["log"].deprecated('Buffer.type', 'Buffer.accessor.type')();
    return this.accessor.type;
  }

  get bytes() {
    _utils__WEBPACK_IMPORTED_MODULE_4__["log"].deprecated('Buffer.bytes', 'Buffer.byteLength')();
    return this.byteLength;
  }

  // DEPRECATIONS - v6.0
  // Deprecated in v6.x, but not warnings not properly implemented
  setByteLength(byteLength) {
    _utils__WEBPACK_IMPORTED_MODULE_4__["log"].deprecated('setByteLength', 'reallocate')();
    return this.reallocate(byteLength);
  }

  // Deprecated in v6.x, but not warnings not properly implemented
  updateAccessor(opts) {
    _utils__WEBPACK_IMPORTED_MODULE_4__["log"].deprecated('updateAccessor(...)', 'setAccessor(new Accessor(buffer.accessor, ...)')();
    this.accessor = new _accessor__WEBPACK_IMPORTED_MODULE_2__["default"](this.accessor, opts);
    return this;
  }
}


/***/ }),

/***/ "../webgl/src/classes/clear.js":
/*!*************************************!*\
  !*** ../webgl/src/classes/clear.js ***!
  \*************************************/
/*! exports provided: clear, clearBuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clearBuffer", function() { return clearBuffer; });
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../context */ "../webgl/src/context/index.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");




// Should collapse during minification
const GL_DEPTH_BUFFER_BIT = 0x00000100;
const GL_STENCIL_BUFFER_BIT = 0x00000400;
const GL_COLOR_BUFFER_BIT = 0x00004000;

const GL_COLOR = 0x1800;
const GL_DEPTH = 0x1801;
const GL_STENCIL = 0x1802;
const GL_DEPTH_STENCIL = 0x84f9;

// Should disappear if asserts are removed
const ERR_ARGUMENTS = 'clear: bad arguments';

// Optionally clears depth, color and stencil buffers
function clear(gl, {framebuffer = null, color = null, depth = null, stencil = null} = {}) {
  const parameters = {};

  if (framebuffer) {
    parameters.framebuffer = framebuffer;
  }

  let clearFlags = 0;

  if (color) {
    clearFlags |= GL_COLOR_BUFFER_BIT;
    if (color !== true) {
      parameters.clearColor = color;
    }
  }

  if (depth) {
    clearFlags |= GL_DEPTH_BUFFER_BIT;
    if (depth !== true) {
      parameters.clearDepth = depth;
    }
  }

  if (stencil) {
    clearFlags |= GL_STENCIL_BUFFER_BIT;
    if (depth !== true) {
      parameters.clearStencil = depth;
    }
  }

  Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(clearFlags !== 0, ERR_ARGUMENTS);

  // Temporarily set any clear "colors" and call clear
  Object(_context__WEBPACK_IMPORTED_MODULE_0__["withParameters"])(gl, parameters, () => {
    gl.clear(clearFlags);
  });
}

// WebGL2 - clear a specific drawing buffer
function clearBuffer(
  gl,
  {framebuffer = null, buffer = GL_COLOR, drawBuffer = 0, value = [0, 0, 0, 0]} = {}
) {
  Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["assertWebGL2Context"])(gl);

  Object(_context__WEBPACK_IMPORTED_MODULE_0__["withParameters"])(gl, {framebuffer}, () => {
    // Method selection per OpenGL ES 3 docs
    switch (buffer) {
      case GL_COLOR:
        switch (value.constructor) {
          case Int32Array:
            gl.clearBufferiv(buffer, drawBuffer, value);
            break;
          case Uint32Array:
            gl.clearBufferuiv(buffer, drawBuffer, value);
            break;
          case Float32Array:
          default:
            gl.clearBufferfv(buffer, drawBuffer, value);
        }
        break;

      case GL_DEPTH:
        gl.clearBufferfv(GL_DEPTH, 0, [value]);
        break;

      case GL_STENCIL:
        gl.clearBufferiv(GL_STENCIL, 0, [value]);
        break;

      case GL_DEPTH_STENCIL:
        const [depth, stencil] = value;
        gl.clearBufferfi(GL_DEPTH_STENCIL, 0, depth, stencil);
        break;

      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(false, ERR_ARGUMENTS);
    }
  });
}


/***/ }),

/***/ "../webgl/src/classes/copy-and-blit.js":
/*!*********************************************!*\
  !*** ../webgl/src/classes/copy-and-blit.js ***!
  \*********************************************/
/*! exports provided: readPixelsToArray, readPixelsToBuffer, copyToDataUrl, copyToImage, copyToTexture, blit */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readPixelsToArray", function() { return readPixelsToArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "readPixelsToBuffer", function() { return readPixelsToBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyToDataUrl", function() { return copyToDataUrl; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyToImage", function() { return copyToImage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "copyToTexture", function() { return copyToTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "blit", function() { return blit; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buffer */ "../webgl/src/classes/buffer.js");
/* harmony import */ var _framebuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./framebuffer */ "../webgl/src/classes/framebuffer.js");
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./texture */ "../webgl/src/classes/texture.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../context */ "../webgl/src/context/index.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _webgl_utils_typed_array_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../webgl-utils/typed-array-utils */ "../webgl/src/webgl-utils/typed-array-utils.js");
/* harmony import */ var _webgl_utils_format_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../webgl-utils/format-utils */ "../webgl/src/webgl-utils/format-utils.js");
/* harmony import */ var _webgl_utils_texture_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../webgl-utils/texture-utils */ "../webgl/src/webgl-utils/texture-utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");











// NOTE: Slow requires roundtrip to GPU
// Copies data from a Framebuffer or a Texture object into ArrayBuffer object.
// App can provide targetPixelArray or have it auto allocated by this method
// @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,
//  newly allocated by this method unless provided by app.
function readPixelsToArray(
  source,
  {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA,
    sourceAttachment = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer
    target = null,
    // following parameters are auto deduced if not provided
    sourceWidth,
    sourceHeight,
    sourceType
  } = {}
) {
  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);
  Object(_utils__WEBPACK_IMPORTED_MODULE_9__["assert"])(framebuffer);
  const {gl, handle, attachments} = framebuffer;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;

  // TODO - Set and unset gl.readBuffer
  if (sourceAttachment === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0 && handle === null) {
    sourceAttachment = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT;
  }

  Object(_utils__WEBPACK_IMPORTED_MODULE_9__["assert"])(attachments[sourceAttachment]);

  // Deduce the type from color attachment if not provided.
  sourceType = sourceType || attachments[sourceAttachment].type;

  // Deduce type and allocated pixelArray if needed
  target = getPixelArray(target, sourceType, sourceFormat, sourceWidth, sourceHeight);

  // Pixel array available, if necessary, deduce type from it.
  sourceType = sourceType || Object(_webgl_utils_typed_array_utils__WEBPACK_IMPORTED_MODULE_6__["getGLTypeFromTypedArray"])(target);

  const prevHandle = gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, handle);
  gl.readPixels(sourceX, sourceY, sourceWidth, sourceHeight, sourceFormat, sourceType, target);
  gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return target;
}

// NOTE: doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.
// Copies data from a Framebuffer or a Texture object into a Buffer object.
function readPixelsToBuffer(
  source,
  {
    sourceX = 0,
    sourceY = 0,
    sourceFormat = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA,
    target = null, // A new Buffer object is created when not provided.
    targetByteOffset = 0, // byte offset in buffer object
    // following parameters are auto deduced if not provided
    sourceWidth,
    sourceHeight,
    sourceType
  }
) {
  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);
  Object(_utils__WEBPACK_IMPORTED_MODULE_9__["assert"])(framebuffer);
  const {gl} = framebuffer;
  sourceWidth = sourceWidth || framebuffer.width;
  sourceHeight = sourceHeight || framebuffer.height;

  // Asynchronus read (PIXEL_PACK_BUFFER) is WebGL2 only feature
  Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_5__["assertWebGL2Context"])(gl);

  // deduce type if not available.
  sourceType = sourceType || (target ? target.type : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE);

  if (!target) {
    // Create new buffer with enough size
    const components = Object(_webgl_utils_format_utils__WEBPACK_IMPORTED_MODULE_7__["glFormatToComponents"])(sourceFormat);
    const byteCount = Object(_webgl_utils_format_utils__WEBPACK_IMPORTED_MODULE_7__["glTypeToBytes"])(sourceType);
    const byteLength = targetByteOffset + sourceWidth * sourceHeight * components * byteCount;
    target = new _buffer__WEBPACK_IMPORTED_MODULE_1__["default"](gl, {byteLength, accessor: {type: sourceType, size: components}});
  }

  target.bind({target: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.PIXEL_PACK_BUFFER});
  Object(_context__WEBPACK_IMPORTED_MODULE_4__["withParameters"])(gl, {framebuffer}, () => {
    gl.readPixels(
      sourceX,
      sourceY,
      sourceWidth,
      sourceHeight,
      sourceFormat,
      sourceType,
      targetByteOffset
    );
  });
  target.unbind({target: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.PIXEL_PACK_BUFFER});
  if (deleteFramebuffer) {
    framebuffer.delete();
  }

  return target;
}

// Reads pixels from a Framebuffer or Texture object to a dataUrl
function copyToDataUrl(
  source,
  {
    sourceAttachment = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer
    targetMaxHeight = Number.MAX_SAFE_INTEGER
  } = {}
) {
  let data = readPixelsToArray(source, {sourceAttachment});

  // Scale down
  let {width, height} = source;
  while (height > targetMaxHeight) {
    ({data, width, height} = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_5__["scalePixels"])({data, width, height}));
  }

  // Flip to top down coordinate system
  Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_5__["flipRows"])({data, width, height});

  /* global document */
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const context = canvas.getContext('2d');

  // Copy the pixels to a 2D canvas
  const imageData = context.createImageData(width, height);
  imageData.data.set(data);
  context.putImageData(imageData, 0, 0);

  return canvas.toDataURL();
}

// Reads pixels from a Framebuffer or Texture object into an HTML Image
function copyToImage(
  source,
  {
    sourceAttachment = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer
    targetImage = null
  } = {}
) {
  /* global Image */
  const dataUrl = copyToDataUrl(source, {sourceAttachment});
  targetImage = targetImage || new Image();
  targetImage.src = dataUrl;
  return targetImage;
}

// Copy a rectangle from a Framebuffer or Texture object into a texture (at an offset)
// eslint-disable-next-line complexity, max-statements
function copyToTexture(
  source,
  target,
  {
    sourceX = 0,
    sourceY = 0,
    // attachment = GL.COLOR_ATTACHMENT0, // TODO - support gl.readBuffer

    targetX,
    targetY,
    targetZ,
    targetMipmaplevel = 0,
    targetInternalFormat = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA,

    width, // defaults to target width
    height // defaults to target height
  } = {}
) {
  const {framebuffer, deleteFramebuffer} = getFramebuffer(source);
  Object(_utils__WEBPACK_IMPORTED_MODULE_9__["assert"])(framebuffer);
  const {gl, handle} = framebuffer;
  const isSubCopy =
    typeof targetX !== 'undefined' ||
    typeof targetY !== 'undefined' ||
    typeof targetZ !== 'undefined';
  targetX = targetX || 0;
  targetY = targetY || 0;
  targetZ = targetZ || 0;
  const prevHandle = gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, handle);
  // TODO - support gl.readBuffer (WebGL2 only)
  // const prevBuffer = gl.readBuffer(attachment);
  Object(_utils__WEBPACK_IMPORTED_MODULE_9__["assert"])(target);
  let texture = null;
  if (target instanceof _texture__WEBPACK_IMPORTED_MODULE_3__["default"]) {
    texture = target;
    width = Number.isFinite(width) ? width : texture.width;
    height = Number.isFinite(height) ? height : texture.height;
    texture.bind(0);
    target = texture.target;
  }

  if (!isSubCopy) {
    gl.copyTexImage2D(
      target,
      targetMipmaplevel,
      targetInternalFormat,
      sourceX,
      sourceY,
      width,
      height,
      0 /* border must be 0 */
    );
  } else {
    switch (target) {
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_2D:
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_CUBE_MAP:
        gl.copyTexSubImage2D(
          target,
          targetMipmaplevel,
          targetX,
          targetY,
          sourceX,
          sourceY,
          width,
          height
        );
        break;
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_2D_ARRAY:
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_3D:
        gl.copyTexSubImage3D(
          target,
          targetMipmaplevel,
          targetX,
          targetY,
          targetZ,
          sourceX,
          sourceY,
          width,
          height
        );
        break;
      default:
    }
  }
  if (texture) {
    texture.unbind();
  }
  gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, prevHandle || null);
  if (deleteFramebuffer) {
    framebuffer.delete();
  }
  return texture;
}

// NOTE: WEBLG2 only
// Copies a rectangle of pixels between Framebuffer or Texture objects
// eslint-disable-next-line max-statements, complexity
function blit(
  source,
  target,
  {
    sourceAttachment = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0,
    sourceX0 = 0,
    sourceY0 = 0,
    sourceX1,
    sourceY1,
    targetX0 = 0,
    targetY0 = 0,
    targetX1,
    targetY1,
    color = true,
    depth = false,
    stencil = false,
    mask = 0,
    filter = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.NEAREST
  } = {}
) {
  const {framebuffer: srcFramebuffer, deleteFramebuffer: deleteSrcFramebuffer} = getFramebuffer(
    source
  );
  const {framebuffer: dstFramebuffer, deleteFramebuffer: deleteDstFramebuffer} = getFramebuffer(
    target
  );

  Object(_utils__WEBPACK_IMPORTED_MODULE_9__["assert"])(srcFramebuffer);
  Object(_utils__WEBPACK_IMPORTED_MODULE_9__["assert"])(dstFramebuffer);
  const {gl, handle, width, height, readBuffer} = dstFramebuffer;
  Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_5__["assertWebGL2Context"])(gl);

  if (!srcFramebuffer.handle && sourceAttachment === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0) {
    sourceAttachment = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRONT;
  }

  if (color) {
    mask |= _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_BUFFER_BIT;
  }
  if (depth) {
    mask |= _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_BUFFER_BIT;
  }
  if (stencil) {
    mask |= _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BUFFER_BIT;
  }

  if (deleteSrcFramebuffer || deleteDstFramebuffer) {
    // Either source or destiantion was a texture object, which is wrapped in a Framebuffer objecgt as color attachment.
    // Overwrite the mask to `COLOR_BUFFER_BIT`
    if (mask & (_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_BUFFER_BIT | _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_BUFFER_BIT)) {
      mask = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_BUFFER_BIT;
      _utils__WEBPACK_IMPORTED_MODULE_9__["log"].warn('Blitting from or into a Texture object, forcing mask to GL.COLOR_BUFFER_BIT')();
    }
  }
  Object(_utils__WEBPACK_IMPORTED_MODULE_9__["assert"])(mask);

  sourceX1 = sourceX1 === undefined ? srcFramebuffer.width : sourceX1;
  sourceY1 = sourceY1 === undefined ? srcFramebuffer.height : sourceY1;
  targetX1 = targetX1 === undefined ? width : targetX1;
  targetY1 = targetY1 === undefined ? height : targetY1;

  const prevDrawHandle = gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DRAW_FRAMEBUFFER, handle);
  const prevReadHandle = gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.READ_FRAMEBUFFER, srcFramebuffer.handle);
  gl.readBuffer(sourceAttachment);
  gl.blitFramebuffer(
    sourceX0,
    sourceY0,
    sourceX1,
    sourceY1,
    targetX0,
    targetY0,
    targetX1,
    targetY1,
    mask,
    filter
  );
  gl.readBuffer(readBuffer);
  gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.READ_FRAMEBUFFER, prevReadHandle || null);
  gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DRAW_FRAMEBUFFER, prevDrawHandle || null);
  if (deleteSrcFramebuffer) {
    srcFramebuffer.delete();
  }
  if (deleteDstFramebuffer) {
    dstFramebuffer.delete();
  }

  return dstFramebuffer;
}

// Helper methods

function getFramebuffer(source) {
  if (!(source instanceof _framebuffer__WEBPACK_IMPORTED_MODULE_2__["default"])) {
    return {framebuffer: Object(_webgl_utils_texture_utils__WEBPACK_IMPORTED_MODULE_8__["toFramebuffer"])(source), deleteFramebuffer: true};
  }
  return {framebuffer: source, deleteFramebuffer: false};
}

function getPixelArray(pixelArray, type, format, width, height) {
  if (pixelArray) {
    return pixelArray;
  }
  // Allocate pixel array if not already available, using supplied type
  type = type || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE;
  const ArrayType = Object(_webgl_utils_typed_array_utils__WEBPACK_IMPORTED_MODULE_6__["getTypedArrayFromGLType"])(type, {clamped: false});
  const components = Object(_webgl_utils_format_utils__WEBPACK_IMPORTED_MODULE_7__["glFormatToComponents"])(format);
  // TODO - check for composite type (components = 1).
  return new ArrayType(width * height * components);
}


/***/ }),

/***/ "../webgl/src/classes/framebuffer.js":
/*!*******************************************!*\
  !*** ../webgl/src/classes/framebuffer.js ***!
  \*******************************************/
/*! exports provided: default, FRAMEBUFFER_ATTACHMENT_PARAMETERS */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Framebuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FRAMEBUFFER_ATTACHMENT_PARAMETERS", function() { return FRAMEBUFFER_ATTACHMENT_PARAMETERS; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resource */ "../webgl/src/classes/resource.js");
/* harmony import */ var _texture_2d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./texture-2d */ "../webgl/src/classes/texture-2d.js");
/* harmony import */ var _renderbuffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./renderbuffer */ "../webgl/src/classes/renderbuffer.js");
/* harmony import */ var _clear__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./clear */ "../webgl/src/classes/clear.js");
/* harmony import */ var _copy_and_blit_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./copy-and-blit.js */ "../webgl/src/classes/copy-and-blit.js");
/* harmony import */ var _features__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../features */ "../webgl/src/features/index.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");














const ERR_MULTIPLE_RENDERTARGETS = 'Multiple render targets not supported';

class Framebuffer extends _resource__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static isSupported(
    gl,
    {
      colorBufferFloat, // Whether floating point textures can be rendered and read
      colorBufferHalfFloat // Whether half float textures can be rendered and read
    } = {}
  ) {
    let supported = true;

    if (colorBufferFloat) {
      supported = Boolean(
        // WebGL 2
        gl.getExtension('EXT_color_buffer_float') ||
          // WebGL 1, not exposed on all platforms
          gl.getExtension('WEBGL_color_buffer_float') ||
          // WebGL 1, implicitly enables float render targets https://www.khronos.org/registry/webgl/extensions/OES_texture_float/
          gl.getExtension('OES_texture_float')
      );
    }

    if (colorBufferHalfFloat) {
      supported =
        supported &&
        Boolean(
          // WebGL 2
          gl.getExtension('EXT_color_buffer_float') ||
            // WebGL 1
            gl.getExtension('EXT_color_buffer_half_float')
        );
    }

    return supported;
  }

  // Create a Framebuffer wrapper for the default framebuffer (target === null)
  static getDefaultFramebuffer(gl) {
    gl.luma = gl.luma || {};
    gl.luma.defaultFramebuffer =
      gl.luma.defaultFramebuffer ||
      new Framebuffer(gl, {
        id: 'default-framebuffer',
        handle: null,
        attachments: {}
      });
    // TODO - can we query for and get a handle to the GL.FRONT renderbuffer?
    return gl.luma.defaultFramebuffer;
  }

  get MAX_COLOR_ATTACHMENTS() {
    return this.gl.getParameter(this.gl.MAX_COLOR_ATTACHMENTS);
  }

  get MAX_DRAW_BUFFERS() {
    return this.gl.getParameter(this.gl.MAX_DRAW_BUFFERS);
  }

  constructor(gl, opts = {}) {
    super(gl, opts);

    // Public members
    this.width = null;
    this.height = null;
    this.attachments = {};
    this.readBuffer = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0;
    this.drawBuffers = [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0];
    this.ownResources = [];
    this.initialize(opts);

    Object.seal(this);
  }

  get color() {
    return this.attachments[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0] || null;
  }

  get texture() {
    return this.attachments[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0] || null;
  }

  get depth() {
    return (
      this.attachments[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_ATTACHMENT] || this.attachments[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_STENCIL_ATTACHMENT] || null
    );
  }

  get stencil() {
    return (
      this.attachments[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_ATTACHMENT] ||
      this.attachments[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_STENCIL_ATTACHMENT] ||
      null
    );
  }

  initialize({
    width = 1,
    height = 1,
    attachments = null,
    color = true,
    depth = true,
    stencil = false,
    check = true,
    readBuffer,
    drawBuffers
  }) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(width >= 0 && height >= 0, 'Width and height need to be integers');

    // Store actual width and height for diffing
    this.width = width;
    this.height = height;

    // Resize any provided attachments - note that resize only resizes if needed
    // Note: A framebuffer has no separate size, it is defined by its attachments (which must agree)
    if (attachments) {
      for (const attachment in attachments) {
        const target = attachments[attachment];
        const object = Array.isArray(target) ? target[0] : target;
        object.resize({width, height});
      }
    } else {
      // Create any requested default attachments
      attachments = this._createDefaultAttachments(color, depth, stencil, width, height);
    }

    this.update({clearAttachments: true, attachments, readBuffer, drawBuffers});

    // Checks that framebuffer was properly set up, if not, throws an explanatory error
    if (attachments && check) {
      this.checkStatus();
    }
  }

  delete() {
    for (const resource of this.ownResources) {
      resource.delete();
    }
    super.delete();
  }
  update({
    attachments = {},
    readBuffer,
    drawBuffers,
    clearAttachments = false,
    resizeAttachments = true
  }) {
    this.attach(attachments, {clearAttachments, resizeAttachments});

    const {gl} = this;
    // Multiple render target support, set read buffer and draw buffers
    const prevHandle = gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, this.handle);
    if (readBuffer) {
      this._setReadBuffer(readBuffer);
    }
    if (drawBuffers) {
      this._setDrawBuffers(drawBuffers);
    }
    gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, prevHandle || null);

    return this;
  }

  // Attachment resize is expected to be a noop if size is same
  resize({width, height} = {}) {
    // for default framebuffer, just update the stored size
    if (this.handle === null) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(width === undefined && height === undefined);
      this.width = this.gl.drawingBufferWidth;
      this.height = this.gl.drawingBufferHeight;
      return this;
    }

    if (width === undefined) {
      width = this.gl.drawingBufferWidth;
    }
    if (height === undefined) {
      height = this.gl.drawingBufferHeight;
    }

    if (width !== this.width && height !== this.height) {
      _utils__WEBPACK_IMPORTED_MODULE_8__["log"].log(2, `Resizing framebuffer ${this.id} to ${width}x${height}`)();
    }
    for (const attachmentPoint in this.attachments) {
      this.attachments[attachmentPoint].resize({width, height});
    }
    this.width = width;
    this.height = height;
    return this;
  }

  // Attach from a map of attachments
  attach(attachments, {clearAttachments = false, resizeAttachments = true} = {}) {
    const newAttachments = {};

    // Any current attachments need to be removed, add null values to map
    if (clearAttachments) {
      Object.keys(this.attachments).forEach(key => {
        newAttachments[key] = null;
      });
    }

    // Overlay the new attachments
    Object.assign(newAttachments, attachments);

    const prevHandle = this.gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, this.handle);

    // Walk the attachments
    for (const key in newAttachments) {
      // Ensure key is not undefined
      Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(key !== undefined, 'Misspelled framebuffer binding point?');

      const attachment = Number(key);

      const descriptor = newAttachments[attachment];
      let object = descriptor;
      if (!object) {
        this._unattach(attachment);
      } else if (object instanceof _renderbuffer__WEBPACK_IMPORTED_MODULE_3__["default"]) {
        this._attachRenderbuffer({attachment, renderbuffer: object});
      } else if (Array.isArray(descriptor)) {
        const [texture, layer = 0, level = 0] = descriptor;
        object = texture;
        this._attachTexture({attachment, texture, layer, level});
      } else {
        this._attachTexture({attachment, texture: object, layer: 0, level: 0});
      }

      // Resize objects
      if (resizeAttachments && object) {
        object.resize({width: this.width, height: this.height});
      }
    }

    this.gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, prevHandle || null);

    // Assign to attachments and remove any nulls to get a clean attachment map
    Object.assign(this.attachments, attachments);
    Object.keys(this.attachments)
      .filter(key => !this.attachments[key])
      .forEach(key => {
        delete this.attachments[key];
      });
  }

  checkStatus() {
    const {gl} = this;
    const status = this.getStatus();
    if (status !== gl.FRAMEBUFFER_COMPLETE) {
      throw new Error(_getFrameBufferStatus(status));
    }
    return this;
  }

  getStatus() {
    const {gl} = this;
    const prevHandle = gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, this.handle);
    const status = gl.checkFramebufferStatus(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER);
    gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, prevHandle || null);
    return status;
  }

  clear({color, depth, stencil, drawBuffers = []} = {}) {
    // Bind framebuffer and delegate to global clear functions
    const prevHandle = this.gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, this.handle);

    if (color || depth || stencil) {
      Object(_clear__WEBPACK_IMPORTED_MODULE_4__["clear"])(this.gl, {color, depth, stencil});
    }

    drawBuffers.forEach((value, drawBuffer) => {
      Object(_clear__WEBPACK_IMPORTED_MODULE_4__["clearBuffer"])({drawBuffer, value});
    });

    this.gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, prevHandle || null);

    return this;
  }

  // NOTE: Slow requires roundtrip to GPU
  // App can provide pixelArray or have it auto allocated by this method
  // @returns {Uint8Array|Uint16Array|FloatArray} - pixel array,
  //  newly allocated by this method unless provided by app.
  readPixels(opts = {}) {
    _utils__WEBPACK_IMPORTED_MODULE_8__["log"].error(
      'Framebuffer.readPixels() is no logner supported, use readPixelsToArray(framebuffer)'
    )();
    return null;
  }

  // Reads data into provided buffer object asynchronously
  // This function doesn't wait for copy to be complete, it programs GPU to perform a DMA transffer.
  readPixelsToBuffer(opts = {}) {
    _utils__WEBPACK_IMPORTED_MODULE_8__["log"].error(
      'Framebuffer.readPixelsToBuffer()is no logner supported, use readPixelsToBuffer(framebuffer)'
    )();
    return null;
  }

  // Reads pixels as a dataUrl
  copyToDataUrl(opts = {}) {
    _utils__WEBPACK_IMPORTED_MODULE_8__["log"].error(
      'Framebuffer.copyToDataUrl() is no logner supported, use copyToDataUrl(framebuffer)'
    )();
    return null;
  }

  // Reads pixels into an HTML Image
  copyToImage(opts = {}) {
    _utils__WEBPACK_IMPORTED_MODULE_8__["log"].error('Framebuffer.copyToImage() is no logner supported, use copyToImage(framebuffer)')();
    return null;
  }

  // copyToFramebuffer({width, height}) {
  //   const scaleX = width / this.width;
  //   const scaleY = height / this.height;
  //   const scale = Math.min(scaleX, scaleY);
  //   width = width * scale;
  //   height = height * scale;
  //   const scaledFramebuffer = new Framebuffer(this.gl, {width, height});
  //   this.blit();
  // }

  // Copy a rectangle from a framebuffer attachment into a texture (at an offset)
  // NOTE: assumes texture has enough storage allocated
  // eslint-disable-next-line complexity
  copyToTexture(opts = {}) {
    _utils__WEBPACK_IMPORTED_MODULE_8__["log"].error(
      'Framebuffer.copyToTexture({...}) is no logner supported, use copyToTexture(source, target, opts})'
    )();
    return null;
  }

  // WEBGL2 INTERFACE

  // Copies a rectangle of pixels between framebuffers
  // eslint-disable-next-line complexity
  blit(opts = {}) {
    _utils__WEBPACK_IMPORTED_MODULE_8__["log"].error('Framebuffer.blit({...}) is no logner supported, use blit(source, target, opts)')();
    return null;
  }

  // signals to the GL that it need not preserve all pixels of a specified region of the framebuffer
  invalidate({attachments = [], x = 0, y = 0, width, height}) {
    const {gl} = this;
    Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_7__["assertWebGL2Context"])(gl);
    const prevHandle = gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.READ_FRAMEBUFFER, this.handle);
    const invalidateAll = x === 0 && y === 0 && width === undefined && height === undefined;
    if (invalidateAll) {
      gl.invalidateFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.READ_FRAMEBUFFER, attachments);
    } else {
      gl.invalidateFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.READ_FRAMEBUFFER, attachments, x, y, width, height);
    }
    gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.READ_FRAMEBUFFER, prevHandle);
    return this;
  }

  // Return the value for `pname` of the specified attachment.
  // The type returned is the type of the requested pname
  getAttachmentParameter(attachment, pname, keys) {
    let value = this._getAttachmentParameterFallback(pname);
    if (value === null) {
      this.gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, this.handle);
      value = this.gl.getFramebufferAttachmentParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, attachment, pname);
      this.gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, null);
    }
    if (keys && value > 1000) {
      value = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_7__["getKey"])(this.gl, value);
    }
    return value;
  }

  getAttachmentParameters(
    attachment = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0,
    keys,
    parameters = this.constructor.ATTACHMENT_PARAMETERS || []
  ) {
    const values = {};
    for (const pname of parameters) {
      const key = keys ? Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_7__["getKey"])(this.gl, pname) : pname;
      values[key] = this.getAttachmentParameter(attachment, pname, keys);
    }
    return values;
  }

  getParameters(keys = true) {
    const attachments = Object.keys(this.attachments);
    // if (this === this.gl.luma.defaultFramebuffer) {
    //   attachments = [GL.COLOR_ATTACHMENT0, GL.DEPTH_STENCIL_ATTACHMENT];
    // }
    const parameters = {};
    for (const attachmentName of attachments) {
      const attachment = Number(attachmentName);
      const key = keys ? Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_7__["getKey"])(this.gl, attachment) : attachment;
      parameters[key] = this.getAttachmentParameters(attachment, keys);
    }
    return parameters;
  }

  // DEBUG

  // Note: Will only work when called in an event handler
  show() {
    /* global window */
    if (typeof window !== 'undefined') {
      window.open(Object(_copy_and_blit_js__WEBPACK_IMPORTED_MODULE_5__["copyToDataUrl"])(this), 'luma-debug-texture');
    }
    return this;
  }

  log(priority = 0, message = '') {
    if (priority > _utils__WEBPACK_IMPORTED_MODULE_8__["log"].priority || typeof window === 'undefined') {
      return this;
    }
    message = message || `Framebuffer ${this.id}`;
    const image = Object(_copy_and_blit_js__WEBPACK_IMPORTED_MODULE_5__["copyToDataUrl"])(this, {maxHeight: 100});
    _utils__WEBPACK_IMPORTED_MODULE_8__["log"].image({priority, message, image}, message)();
    return this;
  }

  // WEBGL INTERFACE
  bind({target = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER} = {}) {
    this.gl.bindFramebuffer(target, this.handle);
    return this;
  }

  unbind({target = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER} = {}) {
    this.gl.bindFramebuffer(target, null);
    return this;
  }

  // PRIVATE METHODS

  _createDefaultAttachments(color, depth, stencil, width, height) {
    let defaultAttachments = null;

    // Add a color buffer if requested and not supplied
    if (color) {
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0] = new _texture_2d__WEBPACK_IMPORTED_MODULE_2__["default"](this.gl, {
        id: `${this.id}-color0`,
        pixels: null, // reserves texture memory, but texels are undefined
        format: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA,
        type: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE,
        width,
        height,
        // Note: Mipmapping can be disabled by texture resource when we resize the texture
        // to a non-power-of-two dimenstion (NPOT texture) under WebGL1. To have consistant
        // behavior we always disable mipmaps.
        mipmaps: false,
        // Set MIN and MAG filtering parameters so mipmaps are not used in sampling.
        // Use LINEAR so subpixel algos like fxaa work.
        // Set WRAP modes that support NPOT textures too.
        parameters: {
          [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MIN_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINEAR,
          [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MAG_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINEAR,
          [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_WRAP_S]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CLAMP_TO_EDGE,
          [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_WRAP_T]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CLAMP_TO_EDGE
        }
      });
      // track to delete later
      this.ownResources.push(defaultAttachments[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0]);
    }

    if (depth && stencil) {
      // TODO - handle separate stencil
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_STENCIL_ATTACHMENT] = new _renderbuffer__WEBPACK_IMPORTED_MODULE_3__["default"](this.gl, {
        id: `${this.id}-depth-stencil`,
        format: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH24_STENCIL8,
        width,
        height: 111
      });
      // track to delete later
      this.ownResources.push(defaultAttachments[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_STENCIL_ATTACHMENT]);
      // TODO - optional texture
      // new Texture2D(this.gl, {
      //   id: `${this.id}-depth-stencil`,
      //   format: GL.DEPTH24_STENCIL8,
      //   dataFormat: GL.DEPTH_STENCIL,
      //   type: GL.UNSIGNED_INT_24_8,
      //   width,
      //   height,
      //   mipmaps: false
      // });
    } else if (depth) {
      // Add a depth buffer if requested and not supplied
      defaultAttachments = defaultAttachments || {};
      defaultAttachments[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_ATTACHMENT] = new _renderbuffer__WEBPACK_IMPORTED_MODULE_3__["default"](this.gl, {
        id: `${this.id}-depth`,
        format: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_COMPONENT16,
        width,
        height
      });
      // track to delete later
      this.ownResources.push(defaultAttachments[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_ATTACHMENT]);
    } else if (stencil) {
      // TODO - handle separate stencil
      Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(false);
    }

    return defaultAttachments;
  }

  _unattach(attachment) {
    const oldAttachment = this.attachments[attachment];
    if (!oldAttachment) {
      return;
    }
    if (oldAttachment instanceof _renderbuffer__WEBPACK_IMPORTED_MODULE_3__["default"]) {
      // render buffer
      this.gl.framebufferRenderbuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, attachment, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERBUFFER, null);
    } else {
      // Must be a texture attachment
      this.gl.framebufferTexture2D(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, attachment, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_2D, null, 0);
    }
    delete this.attachments[attachment];
  }

  _attachRenderbuffer({attachment = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0, renderbuffer}) {
    const {gl} = this;
    // TODO - is the bind needed?
    // gl.bindRenderbuffer(GL.RENDERBUFFER, renderbuffer.handle);
    gl.framebufferRenderbuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, attachment, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERBUFFER, renderbuffer.handle);
    // TODO - is the unbind needed?
    // gl.bindRenderbuffer(GL.RENDERBUFFER, null);

    this.attachments[attachment] = renderbuffer;
  }

  // layer = 0 - index into Texture2DArray and Texture3D or face for `TextureCubeMap`
  // level = 0 - mipmapLevel (must be 0 in WebGL1)
  _attachTexture({attachment = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0, texture, layer, level}) {
    const {gl} = this;
    gl.bindTexture(texture.target, texture.handle);

    switch (texture.target) {
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_2D_ARRAY:
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_3D:
        gl.framebufferTextureLayer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, attachment, texture.target, level, layer);
        break;

      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_CUBE_MAP:
        // layer must be a cubemap face (or if index, converted to cube map face)
        const face = mapIndexToCubeMapFace(layer);
        gl.framebufferTexture2D(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, attachment, face, texture.handle, level);
        break;

      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_2D:
        gl.framebufferTexture2D(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, attachment, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_2D, texture.handle, level);
        break;

      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(false, 'Illegal texture type');
    }

    gl.bindTexture(texture.target, null);
    this.attachments[attachment] = texture;
  }

  // Expects framebuffer to be bound
  _setReadBuffer(readBuffer) {
    const {gl} = this;
    if (Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_7__["isWebGL2"])(gl)) {
      gl.readBuffer(readBuffer);
    } else {
      // Setting to color attachment 0 is a noop, so allow it in WebGL1
      Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(
        readBuffer === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0 || readBuffer === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BACK,
        ERR_MULTIPLE_RENDERTARGETS
      );
    }
    this.readBuffer = readBuffer;
  }

  // Expects framebuffer to be bound
  _setDrawBuffers(drawBuffers) {
    const {gl} = this;
    if (Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_7__["isWebGL2"])(gl)) {
      gl.drawBuffers(drawBuffers);
    } else {
      const ext = gl.getExtension('WEBGL.draw_buffers');
      if (ext) {
        ext.drawBuffersWEBGL(drawBuffers);
      } else {
        // Setting a single draw buffer to color attachment 0 is a noop, allow in WebGL1
        Object(_utils__WEBPACK_IMPORTED_MODULE_8__["assert"])(
          drawBuffers.length === 1 &&
            (drawBuffers[0] === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0 || drawBuffers[0] === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BACK),
          ERR_MULTIPLE_RENDERTARGETS
        );
      }
    }
    this.drawBuffers = drawBuffers;
  }

  // Attempt to provide workable defaults for WebGL2 symbols under WebGL1
  // null means OK to query
  // TODO - move to webgl1 polyfills
  /* eslint-disable complexity */
  _getAttachmentParameterFallback(pname) {
    const caps = Object(_features__WEBPACK_IMPORTED_MODULE_6__["getFeatures"])(this.gl);

    switch (pname) {
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER: // GLint
        return !caps.webgl2 ? 0 : null;
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_RED_SIZE: // GLint
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE: // GLint
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE: // GLint
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE: // GLint
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE: // GLint
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE: // GLint
        return !caps.webgl2 ? 8 : null;
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE: // GLenum
        return !caps.webgl2 ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_INT : null;
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING:
        return !caps.webgl2 && !caps.EXT_sRGB ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINEAR : null;
      default:
        return null;
    }
  }
  /* eslint-enable complexity */

  // RESOURCE METHODS

  _createHandle() {
    return this.gl.createFramebuffer();
  }

  _deleteHandle() {
    this.gl.deleteFramebuffer(this.handle);
  }

  _bindHandle(handle) {
    return this.gl.bindFramebuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER, handle);
  }
}

// PUBLIC METHODS

// Map an index to a cube map face constant
function mapIndexToCubeMapFace(layer) {
  // TEXTURE_CUBE_MAP_POSITIVE_X is a big value (0x8515)
  // if smaller assume layer is index, otherwise assume it is already a cube map face constant
  return layer < _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_CUBE_MAP_POSITIVE_X ? layer + _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_CUBE_MAP_POSITIVE_X : layer;
}

// Helper METHODS
// Get a string describing the framebuffer error if installed
function _getFrameBufferStatus(status) {
  // Use error mapping if installed
  const STATUS = Framebuffer.STATUS || {};
  return STATUS[status] || `Framebuffer error ${status}`;
}

const FRAMEBUFFER_ATTACHMENT_PARAMETERS = [
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME, // WebGLRenderbuffer or WebGLTexture
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE, // GL.RENDERBUFFER, GL.TEXTURE, GL.NONE
  // GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE, // GL.TEXTURE_CUBE_MAP_POSITIVE_X, etc.
  // GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL, // GLint
  // EXT_sRGB or WebGL2
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING, // GL.LINEAR, GL.SRBG
  // WebGL2
  // GL.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER, // GLint
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_RED_SIZE, // GLint
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE, // GLint
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE, // GLint
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE, // GLint
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE, // GLint
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE // GLint
  // GL.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE
  // GL.FLOAT, GL.INT, GL.UNSIGNED_INT, GL.SIGNED_NORMALIZED, OR GL.UNSIGNED_NORMALIZED.
];

Framebuffer.ATTACHMENT_PARAMETERS = FRAMEBUFFER_ATTACHMENT_PARAMETERS;


/***/ }),

/***/ "../webgl/src/classes/program-configuration.js":
/*!*****************************************************!*\
  !*** ../webgl/src/classes/program-configuration.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ProgramConfiguration; });
/* harmony import */ var _accessor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./accessor */ "../webgl/src/classes/accessor.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl-utils/attribute-utils */ "../webgl/src/webgl-utils/attribute-utils.js");
// Contains metadata describing attribute configurations for a program's shaders
// Much of this is automatically extracted from shaders after program linking




class ProgramConfiguration {
  constructor(program) {
    this.id = program.id;
    this.attributeInfos = [];
    this.attributeInfosByName = {};

    // Locations may not be contiguous the case of matrix attributes
    // so keep a separate location->attribute map.
    this.attributeInfosByLocation = [];
    this.varyingInfos = [];
    this.varyingInfosByName = {};
    Object.seal(this);
    this._readAttributesFromProgram(program);
    this._readVaryingsFromProgram(program);
  }

  getAttributeInfo(locationOrName) {
    const location = Number(locationOrName);
    if (Number.isFinite(location)) {
      return this.attributeInfosByLocation[location];
    }
    return this.attributeInfosByName[locationOrName] || null;
  }

  // Resolves an attribute name or index to an index
  getAttributeLocation(locationOrName) {
    const attributeInfo = this.getAttributeInfo(locationOrName);
    return attributeInfo ? attributeInfo.location : -1;
  }

  getAttributeAccessor(locationOrName) {
    const attributeInfo = this.getAttributeInfo(locationOrName);
    return attributeInfo ? attributeInfo.accessor : null;
  }

  getVaryingInfo(locationOrName) {
    const location = Number(locationOrName);
    if (Number.isFinite(location)) {
      return this.varyingInfos[location];
    }
    return this.varyingInfosByName[locationOrName] || null;
  }

  getVaryingIndex(locationOrName) {
    const varying = this.getVaryingInfo();
    return varying ? varying.location : -1;
  }

  getVaryingAccessor(locationOrName) {
    const varying = this.getVaryingInfo();
    return varying ? varying.accessor : null;
  }

  // PRIVATE METHODS

  // linkProgram needs to have been called, although linking does not need to have been successful
  _readAttributesFromProgram(program) {
    const {gl} = program;
    const count = gl.getProgramParameter(program.handle, gl.ACTIVE_ATTRIBUTES);

    for (let index = 0; index < count; index++) {
      const {name, type, size} = gl.getActiveAttrib(program.handle, index);
      const location = gl.getAttribLocation(program.handle, name);
      // Add only user provided attributes, for built-in attributes like
      // `gl_InstanceID` locaiton will be < 0
      if (location >= 0) {
        this._addAttribute(location, name, type, size);
      }
    }

    this.attributeInfos.sort((a, b) => a.location - b.location);
  }

  // linkProgram needs to have been called, although linking does not need to have been successful
  _readVaryingsFromProgram(program) {
    const {gl} = program;
    if (!Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl)) {
      return;
    }

    const count = gl.getProgramParameter(program.handle, gl.TRANSFORM_FEEDBACK_VARYINGS);
    for (let location = 0; location < count; location++) {
      const {name, type, size} = gl.getTransformFeedbackVarying(program.handle, location);
      this._addVarying(location, name, type, size);
    }

    this.varyingInfos.sort((a, b) => a.location - b.location);
  }

  _addAttribute(location, name, compositeType, size) {
    const {type, components} = Object(_webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_2__["decomposeCompositeGLType"])(compositeType);
    const accessor = {type, size: size * components};
    this._inferProperties(location, name, accessor);

    const attributeInfo = {location, name, accessor: new _accessor__WEBPACK_IMPORTED_MODULE_0__["default"](accessor)}; // Base values
    this.attributeInfos.push(attributeInfo);
    this.attributeInfosByLocation[location] = attributeInfo; // For quick location based lookup
    this.attributeInfosByName[attributeInfo.name] = attributeInfo; // For quick name based lookup
  }

  // Extract additional attribute metadata from shader names (based on attribute naming conventions)
  _inferProperties(location, name, accessor) {
    if (/instance/i.test(name)) {
      // Any attribute containing the word "instance" will be assumed to be instanced
      accessor.divisor = 1;
    }
  }

  _addVarying(location, name, compositeType, size) {
    const {type, components} = Object(_webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_2__["decomposeCompositeGLType"])(compositeType);
    const accessor = new _accessor__WEBPACK_IMPORTED_MODULE_0__["default"]({type, size: size * components});

    const varying = {location, name, accessor}; // Base values
    this.varyingInfos.push(varying);
    this.varyingInfosByName[varying.name] = varying; // For quick name based lookup
  }
}


/***/ }),

/***/ "../webgl/src/classes/program.js":
/*!***************************************!*\
  !*** ../webgl/src/classes/program.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Program; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resource */ "../webgl/src/classes/resource.js");
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./texture */ "../webgl/src/classes/texture.js");
/* harmony import */ var _framebuffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./framebuffer */ "../webgl/src/classes/framebuffer.js");
/* harmony import */ var _uniforms__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./uniforms */ "../webgl/src/classes/uniforms.js");
/* harmony import */ var _shader__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shader */ "../webgl/src/classes/shader.js");
/* harmony import */ var _program_configuration__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./program-configuration */ "../webgl/src/classes/program-configuration.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../context */ "../webgl/src/context/index.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../webgl-utils/attribute-utils */ "../webgl/src/webgl-utils/attribute-utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");















const LOG_PROGRAM_PERF_PRIORITY = 4;

const GL_SEPARATE_ATTRIBS = 0x8c8d;

const V6_DEPRECATED_METHODS = [
  'setVertexArray',
  'setAttributes',
  'setBuffers',
  'unsetBuffers',

  'use',
  'getUniformCount',
  'getUniformInfo',
  'getUniformLocation',
  'getUniformValue',

  'getVarying',
  'getFragDataLocation',
  'getAttachedShaders',
  'getAttributeCount',
  'getAttributeLocation',
  'getAttributeInfo'
];

class Program extends _resource__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(gl, props = {}) {
    super(gl, props);

    this.stubRemovedMethods('Program', 'v6.0', V6_DEPRECATED_METHODS);

    // Experimental flag to avoid deleting Program object while it is cached
    this._isCached = false;

    this.initialize(props);

    Object.seal(this);

    this._setId(props.id);
  }

  initialize(props = {}) {
    const {hash, vs, fs, varyings, bufferMode = GL_SEPARATE_ATTRIBS} = props;

    this.hash = hash || ''; // Used by ProgramManager

    // Create shaders if needed
    this.vs =
      typeof vs === 'string' ? new _shader__WEBPACK_IMPORTED_MODULE_5__["VertexShader"](this.gl, {id: `${props.id}-vs`, source: vs}) : vs;
    this.fs =
      typeof fs === 'string' ? new _shader__WEBPACK_IMPORTED_MODULE_5__["FragmentShader"](this.gl, {id: `${props.id}-fs`, source: fs}) : fs;
    Object(_utils__WEBPACK_IMPORTED_MODULE_10__["assert"])(this.vs instanceof _shader__WEBPACK_IMPORTED_MODULE_5__["VertexShader"]);
    Object(_utils__WEBPACK_IMPORTED_MODULE_10__["assert"])(this.fs instanceof _shader__WEBPACK_IMPORTED_MODULE_5__["FragmentShader"]);

    // uniforms
    this.uniforms = {};

    // Setup varyings if supplied
    if (varyings && varyings.length > 0) {
      Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_8__["assertWebGL2Context"])(this.gl);
      this.varyings = varyings;
      this.gl.transformFeedbackVaryings(this.handle, varyings, bufferMode);
    }

    this._compileAndLink();
    this._readUniformLocationsFromLinkedProgram();
    this.configuration = new _program_configuration__WEBPACK_IMPORTED_MODULE_6__["default"](this);

    return this.setProps(props);
  }

  delete(options = {}) {
    if (this._isCached) {
      // This object is cached, do not delete
      return this;
    }
    return super.delete(options);
  }

  setProps(props) {
    if ('uniforms' in props) {
      this.setUniforms(props.uniforms);
    }
    return this;
  }

  // A good thing about the WebGL API is that there are so many ways to draw things ;)
  // This function unifies those ways into a single call using common parameters with sane defaults
  draw({
    logPriority, // Probe log priority, enables Model to do more integrated logging

    drawMode = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TRIANGLES,
    vertexCount,
    offset = 0,
    start,
    end,
    isIndexed = false,
    indexType = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_SHORT,
    isInstanced = false,
    instanceCount = 0,

    vertexArray = null,
    transformFeedback,
    framebuffer,
    parameters = {},

    // Deprecated
    uniforms,
    samplers
  }) {
    if (uniforms || samplers) {
      // DEPRECATED: v7.0 (deprecated earlier but warning not properly implemented)
      _utils__WEBPACK_IMPORTED_MODULE_10__["log"].deprecated('Program.draw({uniforms})', 'Program.setUniforms(uniforms)')();
      this.setUniforms(uniforms || {});
    }

    if (logPriority !== undefined) {
      const fb = framebuffer ? framebuffer.id : 'default';
      const message =
        `mode=${Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_8__["getKey"])(this.gl, drawMode)} verts=${vertexCount} ` +
        `instances=${instanceCount} indexType=${Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_8__["getKey"])(this.gl, indexType)} ` +
        `isInstanced=${isInstanced} isIndexed=${isIndexed} ` +
        `Framebuffer=${fb}`;
      _utils__WEBPACK_IMPORTED_MODULE_10__["log"].log(logPriority, message)();
    }

    // TODO - move vertex array binding and transform feedback binding to withParameters?
    Object(_utils__WEBPACK_IMPORTED_MODULE_10__["assert"])(vertexArray);

    this.gl.useProgram(this.handle);

    // Note: async textures set as uniforms might still be loading.
    // Now that all uniforms have been updated, check if any texture
    // in the uniforms is not yet initialized, then we don't draw
    if (!this._areTexturesRenderable()) {
      return false;
    }

    vertexArray.bindForDraw(vertexCount, instanceCount, () => {
      if (framebuffer !== undefined) {
        parameters = Object.assign({}, parameters, {framebuffer});
      }

      if (transformFeedback) {
        const primitiveMode = Object(_webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_9__["getPrimitiveDrawMode"])(drawMode);
        transformFeedback.begin(primitiveMode);
      }

      this._bindTextures();

      Object(_context__WEBPACK_IMPORTED_MODULE_7__["withParameters"])(this.gl, parameters, () => {
        // TODO - Use polyfilled WebGL2RenderingContext instead of ANGLE extension
        if (isIndexed && isInstanced) {
          this.gl.drawElementsInstanced(drawMode, vertexCount, indexType, offset, instanceCount);
        } else if (isIndexed && Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_8__["isWebGL2"])(this.gl) && !isNaN(start) && !isNaN(end)) {
          this.gl.drawRangeElements(drawMode, start, end, vertexCount, indexType, offset);
        } else if (isIndexed) {
          this.gl.drawElements(drawMode, vertexCount, indexType, offset);
        } else if (isInstanced) {
          this.gl.drawArraysInstanced(drawMode, offset, vertexCount, instanceCount);
        } else {
          this.gl.drawArrays(drawMode, offset, vertexCount);
        }
      });

      if (transformFeedback) {
        transformFeedback.end();
      }
    });

    return true;
  }

  setUniforms(uniforms = {}, _onChangeCallback = () => {}) {
    // Simple change detection - if all uniforms are unchanged, do nothing
    let somethingChanged = false;
    const changedUniforms = {};
    for (const key in uniforms) {
      if (!Object(_uniforms__WEBPACK_IMPORTED_MODULE_4__["areUniformsEqual"])(this.uniforms[key], uniforms[key])) {
        somethingChanged = true;
        changedUniforms[key] = uniforms[key];
        this.uniforms[key] = Object(_uniforms__WEBPACK_IMPORTED_MODULE_4__["getUniformCopy"])(uniforms[key]);
      }
    }

    if (somethingChanged) {
      _onChangeCallback();
      Object(_uniforms__WEBPACK_IMPORTED_MODULE_4__["checkUniformValues"])(changedUniforms, this.id, this._uniformSetters);
      this._setUniforms(changedUniforms);
    }

    return this;
  }

  // PRIVATE METHODS

  // stub for shader chache, should reset uniforms to default valiues
  reset() {}

  // Checks if all texture-values uniforms are renderable (i.e. loaded)
  // Note: This is currently done before every draw call
  _areTexturesRenderable() {
    let texturesRenderable = true;

    for (const uniformName in this.uniforms) {
      const uniformSetter = this._uniformSetters[uniformName];

      if (uniformSetter && uniformSetter.textureIndex !== undefined) {
        let uniform = this.uniforms[uniformName];

        if (uniform instanceof _framebuffer__WEBPACK_IMPORTED_MODULE_3__["default"]) {
          const framebuffer = uniform;
          uniform = framebuffer.texture;
        }

        if (uniform instanceof _texture__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          const texture = uniform;
          // Check that texture is loaded
          texturesRenderable = texturesRenderable && texture.loaded;
        }
      }
    }

    return texturesRenderable;
  }

  // Binds textures
  // Note: This is currently done before every draw call
  _bindTextures() {
    for (const uniformName in this.uniforms) {
      const uniformSetter = this._uniformSetters[uniformName];

      if (uniformSetter && uniformSetter.textureIndex !== undefined) {
        let uniform = this.uniforms[uniformName];

        if (uniform instanceof _framebuffer__WEBPACK_IMPORTED_MODULE_3__["default"]) {
          uniform = uniform.texture;
        }
        if (uniform instanceof _texture__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          const texture = uniform;
          // Bind texture to index
          texture.bind(uniformSetter.textureIndex);
        }
      }
    }
  }

  // Apply a set of uniform values to a program
  // Only uniforms actually present in the linked program will be updated.
  _setUniforms(uniforms) {
    this.gl.useProgram(this.handle);

    for (const uniformName in uniforms) {
      let uniform = uniforms[uniformName];
      const uniformSetter = this._uniformSetters[uniformName];

      if (uniformSetter) {
        if (uniform instanceof _framebuffer__WEBPACK_IMPORTED_MODULE_3__["default"]) {
          uniform = uniform.texture;
        }
        if (uniform instanceof _texture__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          // eslint-disable-next-line max-depth
          if (uniformSetter.textureIndex === undefined) {
            uniformSetter.textureIndex = this._textureIndexCounter++;
          }

          // Bind texture to index
          const texture = uniform;
          const {textureIndex} = uniformSetter;

          texture.bind(textureIndex);

          // Set the uniform sampler to the texture index
          uniformSetter(textureIndex);
        } else {
          // Just set the value
          uniformSetter(uniform);
        }
      }
    }

    return this;
  }

  // RESOURCE METHODS

  _createHandle() {
    return this.gl.createProgram();
  }

  _deleteHandle() {
    this.gl.deleteProgram(this.handle);
  }

  // Extract opts needed to initialize a `Program` from an independently created WebGLProgram handle
  _getOptionsFromHandle(handle) {
    const shaderHandles = this.gl.getAttachedShaders(handle);
    const opts = {};
    for (const shaderHandle of shaderHandles) {
      const type = this.gl.getShaderParameter(this.handle, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SHADER_TYPE);
      switch (type) {
        case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VERTEX_SHADER:
          opts.vs = new _shader__WEBPACK_IMPORTED_MODULE_5__["VertexShader"]({handle: shaderHandle});
          break;
        case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAGMENT_SHADER:
          opts.fs = new _shader__WEBPACK_IMPORTED_MODULE_5__["FragmentShader"]({handle: shaderHandle});
          break;
        default:
      }
    }
    return opts;
  }

  _getParameter(pname) {
    return this.gl.getProgramParameter(this.handle, pname);
  }

  // If program is not named, name it after shader names
  // TODO - this.id will already have been initialized
  _setId(id) {
    if (!id) {
      const programName = this._getName();
      this.id = Object(_utils__WEBPACK_IMPORTED_MODULE_10__["uid"])(programName);
    }
  }

  // Generate a default name for the program based on names of the shaders
  _getName() {
    let programName = this.vs.getName() || this.fs.getName();
    programName = programName.replace(/shader/i, '');
    programName = programName ? `${programName}-program` : 'program';
    return programName;
  }

  _compileAndLink() {
    const {gl} = this;
    gl.attachShader(this.handle, this.vs.handle);
    gl.attachShader(this.handle, this.fs.handle);
    _utils__WEBPACK_IMPORTED_MODULE_10__["log"].time(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();
    gl.linkProgram(this.handle);
    _utils__WEBPACK_IMPORTED_MODULE_10__["log"].timeEnd(LOG_PROGRAM_PERF_PRIORITY, `linkProgram for ${this._getName()}`)();

    // Avoid checking program linking error in production
    if (gl.debug || _utils__WEBPACK_IMPORTED_MODULE_10__["log"].priority > 0) {
      gl.validateProgram(this.handle);
      const linked = gl.getProgramParameter(this.handle, gl.LINK_STATUS);
      if (!linked) {
        throw new Error(`Error linking: ${gl.getProgramInfoLog(this.handle)}`);
      }
    }
  }

  // query uniform locations and build name to setter map.
  // TODO - This overlaps with ProgramConfiguration?
  _readUniformLocationsFromLinkedProgram() {
    const {gl} = this;
    this._uniformSetters = {};
    this._uniformCount = this._getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ACTIVE_UNIFORMS);
    for (let i = 0; i < this._uniformCount; i++) {
      const info = this.gl.getActiveUniform(this.handle, i);
      const {name, isArray} = Object(_uniforms__WEBPACK_IMPORTED_MODULE_4__["parseUniformName"])(info.name);
      let location = gl.getUniformLocation(this.handle, name);
      this._uniformSetters[name] = Object(_uniforms__WEBPACK_IMPORTED_MODULE_4__["getUniformSetter"])(gl, location, info, isArray);
      if (info.size > 1) {
        for (let l = 0; l < info.size; l++) {
          location = gl.getUniformLocation(this.handle, `${name}[${l}]`);
          this._uniformSetters[`${name}[${l}]`] = Object(_uniforms__WEBPACK_IMPORTED_MODULE_4__["getUniformSetter"])(gl, location, info, isArray);
        }
      }
    }
    this._textureIndexCounter = 0;
  }

  // TO BE REMOVED in v7?

  // Rretrieves information about active uniforms identifed by their indices (`uniformIndices`)
  // https://
  // developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniforms
  getActiveUniforms(uniformIndices, pname) {
    return this.gl.getActiveUniforms(this.handle, uniformIndices, pname);
  }

  // Retrieves the index of a uniform block
  getUniformBlockIndex(blockName) {
    return this.gl.getUniformBlockIndex(this.handle, blockName);
  }

  // Retrieves information about an active uniform block (`blockIndex`)
  // https://
  // developer.mozilla.org/en-US/docs/Web/API/WebGL2RenderingContext/getActiveUniformBlockParameter
  getActiveUniformBlockParameter(blockIndex, pname) {
    return this.gl.getActiveUniformBlockParameter(this.handle, blockIndex, pname);
  }

  // Binds a uniform block (`blockIndex`) to a specific binding point (`blockBinding`)
  uniformBlockBinding(blockIndex, blockBinding) {
    this.gl.uniformBlockBinding(this.handle, blockIndex, blockBinding);
  }
}


/***/ }),

/***/ "../webgl/src/classes/query.js":
/*!*************************************!*\
  !*** ../webgl/src/classes/query.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Query; });
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./resource */ "../webgl/src/classes/resource.js");
/* harmony import */ var _features__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../features */ "../webgl/src/features/index.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");
// WebGL2 Query (also handles disjoint timer extensions)
/* global requestAnimationFrame */





const GL_QUERY_RESULT = 0x8866; // Returns a GLuint containing the query result.
const GL_QUERY_RESULT_AVAILABLE = 0x8867; // whether query result is available.

const GL_TIME_ELAPSED_EXT = 0x88bf; // Elapsed time (in nanoseconds).
const GL_GPU_DISJOINT_EXT = 0x8fbb; // Whether GPU performed any disjoint operation.

const GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 0x8c88; // #primitives written to feedback buffers
const GL_ANY_SAMPLES_PASSED = 0x8c2f; // Occlusion query (if drawing passed depth test)
const GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8d6a; // Occlusion query less accurate/faster version

class Query extends _resource__WEBPACK_IMPORTED_MODULE_0__["default"] {
  // Returns true if Query is supported by the WebGL implementation
  // Can also check whether timestamp queries are available.
  static isSupported(gl, opts = []) {
    const webgl2 = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_2__["isWebGL2"])(gl);

    // Initial value
    const hasTimerQuery = Object(_features__WEBPACK_IMPORTED_MODULE_1__["hasFeatures"])(gl, _features__WEBPACK_IMPORTED_MODULE_1__["FEATURES"].TIMER_QUERY);
    let supported = webgl2 || hasTimerQuery;

    for (const key of opts) {
      switch (key) {
        case 'queries':
          supported = supported && webgl2;
          break;
        case 'timers':
          supported = supported && hasTimerQuery;
          break;
        default:
          Object(_utils__WEBPACK_IMPORTED_MODULE_3__["assert"])(false);
      }
    }

    return supported;
  }

  // Create a query class
  constructor(gl, opts = {}) {
    super(gl, opts);

    this.target = null;
    this._queryPending = false;
    this._pollingPromise = null;

    Object.seal(this);
  }

  // Shortcut for timer query (dependent on extension in both WebGL1 and 2)
  // Measures GPU time delta between this call and a matching `end` call in the
  // GPU instruction stream.
  beginTimeElapsedQuery() {
    return this.begin(GL_TIME_ELAPSED_EXT);
  }

  // Shortcut for occlusion queries
  beginOcclusionQuery({conservative = false} = {}) {
    return this.begin(conservative ? GL_ANY_SAMPLES_PASSED_CONSERVATIVE : GL_ANY_SAMPLES_PASSED);
  }

  // Shortcut for transformFeedbackQuery
  beginTransformFeedbackQuery() {
    return this.begin(GL_TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN);
  }

  // Due to OpenGL API limitations, after calling `begin()` on one Query
  // instance, `end()` must be called on that same instance before
  // calling `begin()` on another query. While there can be multiple
  // outstanding queries representing disjoint `begin()`/`end()` intervals.
  // It is not possible to interleave or overlap `begin` and `end` calls.
  begin(target) {
    // Don't start a new query if one is already active.
    if (this._queryPending) {
      return this;
    }

    this.target = target;
    this.gl.beginQuery(this.target, this.handle);

    return this;
  }

  // ends the current query
  end() {
    // Can't end a new query if the last one hasn't been resolved.
    if (this._queryPending) {
      return this;
    }

    if (this.target) {
      this.gl.endQuery(this.target);
      this.target = null;
      this._queryPending = true;
    }
    return this;
  }

  // Returns true if the query result is available
  isResultAvailable() {
    if (!this._queryPending) {
      return false;
    }

    const resultAvailable = this.gl.getQueryParameter(this.handle, GL_QUERY_RESULT_AVAILABLE);
    if (resultAvailable) {
      this._queryPending = false;
    }
    return resultAvailable;
  }

  // Timing query is disjoint, i.e. results are invalid
  isTimerDisjoint() {
    return this.gl.getParameter(GL_GPU_DISJOINT_EXT);
  }

  // Returns query result.
  getResult() {
    return this.gl.getQueryParameter(this.handle, GL_QUERY_RESULT);
  }

  // Returns the query result, converted to milliseconds to match JavaScript conventions.
  getTimerMilliseconds() {
    return this.getResult() / 1e6;
  }

  // Polls the query
  createPoll(limit = Number.POSITIVE_INFINITY) {
    if (this._pollingPromise) {
      return this._pollingPromise;
    }

    let counter = 0;

    this._pollingPromise = new Promise((resolve, reject) => {
      const poll = () => {
        if (this.isResultAvailable()) {
          resolve(this.getResult());
          this._pollingPromise = null;
        } else if (counter++ > limit) {
          reject('Timed out');
          this._pollingPromise = null;
        } else {
          requestAnimationFrame(poll);
        }
      };

      requestAnimationFrame(poll);
    });

    return this._pollingPromise;
  }

  _createHandle() {
    return Query.isSupported(this.gl) ? this.gl.createQuery() : null;
  }

  _deleteHandle() {
    this.gl.deleteQuery(this.handle);
  }
}


/***/ }),

/***/ "../webgl/src/classes/renderbuffer-formats.js":
/*!****************************************************!*\
  !*** ../webgl/src/classes/renderbuffer-formats.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);


// Define local extension strings to optimize minification
// const SRGB = 'EXT_sRGB';
// const EXT_FLOAT_WEBGL1 = 'WEBGL.color_buffer_float';
const EXT_FLOAT_WEBGL2 = 'EXT_color_buffer_float';
// const EXT_HALF_FLOAT_WEBGL1 = 'EXT_color_buffer_half_float';

// NOTE(Tarek): bpp === "bytes per pixel", used for
// memory usage calculations.
/* harmony default export */ __webpack_exports__["default"] = ({
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_COMPONENT16]: {bpp: 2}, // 16 depth bits.
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_COMPONENT24]: {gl2: true, bpp: 3},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_COMPONENT32F]: {gl2: true, bpp: 4},

  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.STENCIL_INDEX8]: {bpp: 1}, // 8 stencil bits.

  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_STENCIL]: {bpp: 4},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH24_STENCIL8]: {gl2: true, bpp: 4},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH32F_STENCIL8]: {gl2: true, bpp: 5},

  // When using a WebGL 1 context, color renderbuffer formats are limited
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA4]: {bpp: 2},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGB565]: {bpp: 2},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGB5_A1]: {bpp: 2},

  // When using a WebGL 2 context, the following values are available additionally:
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.R8]: {gl2: true, bpp: 1},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.R8UI]: {gl2: true, bpp: 1},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.R8I]: {gl2: true, bpp: 1},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.R16UI]: {gl2: true, bpp: 2},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.R16I]: {gl2: true, bpp: 2},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.R32UI]: {gl2: true, bpp: 4},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.R32I]: {gl2: true, bpp: 4},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RG8]: {gl2: true, bpp: 2},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RG8UI]: {gl2: true, bpp: 2},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RG8I]: {gl2: true, bpp: 2},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RG16UI]: {gl2: true, bpp: 4},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RG16I]: {gl2: true, bpp: 4},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RG32UI]: {gl2: true, bpp: 8},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RG32I]: {gl2: true, bpp: 8},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGB8]: {gl2: true, bpp: 3},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA8]: {gl2: true, bpp: 4},
  // [GL.SRGB8_ALPHA8]: {gl2: true, gl1: SRGB}, // When using the EXT_sRGB WebGL1 extension
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGB10_A2]: {gl2: true, bpp: 4},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA8UI]: {gl2: true, bpp: 4},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA8I]: {gl2: true, bpp: 4},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGB10_A2UI]: {gl2: true, bpp: 4},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA16UI]: {gl2: true, bpp: 8},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA16I]: {gl2: true, bpp: 8},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA32I]: {gl2: true, bpp: 16},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA32UI]: {gl2: true, bpp: 16},

  // When using a WebGL 2 context and the EXT_color_buffer_float WebGL2 extension
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.R16F]: {gl2: EXT_FLOAT_WEBGL2, bpp: 2},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RG16F]: {gl2: EXT_FLOAT_WEBGL2, bpp: 4},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA16F]: {gl2: EXT_FLOAT_WEBGL2, bpp: 8},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.R32F]: {gl2: EXT_FLOAT_WEBGL2, bpp: 4},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RG32F]: {gl2: EXT_FLOAT_WEBGL2, bpp: 8},
  // TODO - can't get WEBGL.color_buffer_float to work on renderbuffers
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA32F]: {gl2: EXT_FLOAT_WEBGL2, bpp: 16},
  // [GL.RGBA32F]: {gl2: EXT_FLOAT_WEBGL2, gl1: EXT_FLOAT_WEBGL1},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.R11F_G11F_B10F]: {gl2: EXT_FLOAT_WEBGL2, bpp: 4}
});


/***/ }),

/***/ "../webgl/src/classes/renderbuffer.js":
/*!********************************************!*\
  !*** ../webgl/src/classes/renderbuffer.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Renderbuffer; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resource */ "../webgl/src/classes/resource.js");
/* harmony import */ var _renderbuffer_formats__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderbuffer-formats */ "../webgl/src/classes/renderbuffer-formats.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");
/* eslint-disable no-inline-comments */






function isFormatSupported(gl, format, formats) {
  const info = formats[format];
  if (!info) {
    return false;
  }
  const value = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["isWebGL2"])(gl) ? info.gl2 || info.gl1 : info.gl1;
  if (typeof value === 'string') {
    return gl.getExtension(value);
  }
  return value;
}

class Renderbuffer extends _resource__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static isSupported(gl, {format} = {}) {
    return !format || isFormatSupported(gl, format, _renderbuffer_formats__WEBPACK_IMPORTED_MODULE_2__["default"]);
  }

  static getSamplesForFormat(gl, {format}) {
    // Polyfilled to return [0] under WebGL1
    return gl.getInternalformatParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERBUFFER, format, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLES);
  }

  constructor(gl, opts = {}) {
    super(gl, opts);

    this.initialize(opts);

    Object.seal(this);
  }

  // Creates and initializes a renderbuffer object's data store
  initialize({format, width = 1, height = 1, samples = 0}) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(format, 'Needs format');

    this._trackDeallocatedMemory();

    this.gl.bindRenderbuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERBUFFER, this.handle);

    if (samples !== 0 && Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["isWebGL2"])(this.gl)) {
      this.gl.renderbufferStorageMultisample(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERBUFFER, samples, format, width, height);
    } else {
      this.gl.renderbufferStorage(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERBUFFER, format, width, height);
    }

    // this.gl.bindRenderbuffer(GL.RENDERBUFFER, null);

    this.format = format;
    this.width = width;
    this.height = height;
    this.samples = samples;

    this._trackAllocatedMemory(
      this.width * this.height * (this.samples || 1) * _renderbuffer_formats__WEBPACK_IMPORTED_MODULE_2__["default"][this.format].bpp
    );

    return this;
  }

  resize({width, height}) {
    // Don't resize if width/height haven't changed
    if (width !== this.width || height !== this.height) {
      return this.initialize({width, height, format: this.format, samples: this.samples});
    }
    return this;
  }

  // PRIVATE METHODS
  _createHandle() {
    return this.gl.createRenderbuffer();
  }

  _deleteHandle() {
    this.gl.deleteRenderbuffer(this.handle);
    this._trackDeallocatedMemory();
  }

  _bindHandle(handle) {
    this.gl.bindRenderbuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERBUFFER, handle);
  }

  _syncHandle(handle) {
    this.format = this.getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERBUFFER_INTERNAL_FORMAT);
    this.width = this.getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERBUFFER_WIDTH);
    this.height = this.getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERBUFFER_HEIGHT);
    this.samples = this.getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERBUFFER_SAMPLES);
  }

  // @param {Boolean} opt.autobind=true - method call will bind/unbind object
  // @returns {GLenum|GLint} - depends on pname
  _getParameter(pname) {
    this.gl.bindRenderbuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERBUFFER, this.handle);
    const value = this.gl.getRenderbufferParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERBUFFER, pname);
    // this.gl.bindRenderbuffer(GL.RENDERBUFFER, null);
    return value;
  }
}


/***/ }),

/***/ "../webgl/src/classes/resource.js":
/*!****************************************!*\
  !*** ../webgl/src/classes/resource.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Resource; });
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../init */ "../webgl/src/init.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");




const ERR_RESOURCE_METHOD_UNDEFINED = 'Resource subclass must define virtual methods';

// TODO - Handle context loss
// function glGetContextLossCount(gl) {
//   return (gl.luma && gl.luma.glCount) || 0;
// }

class Resource {
  constructor(gl, opts = {}) {
    Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["assertWebGLContext"])(gl);

    const {id, userData = {}} = opts;
    this.gl = gl;
    // this.ext = polyfillContext(gl);
    this.id = id || Object(_utils__WEBPACK_IMPORTED_MODULE_2__["uid"])(this.constructor.name);
    this.userData = userData;
    this._bound = false;

    // Set the handle
    // If handle was provided, use it, otherwise create a new handle

    // TODO - Stores the handle with context loss information
    // this.glCount = glGetContextLossCount(this.gl);

    // Default VertexArray needs to be created with null handle, so compare against undefined
    this._handle = opts.handle;
    if (this._handle === undefined) {
      this._handle = this._createHandle();
    }

    // Only meaningful for resources that allocate GPU memory
    this.byteLength = 0;

    this._addStats();
  }

  toString() {
    return `${this.constructor.name}(${this.id})`;
  }

  get handle() {
    // TODO - Add context loss handling
    // Will regenerate and reinitialize the handle if necessary
    // const glCount = glGetContextLossCount(this.gl);
    // if (this.glCount !== glCount) {
    //   this._handle = this._createHandle(this.opts);
    //   this._glCount = glCount;
    //   // Reinitialize object
    //   this.initialize(this.opts);
    // }
    return this._handle;
  }

  delete({deleteChildren = false} = {}) {
    // Delete this object, and get refs to any children
    const children = this._handle && this._deleteHandle(this._handle);
    if (this._handle) {
      this._removeStats();
    }
    this._handle = null;

    // Optionally, recursively delete the children
    if (children && deleteChildren) {
      children.filter(Boolean).forEach(child => {
        child.delete();
      });
    }

    return this;
  }

  bind(funcOrHandle = this.handle) {
    if (typeof funcOrHandle !== 'function') {
      this._bindHandle(funcOrHandle);
      return this;
    }

    let value;

    if (!this._bound) {
      this._bindHandle(this.handle);
      this._bound = true;

      value = funcOrHandle();

      this._bound = false;
      this._bindHandle(null);
    } else {
      value = funcOrHandle();
    }

    return value;
  }

  unbind() {
    this.bind(null);
  }

  /**
   * Query a Resource parameter
   *
   * @param {GLenum} pname
   * @return {GLint|GLfloat|GLenum} param
   */
  getParameter(pname, opts = {}) {
    pname = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["getKeyValue"])(this.gl, pname);
    Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(pname);

    const parameters = this.constructor.PARAMETERS || {};

    // Use parameter definitions to handle unsupported parameters
    const parameter = parameters[pname];
    if (parameter) {
      const isWebgl2 = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(this.gl);

      // Check if we can query for this parameter
      const parameterAvailable =
        (!('webgl2' in parameter) || isWebgl2) &&
        (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

      if (!parameterAvailable) {
        const webgl1Default = parameter.webgl1;
        const webgl2Default = 'webgl2' in parameter ? parameter.webgl2 : parameter.webgl1;
        const defaultValue = isWebgl2 ? webgl2Default : webgl1Default;
        return defaultValue;
      }
    }

    // If unknown parameter - Could be a valid parameter not covered by PARAMS
    // Attempt to query for it and let WebGL report errors
    return this._getParameter(pname, opts);
  }

  // Many resources support a getParameter call -
  // getParameters will get all parameters - slow but useful for debugging
  // eslint-disable-next-line complexity
  getParameters(opts = {}) {
    const {parameters, keys} = {};

    // Get parameter definitions for this Resource
    const PARAMETERS = this.constructor.PARAMETERS || {};

    const isWebgl2 = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(this.gl);

    const values = {};

    // Query all parameters if no list provided
    const parameterKeys = parameters || Object.keys(PARAMETERS);

    // WEBGL limits
    for (const pname of parameterKeys) {
      const parameter = PARAMETERS[pname];

      // Check if this parameter is available on this platform
      const parameterAvailable =
        parameter &&
        (!('webgl2' in parameter) || isWebgl2) &&
        (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

      if (parameterAvailable) {
        const key = keys ? Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["getKey"])(this.gl, pname) : pname;
        values[key] = this.getParameter(pname, opts);
        if (keys && parameter.type === 'GLenum') {
          values[key] = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["getKey"])(this.gl, values[key]);
        }
      }
    }

    return values;
  }

  /**
   * Update a Resource setting
   *
   * @todo - cache parameter to avoid issuing WebGL calls?
   *
   * @param {GLenum} pname - parameter (GL constant, value or key)
   * @param {GLint|GLfloat|GLenum} value
   * @return {Resource} returns self to enable chaining
   */
  setParameter(pname, value) {
    pname = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["getKeyValue"])(this.gl, pname);
    Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(pname);

    const parameters = this.constructor.PARAMETERS || {};

    const parameter = parameters[pname];
    if (parameter) {
      const isWebgl2 = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(this.gl);

      // Check if this parameter is available on this platform
      const parameterAvailable =
        (!('webgl2' in parameter) || isWebgl2) &&
        (!('extension' in parameter) || this.gl.getExtension(parameter.extension));

      if (!parameterAvailable) {
        throw new Error('Parameter not available on this platform');
      }

      // Handle string keys
      if (parameter.type === 'GLenum') {
        value = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["getKeyValue"])(value);
      }
    }

    // If unknown parameter - Could be a valid parameter not covered by PARAMS
    // attempt to set it and let WebGL report errors
    this._setParameter(pname, value);
    return this;
  }

  /*
   * Batch update resource parameters
   * Assumes the subclass supports a setParameter call
   */
  setParameters(parameters) {
    for (const pname in parameters) {
      this.setParameter(pname, parameters[pname]);
    }
    return this;
  }

  // Install stubs for removed methods
  stubRemovedMethods(className, version, methodNames) {
    return Object(_utils__WEBPACK_IMPORTED_MODULE_2__["stubRemovedMethods"])(this, className, version, methodNames);
  }

  // PUBLIC VIRTUAL METHODS
  initialize(opts) {}

  // PROTECTED METHODS - These must be overridden by subclass
  _createHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _deleteHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _bindHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _getOptsFromHandle() {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  _getParameter(pname, opts) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  /**
   * @param {GLenum} pname
   * @param {GLint|GLfloat|GLenum} param
   * @return {Sampler} returns self to enable chaining
   */
  _setParameter(pname, value) {
    throw new Error(ERR_RESOURCE_METHOD_UNDEFINED);
  }

  // PRIVATE METHODS

  _context() {
    this.gl.luma = this.gl.luma || {};
    return this.gl.luma;
  }

  _addStats() {
    const name = this.constructor.name;
    const stats = _init__WEBPACK_IMPORTED_MODULE_0__["lumaStats"].get('Resource Counts');

    stats.get('Resources Created').incrementCount();
    stats.get(`${name}s Created`).incrementCount();
    stats.get(`${name}s Active`).incrementCount();
  }

  _removeStats() {
    const name = this.constructor.name;
    const stats = _init__WEBPACK_IMPORTED_MODULE_0__["lumaStats"].get('Resource Counts');

    stats.get(`${name}s Active`).decrementCount();
  }

  _trackAllocatedMemory(bytes, name = this.constructor.name) {
    const stats = _init__WEBPACK_IMPORTED_MODULE_0__["lumaStats"].get('Memory Usage');

    stats.get('GPU Memory').addCount(bytes);
    stats.get(`${name} Memory`).addCount(bytes);
    this.byteLength = bytes;
  }

  _trackDeallocatedMemory(name = this.constructor.name) {
    const stats = _init__WEBPACK_IMPORTED_MODULE_0__["lumaStats"].get('Memory Usage');

    stats.get('GPU Memory').subtractCount(this.byteLength);
    stats.get(`${name} Memory`).subtractCount(this.byteLength);
    this.byteLength = 0;
  }
}


/***/ }),

/***/ "../webgl/src/classes/shader.js":
/*!**************************************!*\
  !*** ../webgl/src/classes/shader.js ***!
  \**************************************/
/*! exports provided: Shader, VertexShader, FragmentShader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shader", function() { return Shader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexShader", function() { return VertexShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FragmentShader", function() { return FragmentShader; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _glsl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../glsl-utils */ "../webgl/src/glsl-utils/index.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./resource */ "../webgl/src/classes/resource.js");






const ERR_SOURCE = 'Shader: GLSL source code must be a JavaScript string';

// For now this is an internal class
class Shader extends _resource__WEBPACK_IMPORTED_MODULE_4__["default"] {
  static getTypeName(shaderType) {
    switch (shaderType) {
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VERTEX_SHADER:
        return 'vertex-shader';
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAGMENT_SHADER:
        return 'fragment-shader';
      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_3__["assert"])(false);
        return 'unknown';
    }
  }

  /* eslint-disable max-statements */
  constructor(gl, props) {
    Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_2__["assertWebGLContext"])(gl);

    // Validate arguments
    Object(_utils__WEBPACK_IMPORTED_MODULE_3__["assert"])(typeof props.source === 'string', ERR_SOURCE);

    // Deduce an id, from shader source, or supplied id, or shader type
    const id =
      Object(_glsl_utils__WEBPACK_IMPORTED_MODULE_1__["getShaderName"])(props.source, null) ||
      props.id ||
      Object(_utils__WEBPACK_IMPORTED_MODULE_3__["uid"])(`unnamed ${Shader.getTypeName(props.shaderType)}`);

    super(gl, {id});

    this.shaderType = props.shaderType;
    this.source = props.source;

    this.initialize(props);
  }

  initialize({source}) {
    const shaderName = Object(_glsl_utils__WEBPACK_IMPORTED_MODULE_1__["getShaderName"])(source, null);
    if (shaderName) {
      this.id = Object(_utils__WEBPACK_IMPORTED_MODULE_3__["uid"])(shaderName);
    }
    this._compile(source);
  }

  // Accessors

  getParameter(pname) {
    return this.gl.getShaderParameter(this.handle, pname);
  }

  toString() {
    return `${Shader.getTypeName(this.shaderType)}:${this.id}`;
  }

  getName() {
    return Object(_glsl_utils__WEBPACK_IMPORTED_MODULE_1__["getShaderName"])(this.source) || 'unnamed-shader';
  }

  getSource() {
    return this.gl.getShaderSource(this.handle);
  }

  // Debug method - Returns translated source if available
  getTranslatedSource() {
    const extension = this.gl.getExtension('WEBGL.debug_shaders');
    return extension
      ? extension.getTranslatedShaderSource(this.handle)
      : 'No translated source available. WEBGL.debug_shaders not implemented';
  }

  // PRIVATE METHODS
  _compile(source = this.source) {
    if (!source.startsWith('#version ')) {
      source = `#version 100\n${source}`;
    }
    this.source = source;
    this.gl.shaderSource(this.handle, this.source);
    this.gl.compileShader(this.handle);

    // TODO - For performance reasons, avoid checking shader compilation errors on production?
    // TODO - Load log even when no error reported, to catch warnings?
    // https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings
    const compileStatus = this.getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COMPILE_STATUS);
    if (!compileStatus) {
      const infoLog = this.gl.getShaderInfoLog(this.handle);
      const {shaderName, errors, warnings} = Object(_glsl_utils__WEBPACK_IMPORTED_MODULE_1__["parseGLSLCompilerError"])(
        infoLog,
        this.source,
        this.shaderType,
        this.id
      );
      _utils__WEBPACK_IMPORTED_MODULE_3__["log"].error(`GLSL compilation errors in ${shaderName}\n${errors}`)();
      _utils__WEBPACK_IMPORTED_MODULE_3__["log"].warn(`GLSL compilation warnings in ${shaderName}\n${warnings}`)();
      throw new Error(`GLSL compilation errors in ${shaderName}`);
    }
  }

  _deleteHandle() {
    this.gl.deleteShader(this.handle);
  }

  _getOptsFromHandle() {
    return {
      type: this.getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SHADER_TYPE),
      source: this.getSource()
    };
  }
}

class VertexShader extends Shader {
  constructor(gl, props) {
    // Signature: new VertexShader(gl, source)
    if (typeof props === 'string') {
      props = {source: props};
    }
    super(gl, Object.assign({}, props, {shaderType: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VERTEX_SHADER}));
  }

  // PRIVATE METHODS
  _createHandle() {
    return this.gl.createShader(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VERTEX_SHADER);
  }
}

class FragmentShader extends Shader {
  constructor(gl, props) {
    // Signature: new FragmentShader(gl, source)
    if (typeof props === 'string') {
      props = {source: props};
    }

    super(gl, Object.assign({}, props, {shaderType: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAGMENT_SHADER}));
  }

  // PRIVATE METHODS
  _createHandle() {
    return this.gl.createShader(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FRAGMENT_SHADER);
  }
}


/***/ }),

/***/ "../webgl/src/classes/texture-2d.js":
/*!******************************************!*\
  !*** ../webgl/src/classes/texture-2d.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Texture2D; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./texture */ "../webgl/src/classes/texture.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _utils_load_file__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/load-file */ "../webgl/src/utils/load-file.js");





class Texture2D extends _texture__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static isSupported(gl, opts) {
    return _texture__WEBPACK_IMPORTED_MODULE_1__["default"].isSupported(gl, opts);
  }

  constructor(gl, props = {}) {
    Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_2__["assertWebGLContext"])(gl);

    // Signature: new Texture2D(gl, url | Promise)
    if (props instanceof Promise || typeof props === 'string') {
      props = {data: props};
    }

    // Signature: new Texture2D(gl, {data: url})
    if (typeof props.data === 'string') {
      props = Object.assign({}, props, {data: Object(_utils_load_file__WEBPACK_IMPORTED_MODULE_3__["loadImage"])(props.data)});
    }

    super(gl, Object.assign({}, props, {target: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_2D}));

    this.initialize(props);

    Object.seal(this);
  }
}


/***/ }),

/***/ "../webgl/src/classes/texture-3d.js":
/*!******************************************!*\
  !*** ../webgl/src/classes/texture-3d.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Texture3D; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../context */ "../webgl/src/context/index.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./texture */ "../webgl/src/classes/texture.js");
/* harmony import */ var _texture_formats__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./texture-formats */ "../webgl/src/classes/texture-formats.js");
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./buffer */ "../webgl/src/classes/buffer.js");







class Texture3D extends _texture__WEBPACK_IMPORTED_MODULE_3__["default"] {
  static isSupported(gl) {
    return Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_2__["isWebGL2"])(gl);
  }

  constructor(gl, props = {}) {
    Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_2__["assertWebGL2Context"])(gl);
    props = Object.assign({depth: 1}, props, {target: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_3D, unpackFlipY: false});
    super(gl, props);
    this.initialize(props);

    Object.seal(this);
  }

  // Image 3D copies from Typed Array or WebGLBuffer
  setImageData({
    level = 0,
    dataFormat = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA,
    width,
    height,
    depth = 1,
    border = 0,
    format,
    type = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE,
    offset = 0,
    data,
    parameters = {}
  }) {
    this._trackDeallocatedMemory('Texture');

    this.gl.bindTexture(this.target, this.handle);

    Object(_context__WEBPACK_IMPORTED_MODULE_1__["withParameters"])(this.gl, parameters, () => {
      if (ArrayBuffer.isView(data)) {
        this.gl.texImage3D(
          this.target,
          level,
          dataFormat,
          width,
          height,
          depth,
          border,
          format,
          type,
          data
        );
      }

      if (data instanceof _buffer__WEBPACK_IMPORTED_MODULE_5__["default"]) {
        this.gl.bindBuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.PIXEL_UNPACK_BUFFER, data.handle);
        this.gl.texImage3D(
          this.target,
          level,
          dataFormat,
          width,
          height,
          depth,
          border,
          format,
          type,
          offset
        );
      }
    });

    if (data && data.byteLength) {
      this._trackAllocatedMemory(data.byteLength, 'Texture');
    } else {
      // NOTE(Tarek): Default to RGBA bytes
      const channels = _texture_formats__WEBPACK_IMPORTED_MODULE_4__["DATA_FORMAT_CHANNELS"][this.dataFormat] || 4;
      const channelSize = _texture_formats__WEBPACK_IMPORTED_MODULE_4__["TYPE_SIZES"][this.type] || 1;

      this._trackAllocatedMemory(
        this.width * this.height * this.depth * channels * channelSize,
        'Texture'
      );
    }

    this.loaded = true;

    return this;
  }
}


/***/ }),

/***/ "../webgl/src/classes/texture-cube.js":
/*!********************************************!*\
  !*** ../webgl/src/classes/texture-cube.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TextureCube; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./texture */ "../webgl/src/classes/texture.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");





const FACES = [
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_CUBE_MAP_POSITIVE_X,
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_CUBE_MAP_NEGATIVE_X,
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_CUBE_MAP_POSITIVE_Y,
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_CUBE_MAP_NEGATIVE_Y,
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_CUBE_MAP_POSITIVE_Z,
  _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_CUBE_MAP_NEGATIVE_Z
];

class TextureCube extends _texture__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(gl, props = {}) {
    Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_2__["assertWebGLContext"])(gl);

    super(gl, Object.assign({}, props, {target: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_CUBE_MAP}));

    this.initialize(props);

    Object.seal(this);
  }

  /* eslint-disable max-len, max-statements */
  initialize(props = {}) {
    const {mipmaps = true, parameters = {}} = props;

    // Store props for accessors
    this.opts = props;

    this.setCubeMapImageData(props).then(() => {
      this.loaded = true;

      // TODO - should genMipmap() be called on the cubemap or on the faces?
      // TODO - without generateMipmap() cube textures do not work at all!!! Why?
      if (mipmaps) {
        this.generateMipmap(props);
      }

      this.setParameters(parameters);
    });
  }

  subImage({face, data, x = 0, y = 0, mipmapLevel = 0}) {
    return this._subImage({target: face, data, x, y, mipmapLevel});
  }

  /* eslint-disable max-statements, max-len */
  async setCubeMapImageData({
    width,
    height,
    pixels,
    data,
    border = 0,
    format = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA,
    type = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE
  }) {
    const {gl} = this;
    const imageDataMap = pixels || data;

    // pixel data (imageDataMap) is an Object from Face to Image or Promise.
    // For example:
    // {
    // GL.TEXTURE_CUBE_MAP_POSITIVE_X : Image-or-Promise,
    // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : Image-or-Promise,
    // ... }
    // To provide multiple level-of-details (LODs) this can be Face to Array
    // of Image or Promise, like this
    // {
    // GL.TEXTURE_CUBE_MAP_POSITIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],
    // GL.TEXTURE_CUBE_MAP_NEGATIVE_X : [Image-or-Promise-LOD-0, Image-or-Promise-LOD-1],
    // ... }

    const resolvedFaces = await Promise.all(
      FACES.map(face => {
        const facePixels = imageDataMap[face];
        return Promise.all(Array.isArray(facePixels) ? facePixels : [facePixels]);
      })
    );

    this.bind();

    FACES.forEach((face, index) => {
      if (resolvedFaces[index].length > 1 && this.opts.mipmaps !== false) {
        // If the user provides multiple LODs, then automatic mipmap
        // generation generateMipmap() should be disabled to avoid overwritting them.
        _utils__WEBPACK_IMPORTED_MODULE_3__["log"].warn(`${this.id} has mipmap and multiple LODs.`)();
      }
      resolvedFaces[index].forEach((image, lodLevel) => {
        // TODO: adjust width & height for LOD!
        if (width && height) {
          gl.texImage2D(face, lodLevel, format, width, height, border, format, type, image);
        } else {
          gl.texImage2D(face, lodLevel, format, format, type, image);
        }
      });
    });

    this.unbind();
  }

  // TODO: update this method to accept LODs
  setImageDataForFace(options) {
    const {
      face,
      width,
      height,
      pixels,
      data,
      border = 0,
      format = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA,
      type = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE
      // generateMipmap = false // TODO
    } = options;

    const {gl} = this;

    const imageData = pixels || data;

    this.bind();
    if (imageData instanceof Promise) {
      imageData.then(resolvedImageData =>
        this.setImageDataForFace(
          Object.assign({}, options, {
            face,
            data: resolvedImageData,
            pixels: resolvedImageData
          })
        )
      );
    } else if (this.width || this.height) {
      gl.texImage2D(face, 0, format, width, height, border, format, type, imageData);
    } else {
      gl.texImage2D(face, 0, format, format, type, imageData);
    }

    return this;
  }
}

TextureCube.FACES = FACES;


/***/ }),

/***/ "../webgl/src/classes/texture-formats.js":
/*!***********************************************!*\
  !*** ../webgl/src/classes/texture-formats.js ***!
  \***********************************************/
/*! exports provided: TEXTURE_FORMATS, DATA_FORMAT_CHANNELS, TYPE_SIZES, isFormatSupported, isLinearFilteringSupported */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXTURE_FORMATS", function() { return TEXTURE_FORMATS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DATA_FORMAT_CHANNELS", function() { return DATA_FORMAT_CHANNELS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TYPE_SIZES", function() { return TYPE_SIZES; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFormatSupported", function() { return isFormatSupported; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isLinearFilteringSupported", function() { return isLinearFilteringSupported; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");



// const S3TC = 'WEBGL_compressed_texture_s3tc';
// const PVRTC = 'WEBGL_compressed_texture_pvrtc';
// const ES3 = 'WEBGL_compressed_texture_es3';
// const ETC1 = 'WEBGL_compressed_texture_etc1';
// const SRGB = 'EXT_sRGB';
// const DEPTH = 'WEBGL_depth_texture';

// Legal combinations for internalFormat, format and type
const TEXTURE_FORMATS = {
  // Unsized texture format - more performance
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGB]: {dataFormat: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGB, types: [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_SHORT_5_6_5]},
  // TODO: format: GL.RGBA type: GL.FLOAT is supported in WebGL1 when 'OES_texure_float' is suported
  // we need to update this table structure to specify extensions (gl1: 'OES_texure_float', gl2: false) for each type.
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA]: {
    dataFormat: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA,
    types: [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_SHORT_4_4_4_4, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_SHORT_5_5_5_1]
  },
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ALPHA]: {dataFormat: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ALPHA, types: [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE]},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LUMINANCE]: {dataFormat: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LUMINANCE, types: [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE]},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LUMINANCE_ALPHA]: {dataFormat: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LUMINANCE_ALPHA, types: [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE]},

  // 32 bit floats
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.R32F]: {dataFormat: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RED, types: [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT], gl2: true},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RG32F]: {dataFormat: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RG, types: [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT], gl2: true},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGB32F]: {dataFormat: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGB, types: [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT], gl2: true},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA32F]: {dataFormat: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA, types: [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT], gl2: true}

  // [GL.DEPTH_COMPONENT]: {types: [GL.UNSIGNED_SHORT, GL.UNSIGNED_INT, GL.UNSIGNED_INT_24_8], gl1: DEPTH},
  // [GL.DEPTH_STENCIL]: {gl1: DEPTH},

  // Sized texture format - more performance
  // R
  // [GL.R8]: {dataFormat: GL.RED, types: [GL.UNSIGNED_BYTE], gl2: true},
  // [GL.R16F]: {dataFormat: GL.RED, types: [GL.HALF_FLOAT, GL.FLOAT], gl2: true},
  // [GL.R8UI]: {dataFormat: GL.RED_INTEGER, types: [GL.UNSIGNED_BYTE], gl2: true},
  // // RG
  // [GL.RG8]: {dataFormat: GL.RG, types: [GL.UNSIGNED_BYTE], gl2: true},
  // [GL.RG16F]: {dataFormat: GL.RG, types: [GL.HALF_FLOAT, GL.FLOAT], gl2: true},
  // [GL.RG8UI]: {dataFormat: GL.RG_INTEGER, types: [GL.UNSIGNED_BYTE], gl2: true},
  // // RGB
  // [GL.RGB8]: {dataFormat: GL.RGB, types: [GL.UNSIGNED_BYTE], gl2: true, gl1: SRGB},
  // [GL.SRGB8]: {dataFormat: GL.RGB, types: [GL.UNSIGNED_BYTE], gl2: true, gl1: SRGB},
  // [GL.RGB565]: {dataFormat: GL.RGB, types: [GL.UNSIGNED_BYTE, GL.UNSIGNED_SHORT_5_6_5], gl2: true},
  // [GL.R11F_G11F_B10F]: {dataFormat: GL.RGB, types: [GL.UNSIGNED_INT_10F_11F_11F_REV, GL.HALF_FLOAT, GL.FLOAT], gl2: true},
  // [GL.RGB9_E5]: {dataFormat: GL.RGB, types: [GL.HALF_FLOAT, GL.FLOAT], gl2: true, gl1: 'WEBGL_color_buffer_half_float'},
  // [GL.RGB16F]: {dataFormat: GL.RGB, types: [GL.HALF_FLOAT, GL.FLOAT], gl2: true, gl1: 'WEBGL_color_buffer_float'},
  // [GL.RGB8UI]: {dataFormat: GL.RGB_INTEGER, types: [GL.UNSIGNED_BYTE], gl2: true},
  // // RGBA
  // [GL.RGBA8]: {dataFormat: GL.RGBA, types: [GL.UNSIGNED_BYTE], gl2: true, gl1: SRGB},
  // [GL.SRGB8_ALPHA8]: {dataFormat: GL.RGBA, types: [GL.UNSIGNED_BYTE], gl2: true, gl1: SRGB},
  // [GL.RGB5_A1]: {dataFormat: GL.RGBA, types: [GL.UNSIGNED_BYTE, GL.UNSIGNED_SHORT_5_5_5_1], gl2: true},
  // [GL.RGBA4]: {dataFormat: GL.RGBA, types: [GL.UNSIGNED_BYTE, GL.UNSIGNED_SHORT_4_4_4_4], gl2: true},
  // [GL.RGBA16F]: {dataFormat: GL.RGBA, types: [GL.HALF_FLOAT, GL.FLOAT], gl2: true},
  // [GL.RGBA8UI]: {dataFormat: GL.RGBA_INTEGER, types: [GL.UNSIGNED_BYTE], gl2: true}

  // Compressed formats

  // WEBGL_compressed_texture_s3tc

  // [GL.COMPRESSED_RGB_S3TC_DXT1_EXT]: {compressed: true, gl1: S3TC},
  // [GL.COMPRESSED_RGBA_S3TC_DXT1_EXT]: {compressed: true, gl1: S3TC},
  // [GL.COMPRESSED_RGBA_S3TC_DXT3_EXT]: {compressed: true, gl1: S3TC},
  // [GL.COMPRESSED_RGBA_S3TC_DXT5_EXT]: {compressed: true, gl1: S3TC},

  // WEBGL_compressed_texture_es3

  // [GL.COMPRESSED_R11_EAC]: {compressed: true, gl1: ES3}, // RED
  // [GL.COMPRESSED_SIGNED_R11_EAC]: {compressed: true, gl1: ES3}, // RED
  // [GL.COMPRESSED_RG11_EAC]: {compressed: true, gl1: ES3}, // RG
  // [GL.COMPRESSED_SIGNED_RG11_EAC]: {compressed: true, gl1: ES3}, // RG
  // [GL.COMPRESSED_RGB8_ETC2]: {compressed: true, gl1: ES3}, // RGB
  // [GL.COMPRESSED_RGBA8_ETC2_EAC]: {compressed: true, gl1: ES3}, // RBG
  // [GL.COMPRESSED_SRGB8_ETC2]: {compressed: true, gl1: ES3}, // RGB
  // [GL.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC]: {compressed: true, gl1: ES3}, // RGBA
  // [GL.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2]: {compressed: true, gl1: ES3}, // RGBA
  // [GL.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2]: {compressed: true, gl1: ES3}, // RGBA
  /* WebGL2 guaranteed availability compressed formats?
  COMPRESSED_R11_EAC RED
  COMPRESSED_SIGNED_R11_EAC RED
  COMPRESSED_RG11_EAC RG
  COMPRESSED_SIGNED_RG11_EAC RG
  COMPRESSED_RGB8_ETC2 RGB
  COMPRESSED_SRGB8_ETC2 RGB
  COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA
  COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA
  COMPRESSED_RGBA8_ETC2_EAC RGBA
  COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
  */

  // WEBGL_compressed_texture_pvrtc

  // [GL.COMPRESSED_RGB_PVRTC_4BPPV1_IMG]: {compressed: true, gl1: PVRTC},
  // [GL.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG]: {compressed: true, gl1: PVRTC},
  // [GL.COMPRESSED_RGB_PVRTC_2BPPV1_IMG]: {compressed: true, gl1: PVRTC},
  // [GL.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG]: {compressed: true, gl1: PVRTC},

  // WEBGL_compressed_texture_etc1

  // [GL.COMPRESSED_RGB_ETC1_WEBGL]: {compressed: true, gl1: ETC1},

  // WEBGL_compressed_texture_atc

  // [GL.COMPRESSED_RGB_ATC_WEBGL]: {compressed: true, gl1: ETC1},
  // [GL.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL]: {compressed: true, gl1: ETC1},
  // [GL.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL]: {compressed: true, gl1: ETC1}
};

const DATA_FORMAT_CHANNELS = {
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RED]: 1,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RED_INTEGER]: 1,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RG]: 2,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RG_INTEGER]: 2,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGB]: 3,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGB_INTEGER]: 3,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA]: 4,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA_INTEGER]: 4,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_COMPONENT]: 1,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.DEPTH_STENCIL]: 1,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ALPHA]: 1,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LUMINANCE]: 1,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LUMINANCE_ALPHA]: 2
};

const TYPE_SIZES = {
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT]: 4,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_INT]: 4,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.INT]: 4,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_SHORT]: 2,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SHORT]: 2,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.HALF_FLOAT]: 2,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BYTE]: 1,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE]: 1
};

function isFormatSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];
  if (!info) {
    return false;
  }
  if (info.gl1 === undefined && info.gl2 === undefined) {
    // No info - always supported
    return true;
  }
  const value = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl) ? info.gl2 || info.gl1 : info.gl1;
  return typeof value === 'string' ? gl.getExtension(value) : value;
}

function isLinearFilteringSupported(gl, format) {
  const info = TEXTURE_FORMATS[format];
  switch (info && info.types[0]) {
    // Both WebGL1 and WebGL2?
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT:
      return gl.getExtension('OES_texture_float_linear');
    // Not in WebGL2?
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.HALF_FLOAT:
      return gl.getExtension('OES_texture_half_float_linear');
    default:
      return true;
  }
}


/***/ }),

/***/ "../webgl/src/classes/texture.js":
/*!***************************************!*\
  !*** ../webgl/src/classes/texture.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Texture; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resource */ "../webgl/src/classes/resource.js");
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buffer */ "../webgl/src/classes/buffer.js");
/* harmony import */ var _texture_formats__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./texture-formats */ "../webgl/src/classes/texture-formats.js");
/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../context */ "../webgl/src/context/index.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");










// Supported min filters for NPOT texture.
const NPOT_MIN_FILTERS = [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINEAR, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.NEAREST];

class Texture extends _resource__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static isSupported(gl, {format, linearFiltering} = {}) {
    let supported = true;
    if (format) {
      supported = supported && Object(_texture_formats__WEBPACK_IMPORTED_MODULE_3__["isFormatSupported"])(gl, format);
      supported = supported && (!linearFiltering || Object(_texture_formats__WEBPACK_IMPORTED_MODULE_3__["isLinearFilteringSupported"])(gl, format));
    }
    return supported;
  }

  // target cannot be modified by bind:
  // textures are special because when you first bind them to a target,
  // they get special information. When you first bind a texture as a
  // GL_TEXTURE_2D, you are actually setting special state in the texture.
  // You are saying that this texture is a 2D texture.
  // And it will always be a 2D texture; this state cannot be changed ever.
  // If you have a texture that was first bound as a GL_TEXTURE_2D,
  // you must always bind it as a GL_TEXTURE_2D;
  // attempting to bind it as GL_TEXTURE_1D will give rise to an error
  // (while run-time).
  constructor(gl, props) {
    const {
      id = Object(_utils__WEBPACK_IMPORTED_MODULE_6__["uid"])('texture'),
      handle,
      target
      // , magFilter, minFilter, wrapS, wrapT
    } = props;

    super(gl, {id, handle});

    this.target = target;
    this.textureUnit = undefined;

    // Program.draw() checks the loaded flag of all textures to avoid
    // Textures that are still loading from promises
    // Set to true as soon as texture has been initialized with valid data
    this.loaded = false;

    this.width = undefined;
    this.height = undefined;
    this.depth = undefined;
    this.format = undefined;
    this.type = undefined;
    this.dataFormat = undefined;
    this.border = undefined;
    this.textureUnit = undefined;
    this.mipmaps = undefined;
  }

  toString() {
    return `Texture(${this.id},${this.width}x${this.height})`;
  }

  /* eslint-disable max-len, max-statements */
  initialize(props = {}) {
    let data = props.data;

    if (data instanceof Promise) {
      data.then(resolvedImageData =>
        this.initialize(
          Object.assign({}, props, {
            pixels: resolvedImageData,
            data: resolvedImageData
          })
        )
      );
      return this;
    }

    const {
      pixels = null,
      format = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA,
      border = 0,
      recreate = false,
      parameters = {},
      pixelStore = {},
      textureUnit = undefined,
      // Deprecated parameters
      unpackFlipY = true
    } = props;

    let {mipmaps = true} = props;

    // pixels variable is for API compatibility purpose
    if (!data) {
      // TODO - This looks backwards? Commenting out for now until we decide
      // which prop to use
      // log.deprecated('data', 'pixels')();
      data = pixels;
    }

    let {width, height, dataFormat, type} = props;
    const {depth = 0} = props;

    // Deduce width and height
    ({width, height, dataFormat, type} = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed: false,
      data,
      width,
      height
    }));

    // Store opts for accessors
    this.width = width;
    this.height = height;
    this.depth = depth;
    this.format = format;
    this.type = type;
    this.dataFormat = dataFormat;
    this.border = border;
    this.textureUnit = textureUnit;

    if (Number.isFinite(this.textureUnit)) {
      this.gl.activeTexture(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE0 + this.textureUnit);
      this.gl.bindTexture(this.target, this.handle);
    }

    // Note: luma.gl defaults to GL.UNPACK_FLIP_Y_WEBGL = true;
    // TODO - compare v4 and v3
    const DEFAULT_TEXTURE_SETTINGS = {
      // Pixel store
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_FLIP_Y_WEBGL]: unpackFlipY
    };
    const glSettings = Object.assign({}, DEFAULT_TEXTURE_SETTINGS, pixelStore);

    if (mipmaps && this._isNPOT()) {
      _utils__WEBPACK_IMPORTED_MODULE_6__["log"].warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();
      mipmaps = false;

      this._updateForNPOT(parameters);
    }

    this.mipmaps = mipmaps;

    this.setImageData({
      data,
      width,
      height,
      depth,
      format,
      type,
      dataFormat,
      border,
      mipmaps,
      parameters: glSettings
    });

    if (mipmaps) {
      this.generateMipmap();
    }

    // Set texture sampler parameters
    this.setParameters(parameters);

    // TODO - Store data to enable auto recreate on context loss
    if (recreate) {
      this.data = data;
    }

    return this;
  }

  // If size has changed, reinitializes with current format
  // note clears image and mipmaps
  resize({height, width, mipmaps = false}) {
    if (width !== this.width || height !== this.height) {
      return this.initialize({
        width,
        height,
        format: this.format,
        type: this.type,
        dataFormat: this.dataFormat,
        border: this.border,
        mipmaps
      });
    }
    return this;
  }

  // Call to regenerate mipmaps after modifying texture(s)
  generateMipmap(params = {}) {
    if (this._isNPOT()) {
      _utils__WEBPACK_IMPORTED_MODULE_6__["log"].warn(`texture: ${this} is Non-Power-Of-Two, disabling mipmaping`)();
      return this;
    }

    this.mipmaps = true;

    this.gl.bindTexture(this.target, this.handle);
    Object(_context__WEBPACK_IMPORTED_MODULE_4__["withParameters"])(this.gl, params, () => {
      this.gl.generateMipmap(this.target);
    });
    this.gl.bindTexture(this.target, null);
    return this;
  }

  /*
   * Allocates storage
   * @param {*} pixels -
   *  null - create empty texture of specified format
   *  Typed array - init from image data in typed array
   *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer
   *  HTMLImageElement|Image - Inits with content of image. Auto width/height
   *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height
   *  HTMLVideoElement - Creates video texture. Auto width/height
   *
   * @param {GLint} width -
   * @param {GLint} height -
   * @param {GLint} mipMapLevel -
   * @param {GLenum} format - format of image data.
   * @param {GLenum} type
   *  - format of array (autodetect from type) or
   *  - (WEBGL2) format of buffer
   * @param {Number} offset - (WEBGL2) offset from start of buffer
   * @param {GLint} border - must be 0.
   * @parameters - temporary settings to be applied, can be used to supply pixel store settings.
   */
  /* eslint-disable max-len, max-statements, complexity */
  setImageData(options) {
    this._trackDeallocatedMemory('Texture');

    const {
      target = this.target,
      pixels = null,
      level = 0,
      format = this.format,
      border = this.border,
      offset = 0,
      parameters = {}
    } = options;

    let {
      data = null,
      type = this.type,
      width = this.width,
      height = this.height,
      dataFormat = this.dataFormat,
      compressed = false
    } = options;

    // pixels variable is  for API compatibility purpose
    if (!data) {
      data = pixels;
    }

    ({type, dataFormat, compressed, width, height} = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));

    const {gl} = this;
    gl.bindTexture(this.target, this.handle);

    let dataType = null;
    ({data, dataType} = this._getDataType({data, compressed}));

    Object(_context__WEBPACK_IMPORTED_MODULE_4__["withParameters"])(this.gl, parameters, () => {
      switch (dataType) {
        case 'null':
          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
          break;
        case 'typed-array':
          // Looks like this assert is not necessary, as offset is ignored under WebGL1
          // assert((offset === 0 || isWebGL2(gl)), 'offset supported in WebGL2 only');
          gl.texImage2D(
            target,
            level,
            format,
            width,
            height,
            border,
            dataFormat,
            type,
            data,
            offset
          );
          break;
        case 'buffer':
          // WebGL2 enables creating textures directly from a WebGL buffer
          Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_5__["assertWebGL2Context"])(gl);
          gl.bindBuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.PIXEL_UNPACK_BUFFER, data.handle || data);
          gl.texImage2D(target, level, format, width, height, border, dataFormat, type, offset);
          gl.bindBuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.PIXEL_UNPACK_BUFFER, null);
          break;
        case 'browser-object':
          if (Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_5__["isWebGL2"])(gl)) {
            gl.texImage2D(target, level, format, width, height, border, dataFormat, type, data);
          } else {
            gl.texImage2D(target, level, format, dataFormat, type, data);
          }
          break;
        case 'compressed':
          gl.compressedTexImage2D(target, level, format, width, height, border, data);
          break;
        default:
          Object(_utils__WEBPACK_IMPORTED_MODULE_6__["assert"])(false, 'Unknown image data type');
      }
    });

    if (data && data.byteLength) {
      this._trackAllocatedMemory(data.byteLength, 'Texture');
    } else {
      // NOTE(Tarek): Default to RGBA bytes
      const channels = _texture_formats__WEBPACK_IMPORTED_MODULE_3__["DATA_FORMAT_CHANNELS"][this.dataFormat] || 4;
      const channelSize = _texture_formats__WEBPACK_IMPORTED_MODULE_3__["TYPE_SIZES"][this.type] || 1;

      this._trackAllocatedMemory(this.width * this.height * channels * channelSize, 'Texture');
    }

    this.loaded = true;

    return this;
  }
  /* eslint-enable max-len, max-statements, complexity */

  /**
   * Redefines an area of an existing texture
   * Note: does not allocate storage
   */
  /*
   * Redefines an area of an existing texture
   * @param {*} pixels, data -
   *  null - create empty texture of specified format
   *  Typed array - init from image data in typed array
   *  Buffer|WebGLBuffer - (WEBGL2) init from image data in WebGLBuffer
   *  HTMLImageElement|Image - Inits with content of image. Auto width/height
   *  HTMLCanvasElement - Inits with contents of canvas. Auto width/height
   *  HTMLVideoElement - Creates video texture. Auto width/height
   *
   * @param {GLint} x - xOffset from where texture to be updated
   * @param {GLint} y - yOffset from where texture to be updated
   * @param {GLint} width - width of the sub image to be updated
   * @param {GLint} height - height of the sub image to be updated
   * @param {GLint} level - mip level to be updated
   * @param {GLenum} format - internal format of image data.
   * @param {GLenum} type
   *  - format of array (autodetect from type) or
   *  - (WEBGL2) format of buffer or ArrayBufferView
   * @param {GLenum} dataFormat - format of image data.
   * @param {Number} offset - (WEBGL2) offset from start of buffer
   * @param {GLint} border - must be 0.
   * @parameters - temporary settings to be applied, can be used to supply pixel store settings.
   */
  setSubImageData({
    target = this.target,
    pixels = null,
    data = null,
    x = 0,
    y = 0,
    width = this.width,
    height = this.height,
    level = 0,
    format = this.format,
    type = this.type,
    dataFormat = this.dataFormat,
    compressed = false,
    offset = 0,
    border = this.border,
    parameters = {}
  }) {
    ({type, dataFormat, compressed, width, height} = this._deduceParameters({
      format,
      type,
      dataFormat,
      compressed,
      data,
      width,
      height
    }));

    Object(_utils__WEBPACK_IMPORTED_MODULE_6__["assert"])(this.depth === 0, 'texSubImage not supported for 3D textures');

    // pixels variable is  for API compatibility purpose
    if (!data) {
      data = pixels;
    }

    // Support ndarrays
    if (data && data.data) {
      const ndarray = data;
      data = ndarray.data;
      width = ndarray.shape[0];
      height = ndarray.shape[1];
    }

    // Support buffers
    if (data instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      data = data.handle;
    }

    this.gl.bindTexture(this.target, this.handle);

    Object(_context__WEBPACK_IMPORTED_MODULE_4__["withParameters"])(this.gl, parameters, () => {
      // TODO - x,y parameters
      if (compressed) {
        this.gl.compressedTexSubImage2D(target, level, x, y, width, height, format, data);
      } else if (data === null) {
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, null);
      } else if (ArrayBuffer.isView(data)) {
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data, offset);
      } else if (data instanceof _webgl_utils__WEBPACK_IMPORTED_MODULE_5__["WebGLBuffer"]) {
        // WebGL2 allows us to create texture directly from a WebGL buffer
        Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_5__["assertWebGL2Context"])(this.gl);
        // This texImage2D signature uses currently bound GL.PIXEL_UNPACK_BUFFER
        this.gl.bindBuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.PIXEL_UNPACK_BUFFER, data);
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, offset);
        this.gl.bindBuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.PIXEL_UNPACK_BUFFER, null);
      } else if (Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_5__["isWebGL2"])(this.gl)) {
        // Assume data is a browser supported object (ImageData, Canvas, ...)
        this.gl.texSubImage2D(target, level, x, y, width, height, dataFormat, type, data);
      } else {
        this.gl.texSubImage2D(target, level, x, y, dataFormat, type, data);
      }
    });

    this.gl.bindTexture(this.target, null);
  }
  /* eslint-enable max-len, max-statements, complexity */

  /**
   * Defines a two-dimensional texture image or cube-map texture image with
   * pixels from the current framebuffer (rather than from client memory).
   * (gl.copyTexImage2D wrapper)
   *
   * Note that binding a texture into a Framebuffer's color buffer and
   * rendering can be faster.
   */
  copyFramebuffer(opts = {}) {
    _utils__WEBPACK_IMPORTED_MODULE_6__["log"].error(
      'Texture.copyFramebuffer({...}) is no logner supported, use copyToTexture(source, target, opts})'
    )();
    return null;
  }

  getActiveUnit() {
    return this.gl.getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ACTIVE_TEXTURE) - _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE0;
  }

  // target cannot be modified by bind:
  // textures are special because when you first bind them to a target,
  // they get special information. When you first bind a texture as a
  // GL_TEXTURE_2D, you are actually setting special state in the texture.
  // You are saying that this texture is a 2D texture.
  // And it will always be a 2D texture; this state cannot be changed ever.
  // If you have a texture that was first bound as a GL_TEXTURE_2D,
  // you must always bind it as a GL_TEXTURE_2D;
  // attempting to bind it as GL_TEXTURE_1D will give rise to an error
  // (while run-time).

  bind(textureUnit = this.textureUnit) {
    const {gl} = this;

    if (textureUnit !== undefined) {
      this.textureUnit = textureUnit;
      gl.activeTexture(gl.TEXTURE0 + textureUnit);
    }

    gl.bindTexture(this.target, this.handle);
    return textureUnit;
  }

  unbind(textureUnit = this.textureUnit) {
    const {gl} = this;

    if (textureUnit !== undefined) {
      this.textureUnit = textureUnit;
      gl.activeTexture(gl.TEXTURE0 + textureUnit);
    }

    gl.bindTexture(this.target, null);
    return textureUnit;
  }

  // PRIVATE METHODS

  _getDataType({data, compressed = false}) {
    if (compressed) {
      return {data, dataType: 'compressed'};
    }
    if (data === null) {
      return {data, dataType: 'null'};
    }
    if (ArrayBuffer.isView(data)) {
      return {data, dataType: 'typed-array'};
    }
    if (data instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      return {data: data.handle, dataType: 'buffer'};
    }
    if (data instanceof _webgl_utils__WEBPACK_IMPORTED_MODULE_5__["WebGLBuffer"]) {
      return {data, dataType: 'buffer'};
    }
    // Assume data is a browser supported object (ImageData, Canvas, ...)
    return {data, dataType: 'browser-object'};
  }

  /* Copied from texture-2d.js
  // WebGL2
  setPixels(opts = {}) {
    const {
      buffer,
      width = null,
      height = null,
      mipmapLevel = 0,
      format = GL.RGBA,
      type = GL.UNSIGNED_BYTE,
      border = 0
    } = opts;

    const {gl} = this;

    // This signature of texImage2D uses currently bound GL.PIXEL_UNPACK_BUFFER
    gl.bindBuffer(GL.PIXEL_UNPACK_BUFFER, buffer.target);
    // And as always, we must also bind the texture itself
    this.bind();

    gl.texImage2D(gl.TEXTURE_2D,
      mipmapLevel, format, width, height, border, format, type, buffer.target);

    this.unbind();
    gl.bindBuffer(GL.GL.PIXEL_UNPACK_BUFFER, null);
    return this;
  }

  setImageDataFromCompressedBuffer(opts) {
    const {
      buffer,
      // offset = 0,
      width = null,
      height = null,
      mipmapLevel = 0,
      internalFormat = GL.RGBA,
      // format = GL.RGBA,
      // type = GL.UNSIGNED_BYTE,
      border = 0
    } = opts;

    const {gl} = this;
    gl.compressedTexImage2D(this.target,
      mipmapLevel, internalFormat, width, height, border, buffer);
    // gl.compressedTexSubImage2D(target,
    //   level, xoffset, yoffset, width, height, format, ArrayBufferView? pixels);
    return this;
  }

  copySubImage(opts) {
    const {
      // pixels,
      // offset = 0,
      // x,
      // y,
      // width,
      // height,
      // mipmapLevel = 0,
      // internalFormat = GL.RGBA,
      // type = GL.UNSIGNED_BYTE,
      // border = 0
    } = opts;

    // if (pixels instanceof ArrayBufferView) {
    //   gl.texSubImage2D(target, level, x, y, width, height, format, type, pixels);
    // }
    // gl.texSubImage2D(target, level, x, y, format, type, ? pixels);
    // gl.texSubImage2D(target, level, x, y, format, type, HTMLImageElement pixels);
    // gl.texSubImage2D(target, level, x, y, format, type, HTMLCanvasElement pixels);
    // gl.texSubImage2D(target, level, x, y, format, type, HTMLVideoElement pixels);
    // // Additional signature in a WebGL 2 context:
    // gl.texSubImage2D(target, level, x, y, format, type, GLintptr offset);
  }
  */

  // HELPER METHODS

  _deduceParameters(opts) {
    const {format, data} = opts;
    let {width, height, dataFormat, type, compressed} = opts;

    // Deduce format and type from format
    const textureFormat = _texture_formats__WEBPACK_IMPORTED_MODULE_3__["TEXTURE_FORMATS"][format];
    dataFormat = dataFormat || (textureFormat && textureFormat.dataFormat);
    type = type || (textureFormat && textureFormat.types[0]);

    // Deduce compression from format
    compressed = compressed || (textureFormat && textureFormat.compressed);

    ({width, height} = this._deduceImageSize(data, width, height));

    return {dataFormat, type, compressed, width, height, format, data};
  }

  /* global ImageData, HTMLImageElement, HTMLCanvasElement, HTMLVideoElement, ImageBitmap */
  // eslint-disable-next-line complexity
  _deduceImageSize(data, width, height) {
    let size;

    if (typeof ImageData !== 'undefined' && data instanceof ImageData) {
      size = {width: data.width, height: data.height};
    } else if (typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement) {
      size = {width: data.naturalWidth, height: data.naturalHeight};
    } else if (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement) {
      size = {width: data.width, height: data.height};
    } else if (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap) {
      size = {width: data.width, height: data.height};
    } else if (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement) {
      size = {width: data.videoWidth, height: data.videoHeight};
    } else if (!data) {
      size = {width: width >= 0 ? width : 1, height: height >= 0 ? height : 1};
    } else {
      size = {width, height};
    }

    Object(_utils__WEBPACK_IMPORTED_MODULE_6__["assert"])(size, 'Could not deduced texture size');
    Object(_utils__WEBPACK_IMPORTED_MODULE_6__["assert"])(
      width === undefined || size.width === width,
      'Deduced texture width does not match supplied width'
    );
    Object(_utils__WEBPACK_IMPORTED_MODULE_6__["assert"])(
      height === undefined || size.height === height,
      'Deduced texture height does not match supplied height'
    );

    return size;
  }

  // RESOURCE METHODS

  _createHandle() {
    return this.gl.createTexture();
  }

  _deleteHandle() {
    this.gl.deleteTexture(this.handle);
    this._trackDeallocatedMemory('Texture');
  }

  _getParameter(pname) {
    switch (pname) {
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_WIDTH:
        return this.width;
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_HEIGHT:
        return this.height;
      default:
        this.gl.bindTexture(this.target, this.handle);
        const value = this.gl.getTexParameter(this.target, pname);
        this.gl.bindTexture(this.target, null);
        return value;
    }
  }

  _setParameter(pname, param) {
    this.gl.bindTexture(this.target, this.handle);

    // NOTE: Apply NPOT workaround
    param = this._getNPOTParam(pname, param);

    // Apparently there are some integer/float conversion rules that made
    // the WebGL committe expose two parameter setting functions in JavaScript.
    // For now, pick the float version for parameters specified as GLfloat.
    switch (pname) {
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MIN_LOD:
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MAX_LOD:
        this.gl.texParameterf(this.handle, pname, param);
        break;

      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_WIDTH:
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_HEIGHT:
        Object(_utils__WEBPACK_IMPORTED_MODULE_6__["assert"])(false);
        break;

      default:
        this.gl.texParameteri(this.target, pname, param);
        break;
    }

    this.gl.bindTexture(this.target, null);
    return this;
  }

  _isNPOT() {
    if (Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_5__["isWebGL2"])(this.gl)) {
      // NPOT restriction is only for WebGL1
      return false;
    }
    // Width and height not available, consider it is not NPOT texture
    if (!this.width || !this.height) {
      return false;
    }
    return !Object(_utils__WEBPACK_IMPORTED_MODULE_6__["isPowerOfTwo"])(this.width) || !Object(_utils__WEBPACK_IMPORTED_MODULE_6__["isPowerOfTwo"])(this.height);
  }

  // Update default settings which are not supported by NPOT textures.
  _updateForNPOT(parameters) {
    if (parameters[this.gl.TEXTURE_MIN_FILTER] === undefined) {
      // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_MIN_FILTER to LINEAR`)();
      parameters[this.gl.TEXTURE_MIN_FILTER] = this.gl.LINEAR;
    }
    if (parameters[this.gl.TEXTURE_WRAP_S] === undefined) {
      // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_WRAP_S to CLAMP_TO_EDGE`)();
      parameters[this.gl.TEXTURE_WRAP_S] = this.gl.CLAMP_TO_EDGE;
    }
    if (parameters[this.gl.TEXTURE_WRAP_T] === undefined) {
      // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_WRAP_T to CLAMP_TO_EDGE`)();
      parameters[this.gl.TEXTURE_WRAP_T] = this.gl.CLAMP_TO_EDGE;
    }
  }

  _getNPOTParam(pname, param) {
    if (this._isNPOT()) {
      switch (pname) {
        case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MIN_FILTER:
          if (NPOT_MIN_FILTERS.indexOf(param) === -1) {
            // log.warn(`texture: ${this} is Non-Power-Of-Two, forcing TEXTURE_MIN_FILTER to LINEAR`)();
            param = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.LINEAR;
          }
          break;
        case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_WRAP_S:
        case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_WRAP_T:
          if (param !== _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CLAMP_TO_EDGE) {
            // log.warn(`texture: ${this} is Non-Power-Of-Two, ${getKey(this.gl, pname)} to CLAMP_TO_EDGE`)();
            param = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CLAMP_TO_EDGE;
          }
          break;
        default:
          break;
      }
    }
    return param;
  }
}


/***/ }),

/***/ "../webgl/src/classes/transform-feedback.js":
/*!**************************************************!*\
  !*** ../webgl/src/classes/transform-feedback.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TransformFeedback; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resource */ "../webgl/src/classes/resource.js");
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buffer */ "../webgl/src/classes/buffer.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");






// NOTE: The `bindOnUse` flag is a major workaround:
// See https://github.com/KhronosGroup/WebGL/issues/2346

class TransformFeedback extends _resource__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static isSupported(gl) {
    return Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["isWebGL2"])(gl);
  }

  constructor(gl, props = {}) {
    Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["assertWebGL2Context"])(gl);
    super(gl, props);

    this.initialize(props);
    this.stubRemovedMethods('TransformFeedback', 'v6.0', ['pause', 'resume']);
    Object.seal(this);
  }

  initialize(props = {}) {
    this.buffers = {};
    this.unused = {};
    this.configuration = null;
    this.bindOnUse = true;

    // Unbind any currently bound buffers
    if (!Object(_utils__WEBPACK_IMPORTED_MODULE_4__["isObjectEmpty"])(this.buffers)) {
      this.bind(() => this._unbindBuffers());
    }

    this.setProps(props);
    return this;
  }

  setProps(props) {
    if ('program' in props) {
      this.configuration = props.program && props.program.configuration;
    }
    if ('configuration' in props) {
      this.configuration = props.configuration;
    }
    if ('bindOnUse' in props) {
      props = props.bindOnUse;
    }
    if ('buffers' in props) {
      this.setBuffers(props.buffers);
    }
  }

  setBuffers(buffers = {}) {
    this.bind(() => {
      for (const bufferName in buffers) {
        this.setBuffer(bufferName, buffers[bufferName]);
      }
    });
    return this;
  }

  setBuffer(locationOrName, bufferOrParams) {
    const location = this._getVaryingIndex(locationOrName);
    const {buffer, byteSize, byteOffset} = this._getBufferParams(bufferOrParams);

    if (location < 0) {
      this.unused[locationOrName] = buffer;
      _utils__WEBPACK_IMPORTED_MODULE_4__["log"].warn(() => `${this.id} unused varying buffer ${locationOrName}`)();
      return this;
    }

    this.buffers[location] = bufferOrParams;

    // Need to avoid chrome bug where buffer that is already bound to a different target
    // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
    if (!this.bindOnUse) {
      this._bindBuffer(location, buffer, byteOffset, byteSize);
    }

    return this;
  }

  begin(primitiveMode = _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POINTS) {
    this.gl.bindTransformFeedback(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TRANSFORM_FEEDBACK, this.handle);
    this._bindBuffers();
    this.gl.beginTransformFeedback(primitiveMode);
    return this;
  }

  end() {
    this.gl.endTransformFeedback();
    this._unbindBuffers();
    this.gl.bindTransformFeedback(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TRANSFORM_FEEDBACK, null);
    return this;
  }

  // PRIVATE METHODS

  _getBufferParams(bufferOrParams) {
    let byteOffset;
    let byteSize;
    let buffer;
    if (bufferOrParams instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"] === false) {
      buffer = bufferOrParams.buffer;
      byteSize = bufferOrParams.byteSize;
      byteOffset = bufferOrParams.byteOffset;
    } else {
      buffer = bufferOrParams;
    }
    // to use bindBufferRange, either offset or size must be specified, use default value for the other.
    if (byteOffset !== undefined || byteSize !== undefined) {
      byteOffset = byteOffset || 0;
      byteSize = byteSize || buffer.byteLength - byteOffset;
    }
    return {buffer, byteOffset, byteSize};
  }

  _getVaryingInfo(locationOrName) {
    return this.configuration && this.configuration.getVaryingInfo(locationOrName);
  }

  _getVaryingIndex(locationOrName) {
    if (this.configuration) {
      return this.configuration.getVaryingInfo(locationOrName).location;
    }
    const location = Number(locationOrName);
    return Number.isFinite(location) ? location : -1;
  }

  // Need to avoid chrome bug where buffer that is already bound to a different target
  // cannot be bound to 'TRANSFORM_FEEDBACK_BUFFER' target.
  _bindBuffers() {
    if (this.bindOnUse) {
      for (const bufferIndex in this.buffers) {
        const {buffer, byteSize, byteOffset} = this._getBufferParams(this.buffers[bufferIndex]);
        this._bindBuffer(bufferIndex, buffer, byteOffset, byteSize);
      }
    }
  }

  _unbindBuffers() {
    if (this.bindOnUse) {
      for (const bufferIndex in this.buffers) {
        this._bindBuffer(bufferIndex, null);
      }
    }
  }

  _bindBuffer(index, buffer, byteOffset = 0, byteSize) {
    const handle = buffer && buffer.handle;
    if (!handle || byteSize === undefined) {
      this.gl.bindBufferBase(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TRANSFORM_FEEDBACK_BUFFER, index, handle);
    } else {
      this.gl.bindBufferRange(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TRANSFORM_FEEDBACK_BUFFER, index, handle, byteOffset, byteSize);
    }
    return this;
  }

  // RESOURCE METHODS

  _createHandle() {
    return this.gl.createTransformFeedback();
  }

  _deleteHandle() {
    this.gl.deleteTransformFeedback(this.handle);
  }

  _bindHandle(handle) {
    this.gl.bindTransformFeedback(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TRANSFORM_FEEDBACK, this.handle);
  }
}


/***/ }),

/***/ "../webgl/src/classes/uniform-buffer-layout.js":
/*!*****************************************************!*\
  !*** ../webgl/src/classes/uniform-buffer-layout.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UniformBufferLayout; });
/* harmony import */ var _webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl-utils/attribute-utils */ "../webgl/src/webgl-utils/attribute-utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");
/* eslint-disable camelcase */



const ERR_ARGUMENT = 'UniformBufferLayout illegal argument';

// Local constants - these will "collapse" during minification
const GL_FLOAT = 0x1406;
const GL_INT = 0x1404;
const GL_UNSIGNED_INT = 0x1405;

// Std140 layout for uniforms
class UniformBufferLayout {
  constructor(layout) {
    this.layout = {};
    this.size = 0;

    // Add layout (type, size and offset) definitions for each uniform in the layout
    for (const key in layout) {
      this._addUniform(key, layout[key]);
    }

    this.size += (4 - (this.size % 4)) % 4;

    // Allocate three typed arrays pointing at same memory
    const data = new Float32Array(this.size);
    this.typedArray = {
      [GL_FLOAT]: data,
      [GL_INT]: new Int32Array(data.buffer),
      [GL_UNSIGNED_INT]: new Uint32Array(data.buffer)
    };
  }

  // Get number of bytes needed for buffer allocation
  getBytes() {
    return this.size * 4;
  }

  // Get the current data as Float32Array, for bufferSubData
  getData() {
    return this.typedArray[GL_FLOAT];
  }

  // Get offset and data for one object (for bufferSubData)
  getSubData(index) {
    let data;
    let offset;
    if (index === undefined) {
      data = this.data;
      offset = 0;
    } else {
      const begin = this.offsets[index];
      const end = begin + this.sizes[index];
      data = this.data.subarray(begin, end);
      offset = begin * 4;
    }
    return {data, offset};
  }

  // Set a map of values
  setUniforms(values) {
    for (const key in values) {
      this._setValue(key, values[key]);
    }
    return this;
  }

  _setValue(key, value) {
    const layout = this.layout[key];
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(layout, 'UniformLayoutStd140 illegal argument');
    const typedArray = this.typedArray[layout.type];
    if (layout.size === 1) {
      // single value -> just set it
      typedArray[layout.offset] = value;
    } else {
      // vector/matrix -> copy the supplied (typed) array, starting from offset
      typedArray.set(value, layout.offset);
    }
  }

  _addUniform(key, uniformType) {
    const typeAndComponents = Object(_webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_0__["decomposeCompositeGLType"])(uniformType);
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(typeAndComponents, ERR_ARGUMENT);
    const {type, components: count} = typeAndComponents;

    // First, align (bump) current offset to an even multiple of current object (1, 2, 4)
    this.size = this._alignTo(this.size, count);
    // Use the aligned size as the offset of the current uniform.
    const offset = this.size;
    // Then, add our object's padded size ((1, 2, multiple of 4) to the current offset
    this.size += count;

    this.layout[key] = {type, size: count, offset};
  }

  // Align offset to 1, 2 or 4 elements (4, 8 or 16 bytes)
  _alignTo(size, count) {
    switch (count) {
      case 1:
        return size; // Pad upwards to even multiple of 2
      case 2:
        return size + (size % 2); // Pad upwards to even multiple of 2
      default:
        return size + ((4 - (size % 4)) % 4); // Pad upwards to even multiple of 4
    }
  }
}


/***/ }),

/***/ "../webgl/src/classes/uniforms.js":
/*!****************************************!*\
  !*** ../webgl/src/classes/uniforms.js ***!
  \****************************************/
/*! exports provided: parseUniformName, getUniformSetter, checkUniformValues, areUniformsEqual, getUniformCopy */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseUniformName", function() { return parseUniformName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUniformSetter", function() { return getUniformSetter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkUniformValues", function() { return checkUniformValues; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "areUniformsEqual", function() { return areUniformsEqual; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUniformCopy", function() { return getUniformCopy; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _framebuffer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./framebuffer */ "../webgl/src/classes/framebuffer.js");
/* harmony import */ var _renderbuffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./renderbuffer */ "../webgl/src/classes/renderbuffer.js");
/* harmony import */ var _texture__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./texture */ "../webgl/src/classes/texture.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");






const UNIFORM_SETTERS = {
  // WEBGL1

  /* eslint-disable max-len */
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT]: (gl, location, value) => gl.uniform1fv(location, toFloatArray(value, 1)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT_VEC2]: (gl, location, value) => gl.uniform2fv(location, toFloatArray(value, 2)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT_VEC3]: (gl, location, value) => gl.uniform3fv(location, toFloatArray(value, 3)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT_VEC4]: (gl, location, value) => gl.uniform4fv(location, toFloatArray(value, 4)),

  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.INT]: (gl, location, value) => gl.uniform1iv(location, toIntArray(value, 1)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.INT_VEC2]: (gl, location, value) => gl.uniform2iv(location, toIntArray(value, 2)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.INT_VEC3]: (gl, location, value) => gl.uniform3iv(location, toIntArray(value, 3)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.INT_VEC4]: (gl, location, value) => gl.uniform4iv(location, toIntArray(value, 4)),

  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BOOL]: (gl, location, value) => gl.uniform1iv(location, toIntArray(value, 1)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BOOL_VEC2]: (gl, location, value) => gl.uniform2iv(location, toIntArray(value, 2)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BOOL_VEC3]: (gl, location, value) => gl.uniform3iv(location, toIntArray(value, 3)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BOOL_VEC4]: (gl, location, value) => gl.uniform4iv(location, toIntArray(value, 4)),

  // uniformMatrix(false): don't transpose the matrix
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT_MAT2]: (gl, location, value) =>
    gl.uniformMatrix2fv(location, false, toFloatArray(value, 4)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT_MAT3]: (gl, location, value) =>
    gl.uniformMatrix3fv(location, false, toFloatArray(value, 9)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT_MAT4]: (gl, location, value) =>
    gl.uniformMatrix4fv(location, false, toFloatArray(value, 16)),

  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLER_2D]: (gl, location, value) => gl.uniform1i(location, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLER_CUBE]: (gl, location, value) => gl.uniform1i(location, value),

  // WEBGL2 - unsigned integers, irregular matrices, additional texture samplers

  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_INT]: (gl, location, value) => gl.uniform1uiv(location, toUIntArray(value, 1)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_INT_VEC2]: (gl, location, value) => gl.uniform2uiv(location, toUIntArray(value, 2)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_INT_VEC3]: (gl, location, value) => gl.uniform3uiv(location, toUIntArray(value, 3)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_INT_VEC4]: (gl, location, value) => gl.uniform4uiv(location, toUIntArray(value, 4)),

  // uniformMatrix(false): don't transpose the matrix
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT_MAT2x3]: (gl, location, value) =>
    gl.uniformMatrix2x3fv(location, false, toFloatArray(value, 6)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT_MAT2x4]: (gl, location, value) =>
    gl.uniformMatrix2x4fv(location, false, toFloatArray(value, 8)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT_MAT3x2]: (gl, location, value) =>
    gl.uniformMatrix3x2fv(location, false, toFloatArray(value, 6)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT_MAT3x4]: (gl, location, value) =>
    gl.uniformMatrix3x4fv(location, false, toFloatArray(value, 12)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT_MAT4x2]: (gl, location, value) =>
    gl.uniformMatrix4x2fv(location, false, toFloatArray(value, 8)),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT_MAT4x3]: (gl, location, value) =>
    gl.uniformMatrix4x3fv(location, false, toFloatArray(value, 12)),

  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLER_3D]: (gl, location, value) => gl.uniform1i(location, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLER_2D_SHADOW]: (gl, location, value) => gl.uniform1i(location, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLER_2D_ARRAY]: (gl, location, value) => gl.uniform1i(location, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLER_2D_ARRAY_SHADOW]: (gl, location, value) => gl.uniform1i(location, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLER_CUBE_SHADOW]: (gl, location, value) => gl.uniform1i(location, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.INT_SAMPLER_2D]: (gl, location, value) => gl.uniform1i(location, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.INT_SAMPLER_3D]: (gl, location, value) => gl.uniform1i(location, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.INT_SAMPLER_CUBE]: (gl, location, value) => gl.uniform1i(location, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.INT_SAMPLER_2D_ARRAY]: (gl, location, value) => gl.uniform1i(location, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_INT_SAMPLER_2D]: (gl, location, value) => gl.uniform1i(location, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_INT_SAMPLER_3D]: (gl, location, value) => gl.uniform1i(location, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_INT_SAMPLER_CUBE]: (gl, location, value) => gl.uniform1i(location, value),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_INT_SAMPLER_2D_ARRAY]: (gl, location, value) => gl.uniform1i(location, value)
  /* eslint-enable max-len */
};

// Pre-allocated typed arrays for temporary conversion
const FLOAT_ARRAY = {};
const INT_ARRAY = {};
const UINT_ARRAY = {};

const array1 = [0];

// Functions to ensure the type of uniform values
// TODO - Why is this necessary? The uniform*v funtions can consume Arrays
function toTypedArray(value, uniformLength, Type, cache) {
  // convert boolean uniforms to Number
  if (uniformLength === 1 && typeof value === 'boolean') {
    value = value ? 1 : 0;
  }
  if (Number.isFinite(value)) {
    array1[0] = value;
    value = array1;
  }
  const length = value.length;
  if (length % uniformLength) {
    _utils__WEBPACK_IMPORTED_MODULE_4__["log"].warn(`Uniform size should be multiples of ${uniformLength}`, value)();
  }

  if (value instanceof Type) {
    return value;
  }
  let result = cache[length];
  if (!result) {
    result = new Type(length);
    cache[length] = result;
  }
  for (let i = 0; i < length; i++) {
    result[i] = value[i];
  }
  return result;
}

function toFloatArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Float32Array, FLOAT_ARRAY);
}

function toIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Int32Array, INT_ARRAY);
}

function toUIntArray(value, uniformLength) {
  return toTypedArray(value, uniformLength, Uint32Array, UINT_ARRAY);
}

function parseUniformName(name) {
  // Shortcut to avoid redundant or bad matches
  if (name[name.length - 1] !== ']') {
    return {
      name,
      length: 1,
      isArray: false
    };
  }

  // if array name then clean the array brackets
  const UNIFORM_NAME_REGEXP = /([^[]*)(\[[0-9]+\])?/;
  const matches = name.match(UNIFORM_NAME_REGEXP);
  if (!matches || matches.length < 2) {
    throw new Error(`Failed to parse GLSL uniform name ${name}`);
  }

  return {
    name: matches[1],
    length: matches[2] || 1,
    isArray: Boolean(matches[2])
  };
}

// Returns a Magic Uniform Setter
/* eslint-disable complexity */
function getUniformSetter(gl, location, info) {
  const setter = UNIFORM_SETTERS[info.type];
  if (!setter) {
    throw new Error(`Unknown GLSL uniform type ${info.type}`);
  }
  return setter.bind(null, gl, location);
}

// Basic checks of uniform values (with or without knowledge of program)
// To facilitate early detection of e.g. undefined values in JavaScript
function checkUniformValues(uniforms, source, uniformMap) {
  for (const uniformName in uniforms) {
    const value = uniforms[uniformName];
    const shouldCheck = !uniformMap || Boolean(uniformMap[uniformName]);
    if (shouldCheck && !checkUniformValue(value)) {
      // Add space to source
      source = source ? `${source} ` : '';
      // Value could be unprintable so write the object on console
      console.error(`${source} Bad uniform ${uniformName}`, value); // eslint-disable-line
      /* eslint-enable no-console */
      throw new Error(`${source} Bad uniform ${uniformName}`);
    }
  }
  return true;
}

// TODO use type information during validation
function checkUniformValue(value) {
  if (Array.isArray(value) || ArrayBuffer.isView(value)) {
    return checkUniformArray(value);
  }

  // Check if single value is a number
  if (isFinite(value)) {
    return true;
  } else if (value === true || value === false) {
    return true;
  } else if (value instanceof _texture__WEBPACK_IMPORTED_MODULE_3__["default"]) {
    return true;
  } else if (value instanceof _renderbuffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
    return true;
  } else if (value instanceof _framebuffer__WEBPACK_IMPORTED_MODULE_1__["default"]) {
    return Boolean(value.texture);
  }
  return false;
}

function checkUniformArray(value) {
  // Check that every element in array is a number, and at least 1 element
  if (value.length === 0) {
    return false;
  }

  const checkLength = Math.min(value.length, 16);

  for (let i = 0; i < checkLength; ++i) {
    if (!Number.isFinite(value[i])) {
      return false;
    }
  }

  return true;
}

/**
 * Given two values of a uniform, returns `true` if they are equal
 */
function areUniformsEqual(uniform1, uniform2) {
  if (Array.isArray(uniform1) || ArrayBuffer.isView(uniform1)) {
    if (!uniform2) {
      return false;
    }
    const len = uniform1.length;
    if (uniform2.length !== len) {
      return false;
    }
    for (let i = 0; i < len; i++) {
      if (uniform1[i] !== uniform2[i]) {
        return false;
      }
    }
    return true;
  }
  return uniform1 === uniform2;
}

/**
 * Creates a copy of the uniform
 */
function getUniformCopy(uniform) {
  if (Array.isArray(uniform) || ArrayBuffer.isView(uniform)) {
    return uniform.slice();
  }
  return uniform;
}


/***/ }),

/***/ "../webgl/src/classes/vertex-array-object.js":
/*!***************************************************!*\
  !*** ../webgl/src/classes/vertex-array-object.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VertexArrayObject; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _resource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./resource */ "../webgl/src/classes/resource.js");
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buffer */ "../webgl/src/classes/buffer.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _utils_array_utils_flat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/array-utils-flat */ "../webgl/src/utils/array-utils-flat.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");
/* harmony import */ var probe_gl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! probe.gl */ "../../node_modules/probe.gl/dist/esm/index.js");








/* eslint-disable camelcase */
const OES_vertex_array_object = 'OES_vertex_array_object';

const ERR_ELEMENTS = 'elements must be GL.ELEMENT_ARRAY_BUFFER';

class VertexArrayObject extends _resource__WEBPACK_IMPORTED_MODULE_1__["default"] {
  static isSupported(gl, options = {}) {
    // Attribute 0 can not be disable on most desktop OpenGL based browsers
    // and on iOS Safari browser.
    if (options.constantAttributeZero) {
      return Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["isWebGL2"])(gl) || Object(probe_gl__WEBPACK_IMPORTED_MODULE_6__["getBrowser"])() === 'Chrome';
    }

    // Whether additional objects can be created
    return Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["isWebGL2"])(gl) || gl.getExtension(OES_vertex_array_object);
  }

  // Returns the global (null) vertex array object. Exists even when no extension available
  static getDefaultArray(gl) {
    gl.luma = gl.luma || {};
    if (!gl.luma.defaultVertexArray) {
      gl.luma.defaultVertexArray = new VertexArrayObject(gl, {handle: null, isDefaultArray: true});
    }
    return gl.luma.defaultVertexArray;
  }

  static getMaxAttributes(gl) {
    // TODO - should be cached per context
    VertexArrayObject.MAX_ATTRIBUTES =
      VertexArrayObject.MAX_ATTRIBUTES || gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
    return VertexArrayObject.MAX_ATTRIBUTES;
  }

  // Note: Constants are stored globally on the WebGL context, not the VAO
  // So they need to be updated before every render
  // TODO - use known type (in configuration or passed in) to allow non-typed arrays?
  // TODO - remember/cache values to avoid setting them unnecessarily?
  static setConstant(gl, location, array) {
    switch (array.constructor) {
      case Float32Array:
        VertexArrayObject._setConstantFloatArray(gl, location, array);
        break;
      case Int32Array:
        VertexArrayObject._setConstantIntArray(gl, location, array);
        break;
      case Uint32Array:
        VertexArrayObject._setConstantUintArray(gl, location, array);
        break;
      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(false);
    }
  }

  // Create a VertexArray
  constructor(gl, opts = {}) {
    // Use program's id if program but no id is supplied
    const id = opts.id || (opts.program && opts.program.id);
    super(gl, Object.assign({}, opts, {id}));

    this.hasVertexArrays = VertexArrayObject.isSupported(gl);
    this.buffer = null;
    this.bufferValue = null;
    // this.isDefaultArray = opts.isDefaultArray || false;

    this.initialize(opts);

    Object.seal(this);
  }

  delete() {
    super.delete();
    if (this.buffer) {
      this.buffer.delete();
    }
  }

  get MAX_ATTRIBUTES() {
    return VertexArrayObject.getMaxAttributes(this.gl);
  }

  initialize(props = {}) {
    return this.setProps(props);
  }

  setProps(props) {
    // TODO: decide which props should be supported
    return this;
  }

  // Set (bind) an elements buffer, for indexed rendering.
  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER. Constants not supported
  setElementBuffer(elementBuffer = null, opts = {}) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(!elementBuffer || elementBuffer.target === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ELEMENT_ARRAY_BUFFER, ERR_ELEMENTS);

    // The GL.ELEMENT_ARRAY_BUFFER_BINDING is stored on the VertexArrayObject...
    this.bind(() => {
      this.gl.bindBuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ELEMENT_ARRAY_BUFFER, elementBuffer ? elementBuffer.handle : null);
    });

    return this;
  }

  // Set a location in vertex attributes array to a bufferk, enables the location, sets divisor
  setBuffer(location, buffer, accessor) {
    // Check target
    if (buffer.target === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ELEMENT_ARRAY_BUFFER) {
      return this.setElementBuffer(buffer, accessor);
    }

    const {size, type, stride, offset, normalized, integer, divisor} = accessor;

    const {gl} = this;
    location = Number(location);

    this.bind(() => {
      // A non-zero buffer object must be bound to the GL_ARRAY_BUFFER target
      gl.bindBuffer(gl.ARRAY_BUFFER, buffer.handle);

      // WebGL2 supports *integer* data formats, i.e. GPU will see integer values
      if (integer) {
        Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["isWebGL2"])(gl));
        gl.vertexAttribIPointer(location, size, type, stride, offset);
      } else {
        // Attaches ARRAY_BUFFER with specified buffer format to location
        gl.vertexAttribPointer(location, size, type, normalized, stride, offset);
      }
      gl.enableVertexAttribArray(location);
      gl.vertexAttribDivisor(location, divisor || 0);

      // NOTE We don't unbind buffer here, typically another buffer will be bound just after
    });

    return this;
  }

  // Enabling an attribute location makes it reference the currently bound buffer
  // Disabling an attribute location makes it reference the global constant value
  // TODO - handle single values for size 1 attributes?
  // TODO - convert classic arrays based on known type?
  enable(location, enable = true) {
    // Attribute 0 cannot be disabled in most desktop OpenGL based browsers
    const disablingAttributeZero =
      !enable &&
      location === 0 &&
      !VertexArrayObject.isSupported(this.gl, {constantAttributeZero: true});

    if (!disablingAttributeZero) {
      location = Number(location);
      this.bind(
        () =>
          enable
            ? this.gl.enableVertexAttribArray(location)
            : this.gl.disableVertexAttribArray(location)
      );
    }
    return this;
  }

  // Provide a means to create a buffer that is equivalent to a constant.
  // NOTE: Desktop OpenGL cannot disable attribute 0.
  // https://stackoverflow.com/questions/20305231/webgl-warning-attribute-0-is-disabled-
  // this-has-significant-performance-penalt
  getConstantBuffer(elementCount, value, accessor) {
    // Create buffer only when needed, and reuse it (avoids inflating buffer creation statistics)

    const constantValue = this._normalizeConstantArrayValue(value, accessor);

    const byteLength = constantValue.byteLength * elementCount;
    const length = constantValue.length * elementCount;

    let updateNeeded = !this.buffer;

    this.buffer = this.buffer || new _buffer__WEBPACK_IMPORTED_MODULE_2__["default"](this.gl, byteLength);
    updateNeeded = updateNeeded || this.buffer.reallocate(byteLength);

    // Reallocate and update contents if needed
    updateNeeded =
      updateNeeded || !this._compareConstantArrayValues(constantValue, this.bufferValue);

    if (updateNeeded) {
      // Create a typed array that is big enough, and fill it with the required data
      const typedArray = Object(_utils_array_utils_flat__WEBPACK_IMPORTED_MODULE_4__["getScratchArray"])(value.constructor, length);
      Object(_utils_array_utils_flat__WEBPACK_IMPORTED_MODULE_4__["fillArray"])({target: typedArray, source: constantValue, start: 0, count: length});
      this.buffer.subData(typedArray);
      this.bufferValue = value;
    }

    return this.buffer;
  }

  // PRIVATE

  // TODO - convert Arrays based on known type? (read type from accessor, don't assume Float32Array)
  // TODO - handle single values for size 1 attributes?
  _normalizeConstantArrayValue(arrayValue, accessor) {
    if (Array.isArray(arrayValue)) {
      return new Float32Array(arrayValue);
    }
    return arrayValue;
  }

  _compareConstantArrayValues(v1, v2) {
    if (!v1 || !v2 || v1.length !== v2.length || v1.constructor !== v2.constructor) {
      return false;
    }
    for (let i = 0; i < v1.length; ++i) {
      if (v1[i] !== v2[i]) {
        return false;
      }
    }
    return true;
  }

  static _setConstantFloatArray(gl, location, array) {
    switch (array.length) {
      case 1:
        gl.vertexAttrib1fv(location, array);
        break;
      case 2:
        gl.vertexAttrib2fv(location, array);
        break;
      case 3:
        gl.vertexAttrib3fv(location, array);
        break;
      case 4:
        gl.vertexAttrib4fv(location, array);
        break;
      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(false);
    }
  }

  static _setConstantIntArray(gl, location, array) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["isWebGL2"])(gl));
    switch (array.length) {
      case 1:
        gl.vertexAttribI1iv(location, array);
        break;
      case 2:
        gl.vertexAttribI2iv(location, array);
        break;
      case 3:
        gl.vertexAttribI3iv(location, array);
        break;
      case 4:
        gl.vertexAttribI4iv(location, array);
        break;
      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(false);
    }
  }

  static _setConstantUintArray(gl, location, array) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_3__["isWebGL2"])(gl));
    switch (array.length) {
      case 1:
        gl.vertexAttribI1uiv(location, array);
        break;
      case 2:
        gl.vertexAttribI2uiv(location, array);
        break;
      case 3:
        gl.vertexAttribI3uiv(location, array);
        break;
      case 4:
        gl.vertexAttribI4uiv(location, array);
        break;
      default:
        Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(false);
    }
  }

  // RESOURCE IMPLEMENTATION

  _createHandle() {
    this.hasVertexArrays = VertexArrayObject.isSupported(this.gl);
    if (this.hasVertexArrays) {
      return this.gl.createVertexArray();
    }
    return null;
  }

  _deleteHandle(handle) {
    if (this.hasVertexArrays) {
      this.gl.deleteVertexArray(handle);
    }
    return [this.elements];
    // return [this.elements, ...this.buffers];
  }

  _bindHandle(handle) {
    if (this.hasVertexArrays) {
      this.gl.bindVertexArray(handle);
    }
  }

  // Generic getter for information about a vertex attribute at a given position
  _getParameter(pname, {location}) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(Number.isFinite(location));
    return this.bind(() => {
      switch (pname) {
        case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VERTEX_ATTRIB_ARRAY_POINTER:
          return this.gl.getVertexAttribOffset(location, pname);
        default:
          return this.gl.getVertexAttrib(location, pname);
      }
    });
  }

  // DEPRECATED

  /*
  setDivisor(location, divisor) {
    location = Number(location);
    this.bind(() => this.gl.vertexAttribDivisor(location, divisor));
    return this;
  }

  // match assumed WebGL defaults
  static resetConstants(gl) {
    const MAX_ATTRIBUTES = VertexArrayObject.getMaxAttributes(gl);
    for (let i = 0; i < MAX_ATTRIBUTES; i++) {
      VertexArrayObject.setConstant(gl, i, [0, 0, 0, 1]);
    }
  }

  // Resets all attributes (to default valued constants)
  resetAttributes() {
    // WebGL offers disabling, but no clear way to set a VertexArray buffer to `null`
    // But Chrome does not like buffers that are bound to several binding points.
    // So we just bind all the attributes to the dummy "attribute zero" buffer
    this.buffer = this.buffer || new Buffer(this.gl, {size: 4});

    for (const location in this.values) {
      if (this.values[location] instanceof Buffer) {
        this.gl.disableVertexAttribArray(location);
        this.gl.bindBuffer(GL.ARRAY_BUFFER, this.buffer.handle);
        this.gl.vertexAttribPointer(location, 1, GL.FLOAT, false, 0, 0);
      }
    }

    this.setElementBuffer(null);
    return this;
  }
  */
}


/***/ }),

/***/ "../webgl/src/classes/vertex-array.js":
/*!********************************************!*\
  !*** ../webgl/src/classes/vertex-array.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VertexArray; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _accessor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./accessor */ "../webgl/src/classes/accessor.js");
/* harmony import */ var _buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buffer */ "../webgl/src/classes/buffer.js");
/* harmony import */ var _vertex_array_object__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vertex-array-object */ "../webgl/src/classes/vertex-array-object.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");






const ERR_ATTRIBUTE_TYPE =
  'VertexArray: attributes must be Buffers or constants (i.e. typed array)';

// This is done to support mat type attributes.
// See section "Notes about setting mat type attributes"
// in vertex-array.md
const MULTI_LOCATION_ATTRIBUTE_REGEXP = /^(.+)__LOCATION_([0-9]+)$/;

const DEPRECATIONS_V6 = [
  'setBuffers',
  'setGeneric',
  'clearBindings',
  'setLocations',
  'setGenericValues',
  'setDivisor',
  'enable',
  'disable'
];

class VertexArray {
  constructor(gl, opts = {}) {
    // Use program's id if program is supplied but no id is supplied
    const id = opts.id || (opts.program && opts.program.id);
    // super(gl, Object.assign({}, opts, {id}));

    this.id = id;
    this.gl = gl;
    this.configuration = null;

    // Extracted information
    this.elements = null;
    this.elementsAccessor = null;
    this.values = null;
    this.accessors = null;
    this.unused = null;
    this.drawParams = null;
    this.buffer = null; // For attribute 0 on desktops, and created when unbinding buffers

    this.attributes = {};

    this.vertexArrayObject = _vertex_array_object__WEBPACK_IMPORTED_MODULE_3__["default"].isSupported(gl)
      ? new _vertex_array_object__WEBPACK_IMPORTED_MODULE_3__["default"](gl)
      : _vertex_array_object__WEBPACK_IMPORTED_MODULE_3__["default"].getDefaultArray(gl);

    // Issue errors when using removed methods
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["stubRemovedMethods"])(this, 'VertexArray', 'v6.0', DEPRECATIONS_V6);

    this.initialize(opts);
    Object.seal(this);
  }

  delete() {
    if (this.buffer) {
      this.buffer.delete();
    }
  }

  initialize(props = {}) {
    this.reset();
    this.configuration = null;
    this.bindOnUse = false;
    return this.setProps(props);
  }

  // Resets all attributes (to default valued constants)
  reset() {
    // this.vertexArrayObject.reset();

    this.elements = null;
    this.elementsAccessor = null;
    const {MAX_ATTRIBUTES} = this.vertexArrayObject;
    this.values = new Array(MAX_ATTRIBUTES).fill(null);
    this.accessors = new Array(MAX_ATTRIBUTES).fill(null);
    this.unused = {};

    // Auto detects draw params
    this.drawParams = null;

    return this;
  }

  setProps(props) {
    if ('program' in props) {
      this.configuration = props.program && props.program.configuration;
    }
    if ('configuration' in props) {
      this.configuration = props.configuration;
    }
    if ('attributes' in props) {
      this.setAttributes(props.attributes);
    }
    if ('elements' in props) {
      this.setElementBuffer(props.elements);
    }
    if ('bindOnUse' in props) {
      props = props.bindOnUse;
    }
    return this;
  }

  // Automatically called if buffers changed through VertexArray API
  clearDrawParams() {
    this.drawParams = null;
  }

  getDrawParams(appParameters) {
    // Auto deduced draw parameters
    this.drawParams = this.drawParams || this._updateDrawParams();

    // Override with any application supplied draw parameters
    return Object.assign({}, this.drawParams, appParameters);
  }

  // Set (bind) an array or map of vertex array buffers, either in numbered or named locations.
  // For names that are not present in `location`, the supplied buffers will be ignored.
  // if a single buffer of type GL.ELEMENT_ARRAY_BUFFER is present, it will be set as elements
  //   Signatures:
  //     {attributeName: buffer}
  //     {attributeName: [buffer, accessor]}
  //     {attributeName: (typed) array} => constant
  setAttributes(attributes) {
    Object.assign(this.attributes, attributes);
    this.vertexArrayObject.bind(() => {
      for (const locationOrName in attributes) {
        const value = attributes[locationOrName];
        this._setAttribute(locationOrName, value);
      }
      // Make sure we don't leave any bindings
      this.gl.bindBuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ARRAY_BUFFER, null);
    });

    return this;
  }

  // Set (bind) an elements buffer, for indexed rendering.
  // Must be a Buffer bound to GL.ELEMENT_ARRAY_BUFFER. Constants not supported
  setElementBuffer(elementBuffer = null, accessor = {}) {
    this.elements = elementBuffer; // Save value for debugging
    this.elementsAccessor = accessor;
    this.clearDrawParams();

    // Update vertexArray immediately if we have our own array
    if (!this.vertexArrayObject.isDefaultArray) {
      this.vertexArrayObject.setElementBuffer(elementBuffer, accessor);
    }
    return this;
  }

  // Set a location in vertex attributes array to a buffer
  setBuffer(locationOrName, buffer, appAccessor = {}) {
    // Check target
    if (buffer.target === _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ELEMENT_ARRAY_BUFFER) {
      return this.setElementBuffer(buffer, appAccessor);
    }

    const {location, accessor} = this._resolveLocationAndAccessor(
      locationOrName,
      buffer,
      buffer.accessor,
      appAccessor
    );

    if (location >= 0) {
      this.values[location] = buffer;
      this.accessors[location] = accessor;
      this.clearDrawParams();

      // Update vertexArray immediately if we have our own array
      if (!this.vertexArrayObject.isDefaultArray) {
        this.vertexArrayObject.setBuffer(location, buffer, accessor);
      }
    }

    return this;
  }

  // Set attribute to constant value (small typed array corresponding to one vertex' worth of data)
  setConstant(locationOrName, arrayValue, appAccessor = {}) {
    const {location, accessor} = this._resolveLocationAndAccessor(
      locationOrName,
      arrayValue,
      // Ensure that size isn't taken from program for multi-column
      // attributes
      Object.assign({size: arrayValue.length}, appAccessor)
    );

    if (location >= 0) {
      arrayValue = this.vertexArrayObject._normalizeConstantArrayValue(arrayValue, accessor);

      this.values[location] = arrayValue;
      this.accessors[location] = accessor;
      this.clearDrawParams();

      // Update vertexArray immediately if we have our own array
      // NOTE: We set the actual constant value later on bind. We can't set the value now since
      // constants are global and affect all other VertexArrays that have disabled attributes
      // in the same location.
      // We do disable the attribute which makes it use the global constant value at that location
      if (!this.vertexArrayObject.isDefaultArray) {
        this.vertexArrayObject.enable(location, false);
      }
    }

    return this;
  }

  // Workaround for Chrome TransformFeedback binding issue
  // If required, unbind temporarily to avoid conflicting with TransformFeedback
  unbindBuffers() {
    this.vertexArrayObject.bind(() => {
      if (this.elements) {
        // Update vertexArray immediately if we have our own array
        if (!this.vertexArrayObject.isDefaultArray) {
          this.vertexArrayObject.setElementBuffer(null);
        }
      }

      // Chrome does not like buffers that are bound to several binding points,
      // so we need to offer and unbind facility
      // WebGL offers disabling, but no clear way to set a VertexArray buffer to `null`
      // So we just bind all the attributes to the dummy "attribute zero" buffer
      this.buffer = this.buffer || new _buffer__WEBPACK_IMPORTED_MODULE_2__["default"](this.gl, {accessor: {size: 4}});

      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        if (this.values[location] instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          this.gl.disableVertexAttribArray(location);
          this.gl.bindBuffer(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ARRAY_BUFFER, this.buffer.handle);
          this.gl.vertexAttribPointer(location, 1, _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT, false, 0, 0);
        }
      }
    });
    return this;
  }

  // Workaround for Chrome TransformFeedback binding issue
  // If required, rebind rebind after temporary unbind
  bindBuffers() {
    this.vertexArrayObject.bind(() => {
      if (this.elements) {
        this.setElementBuffer(this.elements);
      }

      for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
        const buffer = this.values[location];
        if (buffer instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
          this.setBuffer(location, buffer);
        }
      }
    });
    return this;
  }

  // Bind for use
  // When a vertex array is about to be used, we must:
  // - Set constant attributes (since these are stored on the context and reset on bind)
  // - Check if we need to initialize the buffer
  bindForDraw(vertexCount, instanceCount, func) {
    let value;

    this.vertexArrayObject.bind(() => {
      // Make sure that any constant attributes are updated (stored on the context, not the VAO)
      // Also handles attribute 0
      this._setConstantAttributes(vertexCount, instanceCount);

      if (!this.vertexArrayObject.hasVertexArrays) {
        this.bindBuffers();
      }

      value = func();

      if (!this.vertexArrayObject.hasVertexArrays) {
        this.unbindBuffers();
      }
    });

    return value;
  }

  // PRIVATE

  // Resolve locations and accessors
  _resolveLocationAndAccessor(locationOrName, value, valueAccessor, appAccessor) {
    const {location, name} = this._getAttributeIndex(locationOrName);
    if (!Number.isFinite(location) || location < 0) {
      this.unused[locationOrName] = value;
      _utils__WEBPACK_IMPORTED_MODULE_4__["log"].once(3, () => `unused value ${locationOrName} in ${this.id}`)();
      return this;
    }

    const accessInfo = this._getAttributeInfo(name || location);

    // Attribute location wasn't directly found.
    // Likely due to multi-location attributes (e.g. matrix)
    if (!accessInfo) {
      return {
        location: -1,
        accessor: null
      };
    }

    // Resolve the partial accessors into a final accessor
    const accessor = _accessor__WEBPACK_IMPORTED_MODULE_1__["default"].resolve(accessInfo.accessor, valueAccessor, appAccessor);

    const {size, type} = accessor;
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(Number.isFinite(size) && Number.isFinite(type));

    return {location, accessor};
  }

  _getAttributeInfo(attributeName) {
    return this.configuration && this.configuration.getAttributeInfo(attributeName);
  }

  _getAttributeIndex(locationOrName) {
    const location = Number(locationOrName);
    if (Number.isFinite(location)) {
      return {location};
    }

    const multiLocation = MULTI_LOCATION_ATTRIBUTE_REGEXP.exec(locationOrName);
    const name = multiLocation ? multiLocation[1] : locationOrName;
    const locationOffset = multiLocation ? Number(multiLocation[2]) : 0;

    if (this.configuration) {
      return {
        location: this.configuration.getAttributeLocation(name) + locationOffset,
        name
      };
    }

    return {location: -1};
  }

  _setAttribute(locationOrName, value) {
    if (value instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      //  Signature: {attributeName: Buffer}
      this.setBuffer(locationOrName, value);
    } else if (Array.isArray(value) && value.length && value[0] instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      // Signature: {attributeName: [buffer, accessor]}
      const buffer = value[0];
      const accessor = value[1];
      this.setBuffer(locationOrName, buffer, accessor);
    } else if (ArrayBuffer.isView(value) || Array.isArray(value)) {
      // Signature: {attributeName: constant}, constant == short (typed) array
      const constant = value;
      this.setConstant(locationOrName, constant);
    } else if (value.buffer instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      // luma.gl v7: Support accessor objects with 'buffer' field
      // for interleaved data
      // Signature: {attributeName: {...accessor, buffer}}
      const accessor = value;
      this.setBuffer(locationOrName, accessor.buffer, accessor);
    } else {
      throw new Error(ERR_ATTRIBUTE_TYPE);
    }
  }

  // Updates all constant attribute values (constants are used when vertex attributes are disabled).
  // This needs to be done repeatedly since in contrast to buffer bindings,
  // constants are stored on the WebGL context, not the VAO
  _setConstantAttributes(vertexCount, instanceCount) {
    // TODO - use accessor to determine what length to use
    const elementCount = Math.max(vertexCount | 0, instanceCount | 0);
    let constant = this.values[0];
    if (ArrayBuffer.isView(constant)) {
      this._setConstantAttributeZero(constant, elementCount);
    }

    for (let location = 1; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
      constant = this.values[location];
      if (ArrayBuffer.isView(constant)) {
        this._setConstantAttribute(location, constant);
      }
    }
  }

  _setConstantAttributeZero(constant, elementCount) {
    if (_vertex_array_object__WEBPACK_IMPORTED_MODULE_3__["default"].isSupported(this.gl, {constantAttributeZero: true})) {
      this._setConstantAttribute(0, constant);
      return;
    }

    // Get a dummy buffer populated with repeated constants
    const buffer = this.vertexArrayObject.getConstantBuffer(elementCount, constant);

    // Set the buffer on location 0
    this.vertexArrayObject.setBuffer(0, buffer, this.accessors[0]);
  }

  _setConstantAttribute(location, constant) {
    _vertex_array_object__WEBPACK_IMPORTED_MODULE_3__["default"].setConstant(this.gl, location, constant);

    // If we are using the global VertexArrayObject, we need to disable the attribute now
    if (this.vertexArrayObject.isDefaultArray) {
      this.vertexArrayObject.enable(location, false);
    }
  }

  // Walks the buffers and updates draw parameters
  _updateDrawParams() {
    const drawParams = {
      isIndexed: false,
      isInstanced: false,
      indexCount: Infinity,
      vertexCount: Infinity,
      instanceCount: Infinity
    };

    for (let location = 0; location < this.vertexArrayObject.MAX_ATTRIBUTES; location++) {
      this._updateDrawParamsForLocation(drawParams, location);
    }

    if (this.elements) {
      // indexing is autodetected - buffer with target GL.ELEMENT_ARRAY_BUFFER
      // index type is saved for drawElement calls
      drawParams.elementCount = this.elements.getElementCount(this.elements.accessor);
      drawParams.isIndexed = true;
      drawParams.indexType = this.elementsAccessor.type || this.elements.accessor.type;
      drawParams.indexOffset = this.elementsAccessor.offset || 0;
    }

    // Post-calculation checks
    if (drawParams.indexCount === Infinity) {
      drawParams.indexCount = 0;
    }
    if (drawParams.vertexCount === Infinity) {
      drawParams.vertexCount = 0;
    }
    if (drawParams.instanceCount === Infinity) {
      drawParams.instanceCount = 0;
    }

    return drawParams;
  }

  _updateDrawParamsForLocation(drawParams, location) {
    const value = this.values[location];
    const accessor = this.accessors[location];

    if (!value) {
      return;
    }

    // Check if instanced (whether buffer or constant)
    const {divisor} = accessor;
    const isInstanced = divisor > 0;
    drawParams.isInstanced = drawParams.isInstanced || isInstanced;

    if (value instanceof _buffer__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      const buffer = value;

      if (isInstanced) {
        // instance attribute
        const instanceCount = buffer.getVertexCount(accessor);
        drawParams.instanceCount = Math.min(drawParams.instanceCount, instanceCount);
      } else {
        // normal attribute
        const vertexCount = buffer.getVertexCount(accessor);
        drawParams.vertexCount = Math.min(drawParams.vertexCount, vertexCount);
      }
    }
  }

  // DEPRECATED in v6.x - but not warnings not properly implemented

  setElements(elementBuffer = null, accessor = {}) {
    _utils__WEBPACK_IMPORTED_MODULE_4__["log"].deprecated('setElements', 'setElementBuffer')();
    return this.setElementBuffer(elementBuffer, accessor);
  }
}


/***/ }),

/***/ "../webgl/src/context/context.js":
/*!***************************************!*\
  !*** ../webgl/src/context/context.js ***!
  \***************************************/
/*! exports provided: ERR_CONTEXT, ERR_WEBGL, ERR_WEBGL2, isWebGL, isWebGL2, assertWebGLContext, assertWebGL2Context, setGLContextDefaults, createGLContext, instrumentGLContext, destroyGLContext, resizeGLContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERR_CONTEXT", function() { return ERR_CONTEXT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERR_WEBGL", function() { return ERR_WEBGL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERR_WEBGL2", function() { return ERR_WEBGL2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWebGL", function() { return isWebGL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWebGL2", function() { return isWebGL2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assertWebGLContext", function() { return assertWebGLContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assertWebGL2Context", function() { return assertWebGL2Context; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setGLContextDefaults", function() { return setGLContextDefaults; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createGLContext", function() { return createGLContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "instrumentGLContext", function() { return instrumentGLContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "destroyGLContext", function() { return destroyGLContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resizeGLContext", function() { return resizeGLContext; });
/* harmony import */ var _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl-state-tracker */ "../webgl-state-tracker/src/index.js");
/* harmony import */ var _create_headless_context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./create-headless-context */ "../webgl/src/context/create-headless-context.js");
/* harmony import */ var _create_canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./create-canvas */ "../webgl/src/context/create-canvas.js");
/* harmony import */ var _create_browser_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./create-browser-context */ "../webgl/src/context/create-browser-context.js");
/* harmony import */ var _debug_get_context_debug_info__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../debug/get-context-debug-info */ "../webgl/src/debug/get-context-debug-info.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../utils/globals */ "../webgl/src/utils/globals.js");
/* eslint-disable quotes */
// WebGLRenderingContext related methods












const ERR_CONTEXT = 'Invalid WebGLRenderingContext';
const ERR_WEBGL = ERR_CONTEXT;
const ERR_WEBGL2 = 'Requires WebGL2';

function isWebGL(gl) {
  return Boolean(gl && Number.isFinite(gl._version));
}

function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

function assertWebGLContext(gl) {
  // Need to handle debug context
  Object(_utils__WEBPACK_IMPORTED_MODULE_6__["assert"])(isWebGL(gl), ERR_CONTEXT);
}

function assertWebGL2Context(gl) {
  // Need to handle debug context
  Object(_utils__WEBPACK_IMPORTED_MODULE_6__["assert"])(isWebGL2(gl), ERR_WEBGL2);
}

const contextDefaults = {
  // COMMON CONTEXT PARAMETERS
  // Attempt to allocate WebGL2 context
  webgl2: true, // Attempt to create a WebGL2 context (false to force webgl1)
  webgl1: true, // Attempt to create a WebGL1 context (false to fail if webgl2 not available)
  throwOnFailure: true,
  manageState: true,
  // BROWSER CONTEXT PARAMETERS
  canvas: null, // A canvas element or a canvas string id
  debug: false, // Instrument context (at the expense of performance)
  // HEADLESS CONTEXT PARAMETERS
  width: 800, // width are height are only used by headless gl
  height: 600
  // WEBGL/HEADLESS CONTEXT PARAMETERS
  // Remaining options are passed through to context creator
};

/*
 * Change default context creation parameters.
 * Main use case is regression test suite.
 */
function setGLContextDefaults(options = {}) {
  Object.assign(contextDefaults, {width: 1, height: 1}, options);
}

/*
 * Creates a context giving access to the WebGL API
 */
/* eslint-disable complexity, max-statements */
function createGLContext(options = {}) {
  options = Object.assign({}, contextDefaults, options);
  const {width, height} = options;

  // Error reporting function, enables exceptions to be disabled
  function onError(message) {
    if (options.throwOnError) {
      throw new Error(message);
    }
    return null;
  }

  let gl;
  if (_utils__WEBPACK_IMPORTED_MODULE_6__["isBrowser"]) {
    // Get or create a canvas
    const {canvas} = options;
    const targetCanvas = Object(_create_canvas__WEBPACK_IMPORTED_MODULE_2__["getCanvas"])({canvas, width, height, onError});
    // Create a WebGL context in the canvas
    gl = Object(_create_browser_context__WEBPACK_IMPORTED_MODULE_3__["createBrowserContext"])(targetCanvas, options);
  } else {
    // Create a headless-gl context under Node.js
    gl = Object(_create_headless_context__WEBPACK_IMPORTED_MODULE_1__["createHeadlessContext"])({...options, width, height, onError});
  }

  if (!gl) {
    return null;
  }

  gl = instrumentGLContext(gl, options);

  // Log some debug info about the newly created context
  logInfo(gl);

  // Add to seer integration
  return gl;
}

function instrumentGLContext(gl, options = {}) {
  // Avoid multiple instrumentations
  if (gl._instrumented) {
    return gl;
  }

  gl._version = gl._version || getVersion(gl);

  // Cache canvas size information to avoid setting it on every frame.
  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};

  options = Object.assign({}, contextDefaults, options);
  const {manageState, debug} = options;

  // Install context state tracking
  if (manageState) {
    Object(_luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_0__["trackContextState"])(gl, {
      copyState: false,
      log: (...args) => _utils__WEBPACK_IMPORTED_MODULE_6__["log"].log(1, ...args)()
    });
  }

  // Add debug instrumentation to the context
  if (_utils__WEBPACK_IMPORTED_MODULE_6__["isBrowser"] && debug) {
    if (!_utils_globals__WEBPACK_IMPORTED_MODULE_7__["global"].makeDebugContext) {
      _utils__WEBPACK_IMPORTED_MODULE_6__["log"].warn('WebGL debug mode not activated. import "@luma.gl/debug" to enable.')();
    } else {
      gl = _utils_globals__WEBPACK_IMPORTED_MODULE_7__["global"].makeDebugContext(gl, options);
      // Debug forces log level to at least 1
      _utils__WEBPACK_IMPORTED_MODULE_6__["log"].priority = Math.max(_utils__WEBPACK_IMPORTED_MODULE_6__["log"].priority, 1);
    }
  }

  gl._instrumented = true;

  return gl;
}

function destroyGLContext(gl) {
  // TODO - Remove from seer integration

  // TODO - Unregister any tracking/polyfills

  // There is no way to delete browser based context

  // Destroy headless gl context
  const ext = gl.getExtension('STACKGL_destroy_context');
  if (ext) {
    ext.destroy();
  }
}

/**
 * Resize the canvas' drawing buffer.
 *
 * Can match the canvas CSS size, and optionally also consider devicePixelRatio
 * Can be called every frame
 *
 * Regardless of size, the drawing buffer will always be scaled to the viewport, but
 * for best visual results, usually set to either:
 *  canvas CSS width x canvas CSS height
 *  canvas CSS width * devicePixelRatio x canvas CSS height * devicePixelRatio
 * See http://webgl2fundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
 *
 * resizeGLContext(gl, {width, height, useDevicePixels})
 */
function resizeGLContext(gl, options = {}) {
  // Resize browser context
  if (gl.canvas) {
    const devicePixelRatio = Object(_utils__WEBPACK_IMPORTED_MODULE_6__["getDevicePixelRatio"])(options.useDevicePixels);
    setDevicePixelRatio(gl, devicePixelRatio, options);
    return;
  }

  // Resize headless gl context
  const ext = gl.getExtension('STACKGL_resize_drawingbuffer');
  if (ext && `width` in options && `height` in options) {
    ext.resize(options.width, options.height);
  }
}

// HELPER METHODS

function logInfo(gl) {
  const webGL = isWebGL2(gl) ? 'WebGL2' : 'WebGL1';
  const info = Object(_debug_get_context_debug_info__WEBPACK_IMPORTED_MODULE_4__["getContextDebugInfo"])(gl);
  const driver = info ? `(${info.vendor},${info.renderer})` : '';
  const debug = gl.debug ? ' debug' : '';
  _utils__WEBPACK_IMPORTED_MODULE_6__["log"].info(1, `${webGL}${debug} context ${driver}`)();
}

function getVersion(gl) {
  if (typeof _webgl_utils__WEBPACK_IMPORTED_MODULE_5__["WebGL2RenderingContext"] !== 'undefined' && gl instanceof _webgl_utils__WEBPACK_IMPORTED_MODULE_5__["WebGL2RenderingContext"]) {
    // WebGL2 context.
    return 2;
  }
  // Must be a WebGL1 context.
  return 1;
}

// use devicePixelRatio to set canvas width and height
function setDevicePixelRatio(gl, devicePixelRatio, options) {
  // NOTE: if options.width and options.height not used remove in v8
  const clientWidth =
    'width' in options ? options.width : gl.canvas.clientWidth || gl.canvas.width || 1;
  const clientHeight =
    'height' in options ? options.height : gl.canvas.clientHeight || gl.canvas.height || 1;

  gl.luma = gl.luma || {};
  gl.luma.canvasSizeInfo = gl.luma.canvasSizeInfo || {};
  const cachedSize = gl.luma.canvasSizeInfo;
  // Check if canvas needs to be resized
  if (
    cachedSize.clientWidth !== clientWidth ||
    cachedSize.clientHeight !== clientHeight ||
    cachedSize.devicePixelRatio !== devicePixelRatio
  ) {
    let clampedPixelRatio = devicePixelRatio;

    const canvasWidth = Math.floor(clientWidth * clampedPixelRatio);
    const canvasHeight = Math.floor(clientHeight * clampedPixelRatio);
    gl.canvas.width = canvasWidth;
    gl.canvas.height = canvasHeight;

    // Note: when devicePixelRatio is too high, it is possible we might hit system limit for
    // drawing buffer width and hight, in those cases they get clamped and resulting aspect ration may not be maintained
    // for those cases, reduce devicePixelRatio.
    if (gl.drawingBufferWidth !== canvasWidth || gl.drawingBufferHeight !== canvasHeight) {
      _utils__WEBPACK_IMPORTED_MODULE_6__["log"].warn(`Device pixel ratio clamped`)();
      clampedPixelRatio = Math.min(
        gl.drawingBufferWidth / clientWidth,
        gl.drawingBufferHeight / clientHeight
      );

      gl.canvas.width = Math.floor(clientWidth * clampedPixelRatio);
      gl.canvas.height = Math.floor(clientHeight * clampedPixelRatio);
    }

    Object.assign(gl.luma.canvasSizeInfo, {clientWidth, clientHeight, devicePixelRatio});
  }
}


/***/ }),

/***/ "../webgl/src/context/create-browser-context.js":
/*!******************************************************!*\
  !*** ../webgl/src/context/create-browser-context.js ***!
  \******************************************************/
/*! exports provided: createBrowserContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createBrowserContext", function() { return createBrowserContext; });
/**
 * Create a WebGL context for a canvas
 * Note calling this multiple time on the same canvas does return the same context
 */
function createBrowserContext(canvas, options) {
  const {onError = message => null} = options;

  // Try to extract any extra information about why context creation failed
  const onCreateError = error => onError(`WebGL context: ${error.statusMessage || 'error'}`);
  canvas.addEventListener('webglcontextcreationerror', onCreateError, false);

  const {webgl1 = true, webgl2 = true} = options;
  let gl = null;
  // Prefer webgl2 over webgl1, prefer conformant over experimental
  if (webgl2) {
    gl = gl || canvas.getContext('webgl2', options);
    gl = gl || canvas.getContext('experimental-webgl2', options);
  }
  if (webgl1) {
    gl = gl || canvas.getContext('webgl', options);
    gl = gl || canvas.getContext('experimental-webgl', options);
  }

  canvas.removeEventListener('webglcontextcreationerror', onCreateError, false);

  if (!gl) {
    return onError(`Failed to create ${webgl2 && !webgl1 ? 'WebGL2' : 'WebGL'} context`);
  }

  return gl;
}


/***/ }),

/***/ "../webgl/src/context/create-canvas.js":
/*!*********************************************!*\
  !*** ../webgl/src/context/create-canvas.js ***!
  \*********************************************/
/*! exports provided: getPageLoadPromise, createCanvas, getCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPageLoadPromise", function() { return getPageLoadPromise; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCanvas", function() { return createCanvas; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCanvas", function() { return getCanvas; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");
// Resizing a webgl canvas

/* global window, document */


const isPage = _utils__WEBPACK_IMPORTED_MODULE_0__["isBrowser"] && typeof document !== 'undefined';
let isPageLoaded = isPage && document.readyState === 'complete';

let pageLoadPromise;

/**
 * Returns a promise that resolves when the page is loaded
 * at this point the DOM can be manipulated, and e.g. a new canvas can be inserted
 * @return {Promise} - resolves when the page is loaded
 */
function getPageLoadPromise() {
  if (!pageLoadPromise) {
    pageLoadPromise = isPage
      ? new Promise((resolve, reject) => {
          if (isPage && document.readyState === 'complete') {
            isPageLoaded = true;
            resolve(document);
            return;
          }
          window.onload = () => {
            isPageLoaded = true;
            resolve(document);
          };
        })
      : Promise.resolve({});
  }
  return pageLoadPromise;
}

/**
 * Create a canvas
 * @param {Number} width - set to 100%
 * @param {Number} height - set to 100%
 */
function createCanvas({width = 800, height = 600, id = 'gl-canvas', insert = true}) {
  const canvas = document.createElement('canvas');
  canvas.id = id;
  canvas.style.width = Number.isFinite(width) ? `${width}px` : '100%';
  canvas.style.height = Number.isFinite(height) ? `${height}px` : '100%';
  // add the canvas to the body element once the page has loaded
  if (insert) {
    const body = document.body;
    body.insertBefore(canvas, body.firstChild);
    // getPageLoadPromise().then(document => {});
  }
  return canvas;
}

function getCanvas({canvas, width, height, onError = () => {}}) {
  let targetCanvas;
  if (typeof canvas === 'string') {
    if (!isPageLoaded) {
      onError(`createGLContext called on canvas '${canvas}' before page was loaded`);
    }
    targetCanvas = document.getElementById(canvas);
  } else if (canvas) {
    targetCanvas = canvas;
  } else {
    targetCanvas = createCanvas({id: 'lumagl-canvas', width, height, onError});
  }

  return targetCanvas;
}


/***/ }),

/***/ "../webgl/src/context/create-headless-context.js":
/*!*******************************************************!*\
  !*** ../webgl/src/context/create-headless-context.js ***!
  \*******************************************************/
/*! exports provided: createHeadlessContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createHeadlessContext", function() { return createHeadlessContext; });
/* harmony import */ var _webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl-utils/webgl-types */ "../webgl/src/webgl-utils/webgl-types.js");


const ERR_HEADLESSGL_NOT_AVAILABLE =
  'Failed to create WebGL context in Node.js, headless gl not available';

const ERR_HEADLESSGL_FAILED =
  'Failed to create WebGL context in Node.js, headless gl returned null';

// Create headless gl context (for running under Node.js)
function createHeadlessContext(options) {
  const {width, height, webgl1, webgl2, onError} = options;
  if (webgl2 && !webgl1) {
    return onError('headless-gl does not support WebGL2');
  }
  if (!_webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_0__["headlessGL"]) {
    return onError(ERR_HEADLESSGL_NOT_AVAILABLE);
  }
  const gl = Object(_webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_0__["headlessGL"])(width, height, options);
  if (!gl) {
    return onError(ERR_HEADLESSGL_FAILED);
  }
  return gl;
}


/***/ }),

/***/ "../webgl/src/context/index.js":
/*!*************************************!*\
  !*** ../webgl/src/context/index.js ***!
  \*************************************/
/*! exports provided: trackContextState, resetParameters, getParameter, getParameters, setParameter, setParameters, withParameters, getModifiedParameters, createGLContext, instrumentGLContext, destroyGLContext, resizeGLContext, setGLContextDefaults, getPageLoadPromise, getCanvas */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl-state-tracker */ "../webgl-state-tracker/src/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "trackContextState", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_0__["trackContextState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resetParameters", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_0__["resetParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getParameter", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_0__["getParameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getParameters", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_0__["getParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setParameter", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_0__["setParameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setParameters", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_0__["setParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withParameters", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_0__["withParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getModifiedParameters", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_0__["getModifiedParameters"]; });

/* harmony import */ var _context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./context */ "../webgl/src/context/context.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createGLContext", function() { return _context__WEBPACK_IMPORTED_MODULE_1__["createGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "instrumentGLContext", function() { return _context__WEBPACK_IMPORTED_MODULE_1__["instrumentGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "destroyGLContext", function() { return _context__WEBPACK_IMPORTED_MODULE_1__["destroyGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resizeGLContext", function() { return _context__WEBPACK_IMPORTED_MODULE_1__["resizeGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setGLContextDefaults", function() { return _context__WEBPACK_IMPORTED_MODULE_1__["setGLContextDefaults"]; });

/* harmony import */ var _create_canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./create-canvas */ "../webgl/src/context/create-canvas.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPageLoadPromise", function() { return _create_canvas__WEBPACK_IMPORTED_MODULE_2__["getPageLoadPromise"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCanvas", function() { return _create_canvas__WEBPACK_IMPORTED_MODULE_2__["getCanvas"]; });








/***/ }),

/***/ "../webgl/src/debug/debug-program-configuration.js":
/*!*********************************************************!*\
  !*** ../webgl/src/debug/debug-program-configuration.js ***!
  \*********************************************************/
/*! exports provided: getDebugTableForProgramConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDebugTableForProgramConfiguration", function() { return getDebugTableForProgramConfiguration; });
/* harmony import */ var _webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../webgl-utils/attribute-utils */ "../webgl/src/webgl-utils/attribute-utils.js");


function getDebugTableForProgramConfiguration(config) {
  const table = {};

  const header = `Accessors for ${config.id}`;

  for (const attributeInfo of config.attributeInfos) {
    if (attributeInfo) {
      const glslDeclaration = getGLSLDeclaration(attributeInfo);
      table[`in ${glslDeclaration}`] = {[header]: JSON.stringify(attributeInfo.accessor)};
    }
  }

  for (const varyingInfo of config.varyingInfos) {
    if (varyingInfo) {
      const glslDeclaration = getGLSLDeclaration(varyingInfo);
      table[`out ${glslDeclaration}`] = {[header]: JSON.stringify(varyingInfo.accessor)};
    }
  }

  return table;
}

function getGLSLDeclaration(attributeInfo) {
  const {type, size} = attributeInfo.accessor;
  const typeAndName = Object(_webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_0__["getCompositeGLType"])(type, size);
  if (typeAndName) {
    return `${typeAndName.name} ${attributeInfo.name}`;
  }
  return attributeInfo.name;
}


/***/ }),

/***/ "../webgl/src/debug/debug-uniforms.js":
/*!********************************************!*\
  !*** ../webgl/src/debug/debug-uniforms.js ***!
  \********************************************/
/*! exports provided: getDebugTableForUniforms */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDebugTableForUniforms", function() { return getDebugTableForUniforms; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");


// Prepares a table suitable for console.table
/* eslint-disable max-statements, complexity */
function getDebugTableForUniforms({
  header = 'Uniforms',
  program,
  uniforms,
  undefinedOnly = false
} = {}) {
  Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(program);

  const SHADER_MODULE_UNIFORM_REGEXP = '.*_.*';
  const PROJECT_MODULE_UNIFORM_REGEXP = '.*Matrix'; // TODO - Use explicit list

  const uniformLocations = program._uniformSetters;
  const table = {}; // {[header]: {}};

  // Add program's provided uniforms (in alphabetical order)
  const uniformNames = Object.keys(uniformLocations).sort();

  let count = 0;

  // First add non-underscored uniforms (assumed not coming from shader modules)
  for (const uniformName of uniformNames) {
    if (
      !uniformName.match(SHADER_MODULE_UNIFORM_REGEXP) &&
      !uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)
    ) {
      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {
        count++;
      }
    }
  }

  // add underscored uniforms (assumed from shader modules)
  for (const uniformName of uniformNames) {
    if (uniformName.match(PROJECT_MODULE_UNIFORM_REGEXP)) {
      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {
        count++;
      }
    }
  }

  for (const uniformName of uniformNames) {
    if (!table[uniformName]) {
      if (addUniformToTable({table, header, uniforms, uniformName, undefinedOnly})) {
        count++;
      }
    }
  }

  // Create a table of unused uniforms
  let unusedCount = 0;
  const unusedTable = {};
  if (!undefinedOnly) {
    for (const uniformName in uniforms) {
      const uniform = uniforms[uniformName];
      if (!table[uniformName]) {
        unusedCount++;
        unusedTable[uniformName] = {
          Type: `NOT USED: ${uniform}`,
          [header]: Object(_utils__WEBPACK_IMPORTED_MODULE_0__["formatValue"])(uniform)
        };
      }
    }
  }

  return {table, count, unusedTable, unusedCount};
}

// Helper
function addUniformToTable({table, header, uniforms, uniformName, undefinedOnly}) {
  const value = uniforms[uniformName];
  const isDefined = isUniformDefined(value);
  if (!undefinedOnly || !isDefined) {
    table[uniformName] = {
      // Add program's unprovided uniforms
      [header]: isDefined ? Object(_utils__WEBPACK_IMPORTED_MODULE_0__["formatValue"])(value) : 'N/A',
      'Uniform Type': isDefined ? value : 'NOT PROVIDED'
    };
    return true;
  }
  return false;
}

function isUniformDefined(value) {
  return value !== undefined && value !== null;
}


/***/ }),

/***/ "../webgl/src/debug/debug-vertex-array.js":
/*!************************************************!*\
  !*** ../webgl/src/debug/debug-vertex-array.js ***!
  \************************************************/
/*! exports provided: getDebugTableForVertexArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDebugTableForVertexArray", function() { return getDebugTableForVertexArray; });
/* harmony import */ var _classes_buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/buffer */ "../webgl/src/classes/buffer.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../webgl-utils/attribute-utils */ "../webgl/src/webgl-utils/attribute-utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");





// Creates object suitable as input for console.table
function getDebugTableForVertexArray({vertexArray, header = 'Attributes'} = {}) {
  if (!vertexArray.configuration) {
    return {};
  }

  const table = {}; // {[header]: {}};

  // Add index (elements) if available
  if (vertexArray.elements) {
    // const elements = Object.assign({size: 1}, vertexArray.elements);
    table.ELEMENT_ARRAY_BUFFER = getDebugTableRow(vertexArray, vertexArray.elements, null, header);
  }

  // Add used attributes
  const attributes = vertexArray.values;

  for (const attributeLocation in attributes) {
    const info = vertexArray._getAttributeInfo(attributeLocation);
    if (info) {
      let rowHeader = `${attributeLocation}: ${info.name}`;
      const accessor = vertexArray.accessors[info.location];
      if (accessor) {
        rowHeader = `${attributeLocation}: ${getGLSLDeclaration(info.name, accessor)}`;
      }
      table[rowHeader] = getDebugTableRow(
        vertexArray,
        attributes[attributeLocation],
        accessor,
        header
      );
    }
  }

  return table;
}

/* eslint-disable max-statements */
function getDebugTableRow(vertexArray, attribute, accessor, header) {
  const {gl} = vertexArray;

  if (!attribute) {
    return {
      [header]: 'null',
      'Format ': 'N/A'
    };
  }

  let type = 'NOT PROVIDED';
  let size = 'N/A';
  let verts = 'N/A';
  let bytes = 'N/A';

  let isInteger;
  let marker;
  let value;

  if (accessor) {
    type = accessor.type;
    size = accessor.size;

    // Generate a type name by dropping Array from Float32Array etc.
    type = String(type).replace('Array', '');

    // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array
    isInteger = type.indexOf('nt') !== -1;
  }

  if (attribute instanceof _classes_buffer__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    const buffer = attribute;

    const {data, modified} = buffer.getDebugData();
    marker = modified ? '*' : '';

    value = data;
    bytes = buffer.byteLength;
    verts = bytes / data.BYTES_PER_ELEMENT / size;

    let format;

    if (accessor) {
      const instanced = accessor.divisor > 0;
      format = `${instanced ? 'I ' : 'P '} ${verts} (x${size}=${bytes} bytes ${Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["getKey"])(gl, type)})`;
    } else {
      // element buffer
      isInteger = true;
      format = `${bytes} bytes`;
    }

    return {
      [header]: `${marker}${Object(_utils__WEBPACK_IMPORTED_MODULE_3__["formatValue"])(value, {size, isInteger})}`,
      'Format ': format
    };
  }

  // CONSTANT VALUE
  value = attribute;
  size = attribute.length;
  // Generate a type name by dropping Array from Float32Array etc.
  type = String(attribute.constructor.name).replace('Array', '');
  // Look for 'nt' to detect integer types, e.g. Int32Array, Uint32Array
  isInteger = type.indexOf('nt') !== -1;

  return {
    [header]: `${Object(_utils__WEBPACK_IMPORTED_MODULE_3__["formatValue"])(value, {size, isInteger})} (constant)`,
    'Format ': `${size}x${type} (constant)`
  };
}
/* eslint-ensable max-statements */

function getGLSLDeclaration(name, accessor) {
  const {type, size} = accessor;
  const typeAndName = Object(_webgl_utils_attribute_utils__WEBPACK_IMPORTED_MODULE_2__["getCompositeGLType"])(type, size);
  return typeAndName ? `${name} (${typeAndName.name})` : name;
}


/***/ }),

/***/ "../webgl/src/debug/get-context-debug-info.js":
/*!****************************************************!*\
  !*** ../webgl/src/debug/get-context-debug-info.js ***!
  \****************************************************/
/*! exports provided: getContextDebugInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContextDebugInfo", function() { return getContextDebugInfo; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);


/**
 * Provides strings identifying the GPU vendor and driver.
 * https://www.khronos.org/registry/webgl/extensions/WEBGL_debug_renderer_info/
 * @param {WebGLRenderingContext} gl - context
 * @return {Object} - 'vendor' and 'renderer' string fields.
 */
function getContextDebugInfo(gl) {
  const vendorMasked = gl.getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VENDOR);
  const rendererMasked = gl.getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERER);
  const ext = gl.getExtension('WEBGL_debug_renderer_info');
  const vendorUnmasked = ext && gl.getParameter(ext.UNMASKED_VENDOR_WEBGL || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VENDOR);
  const rendererUnmasked = ext && gl.getParameter(ext.UNMASKED_RENDERER_WEBGL || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERER);
  return {
    vendor: vendorUnmasked || vendorMasked,
    renderer: rendererUnmasked || rendererMasked,
    vendorMasked,
    rendererMasked,
    version: gl.getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VERSION),
    shadingLanguageVersion: gl.getParameter(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SHADING_LANGUAGE_VERSION)
  };
}


/***/ }),

/***/ "../webgl/src/features/check-glsl-extension.js":
/*!*****************************************************!*\
  !*** ../webgl/src/features/check-glsl-extension.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return canCompileGLGSExtension; });
/* harmony import */ var _check_old_ie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./check-old-ie */ "../webgl/src/features/check-old-ie.js");
/* harmony import */ var _webgl_features_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl-features-table */ "../webgl/src/features/webgl-features-table.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");




// Enables feature detection in IE11 due to a bug where gl.getExtension may return true
// but fail to compile when the extension is enabled in the shader. Specifically,
// the OES_standard_derivatives extension fails to compile in IE11 even though its included
// in the list of supported extensions.
const compiledGlslExtensions = {};

// options allows user agent to be overridden for testing
function canCompileGLGSExtension(gl, cap, options = {}) {
  const feature = _webgl_features_table__WEBPACK_IMPORTED_MODULE_1__["default"][cap];
  Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(feature, cap);

  if (!Object(_check_old_ie__WEBPACK_IMPORTED_MODULE_0__["default"])(options)) {
    return true;
  }

  if (cap in compiledGlslExtensions) {
    return compiledGlslExtensions[cap];
  }

  const extensionName = feature[0];
  const source = `#extension GL_${extensionName} : enable\nvoid main(void) {}`;

  const shader = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  const canCompile = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  gl.deleteShader(shader);
  compiledGlslExtensions[cap] = canCompile;
  return canCompile;
}


/***/ }),

/***/ "../webgl/src/features/check-old-ie.js":
/*!*********************************************!*\
  !*** ../webgl/src/features/check-old-ie.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isOldIE; });
/* global window */

// opts allows user agent to be overridden for testing
function isOldIE(opts = {}) {
  const navigator = (typeof window !== 'undefined' && window.navigator) || {};
  const userAgent = opts.userAgent || navigator.userAgent || '';
  // We only care about older versions of IE (IE 11 and below). Newer versions of IE (Edge)
  // have much better web standards support.
  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}


/***/ }),

/***/ "../webgl/src/features/features.js":
/*!*****************************************!*\
  !*** ../webgl/src/features/features.js ***!
  \*****************************************/
/*! exports provided: hasFeature, hasFeatures, getFeatures */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasFeature", function() { return hasFeature; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hasFeatures", function() { return hasFeatures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getFeatures", function() { return getFeatures; });
/* harmony import */ var _webgl_features_table__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-features-table */ "../webgl/src/features/webgl-features-table.js");
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");
// Feature detection for WebGL
//
// Provides a function that enables simple checking of which WebGL features are
// available in an WebGL1 or WebGL2 environment.





const LOG_UNSUPPORTED_FEATURE = 2;

// Check one feature
function hasFeature(gl, feature) {
  return hasFeatures(gl, feature);
}

// Check one or more features
function hasFeatures(gl, features) {
  features = Array.isArray(features) ? features : [features];
  return features.every(feature => {
    return isFeatureSupported(gl, feature);
  });
}

// Return a list of supported features
function getFeatures(gl) {
  gl.luma = gl.luma || {};
  if (!gl.luma.caps) {
    gl.luma.caps = {};
    gl.luma.caps.webgl2 = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl);
    for (const cap in _webgl_features_table__WEBPACK_IMPORTED_MODULE_0__["default"]) {
      gl.luma.caps[cap] = isFeatureSupported(gl, cap);
    }
  }
  return gl.luma.caps;
}

// TODO - cache the value
function isFeatureSupported(gl, cap) {
  const feature = _webgl_features_table__WEBPACK_IMPORTED_MODULE_0__["default"][cap];
  Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(feature, cap);

  // Get extension name from table
  const featureDefinition = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl) ? feature[1] || feature[0] : feature[0];

  let isSupported;

  // Check if the value is dependent on checking one or more extensions
  if (typeof featureDefinition === 'function') {
    isSupported = featureDefinition(gl);
  } else if (Array.isArray(featureDefinition)) {
    isSupported = true;
    for (const extension of featureDefinition) {
      isSupported = isSupported && Boolean(gl.getExtension(extension));
    }
  } else if (typeof featureDefinition === 'string') {
    isSupported = Boolean(gl.getExtension(featureDefinition));
  } else if (typeof featureDefinition === 'boolean') {
    isSupported = featureDefinition;
  } else {
    Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(false);
  }

  if (!isSupported) {
    _utils__WEBPACK_IMPORTED_MODULE_2__["log"].log(LOG_UNSUPPORTED_FEATURE, `Feature: ${cap} not supported`)();
  }

  return isSupported;
}


/***/ }),

/***/ "../webgl/src/features/index.js":
/*!**************************************!*\
  !*** ../webgl/src/features/index.js ***!
  \**************************************/
/*! exports provided: getContextInfo, getGLContextInfo, getContextLimits, FEATURES, hasFeature, hasFeatures, getFeatures, canCompileGLGSExtension */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _limits__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./limits */ "../webgl/src/features/limits.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContextInfo", function() { return _limits__WEBPACK_IMPORTED_MODULE_0__["getContextInfo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getGLContextInfo", function() { return _limits__WEBPACK_IMPORTED_MODULE_0__["getGLContextInfo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContextLimits", function() { return _limits__WEBPACK_IMPORTED_MODULE_0__["getContextLimits"]; });

/* harmony import */ var _webgl_features_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl-features-table */ "../webgl/src/features/webgl-features-table.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FEATURES", function() { return _webgl_features_table__WEBPACK_IMPORTED_MODULE_1__["FEATURES"]; });

/* harmony import */ var _features__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./features */ "../webgl/src/features/features.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasFeature", function() { return _features__WEBPACK_IMPORTED_MODULE_2__["hasFeature"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasFeatures", function() { return _features__WEBPACK_IMPORTED_MODULE_2__["hasFeatures"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getFeatures", function() { return _features__WEBPACK_IMPORTED_MODULE_2__["getFeatures"]; });

/* harmony import */ var _check_glsl_extension__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./check-glsl-extension */ "../webgl/src/features/check-glsl-extension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "canCompileGLGSExtension", function() { return _check_glsl_extension__WEBPACK_IMPORTED_MODULE_3__["default"]; });








/***/ }),

/***/ "../webgl/src/features/limits.js":
/*!***************************************!*\
  !*** ../webgl/src/features/limits.js ***!
  \***************************************/
/*! exports provided: getContextLimits, getGLContextInfo, getContextInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContextLimits", function() { return getContextLimits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGLContextInfo", function() { return getGLContextInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContextInfo", function() { return getContextInfo; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _webgl_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../webgl-utils */ "../webgl/src/webgl-utils/index.js");
/* harmony import */ var _webgl_limits_table__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webgl-limits-table */ "../webgl/src/features/webgl-limits-table.js");
/* harmony import */ var _debug_get_context_debug_info__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../debug/get-context-debug-info */ "../webgl/src/debug/get-context-debug-info.js");






function getContextLimits(gl) {
  gl.luma = gl.luma || {};

  if (!gl.luma.limits) {
    gl.luma.limits = {};
    gl.luma.webgl1MinLimits = {};
    gl.luma.webgl2MinLimits = {};

    const isWebgl2 = Object(_webgl_utils__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"])(gl);

    // WEBGL limits
    for (const parameter in _webgl_limits_table__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      const limit = _webgl_limits_table__WEBPACK_IMPORTED_MODULE_2__["default"][parameter];

      const webgl1MinLimit = limit.gl1;
      const webgl2MinLimit = 'gl2' in limit ? limit.gl2 : limit.gl1;
      const minLimit = isWebgl2 ? webgl2MinLimit : webgl1MinLimit;

      // Check if we can query for this limit
      const limitNotAvailable =
        ('gl2' in limit && !isWebgl2) ||
        ('extension' in limit && !gl.getExtension(limit.extension));

      const value = limitNotAvailable ? minLimit : gl.getParameter(parameter);
      gl.luma.limits[parameter] = value;
      gl.luma.webgl1MinLimits[parameter] = webgl1MinLimit;
      gl.luma.webgl2MinLimits[parameter] = webgl2MinLimit;
    }
  }

  return gl.luma.limits;
}

function getGLContextInfo(gl) {
  gl.luma = gl.luma || {};

  const info = Object(_debug_get_context_debug_info__WEBPACK_IMPORTED_MODULE_3__["getContextDebugInfo"])(gl);
  if (!gl.luma.info) {
    gl.luma.info = {
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNMASKED_VENDOR_WEBGL]: info.vendor,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNMASKED_RENDERER_WEBGL]: info.renderer,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VENDOR]: info.vendorMasked,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERER]: info.rendererMasked,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VERSION]: info.version,
      [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SHADING_LANGUAGE_VERSION]: info.shadingLanguageVersion
    };
  }

  return gl.luma.info;
}

function getContextInfo(gl) {
  return Object.assign(Object(_debug_get_context_debug_info__WEBPACK_IMPORTED_MODULE_3__["getContextDebugInfo"])(gl), {
    limits: getContextLimits(gl),
    info: getGLContextInfo(gl),
    webgl1MinLimits: gl.luma.webgl1MinLimits,
    webgl2MinLimits: gl.luma.webgl2MinLimits
  });
}


/***/ }),

/***/ "../webgl/src/features/webgl-features-table.js":
/*!*****************************************************!*\
  !*** ../webgl/src/features/webgl-features-table.js ***!
  \*****************************************************/
/*! exports provided: FEATURES, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FEATURES", function() { return FEATURES; });
/* harmony import */ var _classes_framebuffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/framebuffer */ "../webgl/src/classes/framebuffer.js");
/* harmony import */ var _classes_texture_2d__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/texture-2d */ "../webgl/src/classes/texture-2d.js");


// TODO - this should be the default export, test cases need updating
const FEATURES = {
  WEBGL2: 'WEBGL2',

  // API SUPPORT
  VERTEX_ARRAY_OBJECT: 'VERTEX_ARRAY_OBJECT',
  TIMER_QUERY: 'TIMER_QUERY',
  INSTANCED_RENDERING: 'INSTANCED_RENDERING',
  MULTIPLE_RENDER_TARGETS: 'MULTIPLE_RENDER_TARGETS',

  // FEATURES
  ELEMENT_INDEX_UINT32: 'ELEMENT_INDEX_UINT32',

  // BLENDING
  BLEND_EQUATION_MINMAX: 'BLEND_EQUATION_MINMAX',
  FLOAT_BLEND: 'FLOAT_BLEND',

  // TEXTURES: '// TEXTURES', RENDERBUFFERS
  COLOR_ENCODING_SRGB: 'COLOR_ENCODING_SRGB',

  // TEXTURES
  TEXTURE_DEPTH: 'TEXTURE_DEPTH',
  TEXTURE_FLOAT: 'TEXTURE_FLOAT',
  TEXTURE_HALF_FLOAT: 'TEXTURE_HALF_FLOAT',

  TEXTURE_FILTER_LINEAR_FLOAT: 'TEXTURE_FILTER_LINEAR_FLOAT',
  TEXTURE_FILTER_LINEAR_HALF_FLOAT: 'TEXTURE_FILTER_LINEAR_HALF_FLOAT',
  TEXTURE_FILTER_ANISOTROPIC: 'TEXTURE_FILTER_ANISOTROPIC',

  // FRAMEBUFFERS: '// FRAMEBUFFERS', TEXTURES AND RENDERBUFFERS
  COLOR_ATTACHMENT_RGBA32F: 'COLOR_ATTACHMENT_RGBA32F',
  COLOR_ATTACHMENT_FLOAT: 'COLOR_ATTACHMENT_FLOAT',
  COLOR_ATTACHMENT_HALF_FLOAT: 'COLOR_ATTACHMENT_HALF_FLOAT',

  // GLSL extensions
  GLSL_FRAG_DATA: 'GLSL_FRAG_DATA',
  GLSL_FRAG_DEPTH: 'GLSL_FRAG_DEPTH',
  GLSL_DERIVATIVES: 'GLSL_DERIVATIVES',
  GLSL_TEXTURE_LOD: 'GLSL_TEXTURE_LOD'
};

// TODO: remove this global (https://github.com/uber/luma.gl/issues/1258)
let float32ColorAttachmentSupport = null;

// function to test if Float 32 bit format texture can be bound as color attachment
function checkFloat32ColorAttachment(gl) {
  // if previously queried, return the cache value.
  if (float32ColorAttachmentSupport !== null) {
    return float32ColorAttachmentSupport;
  }
  const testTexture = new _classes_texture_2d__WEBPACK_IMPORTED_MODULE_1__["default"](gl, {
    format: gl.RGBA,
    type: gl.FLOAT,
    dataFormat: gl.RGBA
  });
  const testFb = new _classes_framebuffer__WEBPACK_IMPORTED_MODULE_0__["default"](gl, {
    id: `test-framebuffer`,
    check: false,
    attachments: {
      [gl.COLOR_ATTACHMENT0]: testTexture
    }
  });
  const status = testFb.getStatus();
  testTexture.delete();
  testFb.delete();
  float32ColorAttachmentSupport = status === gl.FRAMEBUFFER_COMPLETE;
  return float32ColorAttachmentSupport;
}

// Defines luma.gl "feature" names and semantics
// Format: 'feature-name: [WebGL1 support, WebGL2 support] / [WebGL1 and WebGL2 support]', when support is 'string' it is the name of the extension
/* harmony default export */ __webpack_exports__["default"] = ({
  [FEATURES.WEBGL2]: [false, true],

  // API SUPPORT
  [FEATURES.VERTEX_ARRAY_OBJECT]: ['OES_vertex_array_object', true],
  [FEATURES.TIMER_QUERY]: ['EXT_disjoint_timer_query', 'EXT_disjoint_timer_query_webgl2'],
  [FEATURES.INSTANCED_RENDERING]: ['ANGLE_instanced_arrays', true],
  [FEATURES.MULTIPLE_RENDER_TARGETS]: ['WEBGL_draw_buffers', true],

  // FEATURES
  [FEATURES.ELEMENT_INDEX_UINT32]: ['OES_element_index_uint', true],

  // BLENDING
  [FEATURES.BLEND_EQUATION_MINMAX]: ['EXT_blend_minmax', true],
  [FEATURES.FLOAT_BLEND]: ['EXT_float_blend'],

  // TEXTURES, RENDERBUFFERS
  [FEATURES.COLOR_ENCODING_SRGB]: ['EXT_sRGB', true],

  // TEXTURES
  [FEATURES.TEXTURE_DEPTH]: ['WEBGL_depth_texture', true],
  [FEATURES.TEXTURE_FLOAT]: ['OES_texture_float', true],
  [FEATURES.TEXTURE_HALF_FLOAT]: ['OES_texture_half_float', true],

  [FEATURES.TEXTURE_FILTER_LINEAR_FLOAT]: ['OES_texture_float_linear'],
  [FEATURES.TEXTURE_FILTER_LINEAR_HALF_FLOAT]: ['OES_texture_half_float_linear'],
  [FEATURES.TEXTURE_FILTER_ANISOTROPIC]: ['EXT_texture_filter_anisotropic'],

  // FRAMEBUFFERS, TEXTURES AND RENDERBUFFERS
  [FEATURES.COLOR_ATTACHMENT_RGBA32F]: [checkFloat32ColorAttachment, 'EXT_color_buffer_float'],
  [FEATURES.COLOR_ATTACHMENT_FLOAT]: [false, 'EXT_color_buffer_float'],
  [FEATURES.COLOR_ATTACHMENT_HALF_FLOAT]: ['EXT_color_buffer_half_float'],

  // GLSL extensions
  [FEATURES.GLSL_FRAG_DATA]: ['WEBGL_draw_buffers', true],
  [FEATURES.GLSL_FRAG_DEPTH]: ['EXT_frag_depth', true],
  [FEATURES.GLSL_DERIVATIVES]: ['OES_standard_derivatives', true],
  [FEATURES.GLSL_TEXTURE_LOD]: ['EXT_shader_texture_lod', true]
});


/***/ }),

/***/ "../webgl/src/features/webgl-limits-table.js":
/*!***************************************************!*\
  !*** ../webgl/src/features/webgl-limits-table.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);


/* harmony default export */ __webpack_exports__["default"] = ({
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ALIASED_LINE_WIDTH_RANGE]: {gl1: new Float32Array([1, 1])},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ALIASED_POINT_SIZE_RANGE]: {gl1: new Float32Array([1, 1])},
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_TEXTURE_SIZE]: {gl1: 64, gl2: 2048}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_CUBE_MAP_TEXTURE_SIZE]: {gl1: 16}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_TEXTURE_IMAGE_UNITS]: {gl1: 8}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_COMBINED_TEXTURE_IMAGE_UNITS]: {gl1: 8}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_VERTEX_TEXTURE_IMAGE_UNITS]: {gl1: 0}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_RENDERBUFFER_SIZE]: {gl1: 1}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_VARYING_VECTORS]: {gl1: 8}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_VERTEX_ATTRIBS]: {gl1: 8}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_VERTEX_UNIFORM_VECTORS]: {gl1: 128}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_FRAGMENT_UNIFORM_VECTORS]: {gl1: 16}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_VIEWPORT_DIMS]: {gl1: new Int32Array([0, 0])},

  // Extensions
  // [GL.MAX_TEXTURE_MAX_ANISOTROPY_EXT]: {gl1: 1.0, extension: 'EXT_texture_filter_anisotropic'},

  // WebGL2 Limits
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_3D_TEXTURE_SIZE]: {gl1: 0, gl2: 256}, //  GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_ARRAY_TEXTURE_LAYERS]: {gl1: 0, gl2: 256}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_CLIENT_WAIT_TIMEOUT_WEBGL]: {gl1: 0, gl2: 0}, //  GLint64
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_COLOR_ATTACHMENTS]: {gl1: 0, gl2: 4}, //  GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS]: {gl1: 0, gl2: 0}, // GLint64
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_COMBINED_UNIFORM_BLOCKS]: {gl1: 0, gl2: 0}, //  GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS]: {gl1: 0, gl2: 0}, // GLint64
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_DRAW_BUFFERS]: {gl1: 0, gl2: 4}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_ELEMENT_INDEX]: {gl1: 0, gl2: 0}, //  GLint64
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_ELEMENTS_INDICES]: {gl1: 0, gl2: 0}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_ELEMENTS_VERTICES]: {gl1: 0, gl2: 0}, //  GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_FRAGMENT_INPUT_COMPONENTS]: {gl1: 0, gl2: 0}, //  GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_FRAGMENT_UNIFORM_BLOCKS]: {gl1: 0, gl2: 0}, //  GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_FRAGMENT_UNIFORM_COMPONENTS]: {gl1: 0, gl2: 0}, //  GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_SAMPLES]: {gl1: 0, gl2: 0}, //  GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_SERVER_WAIT_TIMEOUT]: {gl1: 0, gl2: 0}, //  GLint64
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_TEXTURE_LOD_BIAS]: {gl1: 0, gl2: 0}, // GLfloat
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS]: {gl1: 0, gl2: 0}, //  GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS]: {gl1: 0, gl2: 0}, //  GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS]: {gl1: 0, gl2: 0}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_UNIFORM_BLOCK_SIZE]: {gl1: 0, gl2: 0}, // GLint64
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_UNIFORM_BUFFER_BINDINGS]: {gl1: 0, gl2: 0}, //  GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_VARYING_COMPONENTS]: {gl1: 0, gl2: 0}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_VERTEX_OUTPUT_COMPONENTS]: {gl1: 0, gl2: 0}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_VERTEX_UNIFORM_BLOCKS]: {gl1: 0, gl2: 0}, //  GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_VERTEX_UNIFORM_COMPONENTS]: {gl1: 0, gl2: 0}, //  GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MIN_PROGRAM_TEXEL_OFFSET]: {gl1: 0, gl2: -8, negative: true}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_PROGRAM_TEXEL_OFFSET]: {gl1: 0, gl2: 7}, // GLint
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNIFORM_BUFFER_OFFSET_ALIGNMENT]: {gl1: 0, gl2: 0} // GLint
});


/***/ }),

/***/ "../webgl/src/glsl-utils/format-glsl-error.js":
/*!****************************************************!*\
  !*** ../webgl/src/glsl-utils/format-glsl-error.js ***!
  \****************************************************/
/*! exports provided: default, parseGLSLCompilerError */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return formatGLSLCompilerError; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseGLSLCompilerError", function() { return parseGLSLCompilerError; });
/* harmony import */ var _get_shader_name__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./get-shader-name */ "../webgl/src/glsl-utils/get-shader-name.js");
/* harmony import */ var _get_shader_type_name__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-shader-type-name */ "../webgl/src/glsl-utils/get-shader-type-name.js");
// TODO - formatGLSLCompilerError should not depend on this



// Formats GLSL compiler error log into single string
function formatGLSLCompilerError(errLog, src, shaderType) {
  const {shaderName, errors, warnings} = parseGLSLCompilerError(errLog, src, shaderType);
  return `GLSL compilation error in ${shaderName}\n\n${errors}\n${warnings}`;
}

/**
 * Parse a GLSL compiler error log into a string showing the source code around each error.
 * Based on https://github.com/wwwtyro/gl-format-compiler-error (public domain)
 */
/* eslint-disable no-continue, max-statements */
function parseGLSLCompilerError(errLog, src, shaderType, shaderName) {
  const errorStrings = errLog.split(/\r?\n/);
  const errors = {};
  const warnings = {};

  // Patch the shader name
  const name = shaderName || Object(_get_shader_name__WEBPACK_IMPORTED_MODULE_0__["default"])(src) || '(unnamed)';
  const shaderDescription = `${Object(_get_shader_type_name__WEBPACK_IMPORTED_MODULE_1__["default"])(shaderType)} shader ${name}`;

  // Parse the error - note: browser and driver dependent
  for (let i = 0; i < errorStrings.length; i++) {
    const errorString = errorStrings[i];
    if (errorString.length <= 1) {
      continue;
    }
    const segments = errorString.split(':');
    const type = segments[0];
    const line = parseInt(segments[2], 10);
    if (isNaN(line)) {
      throw new Error(`GLSL compilation error in ${shaderDescription}: ${errLog}`);
    }
    if (type !== 'WARNING') {
      errors[line] = errorString;
    } else {
      warnings[line] = errorString;
    }
  }

  // Format the error inline with the code
  const lines = addLineNumbers(src);

  return {
    shaderName: shaderDescription,
    errors: formatErrors(errors, lines),
    warnings: formatErrors(warnings, lines)
  };
}

// helper function, outputs annotated errors or warnings
function formatErrors(errors, lines) {
  let message = '';
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (!errors[i + 3] && !errors[i + 2] && !errors[i + 1]) {
      continue;
    }
    message += `${line}\n`;
    if (errors[i + 1]) {
      const error = errors[i + 1];
      const segments = error.split(':', 3);
      const type = segments[0];
      const column = parseInt(segments[1], 10) || 0;
      const err = error.substring(segments.join(':').length + 1).trim();
      message += padLeft(`^^^ ${type}: ${err}\n\n`, column);
    }
  }
  return message;
}

/**
 * Prepends line numbers to each line of a string.
 * The line numbers will be left-padded with spaces to ensure an
 * aligned layout when rendered using monospace fonts.
 * @param {String} string - multi-line string to add line numbers to
 * @param {Number} start=1 - number of spaces to add
 * @param {String} delim =': ' - injected between line number and original line
 * @return {String[]} strings - array of string, one per line, with line numbers added
 */
function addLineNumbers(string, start = 1, delim = ': ') {
  const lines = string.split(/\r?\n/);
  const maxDigits = String(lines.length + start - 1).length;
  return lines.map((line, i) => {
    const lineNumber = i + start;
    const digits = String(lineNumber).length;
    const prefix = padLeft(lineNumber, maxDigits - digits);
    return prefix + delim + line;
  });
}

/**
 * Pads a string with a number of spaces (space characters) to the left
 * @param {String} string - string to pad
 * @param {Number} digits - number of spaces to add
 * @return {String} string - The padded string
 */
function padLeft(string, digits) {
  let result = '';
  for (let i = 0; i < digits; ++i) {
    result += ' ';
  }
  return `${result}${string}`;
}


/***/ }),

/***/ "../webgl/src/glsl-utils/get-shader-name.js":
/*!**************************************************!*\
  !*** ../webgl/src/glsl-utils/get-shader-name.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getShaderName; });
// Supports GLSLIFY style naming of shaders
// #define SHADER_NAME ...
function getShaderName(shader, defaultName = 'unnamed') {
  const SHADER_NAME_REGEXP = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/;
  const match = shader.match(SHADER_NAME_REGEXP);
  return match ? match[1] : defaultName;
}


/***/ }),

/***/ "../webgl/src/glsl-utils/get-shader-type-name.js":
/*!*******************************************************!*\
  !*** ../webgl/src/glsl-utils/get-shader-type-name.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getShaderTypeName; });
const GL_FRAGMENT_SHADER = 0x8b30;
const GL_VERTEX_SHADER = 0x8b31;

function getShaderTypeName(type) {
  switch (type) {
    case GL_FRAGMENT_SHADER:
      return 'fragment';
    case GL_VERTEX_SHADER:
      return 'vertex';
    default:
      return 'unknown type';
  }
}


/***/ }),

/***/ "../webgl/src/glsl-utils/get-shader-version.js":
/*!*****************************************************!*\
  !*** ../webgl/src/glsl-utils/get-shader-version.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return getShaderVersion; });
// returns GLSL shader version of given shader string
function getShaderVersion(source) {
  let version = 100;
  const words = source.match(/[^\s]+/g);
  if (words.length >= 2 && words[0] === '#version') {
    const v = parseInt(words[1], 10);
    if (Number.isFinite(v)) {
      version = v;
    }
  }
  return version;
}


/***/ }),

/***/ "../webgl/src/glsl-utils/index.js":
/*!****************************************!*\
  !*** ../webgl/src/glsl-utils/index.js ***!
  \****************************************/
/*! exports provided: formatGLSLCompilerError, parseGLSLCompilerError, getShaderName, getShaderVersion, getShaderTypeName */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _format_glsl_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./format-glsl-error */ "../webgl/src/glsl-utils/format-glsl-error.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatGLSLCompilerError", function() { return _format_glsl_error__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseGLSLCompilerError", function() { return _format_glsl_error__WEBPACK_IMPORTED_MODULE_0__["parseGLSLCompilerError"]; });

/* harmony import */ var _get_shader_name__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./get-shader-name */ "../webgl/src/glsl-utils/get-shader-name.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getShaderName", function() { return _get_shader_name__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _get_shader_version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./get-shader-version */ "../webgl/src/glsl-utils/get-shader-version.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getShaderVersion", function() { return _get_shader_version__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _get_shader_type_name__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./get-shader-type-name */ "../webgl/src/glsl-utils/get-shader-type-name.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getShaderTypeName", function() { return _get_shader_type_name__WEBPACK_IMPORTED_MODULE_3__["default"]; });

// PARSE SHADER ERRORS


// PARSE SHADER SOURCE






/***/ }),

/***/ "../webgl/src/index.js":
/*!*****************************!*\
  !*** ../webgl/src/index.js ***!
  \*****************************/
/*! exports provided: lumaStats, resetParameters, getParameter, getParameters, setParameter, setParameters, withParameters, getModifiedParameters, Image, WebGLRenderingContext, WebGLProgram, WebGLShader, WebGLBuffer, WebGLFramebuffer, WebGLRenderbuffer, WebGLTexture, WebGLUniformLocation, WebGLActiveInfo, WebGLShaderPrecisionFormat, WebGL2RenderingContext, webGLTypesAvailable, createGLContext, destroyGLContext, resizeGLContext, instrumentGLContext, setGLContextDefaults, getCanvas, getPageLoadPromise, requestAnimationFrame, cancelAnimationFrame, isWebGL, isWebGL2, cloneTextureFrom, getKeyValue, getKey, getContextInfo, getGLContextInfo, getContextLimits, getContextDebugInfo, FEATURES, hasFeature, hasFeatures, getFeatures, canCompileGLGSExtension, Accessor, Buffer, Shader, VertexShader, FragmentShader, Program, Framebuffer, Renderbuffer, Texture2D, TextureCube, clear, clearBuffer, readPixelsToArray, readPixelsToBuffer, copyToDataUrl, copyToImage, copyToTexture, blit, Query, Texture3D, TransformFeedback, VertexArrayObject, VertexArray, UniformBufferLayout, setPathPrefix, loadFile, loadImage, getShaderName, getShaderVersion, log, assert, uid, isObjectEmpty, self, window, global, document, isBrowser, cssToDeviceRatio, cssToDevicePixels, parseUniformName, getUniformSetter, getDebugTableForUniforms, getDebugTableForVertexArray, getDebugTableForProgramConfiguration */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _init__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./init */ "../webgl/src/init.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lumaStats", function() { return _init__WEBPACK_IMPORTED_MODULE_0__["lumaStats"]; });

/* harmony import */ var _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl-state-tracker */ "../webgl-state-tracker/src/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resetParameters", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__["resetParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getParameter", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__["getParameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getParameters", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__["getParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setParameter", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__["setParameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setParameters", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__["setParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withParameters", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__["withParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getModifiedParameters", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__["getModifiedParameters"]; });

/* harmony import */ var _webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./webgl-utils/webgl-types */ "../webgl/src/webgl-utils/webgl-types.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Image", function() { return _webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_2__["Image"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderingContext", function() { return _webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_2__["WebGLRenderingContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLProgram", function() { return _webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_2__["WebGLProgram"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLShader", function() { return _webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_2__["WebGLShader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLBuffer", function() { return _webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_2__["WebGLBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLFramebuffer", function() { return _webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_2__["WebGLFramebuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderbuffer", function() { return _webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_2__["WebGLRenderbuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLTexture", function() { return _webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_2__["WebGLTexture"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLUniformLocation", function() { return _webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_2__["WebGLUniformLocation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLActiveInfo", function() { return _webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_2__["WebGLActiveInfo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLShaderPrecisionFormat", function() { return _webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_2__["WebGLShaderPrecisionFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGL2RenderingContext", function() { return _webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_2__["WebGL2RenderingContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "webGLTypesAvailable", function() { return _webgl_utils_webgl_types__WEBPACK_IMPORTED_MODULE_2__["webGLTypesAvailable"]; });

/* harmony import */ var _context_context__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./context/context */ "../webgl/src/context/context.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createGLContext", function() { return _context_context__WEBPACK_IMPORTED_MODULE_3__["createGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "destroyGLContext", function() { return _context_context__WEBPACK_IMPORTED_MODULE_3__["destroyGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resizeGLContext", function() { return _context_context__WEBPACK_IMPORTED_MODULE_3__["resizeGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "instrumentGLContext", function() { return _context_context__WEBPACK_IMPORTED_MODULE_3__["instrumentGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setGLContextDefaults", function() { return _context_context__WEBPACK_IMPORTED_MODULE_3__["setGLContextDefaults"]; });

/* harmony import */ var _context_create_canvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./context/create-canvas */ "../webgl/src/context/create-canvas.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCanvas", function() { return _context_create_canvas__WEBPACK_IMPORTED_MODULE_4__["getCanvas"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPageLoadPromise", function() { return _context_create_canvas__WEBPACK_IMPORTED_MODULE_4__["getPageLoadPromise"]; });

/* harmony import */ var _webgl_utils_request_animation_frame__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./webgl-utils/request-animation-frame */ "../webgl/src/webgl-utils/request-animation-frame.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "requestAnimationFrame", function() { return _webgl_utils_request_animation_frame__WEBPACK_IMPORTED_MODULE_5__["requestAnimationFrame"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cancelAnimationFrame", function() { return _webgl_utils_request_animation_frame__WEBPACK_IMPORTED_MODULE_5__["cancelAnimationFrame"]; });

/* harmony import */ var _webgl_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./webgl-utils/webgl-checks */ "../webgl/src/webgl-utils/webgl-checks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWebGL", function() { return _webgl_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_6__["isWebGL"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWebGL2", function() { return _webgl_utils_webgl_checks__WEBPACK_IMPORTED_MODULE_6__["isWebGL2"]; });

/* harmony import */ var _webgl_utils_texture_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./webgl-utils/texture-utils */ "../webgl/src/webgl-utils/texture-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cloneTextureFrom", function() { return _webgl_utils_texture_utils__WEBPACK_IMPORTED_MODULE_7__["cloneTextureFrom"]; });

/* harmony import */ var _webgl_utils_constants_to_keys__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./webgl-utils/constants-to-keys */ "../webgl/src/webgl-utils/constants-to-keys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getKeyValue", function() { return _webgl_utils_constants_to_keys__WEBPACK_IMPORTED_MODULE_8__["getKeyValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getKey", function() { return _webgl_utils_constants_to_keys__WEBPACK_IMPORTED_MODULE_8__["getKey"]; });

/* harmony import */ var _features_limits__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./features/limits */ "../webgl/src/features/limits.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContextInfo", function() { return _features_limits__WEBPACK_IMPORTED_MODULE_9__["getContextInfo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getGLContextInfo", function() { return _features_limits__WEBPACK_IMPORTED_MODULE_9__["getGLContextInfo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContextLimits", function() { return _features_limits__WEBPACK_IMPORTED_MODULE_9__["getContextLimits"]; });

/* harmony import */ var _debug_get_context_debug_info__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./debug/get-context-debug-info */ "../webgl/src/debug/get-context-debug-info.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContextDebugInfo", function() { return _debug_get_context_debug_info__WEBPACK_IMPORTED_MODULE_10__["getContextDebugInfo"]; });

/* harmony import */ var _features_webgl_features_table__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./features/webgl-features-table */ "../webgl/src/features/webgl-features-table.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FEATURES", function() { return _features_webgl_features_table__WEBPACK_IMPORTED_MODULE_11__["FEATURES"]; });

/* harmony import */ var _features_features__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./features/features */ "../webgl/src/features/features.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasFeature", function() { return _features_features__WEBPACK_IMPORTED_MODULE_12__["hasFeature"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasFeatures", function() { return _features_features__WEBPACK_IMPORTED_MODULE_12__["hasFeatures"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getFeatures", function() { return _features_features__WEBPACK_IMPORTED_MODULE_12__["getFeatures"]; });

/* harmony import */ var _features_check_glsl_extension__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./features/check-glsl-extension */ "../webgl/src/features/check-glsl-extension.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "canCompileGLGSExtension", function() { return _features_check_glsl_extension__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _classes_accessor__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./classes/accessor */ "../webgl/src/classes/accessor.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Accessor", function() { return _classes_accessor__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _classes_buffer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./classes/buffer */ "../webgl/src/classes/buffer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Buffer", function() { return _classes_buffer__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _classes_shader__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./classes/shader */ "../webgl/src/classes/shader.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Shader", function() { return _classes_shader__WEBPACK_IMPORTED_MODULE_16__["Shader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VertexShader", function() { return _classes_shader__WEBPACK_IMPORTED_MODULE_16__["VertexShader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FragmentShader", function() { return _classes_shader__WEBPACK_IMPORTED_MODULE_16__["FragmentShader"]; });

/* harmony import */ var _classes_program__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./classes/program */ "../webgl/src/classes/program.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Program", function() { return _classes_program__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _classes_framebuffer__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./classes/framebuffer */ "../webgl/src/classes/framebuffer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Framebuffer", function() { return _classes_framebuffer__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _classes_renderbuffer__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./classes/renderbuffer */ "../webgl/src/classes/renderbuffer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Renderbuffer", function() { return _classes_renderbuffer__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _classes_texture_2d__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./classes/texture-2d */ "../webgl/src/classes/texture-2d.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Texture2D", function() { return _classes_texture_2d__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _classes_texture_cube__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./classes/texture-cube */ "../webgl/src/classes/texture-cube.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextureCube", function() { return _classes_texture_cube__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _classes_clear__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./classes/clear */ "../webgl/src/classes/clear.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return _classes_clear__WEBPACK_IMPORTED_MODULE_22__["clear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clearBuffer", function() { return _classes_clear__WEBPACK_IMPORTED_MODULE_22__["clearBuffer"]; });

/* harmony import */ var _classes_copy_and_blit__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./classes/copy-and-blit */ "../webgl/src/classes/copy-and-blit.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readPixelsToArray", function() { return _classes_copy_and_blit__WEBPACK_IMPORTED_MODULE_23__["readPixelsToArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readPixelsToBuffer", function() { return _classes_copy_and_blit__WEBPACK_IMPORTED_MODULE_23__["readPixelsToBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToDataUrl", function() { return _classes_copy_and_blit__WEBPACK_IMPORTED_MODULE_23__["copyToDataUrl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToImage", function() { return _classes_copy_and_blit__WEBPACK_IMPORTED_MODULE_23__["copyToImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToTexture", function() { return _classes_copy_and_blit__WEBPACK_IMPORTED_MODULE_23__["copyToTexture"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "blit", function() { return _classes_copy_and_blit__WEBPACK_IMPORTED_MODULE_23__["blit"]; });

/* harmony import */ var _classes_query__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./classes/query */ "../webgl/src/classes/query.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Query", function() { return _classes_query__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _classes_texture_3d__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./classes/texture-3d */ "../webgl/src/classes/texture-3d.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Texture3D", function() { return _classes_texture_3d__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _classes_transform_feedback__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./classes/transform-feedback */ "../webgl/src/classes/transform-feedback.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransformFeedback", function() { return _classes_transform_feedback__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _classes_vertex_array_object__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./classes/vertex-array-object */ "../webgl/src/classes/vertex-array-object.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VertexArrayObject", function() { return _classes_vertex_array_object__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony import */ var _classes_vertex_array__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./classes/vertex-array */ "../webgl/src/classes/vertex-array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VertexArray", function() { return _classes_vertex_array__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony import */ var _classes_uniform_buffer_layout__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./classes/uniform-buffer-layout */ "../webgl/src/classes/uniform-buffer-layout.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UniformBufferLayout", function() { return _classes_uniform_buffer_layout__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony import */ var _utils_load_file__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./utils/load-file */ "../webgl/src/utils/load-file.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return _utils_load_file__WEBPACK_IMPORTED_MODULE_30__["setPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFile", function() { return _utils_load_file__WEBPACK_IMPORTED_MODULE_30__["loadFile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return _utils_load_file__WEBPACK_IMPORTED_MODULE_30__["loadImage"]; });

/* harmony import */ var _glsl_utils_get_shader_name__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./glsl-utils/get-shader-name */ "../webgl/src/glsl-utils/get-shader-name.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getShaderName", function() { return _glsl_utils_get_shader_name__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _glsl_utils_get_shader_version__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./glsl-utils/get-shader-version */ "../webgl/src/glsl-utils/get-shader-version.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getShaderVersion", function() { return _glsl_utils_get_shader_version__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./utils/log */ "../webgl/src/utils/log.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log", function() { return _utils_log__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony import */ var _utils_assert__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./utils/assert */ "../webgl/src/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _utils_assert__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony import */ var _utils_utils__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./utils/utils */ "../webgl/src/utils/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uid", function() { return _utils_utils__WEBPACK_IMPORTED_MODULE_35__["uid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObjectEmpty", function() { return _utils_utils__WEBPACK_IMPORTED_MODULE_35__["isObjectEmpty"]; });

/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./utils/globals */ "../webgl/src/utils/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_36__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_36__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_36__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_36__["document"]; });

/* harmony import */ var _utils_is_browser__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./utils/is-browser */ "../webgl/src/utils/is-browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _utils_is_browser__WEBPACK_IMPORTED_MODULE_37__["default"]; });

/* harmony import */ var _utils_device_pixels__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./utils/device-pixels */ "../webgl/src/utils/device-pixels.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cssToDeviceRatio", function() { return _utils_device_pixels__WEBPACK_IMPORTED_MODULE_38__["cssToDeviceRatio"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cssToDevicePixels", function() { return _utils_device_pixels__WEBPACK_IMPORTED_MODULE_38__["cssToDevicePixels"]; });

/* harmony import */ var _classes_uniforms__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./classes/uniforms */ "../webgl/src/classes/uniforms.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseUniformName", function() { return _classes_uniforms__WEBPACK_IMPORTED_MODULE_39__["parseUniformName"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getUniformSetter", function() { return _classes_uniforms__WEBPACK_IMPORTED_MODULE_39__["getUniformSetter"]; });

/* harmony import */ var _debug_debug_uniforms__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./debug/debug-uniforms */ "../webgl/src/debug/debug-uniforms.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDebugTableForUniforms", function() { return _debug_debug_uniforms__WEBPACK_IMPORTED_MODULE_40__["getDebugTableForUniforms"]; });

/* harmony import */ var _debug_debug_vertex_array__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./debug/debug-vertex-array */ "../webgl/src/debug/debug-vertex-array.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDebugTableForVertexArray", function() { return _debug_debug_vertex_array__WEBPACK_IMPORTED_MODULE_41__["getDebugTableForVertexArray"]; });

/* harmony import */ var _debug_debug_program_configuration__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./debug/debug-program-configuration */ "../webgl/src/debug/debug-program-configuration.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDebugTableForProgramConfiguration", function() { return _debug_debug_program_configuration__WEBPACK_IMPORTED_MODULE_42__["getDebugTableForProgramConfiguration"]; });

// luma.gl Base WebGL wrapper library
// Provides simple class/function wrappers around the low level webgl objects
// These classes are intentionally close to the WebGL API
// but make it easier to use.
// Higher level abstractions can be built on these classes

// Initialize any global state


// TODO - should we reexport these?


// Exports WebGL API constants and types, plus some basic type checks






// UTILS


// WebGL Functions









// WebGL Helper Classes


// WebGL1 classes










// Copy and Blit


// WebGL2 classes & Extensions







// experimental WebGL exports



// PARSE SHADER SOURCE



// UTILS







// INTERNAL






/***/ }),

/***/ "../webgl/src/init.js":
/*!****************************!*\
  !*** ../webgl/src/init.js ***!
  \****************************/
/*! exports provided: global, lumaStats, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "lumaStats", function() { return lumaStats; });
/* harmony import */ var _utils_is_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/is-browser */ "../webgl/src/utils/is-browser.js");
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils/globals */ "../webgl/src/utils/globals.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _utils_globals__WEBPACK_IMPORTED_MODULE_1__["global"]; });

/* harmony import */ var _utils_log__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/log */ "../webgl/src/utils/log.js");
/* harmony import */ var probe_gl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! probe.gl */ "../../node_modules/probe.gl/dist/esm/index.js");
/* harmony import */ var _luma_gl_webgl2_polyfill__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @luma.gl/webgl2-polyfill */ "../webgl2-polyfill/src/index.js");





// TODO - when webgl2 gets ubiquitous, remove default support for webgl1 by dropping next line
// Can be installed by applications


// Version detection using babel plugin
/* global __VERSION__ */
const VERSION =  true ? "7.3.1" : undefined;

const STARTUP_MESSAGE = 'set luma.log.priority=1 (or higher) to trace rendering';
// Assign luma.log.priority in console to control logging: \
// 0: none, 1: minimal, 2: verbose, 3: attribute/uniforms, 4: gl logs
// luma.log.break[], set to gl funcs, luma.log.profile[] set to model names`;

class StatsManager {
  constructor() {
    this.stats = new Map();
  }

  get(name) {
    if (!this.stats.has(name)) {
      this.stats.set(name, new probe_gl__WEBPACK_IMPORTED_MODULE_3__["Stats"]({id: name}));
    }

    return this.stats.get(name);
  }
}

const lumaStats = new StatsManager();

if (_utils_globals__WEBPACK_IMPORTED_MODULE_1__["global"].luma && _utils_globals__WEBPACK_IMPORTED_MODULE_1__["global"].luma.VERSION !== VERSION) {
  throw new Error(`luma.gl - multiple VERSIONs detected: ${_utils_globals__WEBPACK_IMPORTED_MODULE_1__["global"].luma.VERSION} vs ${VERSION}`);
}

if (!_utils_globals__WEBPACK_IMPORTED_MODULE_1__["global"].luma) {
  if (_utils_is_browser__WEBPACK_IMPORTED_MODULE_0__["default"]) {
    _utils_log__WEBPACK_IMPORTED_MODULE_2__["default"].log(1, `luma.gl ${VERSION} - ${STARTUP_MESSAGE}`)();
  }

  _utils_globals__WEBPACK_IMPORTED_MODULE_1__["global"].luma = _utils_globals__WEBPACK_IMPORTED_MODULE_1__["global"].luma || {
    VERSION,
    version: VERSION,
    log: _utils_log__WEBPACK_IMPORTED_MODULE_2__["default"],

    // A global stats object that various components can add information to
    // E.g. see webgl/resource.js
    stats: lumaStats,

    // Keep some luma globals in a sub-object
    // This allows us to dynamically detect if certain modules have been
    // included (such as IO and headless) and enable related functionality,
    // without unconditionally requiring and thus bundling big dependencies
    // into the app.
    globals: {
      modules: {},
      nodeIO: {}
    }
  };
}



/* harmony default export */ __webpack_exports__["default"] = (_utils_globals__WEBPACK_IMPORTED_MODULE_1__["global"].luma);


/***/ }),

/***/ "../webgl/src/utils/array-utils-flat.js":
/*!**********************************************!*\
  !*** ../webgl/src/utils/array-utils-flat.js ***!
  \**********************************************/
/*! exports provided: getScratchArrayBuffer, getScratchArray, fillArray */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScratchArrayBuffer", function() { return getScratchArrayBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getScratchArray", function() { return getScratchArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fillArray", function() { return fillArray; });
let arrayBuffer = null;

function getScratchArrayBuffer(byteLength) {
  if (!arrayBuffer || arrayBuffer.byteLength < byteLength) {
    arrayBuffer = new ArrayBuffer(byteLength);
  }
  return arrayBuffer;
}

function getScratchArray(Type, length) {
  const scratchArrayBuffer = getScratchArrayBuffer(Type.BYTES_PER_ELEMENT * length);
  return new Type(scratchArrayBuffer, 0, length); // arrayBuffer, byteOffset, length (in elements)
}

// Uses copyWithin to significantly speed up typed array value filling
function fillArray({target, source, start = 0, count = 1}) {
  const length = source.length;
  const total = count * length;
  let copied = 0;
  for (let i = start; copied < length; copied++) {
    target[i++] = source[copied];
  }

  while (copied < total) {
    // If we have copied less than half, copy everything we got
    // else copy remaining in one operation
    if (copied < total - copied) {
      target.copyWithin(start + copied, start, start + copied);
      copied *= 2;
    } else {
      target.copyWithin(start + copied, start, start + total - copied);
      copied = total;
    }
  }

  return target;
}

/*

// Creates a new Uint8Array based on two different ArrayBuffers
// @private
// @param {ArrayBuffers} buffer1 The first buffer.
// @param {ArrayBuffers} buffer2 The second buffer.
// @return {ArrayBuffers} The new ArrayBuffer created out of the two.
//
export function copyArrayBuffer(
  targetBuffer, sourceBuffer, byteOffset, byteLength = sourceBuffer.byteLength
) {
  const targetArray = new Uint8Array(targetBuffer, byteOffset, byteLength);
  const sourceArray = new Uint8Array(sourceBuffer);
  targetArray.set(sourceArray);
  return targetBuffer;
}

*/


/***/ }),

/***/ "../webgl/src/utils/assert.js":
/*!************************************!*\
  !*** ../webgl/src/utils/assert.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
// Recommendation is to ignore message but current test suite checks agains the
// message so keep it for now.
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'luma.gl: assertion failed.');
  }
}


/***/ }),

/***/ "../webgl/src/utils/check-props.js":
/*!*****************************************!*\
  !*** ../webgl/src/utils/check-props.js ***!
  \*****************************************/
/*! exports provided: checkProps */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkProps", function() { return checkProps; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log */ "../webgl/src/utils/log.js");
/* Use as
import {checkProps} from '../util/check-props;'

const PROP_CHECKS = {
  // Removed props no longer supported, print error and link to upgrade guide
  removedProps: {
  },
  // Deprecated props
  deprecatedProps: {
    offset: 'accessor',
    stride: 'accessor',
    type: 'accessor',
    size: 'accessor',
    divisor: 'accessor',
    normalized: 'accessor',
    integer: 'accessor'
  },
  // Deprecated props that can be autosubstituted, print warning and return updated props object
  replacedProps: {
    bytes: 'byteLength'
  }
}

class Buffer {
  setProps(props) {
    checkProps('Buffer', props, PROP_CHECKS);
  }
}
*/


function checkProps(className, props, propChecks) {
  const {removedProps = {}, deprecatedProps = {}, replacedProps = {}} = propChecks;

  // removedProps: Removed props no longer supported
  // print error and link to upgrade guide
  for (const propName in removedProps) {
    if (propName in props) {
      const replacementProp = removedProps[propName];
      const replacement = replacementProp ? `${className}.${removedProps[propName]}` : 'N/A';
      _log__WEBPACK_IMPORTED_MODULE_0__["default"].removed(`${className}.${propName}`, replacement)();
    }
  }

  // deprecatedProps: Deprecated props that can not be autosubstituted
  // print warning and rely on caller to substitute
  for (const propName in deprecatedProps) {
    if (propName in props) {
      const replacementProp = deprecatedProps[propName];
      _log__WEBPACK_IMPORTED_MODULE_0__["default"].deprecated(`${className}.${propName}`, `${className}.${replacementProp}`)();
    }
  }

  // replacedProps: Deprecated props that can be autosubstituted
  // print warning and return updated props object
  let newProps = null;
  for (const propName in replacedProps) {
    if (propName in props) {
      const replacementProp = replacedProps[propName];
      _log__WEBPACK_IMPORTED_MODULE_0__["default"].deprecated(`${className}.${propName}`, `${className}.${replacementProp}`)();
      newProps = newProps || Object.assign({}, props);
      newProps[replacementProp] = props[propName];
      delete newProps[propName];
    }
  }

  return newProps || props;
}


/***/ }),

/***/ "../webgl/src/utils/device-pixels.js":
/*!*******************************************!*\
  !*** ../webgl/src/utils/device-pixels.js ***!
  \*******************************************/
/*! exports provided: cssToDeviceRatio, cssToDevicePixels, getDevicePixelRatio */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssToDeviceRatio", function() { return cssToDeviceRatio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cssToDevicePixels", function() { return cssToDevicePixels; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDevicePixelRatio", function() { return getDevicePixelRatio; });
/* global window */

// multiplier need to convert CSS size to Device size
function cssToDeviceRatio(gl) {
  if (gl.canvas) {
    return gl.drawingBufferWidth / (gl.canvas.clientWidth || gl.canvas.width || 1);
  }
  // use default device pixel ratio
  return 1;
}

// Maps CSS pixel position to device pixel position
function cssToDevicePixels(gl, cssPixel, yInvert = true) {
  const ratio = cssToDeviceRatio(gl);
  const width = gl.drawingBufferWidth;
  const height = gl.drawingBufferHeight;
  return scalePixels(cssPixel, ratio, width, height, yInvert);
}

// HELPER METHODS

/**
 * Calulates device pixel ratio, used during context creation
 *
 * @param {boolean or Number} useDevicePixels - boolean or a Number
 * @return {Number} - device pixel ratio
 */
function getDevicePixelRatio(useDevicePixels) {
  const windowRatio = typeof window === 'undefined' ? 1 : window.devicePixelRatio || 1;
  if (Number.isFinite(useDevicePixels)) {
    return useDevicePixels <= 0 ? 1 : useDevicePixels;
  }
  return useDevicePixels ? windowRatio : 1;
}

// PRIVATE

function scalePixels(pixel, ratio, width, height, yInvert) {
  const x = scaleX(pixel[0], ratio, width);
  let y = scaleY(pixel[1], ratio, height, yInvert);

  // Find boundaries of next pixel to provide valid range of device pixel locaitons

  let t = scaleX(pixel[0] + 1, ratio, width);
  // If next pixel's position is clamped to boundary, use it as is, otherwise subtract 1 for current pixel boundary
  const xHigh = t === width - 1 ? t : t - 1;

  t = scaleY(pixel[1] + 1, ratio, height, yInvert);
  let yHigh;
  if (yInvert) {
    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range
    t = t === 0 ? t : t + 1;
    // swap y and yHigh
    yHigh = y;
    y = t;
  } else {
    // If next pixel's position is clamped to boundary, use it as is, otherwise clamp it to valid range
    yHigh = t === height - 1 ? t : t - 1;
    // y remains same
  }
  return {
    x,
    y,
    // when ratio < 1, current css pixel and next css pixel may point to same device pixel, set width/height to 1 in those cases.
    width: Math.max(xHigh - x + 1, 1),
    height: Math.max(yHigh - y + 1, 1)
  };
}

function scaleX(x, ratio, width) {
  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit
  const r = Math.min(Math.round(x * ratio), width - 1);
  return r;
}

function scaleY(y, ratio, height, yInvert) {
  // since we are rounding to nearest, when ratio > 1, edge pixels may point to out of bounds value, clamp to the limit
  return yInvert
    ? Math.max(0, height - 1 - Math.round(y * ratio))
    : Math.min(Math.round(y * ratio), height - 1);
}


/***/ }),

/***/ "../webgl/src/utils/format-value.js":
/*!******************************************!*\
  !*** ../webgl/src/utils/format-value.js ***!
  \******************************************/
/*! exports provided: formatValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatValue", function() { return formatValue; });
// TODO / DEPRECATED - delete when confident that probe.gl logging implements all opts
/* eslint-disable no-console */
function formatArrayValue(v, opts) {
  const {maxElts = 16, size = 1} = opts;
  let string = '[';
  for (let i = 0; i < v.length && i < maxElts; ++i) {
    if (i > 0) {
      string += `,${i % size === 0 ? ' ' : ''}`;
    }
    string += formatValue(v[i], opts);
  }
  const terminator = v.length > maxElts ? '...' : ']';
  return `${string}${terminator}`;
}

function formatValue(v, opts = {}) {
  const EPSILON = 1e-16;
  const {isInteger = false} = opts;
  if (Array.isArray(v) || ArrayBuffer.isView(v)) {
    return formatArrayValue(v, opts);
  }
  if (!Number.isFinite(v)) {
    return String(v);
  }
  if (Math.abs(v) < EPSILON) {
    return isInteger ? '0' : '0.';
  }
  if (isInteger) {
    return v.toFixed(0);
  }
  if (Math.abs(v) > 100 && Math.abs(v) < 10000) {
    return v.toFixed(0);
  }
  const string = v.toPrecision(2);
  const decimal = string.indexOf('.0');
  return decimal === string.length - 2 ? string.slice(0, -1) : string;
}


/***/ }),

/***/ "../webgl/src/utils/globals.js":
/*!*************************************!*\
  !*** ../webgl/src/utils/globals.js ***!
  \*************************************/
/*! exports provided: self, window, global, document */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "self", function() { return self_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "window", function() { return window_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "global", function() { return global_; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "document", function() { return document_; });
/* eslint-disable no-restricted-globals */
/* global self, window, global, document */
/* eslint-disable no-restricted-globals */
const globals = {
  self: typeof self !== 'undefined' && self,
  window: typeof window !== 'undefined' && window,
  global: typeof global !== 'undefined' && global,
  document: typeof document !== 'undefined' && document
};

const self_ = globals.self || globals.window || globals.global;
const window_ = globals.window || globals.self || globals.global;
const global_ = globals.global || globals.self || globals.window;
const document_ = globals.document || {};



/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../webgl/src/utils/index.js":
/*!***********************************!*\
  !*** ../webgl/src/utils/index.js ***!
  \***********************************/
/*! exports provided: assert, log, isBrowser, isOldIE, uid, isPowerOfTwo, isObjectEmpty, formatValue, stubRemovedMethods, checkProps, cssToDevicePixels, cssToDeviceRatio, getDevicePixelRatio */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../webgl/src/utils/assert.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _assert__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./log */ "../webgl/src/utils/log.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log", function() { return _log__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _is_browser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is-browser */ "../webgl/src/utils/is-browser.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBrowser", function() { return _is_browser__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _is_old_ie__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./is-old-ie */ "../webgl/src/utils/is-old-ie.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isOldIE", function() { return _is_old_ie__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ "../webgl/src/utils/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uid", function() { return _utils__WEBPACK_IMPORTED_MODULE_4__["uid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isPowerOfTwo", function() { return _utils__WEBPACK_IMPORTED_MODULE_4__["isPowerOfTwo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObjectEmpty", function() { return _utils__WEBPACK_IMPORTED_MODULE_4__["isObjectEmpty"]; });

/* harmony import */ var _format_value__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./format-value */ "../webgl/src/utils/format-value.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatValue", function() { return _format_value__WEBPACK_IMPORTED_MODULE_5__["formatValue"]; });

/* harmony import */ var _stub_methods__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./stub-methods */ "../webgl/src/utils/stub-methods.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stubRemovedMethods", function() { return _stub_methods__WEBPACK_IMPORTED_MODULE_6__["stubRemovedMethods"]; });

/* harmony import */ var _check_props__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./check-props */ "../webgl/src/utils/check-props.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "checkProps", function() { return _check_props__WEBPACK_IMPORTED_MODULE_7__["checkProps"]; });

/* harmony import */ var _device_pixels__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./device-pixels */ "../webgl/src/utils/device-pixels.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cssToDevicePixels", function() { return _device_pixels__WEBPACK_IMPORTED_MODULE_8__["cssToDevicePixels"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cssToDeviceRatio", function() { return _device_pixels__WEBPACK_IMPORTED_MODULE_8__["cssToDeviceRatio"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDevicePixelRatio", function() { return _device_pixels__WEBPACK_IMPORTED_MODULE_8__["getDevicePixelRatio"]; });












/***/ }),

/***/ "../webgl/src/utils/is-browser.js":
/*!****************************************!*\
  !*** ../webgl/src/utils/is-browser.js ***!
  \****************************************/
/*! exports provided: isBrowserMainThread, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBrowserMainThread", function() { return isBrowserMainThread; });
/* harmony import */ var _is_electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is-electron */ "../webgl/src/utils/is-electron.js");
// This function is needed in initialization stages,
// make sure it can be imported in isolation
/* global process */



const isNode =
  typeof process === 'object' && String(process) === '[object process]' && !process.browser;

const isBrowser = !isNode || _is_electron__WEBPACK_IMPORTED_MODULE_0__["default"];

// document does not exist on worker thread
const isBrowserMainThread = isBrowser && typeof document !== 'undefined';

/* harmony default export */ __webpack_exports__["default"] = (isBrowser);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../webgl/src/utils/is-electron.js":
/*!*****************************************!*\
  !*** ../webgl/src/utils/is-electron.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(process) {// based on https://github.com/cheton/is-electron
// https://github.com/electron/electron/issues/2288
/* global window, process, navigator */
function isElectron() {
  // Renderer process
  if (
    typeof window !== 'undefined' &&
    typeof window.process === 'object' &&
    window.process.type === 'renderer'
  ) {
    return true;
  }
  // Main process
  if (
    typeof process !== 'undefined' &&
    typeof process.versions === 'object' &&
    Boolean(process.versions.electron)
  ) {
    return true;
  }
  // Detect the user agent when the `nodeIntegration` option is set to true
  if (
    typeof navigator === 'object' &&
    typeof navigator.userAgent === 'string' &&
    navigator.userAgent.indexOf('Electron') >= 0
  ) {
    return true;
  }
  return false;
}

/* harmony default export */ __webpack_exports__["default"] = (isElectron());

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/process/browser.js */ "../../node_modules/process/browser.js")))

/***/ }),

/***/ "../webgl/src/utils/is-old-ie.js":
/*!***************************************!*\
  !*** ../webgl/src/utils/is-old-ie.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return isOldIE; });
/* harmony import */ var _globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./globals */ "../webgl/src/utils/globals.js");


// opts allows user agent to be overridden for testing
function isOldIE(opts = {}) {
  const navigator = _globals__WEBPACK_IMPORTED_MODULE_0__["window"].navigator || {};
  const userAgent = opts.userAgent || navigator.userAgent || '';
  // We only care about older versions of IE (IE 11 and below). Newer versions of IE (Edge)
  // have much better web standards support.
  const isMSIE = userAgent.indexOf('MSIE ') !== -1;
  const isTrident = userAgent.indexOf('Trident/') !== -1;
  return isMSIE || isTrident;
}


/***/ }),

/***/ "../webgl/src/utils/load-file.js":
/*!***************************************!*\
  !*** ../webgl/src/utils/load-file.js ***!
  \***************************************/
/*! exports provided: setPathPrefix, loadFile, loadImage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return setPathPrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadFile", function() { return loadFile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return loadImage; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");
/* global fetch, Image */


let pathPrefix = '';

/*
 * Set a relative path prefix
 */
function setPathPrefix(prefix) {
  pathPrefix = prefix;
}

// Reads raw file data from:
function loadFile(url, options = {}) {
  Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(typeof url === 'string');
  url = pathPrefix + url;
  const dataType = options.dataType || 'text';
  return fetch(url, options).then(res => res[dataType]());
}

/*
 * Loads images asynchronously
 * image.crossOrigin can be set via opts.crossOrigin, default to 'anonymous'
 * returns a promise tracking the load
 */
function loadImage(url, opts) {
  Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(typeof url === 'string');
  url = pathPrefix + url;
  return new Promise((resolve, reject) => {
    try {
      const image = new Image();
      image.onload = () => resolve(image);
      image.onerror = () => reject(new Error(`Could not load image ${url}.`));
      image.crossOrigin = (opts && opts.crossOrigin) || 'anonymous';
      image.src = url;
    } catch (error) {
      reject(error);
    }
  });
}


/***/ }),

/***/ "../webgl/src/utils/log.js":
/*!*********************************!*\
  !*** ../webgl/src/utils/log.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var probe_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! probe.gl */ "../../node_modules/probe.gl/dist/esm/index.js");


/* harmony default export */ __webpack_exports__["default"] = (new probe_gl__WEBPACK_IMPORTED_MODULE_0__["Log"]({id: 'luma'}).enable());


/***/ }),

/***/ "../webgl/src/utils/stub-methods.js":
/*!******************************************!*\
  !*** ../webgl/src/utils/stub-methods.js ***!
  \******************************************/
/*! exports provided: stubRemovedMethods */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stubRemovedMethods", function() { return stubRemovedMethods; });
/* harmony import */ var _log__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log */ "../webgl/src/utils/log.js");


// Install stubs for removed methods
function stubRemovedMethods(instance, className, version, methodNames) {
  const upgradeMessage = `See luma.gl ${version} Upgrade Guide at \
http://uber.github.io/luma.gl/#/documentation/overview/upgrade-guide`;

  const prototype = Object.getPrototypeOf(instance);

  methodNames.forEach(methodName => {
    if (prototype.methodName) {
      return;
    }

    prototype[methodName] = () => {
      _log__WEBPACK_IMPORTED_MODULE_0__["default"].removed(`Calling removed method ${className}.${methodName}: `, upgradeMessage)();
      throw new Error(methodName);
    };
  });
}


/***/ }),

/***/ "../webgl/src/utils/utils.js":
/*!***********************************!*\
  !*** ../webgl/src/utils/utils.js ***!
  \***********************************/
/*! exports provided: uid, isPowerOfTwo, isObjectEmpty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uid", function() { return uid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isPowerOfTwo", function() { return isPowerOfTwo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObjectEmpty", function() { return isObjectEmpty; });
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../webgl/src/utils/assert.js");


const uidCounters = {};

/**
 * Returns a UID.
 * @param {String} id= - Identifier base name
 * @return {number} uid
 **/
function uid(id = 'id') {
  uidCounters[id] = uidCounters[id] || 1;
  const count = uidCounters[id]++;
  return `${id}-${count}`;
}

/**
 * Verifies if a given number is power of two or not.
 * @param {object} n - The number to check.
 * @return {Array} Returns true if the given number is power of 2, false otherwise.
 **/
function isPowerOfTwo(n) {
  Object(_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(typeof n === 'number', 'Input must be a number');
  return n && (n & (n - 1)) === 0;
}

// Returns true if given object is empty, false otherwise.
function isObjectEmpty(obj) {
  let isEmpty = true;
  /* eslint-disable no-unused-vars  */
  for (const key in obj) {
    isEmpty = false;
    break;
  }
  /* eslint-enable no-unused-vars  */
  return isEmpty;
}


/***/ }),

/***/ "../webgl/src/webgl-utils/attribute-utils.js":
/*!***************************************************!*\
  !*** ../webgl/src/webgl-utils/attribute-utils.js ***!
  \***************************************************/
/*! exports provided: getPrimitiveDrawMode, getPrimitiveCount, getVertexCount, decomposeCompositeGLType, getCompositeGLType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPrimitiveDrawMode", function() { return getPrimitiveDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPrimitiveCount", function() { return getPrimitiveCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVertexCount", function() { return getVertexCount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decomposeCompositeGLType", function() { return decomposeCompositeGLType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCompositeGLType", function() { return getCompositeGLType; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");
/* eslint-disable camelcase */


const GL_BYTE = 0x1400;
const GL_UNSIGNED_BYTE = 0x1401;
const GL_SHORT = 0x1402;
const GL_UNSIGNED_SHORT = 0x1403;

const GL_POINTS = 0x0;
const GL_LINES = 0x1;
const GL_LINE_LOOP = 0x2;
const GL_LINE_STRIP = 0x3;
const GL_TRIANGLES = 0x4;
const GL_TRIANGLE_STRIP = 0x5;
const GL_TRIANGLE_FAN = 0x6;

// Local constants - these will "collapse" during minification
const GL_FLOAT = 0x1406;
const GL_FLOAT_VEC2 = 0x8b50;
const GL_FLOAT_VEC3 = 0x8b51;
const GL_FLOAT_VEC4 = 0x8b52;

const GL_INT = 0x1404;
const GL_INT_VEC2 = 0x8b53;
const GL_INT_VEC3 = 0x8b54;
const GL_INT_VEC4 = 0x8b55;

const GL_UNSIGNED_INT = 0x1405;
const GL_UNSIGNED_INT_VEC2 = 0x8dc6;
const GL_UNSIGNED_INT_VEC3 = 0x8dc7;
const GL_UNSIGNED_INT_VEC4 = 0x8dc8;

const GL_BOOL = 0x8b56;
const GL_BOOL_VEC2 = 0x8b57;
const GL_BOOL_VEC3 = 0x8b58;
const GL_BOOL_VEC4 = 0x8b59;

const GL_FLOAT_MAT2 = 0x8b5a;
const GL_FLOAT_MAT3 = 0x8b5b;
const GL_FLOAT_MAT4 = 0x8b5c;

const GL_FLOAT_MAT2x3 = 0x8b65;
const GL_FLOAT_MAT2x4 = 0x8b66;
const GL_FLOAT_MAT3x2 = 0x8b67;
const GL_FLOAT_MAT3x4 = 0x8b68;
const GL_FLOAT_MAT4x2 = 0x8b69;
const GL_FLOAT_MAT4x3 = 0x8b6a;

// Composite types table
const COMPOSITE_GL_TYPES = {
  [GL_FLOAT]: [GL_FLOAT, 1, 'float'],
  [GL_FLOAT_VEC2]: [GL_FLOAT, 2, 'vec2'],
  [GL_FLOAT_VEC3]: [GL_FLOAT, 3, 'vec3'],
  [GL_FLOAT_VEC4]: [GL_FLOAT, 4, 'vec4'],

  [GL_INT]: [GL_INT, 1, 'int'],
  [GL_INT_VEC2]: [GL_INT, 2, 'ivec2'],
  [GL_INT_VEC3]: [GL_INT, 3, 'ivec3'],
  [GL_INT_VEC4]: [GL_INT, 4, 'ivec4'],

  [GL_UNSIGNED_INT]: [GL_UNSIGNED_INT, 1, 'uint'],
  [GL_UNSIGNED_INT_VEC2]: [GL_UNSIGNED_INT, 2, 'uvec2'],
  [GL_UNSIGNED_INT_VEC3]: [GL_UNSIGNED_INT, 3, 'uvec3'],
  [GL_UNSIGNED_INT_VEC4]: [GL_UNSIGNED_INT, 4, 'uvec4'],

  [GL_BOOL]: [GL_FLOAT, 1, 'bool'],
  [GL_BOOL_VEC2]: [GL_FLOAT, 2, 'bvec2'],
  [GL_BOOL_VEC3]: [GL_FLOAT, 3, 'bvec3'],
  [GL_BOOL_VEC4]: [GL_FLOAT, 4, 'bvec4'],

  [GL_FLOAT_MAT2]: [GL_FLOAT, 8, 'mat2'], // 4
  [GL_FLOAT_MAT2x3]: [GL_FLOAT, 8, 'mat2x3'], // 6
  [GL_FLOAT_MAT2x4]: [GL_FLOAT, 8, 'mat2x4'], // 8

  [GL_FLOAT_MAT3]: [GL_FLOAT, 12, 'mat3'], // 9
  [GL_FLOAT_MAT3x2]: [GL_FLOAT, 12, 'mat3x2'], // 6
  [GL_FLOAT_MAT3x4]: [GL_FLOAT, 12, 'mat3x4'], // 12

  [GL_FLOAT_MAT4]: [GL_FLOAT, 16, 'mat4'], // 16
  [GL_FLOAT_MAT4x2]: [GL_FLOAT, 16, 'mat4x2'], // 8
  [GL_FLOAT_MAT4x3]: [GL_FLOAT, 16, 'mat4x3'] // 12
};

// Counts the number of complete primitives given a number of vertices and a drawMode
function getPrimitiveDrawMode(drawMode) {
  switch (drawMode) {
    case GL_POINTS:
      return GL_POINTS;
    case GL_LINES:
      return GL_LINES;
    case GL_LINE_STRIP:
      return GL_LINES;
    case GL_LINE_LOOP:
      return GL_LINES;
    case GL_TRIANGLES:
      return GL_TRIANGLES;
    case GL_TRIANGLE_STRIP:
      return GL_TRIANGLES;
    case GL_TRIANGLE_FAN:
      return GL_TRIANGLES;
    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
      return 0;
  }
}

// Counts the number of complete "primitives" given a number of vertices and a drawMode
function getPrimitiveCount({drawMode, vertexCount}) {
  switch (drawMode) {
    case GL_POINTS:
    case GL_LINE_LOOP:
      return vertexCount;
    case GL_LINES:
      return vertexCount / 2;
    case GL_LINE_STRIP:
      return vertexCount - 1;
    case GL_TRIANGLES:
      return vertexCount / 3;
    case GL_TRIANGLE_STRIP:
    case GL_TRIANGLE_FAN:
      return vertexCount - 2;
    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
      return 0;
  }
}

// Counts the number of vertices after splitting the vertex stream into separate "primitives"
function getVertexCount({drawMode, vertexCount}) {
  const primitiveCount = getPrimitiveCount({drawMode, vertexCount});
  switch (getPrimitiveDrawMode(drawMode)) {
    case GL_POINTS:
      return primitiveCount;
    case GL_LINES:
      return primitiveCount * 2;
    case GL_TRIANGLES:
      return primitiveCount * 3;
    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(false);
      return 0;
  }
}

// Decomposes a composite type GL.VEC3 into a basic type (GL.FLOAT) and components (3)
function decomposeCompositeGLType(compositeGLType) {
  const typeAndSize = COMPOSITE_GL_TYPES[compositeGLType];
  if (!typeAndSize) {
    return null;
  }
  const [type, components] = typeAndSize;
  return {type, components};
}

function getCompositeGLType(type, components) {
  switch (type) {
    case GL_BYTE:
    case GL_UNSIGNED_BYTE:
    case GL_SHORT:
    case GL_UNSIGNED_SHORT:
      type = GL_FLOAT;
      break;
    default:
  }

  for (const glType in COMPOSITE_GL_TYPES) {
    const [compType, compComponents, name] = COMPOSITE_GL_TYPES[glType];
    if (compType === type && compComponents === components) {
      return {glType, name};
    }
  }
  return null;
}


/***/ }),

/***/ "../webgl/src/webgl-utils/constants-to-keys.js":
/*!*****************************************************!*\
  !*** ../webgl/src/webgl-utils/constants-to-keys.js ***!
  \*****************************************************/
/*! exports provided: getKeyValue, getKey, getKeyType */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKeyValue", function() { return getKeyValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKey", function() { return getKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKeyType", function() { return getKeyType; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");


// Resolve a WebGL enumeration name (returns itself if already a number)
function getKeyValue(gl, name) {
  // If not a string, return (assume number)
  if (typeof name !== 'string') {
    return name;
  }

  // If string converts to number, return number
  const number = Number(name);
  if (!isNaN(number)) {
    return number;
  }

  // Look up string, after removing any 'GL.' or 'gl.' prefix
  name = name.replace(/^.*\./, '');
  const value = gl[name];
  Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(value !== undefined, `Accessing undefined constant GL.${name}`);
  return value;
}

function getKey(gl, value) {
  value = Number(value);
  for (const key in gl) {
    if (gl[key] === value) {
      return `GL.${key}`;
    }
  }
  return String(value);
}

function getKeyType(gl, value) {
  Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(value !== undefined, 'undefined key');
  value = Number(value);
  for (const key in gl) {
    if (gl[key] === value) {
      return `GL.${key}`;
    }
  }
  return String(value);
}


/***/ }),

/***/ "../webgl/src/webgl-utils/format-utils.js":
/*!************************************************!*\
  !*** ../webgl/src/webgl-utils/format-utils.js ***!
  \************************************************/
/*! exports provided: glFormatToComponents, glTypeToBytes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glFormatToComponents", function() { return glFormatToComponents; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "glTypeToBytes", function() { return glTypeToBytes; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");



// Returns number of components in a specific readPixels WebGL format
function glFormatToComponents(format) {
  switch (format) {
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ALPHA:
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.R32F:
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RED:
      return 1;
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RG32F:
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RG:
      return 2;
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGB:
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGB32F:
      return 3;
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA:
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RGBA32F:
      return 4;
    // TODO: Add support for additional WebGL2 formats
    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(false);
      return 0;
  }
}

// Return byte count for given readPixels WebGL type
function glTypeToBytes(type) {
  switch (type) {
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE:
      return 1;
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_SHORT_5_6_5:
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_SHORT_4_4_4_4:
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_SHORT_5_5_5_1:
      return 2;
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT:
      return 4;
    // TODO: Add support for additional WebGL2 types
    default:
      Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(false);
      return 0;
  }
}


/***/ }),

/***/ "../webgl/src/webgl-utils/index.js":
/*!*****************************************!*\
  !*** ../webgl/src/webgl-utils/index.js ***!
  \*****************************************/
/*! exports provided: Image, WebGLRenderingContext, WebGL2RenderingContext, WebGLProgram, WebGLShader, WebGLBuffer, WebGLFramebuffer, WebGLRenderbuffer, WebGLTexture, WebGLUniformLocation, WebGLActiveInfo, WebGLShaderPrecisionFormat, webGLTypesAvailable, isWebGL, isWebGL2, assertWebGLContext, assertWebGL2Context, requestAnimationFrame, cancelAnimationFrame, getGLTypeFromTypedArray, getTypedArrayFromGLType, flipRows, scalePixels, getKeyValue, getKey, getKeyType, cloneTextureFrom */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _webgl_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-types */ "../webgl/src/webgl-utils/webgl-types.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Image", function() { return _webgl_types__WEBPACK_IMPORTED_MODULE_0__["Image"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderingContext", function() { return _webgl_types__WEBPACK_IMPORTED_MODULE_0__["WebGLRenderingContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGL2RenderingContext", function() { return _webgl_types__WEBPACK_IMPORTED_MODULE_0__["WebGL2RenderingContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLProgram", function() { return _webgl_types__WEBPACK_IMPORTED_MODULE_0__["WebGLProgram"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLShader", function() { return _webgl_types__WEBPACK_IMPORTED_MODULE_0__["WebGLShader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLBuffer", function() { return _webgl_types__WEBPACK_IMPORTED_MODULE_0__["WebGLBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLFramebuffer", function() { return _webgl_types__WEBPACK_IMPORTED_MODULE_0__["WebGLFramebuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderbuffer", function() { return _webgl_types__WEBPACK_IMPORTED_MODULE_0__["WebGLRenderbuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLTexture", function() { return _webgl_types__WEBPACK_IMPORTED_MODULE_0__["WebGLTexture"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLUniformLocation", function() { return _webgl_types__WEBPACK_IMPORTED_MODULE_0__["WebGLUniformLocation"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLActiveInfo", function() { return _webgl_types__WEBPACK_IMPORTED_MODULE_0__["WebGLActiveInfo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebGLShaderPrecisionFormat", function() { return _webgl_types__WEBPACK_IMPORTED_MODULE_0__["WebGLShaderPrecisionFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "webGLTypesAvailable", function() { return _webgl_types__WEBPACK_IMPORTED_MODULE_0__["webGLTypesAvailable"]; });

/* harmony import */ var _webgl_checks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl-checks */ "../webgl/src/webgl-utils/webgl-checks.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWebGL", function() { return _webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWebGL2", function() { return _webgl_checks__WEBPACK_IMPORTED_MODULE_1__["isWebGL2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assertWebGLContext", function() { return _webgl_checks__WEBPACK_IMPORTED_MODULE_1__["assertWebGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assertWebGL2Context", function() { return _webgl_checks__WEBPACK_IMPORTED_MODULE_1__["assertWebGL2Context"]; });

/* harmony import */ var _request_animation_frame__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./request-animation-frame */ "../webgl/src/webgl-utils/request-animation-frame.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "requestAnimationFrame", function() { return _request_animation_frame__WEBPACK_IMPORTED_MODULE_2__["requestAnimationFrame"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cancelAnimationFrame", function() { return _request_animation_frame__WEBPACK_IMPORTED_MODULE_2__["cancelAnimationFrame"]; });

/* harmony import */ var _typed_array_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typed-array-utils */ "../webgl/src/webgl-utils/typed-array-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getGLTypeFromTypedArray", function() { return _typed_array_utils__WEBPACK_IMPORTED_MODULE_3__["getGLTypeFromTypedArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getTypedArrayFromGLType", function() { return _typed_array_utils__WEBPACK_IMPORTED_MODULE_3__["getTypedArrayFromGLType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "flipRows", function() { return _typed_array_utils__WEBPACK_IMPORTED_MODULE_3__["flipRows"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "scalePixels", function() { return _typed_array_utils__WEBPACK_IMPORTED_MODULE_3__["scalePixels"]; });

/* harmony import */ var _constants_to_keys__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./constants-to-keys */ "../webgl/src/webgl-utils/constants-to-keys.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getKeyValue", function() { return _constants_to_keys__WEBPACK_IMPORTED_MODULE_4__["getKeyValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getKey", function() { return _constants_to_keys__WEBPACK_IMPORTED_MODULE_4__["getKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getKeyType", function() { return _constants_to_keys__WEBPACK_IMPORTED_MODULE_4__["getKeyType"]; });

/* harmony import */ var _texture_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./texture-utils */ "../webgl/src/webgl-utils/texture-utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cloneTextureFrom", function() { return _texture_utils__WEBPACK_IMPORTED_MODULE_5__["cloneTextureFrom"]; });

// Exports WebGL API constants and types, plus some basic type checks













/***/ }),

/***/ "../webgl/src/webgl-utils/request-animation-frame.js":
/*!***********************************************************!*\
  !*** ../webgl/src/webgl-utils/request-animation-frame.js ***!
  \***********************************************************/
/*! exports provided: requestAnimationFrame, cancelAnimationFrame */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "requestAnimationFrame", function() { return requestAnimationFrame; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cancelAnimationFrame", function() { return cancelAnimationFrame; });
// Node.js polyfills for requestAnimationFrame and cancelAnimationFrame
/* global window, setTimeout, clearTimeout */

function requestAnimationFrame(callback) {
  return typeof window !== 'undefined' && window.requestAnimationFrame
    ? window.requestAnimationFrame(callback)
    : setTimeout(callback, 1000 / 60);
}

function cancelAnimationFrame(timerId) {
  return typeof window !== 'undefined' && window.cancelAnimationFrame
    ? window.cancelAnimationFrame(timerId)
    : clearTimeout(timerId);
}


/***/ }),

/***/ "../webgl/src/webgl-utils/texture-utils.js":
/*!*************************************************!*\
  !*** ../webgl/src/webgl-utils/texture-utils.js ***!
  \*************************************************/
/*! exports provided: cloneTextureFrom, toFramebuffer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "cloneTextureFrom", function() { return cloneTextureFrom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toFramebuffer", function() { return toFramebuffer; });
/* harmony import */ var _classes_texture_2d__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/texture-2d */ "../webgl/src/classes/texture-2d.js");
/* harmony import */ var _classes_texture_cube__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../classes/texture-cube */ "../webgl/src/classes/texture-cube.js");
/* harmony import */ var _classes_texture_3d__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../classes/texture-3d */ "../webgl/src/classes/texture-3d.js");
/* harmony import */ var _classes_framebuffer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../classes/framebuffer */ "../webgl/src/classes/framebuffer.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");
// TODO: Two subdirectories must not depend on each other (classes vs utils)!







// Clone a new texture object from a reference texture object.
function cloneTextureFrom(refTexture, overrides) {
  Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(
    refTexture instanceof _classes_texture_2d__WEBPACK_IMPORTED_MODULE_0__["default"] ||
      refTexture instanceof _classes_texture_cube__WEBPACK_IMPORTED_MODULE_1__["default"] ||
      refTexture instanceof _classes_texture_3d__WEBPACK_IMPORTED_MODULE_2__["default"]
  );

  const TextureType = refTexture.constructor;

  const {gl, width, height, format, type, dataFormat, border, mipmaps} = refTexture;

  const textureOptions = Object.assign(
    {
      width,
      height,
      format,
      type,
      dataFormat,
      border,
      mipmaps
    },
    overrides
  );

  // TODO: move this to `Texture` class as instance method and use this.constructor
  return new TextureType(gl, textureOptions);
}

// Wraps a given texture into a framebuffer object, that can be further used
// to read data from the texture object.
function toFramebuffer(texture, opts) {
  const {gl, width, height, id} = texture;
  const framebuffer = new _classes_framebuffer__WEBPACK_IMPORTED_MODULE_3__["default"](
    gl,
    Object.assign({}, opts, {
      id: `framebuffer-for-${id}`,
      width,
      height,
      attachments: {
        [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_4___default.a.COLOR_ATTACHMENT0]: texture
      }
    })
  );
  return framebuffer;
}


/***/ }),

/***/ "../webgl/src/webgl-utils/typed-array-utils.js":
/*!*****************************************************!*\
  !*** ../webgl/src/webgl-utils/typed-array-utils.js ***!
  \*****************************************************/
/*! exports provided: getGLTypeFromTypedArray, getTypedArrayFromGLType, flipRows, scalePixels */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getGLTypeFromTypedArray", function() { return getGLTypeFromTypedArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTypedArrayFromGLType", function() { return getTypedArrayFromGLType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flipRows", function() { return flipRows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "scalePixels", function() { return scalePixels; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);


const ERR_TYPE_DEDUCTION = 'Failed to deduce GL constant from typed array';

// Converts TYPED ARRAYS to corresponding GL constant
// Used to auto deduce gl parameter types
function getGLTypeFromTypedArray(arrayOrType) {
  // If typed array, look up constructor
  const type = ArrayBuffer.isView(arrayOrType) ? arrayOrType.constructor : arrayOrType;
  switch (type) {
    case Float32Array:
      return _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT;
    case Uint16Array:
      return _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_SHORT;
    case Uint32Array:
      return _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_INT;
    case Uint8Array:
      return _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE;
    case Uint8ClampedArray:
      return _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE;
    case Int8Array:
      return _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BYTE;
    case Int16Array:
      return _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SHORT;
    case Int32Array:
      return _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.INT;
    default:
      throw new Error(ERR_TYPE_DEDUCTION);
  }
}

// Converts GL constant to corresponding TYPED ARRAY
// Used to auto deduce gl parameter types

/* eslint-disable complexity */
function getTypedArrayFromGLType(glType, {clamped = true} = {}) {
  // Sorted in some order of likelihood to reduce amount of comparisons
  switch (glType) {
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.FLOAT:
      return Float32Array;
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_SHORT:
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_SHORT_5_6_5:
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_SHORT_4_4_4_4:
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_SHORT_5_5_5_1:
      return Uint16Array;
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_INT:
      return Uint32Array;
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNSIGNED_BYTE:
      return clamped ? Uint8ClampedArray : Uint8Array;
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.BYTE:
      return Int8Array;
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SHORT:
      return Int16Array;
    case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.INT:
      return Int32Array;
    default:
      throw new Error('Failed to deduce typed array type from GL constant');
  }
}
/* eslint-enable complexity */

// Flip rows (can be used on arrays returned from `Framebuffer.readPixels`)
// https://stackoverflow.com/questions/41969562/
// how-can-i-flip-the-result-of-webglrenderingcontext-readpixels
function flipRows({data, width, height, bytesPerPixel = 4, temp}) {
  const bytesPerRow = width * bytesPerPixel;

  // make a temp buffer to hold one row
  temp = temp || new Uint8Array(bytesPerRow);
  for (let y = 0; y < height / 2; ++y) {
    const topOffset = y * bytesPerRow;
    const bottomOffset = (height - y - 1) * bytesPerRow;
    // make copy of a row on the top half
    temp.set(data.subarray(topOffset, topOffset + bytesPerRow));
    // copy a row from the bottom half to the top
    data.copyWithin(topOffset, bottomOffset, bottomOffset + bytesPerRow);
    // copy the copy of the top half row to the bottom half
    data.set(temp, bottomOffset);
  }
}

function scalePixels({data, width, height}) {
  const newWidth = Math.round(width / 2);
  const newHeight = Math.round(height / 2);
  const newData = new Uint8Array(newWidth * newHeight * 4);
  for (let y = 0; y < newHeight; y++) {
    for (let x = 0; x < newWidth; x++) {
      for (let c = 0; c < 4; c++) {
        newData[(y * newWidth + x) * 4 + c] = data[(y * 2 * width + x * 2) * 4 + c];
      }
    }
  }
  return {data: newData, width: newWidth, height: newHeight};
}


/***/ }),

/***/ "../webgl/src/webgl-utils/webgl-checks.js":
/*!************************************************!*\
  !*** ../webgl/src/webgl-utils/webgl-checks.js ***!
  \************************************************/
/*! exports provided: ERR_CONTEXT, ERR_WEBGL, ERR_WEBGL2, isWebGL, isWebGL2, assertWebGLContext, assertWebGL2Context */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERR_CONTEXT", function() { return ERR_CONTEXT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERR_WEBGL", function() { return ERR_WEBGL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERR_WEBGL2", function() { return ERR_WEBGL2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWebGL", function() { return isWebGL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWebGL2", function() { return isWebGL2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assertWebGLContext", function() { return assertWebGLContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "assertWebGL2Context", function() { return assertWebGL2Context; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "../webgl/src/utils/index.js");
// import {WebGLRenderingContext, WebGL2RenderingContext} from './webgl-types';


// Heuristic testing of contexts (to indentify debug wrappers around gl contexts)
// const GL_ARRAY_BUFFER = 0x8892;

const ERR_CONTEXT = 'Invalid WebGLRenderingContext';
const ERR_WEBGL = ERR_CONTEXT;
const ERR_WEBGL2 = 'Requires WebGL2';

function isWebGL(gl) {
  return Boolean(gl && Number.isFinite(gl._version));
}

function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

function assertWebGLContext(gl) {
  // Need to handle debug context
  Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(isWebGL(gl), ERR_CONTEXT);
}

function assertWebGL2Context(gl) {
  // Need to handle debug context
  Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(isWebGL2(gl), ERR_WEBGL2);
}


/***/ }),

/***/ "../webgl/src/webgl-utils/webgl-types.js":
/*!***********************************************!*\
  !*** ../webgl/src/webgl-utils/webgl-types.js ***!
  \***********************************************/
/*! exports provided: ERR_HEADLESSGL_LOAD, headlessTypes, headlessGL, webGLTypesAvailable, Image, WebGLRenderingContext, WebGLProgram, WebGLShader, WebGLBuffer, WebGLFramebuffer, WebGLRenderbuffer, WebGLTexture, WebGLUniformLocation, WebGLActiveInfo, WebGLShaderPrecisionFormat, WebGL2RenderingContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ERR_HEADLESSGL_LOAD", function() { return ERR_HEADLESSGL_LOAD; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "headlessTypes", function() { return headlessTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "headlessGL", function() { return headlessGL; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "webGLTypesAvailable", function() { return webGLTypesAvailable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Image", function() { return Image; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderingContext", function() { return WebGLRenderingContext; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLProgram", function() { return WebGLProgram; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLShader", function() { return WebGLShader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLBuffer", function() { return WebGLBuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLFramebuffer", function() { return WebGLFramebuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderbuffer", function() { return WebGLRenderbuffer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLTexture", function() { return WebGLTexture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLUniformLocation", function() { return WebGLUniformLocation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLActiveInfo", function() { return WebGLActiveInfo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLShaderPrecisionFormat", function() { return WebGLShaderPrecisionFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGL2RenderingContext", function() { return WebGL2RenderingContext; });
/* harmony import */ var _utils_globals__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/globals */ "../webgl/src/utils/globals.js");
/* harmony import */ var _utils_is_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/is-browser */ "../webgl/src/utils/is-browser.js");
// WEBGL BUILT-IN TYPES
// 1) Exports all WebGL constants as {GL}
// 2) Enables app to "import" WebGL types
//    - Importing these types makes them known to eslint etc.
//    - Provides dummy types for WebGL2 when not available to streamline
//      library code.
//    - Exports types from headless gl when running under Node.js

/* eslint-disable quotes, no-console */



const ERR_HEADLESSGL_LOAD = `\
luma.gl: loaded under Node.js without headless gl installed, meaning that WebGL \
contexts can not be created. This may not be an error. For example, this is a \
typical configuration for isorender applications running on the server.`;

// TODO(Tarek): OOGLY HACK to avoid webpack requiring headless
//   browser bundles. Will be removed in 8.0 when we
//   remove automatic headless context creation
const m = module;

// Load headless gl dynamically, if available
let headlessTypes = null;
function headlessGL(...args) {
  const headless = m.require('gl');
  if (!headless) {
    throw new Error(ERR_HEADLESSGL_LOAD);
  }
  return headless(...args);
}

if (!_utils_is_browser__WEBPACK_IMPORTED_MODULE_1__["default"]) {
  try {
    headlessTypes = m.require('gl/wrap');
  } catch (error) {
    // /* global console */
    // console.info(ERR_HEADLESSGL_LOAD);
  }
}

class DummyType {}

const {
  WebGLRenderingContext = DummyType,
  WebGLProgram = DummyType,
  WebGLShader = DummyType,
  WebGLBuffer = DummyType,
  WebGLFramebuffer = DummyType,
  WebGLRenderbuffer = DummyType,
  WebGLTexture = DummyType,
  WebGLUniformLocation = DummyType,
  WebGLActiveInfo = DummyType,
  WebGLShaderPrecisionFormat = DummyType
} = headlessTypes || _utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"];

const webGLTypesAvailable =
  WebGLRenderingContext !== DummyType &&
  WebGLProgram !== DummyType &&
  WebGLShader !== DummyType &&
  WebGLBuffer !== DummyType &&
  WebGLFramebuffer !== DummyType &&
  WebGLRenderbuffer !== DummyType &&
  WebGLTexture !== DummyType &&
  WebGLUniformLocation !== DummyType &&
  WebGLActiveInfo !== DummyType &&
  WebGLShaderPrecisionFormat !== DummyType;

// Ensures that WebGL2RenderingContext is defined in non-WebGL2 environments
// so that apps can test their gl contexts with instanceof
// E.g. if (gl instanceof WebGL2RenderingContext) { }
function getWebGL2RenderingContext() {
  class WebGL2RenderingContextNotSupported {}
  return _utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"].WebGL2RenderingContext || WebGL2RenderingContextNotSupported;
}

// Ensure that Image is defined under Node.js
function getImage() {
  class ImageNotSupported {}
  return _utils_globals__WEBPACK_IMPORTED_MODULE_0__["global"].Image || ImageNotSupported;
}

const WebGL2RenderingContext = getWebGL2RenderingContext();
const Image = getImage();

// Export the standard WebGL types


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/harmony-module.js */ "../../node_modules/webpack/buildin/harmony-module.js")(module)))

/***/ }),

/***/ "../webgl2-polyfill/src/assert.js":
/*!****************************************!*\
  !*** ../webgl2-polyfill/src/assert.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return assert; });
function assert(condition, message) {
  if (!condition) {
    throw new Error(message || 'webgl2-polyfill: assertion failed.');
  }
}


/***/ }),

/***/ "../webgl2-polyfill/src/index.js":
/*!***************************************!*\
  !*** ../webgl2-polyfill/src/index.js ***!
  \***************************************/
/*! exports provided: polyfillContext, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _polyfill_context__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./polyfill-context */ "../webgl2-polyfill/src/polyfill-context.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "polyfillContext", function() { return _polyfill_context__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "default", function() { return _polyfill_context__WEBPACK_IMPORTED_MODULE_0__["default"]; });

// Installs polyfills to support a subset of WebGL2 APIs on WebGL1 contexts





/***/ }),

/***/ "../webgl2-polyfill/src/polyfill-context.js":
/*!**************************************************!*\
  !*** ../webgl2-polyfill/src/polyfill-context.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return polyfillContext; });
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./assert */ "../webgl2-polyfill/src/assert.js");
/* harmony import */ var _polyfill_table__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./polyfill-table */ "../webgl2-polyfill/src/polyfill-table.js");
// WebGL1/WebGL2 extension polyfill support
//
// Provides a function that creates polyfills for WebGL2 functions based
// on available extensions and installs them on a supplied target (could be
// the WebGLContext or its prototype, or a separate object).
//
// This is intended to be a stand-alone file with minimal dependencies,
// easy to reuse or repurpose in other projects.

/* eslint-disable camelcase, brace-style */




// Registers extensions, polyfills or mock functions for extensions in the polyfills list
// TODO - remove use of name `luma`.
function polyfillContext(gl) {
  gl.luma = gl.luma || {};
  initializeExtensions(gl);
  if (!gl.luma.polyfilled) {
    installPolyfills(gl, _polyfill_table__WEBPACK_IMPORTED_MODULE_1__["WEBGL2_CONTEXT_POLYFILLS"]);
    installOverrides(gl, {target: gl.luma, target2: gl});
    gl.luma.polyfilled = true;
  }
  return gl;
}

// TODO - is this still required?
/* global window, global */
const global_ = typeof global !== 'undefined' ? global : window;
global_.polyfillContext = polyfillContext;

function initializeExtensions(gl) {
  gl.luma.extensions = {};
  // `getSupportedExtensions` can return null when context is lost.
  const EXTENSIONS = gl.getSupportedExtensions() || [];
  for (const extension of EXTENSIONS) {
    gl.luma[extension] = gl.getExtension(extension);
  }
}

// Install simple overrides (mostly get* functions)
function installOverrides(gl, {target, target2}) {
  Object.keys(_polyfill_table__WEBPACK_IMPORTED_MODULE_1__["WEBGL2_CONTEXT_OVERRIDES"]).forEach(key => {
    if (typeof _polyfill_table__WEBPACK_IMPORTED_MODULE_1__["WEBGL2_CONTEXT_OVERRIDES"][key] === 'function') {
      // install an override, if no implementation was detected
      const originalFunc = gl[key] ? gl[key].bind(gl) : () => {};
      const polyfill = _polyfill_table__WEBPACK_IMPORTED_MODULE_1__["WEBGL2_CONTEXT_OVERRIDES"][key].bind(null, gl, originalFunc);
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  });
}

function installPolyfills(gl, polyfills) {
  for (const extension of Object.getOwnPropertyNames(polyfills)) {
    if (extension !== 'overrides') {
      polyfillExtension(gl, {extension, target: gl.luma, target2: gl});
    }
  }
}

// Polyfills a single WebGL extension into the `target` object
function polyfillExtension(gl, {extension, target, target2}) {
  const defaults = _polyfill_table__WEBPACK_IMPORTED_MODULE_1__["WEBGL2_CONTEXT_POLYFILLS"][extension];
  Object(_assert__WEBPACK_IMPORTED_MODULE_0__["default"])(defaults);

  const {meta = {}} = defaults;
  const {suffix = ''} = meta;

  const ext = gl.getExtension(extension);

  for (const key of Object.keys(defaults)) {
    const extKey = `${key}${suffix}`;

    let polyfill = null;
    if (key === 'meta') {
      // ignore
    } else if (typeof gl[key] === 'function') {
      // WebGL2 implementation is already
    } else if (ext && typeof ext[extKey] === 'function') {
      // pick extension implemenentation,if available
      polyfill = (...args) => ext[extKey](...args);
    } else if (typeof defaults[key] === 'function') {
      // pick the mock implementation, if no implementation was detected
      polyfill = defaults[key].bind(target);
    }

    if (polyfill) {
      target[key] = polyfill;
      target2[key] = polyfill;
    }
  }
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../webgl2-polyfill/src/polyfill-table.js":
/*!************************************************!*\
  !*** ../webgl2-polyfill/src/polyfill-table.js ***!
  \************************************************/
/*! exports provided: WEBGL2_CONTEXT_POLYFILLS, WEBGL2_CONTEXT_OVERRIDES */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBGL2_CONTEXT_POLYFILLS", function() { return WEBGL2_CONTEXT_POLYFILLS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WEBGL2_CONTEXT_OVERRIDES", function() { return WEBGL2_CONTEXT_OVERRIDES; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _assert__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assert */ "../webgl2-polyfill/src/assert.js");
/* harmony import */ var _polyfills_get_parameter_polyfill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./polyfills/get-parameter-polyfill */ "../webgl2-polyfill/src/polyfills/get-parameter-polyfill.js");





const OES_vertex_array_object = 'OES_vertex_array_object';
const ANGLE_instanced_arrays = 'ANGLE_instanced_arrays';
const WEBGL_draw_buffers = 'WEBGL_draw_buffers';
const EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
const EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';

const ERR_VAO_NOT_SUPPORTED = 'VertexArray requires WebGL2 or OES_vertex_array_object extension';

// Return true if WebGL2 context
function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

// Return object with webgl2 flag and an extension
function getExtensionData(gl, extension) {
  return {
    webgl2: isWebGL2(gl),
    ext: gl.getExtension(extension)
  };
}

// function mapExtensionConstant(gl, constant) {
//   switch (constant) {
//   case ext.FRAGMENT_SHADER_DERIVATIVE_HINT_OES: return GL.FRAGMENT_SHADER_DERIVATIVE_HINT;
//   }
// }

const WEBGL2_CONTEXT_POLYFILLS = {
  // POLYFILL TABLE
  [OES_vertex_array_object]: {
    meta: {suffix: 'OES'},
    // NEW METHODS
    createVertexArray: () => {
      Object(_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false, ERR_VAO_NOT_SUPPORTED);
    },
    deleteVertexArray: () => {},
    bindVertexArray: () => {},
    isVertexArray: () => false
  },
  [ANGLE_instanced_arrays]: {
    meta: {
      suffix: 'ANGLE'
      // constants: {
      //   VERTEX_ATTRIB_ARRAY_DIVISOR: 'VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE'
      // }
    },
    vertexAttribDivisor(location, divisor) {
      // Accept divisor 0 even if instancing is not supported (0 = no instancing)
      Object(_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(divisor === 0, 'WebGL instanced rendering not supported');
    },
    drawElementsInstanced: () => {},
    drawArraysInstanced: () => {}
  },
  [WEBGL_draw_buffers]: {
    meta: {
      suffix: 'WEBGL'
    },
    drawBuffers: () => {
      Object(_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
    }
  },
  [EXT_disjoint_timer_query]: {
    meta: {suffix: 'EXT'},
    // WebGL1: Polyfills the WebGL2 Query API
    createQuery: () => {
      Object(_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
    },
    deleteQuery: () => {
      Object(_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
    },
    beginQuery: () => {
      Object(_assert__WEBPACK_IMPORTED_MODULE_1__["default"])(false);
    },
    endQuery: () => {},
    getQuery(handle, pname) {
      return this.getQueryObject(handle, pname);
    },
    // The WebGL1 extension uses getQueryObject rather then getQueryParameter
    getQueryParameter(handle, pname) {
      return this.getQueryObject(handle, pname);
    },
    getQueryObject: () => {}
  }
};

const WEBGL2_CONTEXT_OVERRIDES = {
  // Ensure readBuffer is a no-op
  readBuffer: (gl, originalFunc, attachment) => {
    if (isWebGL2(gl)) {
      originalFunc(attachment);
    } else {
      // assert(attachment !== GL_COLOR_ATTACHMENT0 && attachment !== GL_FRONT);
    }
  },
  // Override for getVertexAttrib that returns sane values for non-WebGL1 constants
  getVertexAttrib: (gl, originalFunc, location, pname) => {
    // const gl = this; // eslint-disable-line
    const {webgl2, ext} = getExtensionData(gl, ANGLE_instanced_arrays);

    let result;
    switch (pname) {
      // WebGL1 attributes will never be integer
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VERTEX_ATTRIB_ARRAY_INTEGER:
        result = !webgl2 ? false : undefined;
        break;
      // if instancing is not available, return 0 meaning divisor has not been set
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VERTEX_ATTRIB_ARRAY_DIVISOR:
        result = !webgl2 && !ext ? 0 : undefined;
        break;
      default:
    }

    return result !== undefined ? result : originalFunc(location, pname);
  },
  // Handle transform feedback and uniform block queries in WebGL1
  getProgramParameter: (gl, originalFunc, program, pname) => {
    if (!isWebGL2(gl)) {
      switch (pname) {
        case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TRANSFORM_FEEDBACK_BUFFER_MODE:
          return _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SEPARATE_ATTRIBS;
        case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TRANSFORM_FEEDBACK_VARYINGS:
          return 0;
        case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ACTIVE_UNIFORM_BLOCKS:
          return 0;
        default:
      }
    }
    return originalFunc(program, pname);
  },
  getInternalformatParameter: (gl, originalFunc, target, format, pname) => {
    if (!isWebGL2(gl)) {
      switch (pname) {
        case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLES:
          return new Int32Array([0]);
        default:
      }
    }
    return gl.getInternalformatParameter(target, format, pname);
  },
  getTexParameter(gl, originalFunc, target, pname) {
    switch (pname) {
      case _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MAX_ANISOTROPY_EXT:
        const {extensions} = gl.luma;
        const ext = extensions[EXT_texture_filter_anisotropic];
        pname = (ext && ext.TEXTURE_MAX_ANISOTROPY_EXT) || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MAX_ANISOTROPY_EXT;
        break;
      default:
    }
    return originalFunc(target, pname);
  },
  getParameter: _polyfills_get_parameter_polyfill__WEBPACK_IMPORTED_MODULE_2__["getParameterPolyfill"],
  hint(gl, originalFunc, pname, value) {
    // TODO - handle GL.FRAGMENT_SHADER_DERIVATIVE_HINT:
    // switch (pname) {
    // case GL.FRAGMENT_SHADER_DERIVATIVE_HINT:
    // }
    return originalFunc(pname, value);
  }
};


/***/ }),

/***/ "../webgl2-polyfill/src/polyfills/get-parameter-polyfill.js":
/*!******************************************************************!*\
  !*** ../webgl2-polyfill/src/polyfills/get-parameter-polyfill.js ***!
  \******************************************************************/
/*! exports provided: getParameterPolyfill */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getParameterPolyfill", function() { return getParameterPolyfill; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* eslint-disable no-inline-comments, max-len, camelcase */


const OES_element_index = 'OES_element_index';
const WEBGL_draw_buffers = 'WEBGL_draw_buffers';
const EXT_disjoint_timer_query = 'EXT_disjoint_timer_query';
const EXT_disjoint_timer_query_webgl2 = 'EXT_disjoint_timer_query_webgl2';
const EXT_texture_filter_anisotropic = 'EXT_texture_filter_anisotropic';
const WEBGL_debug_renderer_info = 'WEBGL_debug_renderer_info';

const GL_FRAGMENT_SHADER_DERIVATIVE_HINT = 0x8b8b;
const GL_DONT_CARE = 0x1100;
const GL_GPU_DISJOINT_EXT = 0x8fbb;
const GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT = 0x84ff;
const GL_UNMASKED_VENDOR_WEBGL = 0x9245; // vendor string of the graphics driver.
const GL_UNMASKED_RENDERER_WEBGL = 0x9246; // renderer string of the graphics driver.

const getWebGL2ValueOrZero = gl => (!isWebGL2(gl) ? 0 : undefined);

// if a function returns undefined in this table,
// the original getParameter will be called, defeating the override
const WEBGL_PARAMETERS = {
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.READ_BUFFER]: gl => (!isWebGL2(gl) ? _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0 : undefined),

  // WebGL2 context parameters
  [GL_FRAGMENT_SHADER_DERIVATIVE_HINT]: gl => (!isWebGL2(gl) ? GL_DONT_CARE : undefined),

  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RASTERIZER_DISCARD]: getWebGL2ValueOrZero,

  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.SAMPLES]: getWebGL2ValueOrZero,

  // WebGL2 extension context parameters
  [GL_GPU_DISJOINT_EXT]: (gl, getParameter) => {
    const ext = isWebGL2(gl)
      ? gl.getExtension(EXT_disjoint_timer_query_webgl2)
      : gl.getExtension(EXT_disjoint_timer_query);
    return ext && ext.GPU_DISJOINT_EXT ? getParameter(ext.GPU_DISJOINT_EXT) : 0;
  },

  // Extension fixed values
  [GL_UNMASKED_VENDOR_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter((ext && ext.UNMASKED_VENDOR_WEBGL) || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.VENDOR);
  },

  [GL_UNMASKED_RENDERER_WEBGL]: (gl, getParameter) => {
    const ext = gl.getExtension(WEBGL_debug_renderer_info);
    return getParameter((ext && ext.UNMASKED_RENDERER_WEBGL) || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RENDERER);
  },

  // Extension LIMITS
  [GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT]: (gl, getParameter) => {
    const ext = gl.luma.extensions[EXT_texture_filter_anisotropic];
    return ext ? getParameter(ext.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 1.0;
  },

  // WebGL2 Limits
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_3D_TEXTURE_SIZE]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_ARRAY_TEXTURE_LAYERS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_CLIENT_WAIT_TIMEOUT_WEBGL]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_COLOR_ATTACHMENTS]: (gl, getParameter) => {
    if (!isWebGL2(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? getParameter(ext.MAX_COLOR_ATTACHMENTS_WEBGL) : 0;
    }
    return undefined;
  },
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_COMBINED_UNIFORM_BLOCKS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_DRAW_BUFFERS]: gl => {
    if (!isWebGL2(gl)) {
      const ext = gl.getExtension(WEBGL_draw_buffers);
      return ext ? ext.MAX_DRAW_BUFFERS_WEBGL : 0;
    }
    return undefined;
  },
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_ELEMENT_INDEX]:
    // Guess: per webglstats.com 99.6% of webgl2 supports 2147483647
    gl => (gl.getExtension(OES_element_index) ? 2147483647 : 65535),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_ELEMENTS_INDICES]:
    // Guess: "Reasonably safe" per webglstats.com - could be higher/lower (on some mobile devices)
    gl => (gl.getExtension(OES_element_index) ? 16777216 : 65535),
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_ELEMENTS_VERTICES]:
    // Guess: "Reasonably safe" per webglstats.com - could be higher/lower (on some mobile devices)
    gl => 16777216,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_FRAGMENT_INPUT_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_FRAGMENT_UNIFORM_BLOCKS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_FRAGMENT_UNIFORM_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_SAMPLES]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_SERVER_WAIT_TIMEOUT]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_TEXTURE_LOD_BIAS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_UNIFORM_BLOCK_SIZE]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_UNIFORM_BUFFER_BINDINGS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_VARYING_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_VERTEX_OUTPUT_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_VERTEX_UNIFORM_BLOCKS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_VERTEX_UNIFORM_COMPONENTS]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MIN_PROGRAM_TEXEL_OFFSET]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.MAX_PROGRAM_TEXEL_OFFSET]: getWebGL2ValueOrZero,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNIFORM_BUFFER_OFFSET_ALIGNMENT]: getWebGL2ValueOrZero
};

// Return true if WebGL2 context
function isWebGL2(gl) {
  return Boolean(gl && gl._version === 2);
}

// A "replacement" gl.getParameter that accepts "enums" from extensions and WebGL2
// and returns reasonably safe defaults
function getParameterPolyfill(gl, originalGetParameter, pname) {
  // Return mock limits (usually 0) for WebGL2 constants to ensure these
  // can be queries without error
  const limit = WEBGL_PARAMETERS[pname];
  const value = typeof limit === 'function' ? limit(gl, originalGetParameter, pname) : limit;
  const result = value !== undefined ? value : originalGetParameter(pname);
  return result;
}


/***/ }),

/***/ "./bundle.js":
/*!*******************!*\
  !*** ./bundle.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {/* global window, global */
const moduleExports = __webpack_require__(/*! ./src */ "./src/index.js");

const _global = typeof window === 'undefined' ? global : window;
_global.loaders = _global.luma || {};

module.exports = Object.assign(_global.luma, moduleExports);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../node_modules/webpack/buildin/global.js */ "../../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./src/debug/seer-integration.js":
/*!***************************************!*\
  !*** ./src/debug/seer-integration.js ***!
  \***************************************/
/*! exports provided: addModel, logModel, removeModel, setOverride, getOverrides */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "addModel", function() { return addModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logModel", function() { return logModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "removeModel", function() { return removeModel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setOverride", function() { return setOverride; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getOverrides", function() { return getOverrides; });
/* harmony import */ var seer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! seer */ "../../node_modules/seer/dist/index.js");
/* harmony import */ var seer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(seer__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");




const models = {};

/**
 * Add a model to our cache indexed by id
 */
const addModel = model => {
  if (models[model.id]) {
    return;
  }
  models[model.id] = model;

  seer__WEBPACK_IMPORTED_MODULE_0___default.a.listItem('luma.gl', model.id);
};

/**
 * Log a model uniforms and attributes.
 */
const logModel = (model, uniforms) => {
  if (!seer__WEBPACK_IMPORTED_MODULE_0___default.a.isReady() || seer__WEBPACK_IMPORTED_MODULE_0___default.a.throttle(`luma.gl:${model.id}`, 1e3)) {
    return;
  }

  const attributesObject = model.geometry
    ? Object.assign({}, model.geometry.attributes, model.attributes)
    : model.attributes;
  const uniformsObject = Object.assign({}, model.uniforms, uniforms);

  seer__WEBPACK_IMPORTED_MODULE_0___default.a.multiUpdate('luma.gl', model.id, [
    {path: 'objects.uniforms', data: uniformsObject},
    {path: 'objects.attributes', data: attributesObject}
  ]);
};

/**
 * Remove a previously set model from the cache
 */
const removeModel = id => {
  delete models[id];
  seer__WEBPACK_IMPORTED_MODULE_0___default.a.deleteItem('luma.gl', id);
};

/**
 * Recursively traverse an object given a path of properties and set the given value
 */
const recursiveSet = (obj, path, value) => {
  if (!obj) {
    return;
  }

  if (path.length > 1) {
    recursiveSet(obj[path[0]], path.slice(1), value);
  } else {
    obj[path[0]] = value;
  }
};

const overrides = new Map();

/**
 * Create an override on the specify layer, indexed by a valuePath array.
 * Do nothing in case Seer as not been initialized to prevent any preformance drawback.
 */
const setOverride = (id, valuePath, value) => {
  if (!_utils__WEBPACK_IMPORTED_MODULE_1__["window"].__SEER_INITIALIZED__) {
    return;
  }

  if (!overrides.has(id)) {
    overrides.set(id, new Map());
  }

  const uniforms = overrides.get(id);
  uniforms.set(valuePath, value);
};

/**
 * Apply overrides to a specific model's uniforms
 */
const getOverrides = (id, uniforms) => {
  if (!_utils__WEBPACK_IMPORTED_MODULE_1__["window"].__SEER_INITIALIZED__ || !id) {
    return;
  }

  const overs = overrides.get(id);
  if (!overs) {
    return;
  }

  overs.forEach((value, valuePath) => {
    recursiveSet(uniforms, valuePath, value);
  });
};

/**
 * Listen for luma.gl edit events
 */
seer__WEBPACK_IMPORTED_MODULE_0___default.a.listenFor('luma.gl', payload => {
  const model = models[payload.itemKey];
  if (!model || payload.type !== 'edit' || payload.valuePath[0] !== 'uniforms') {
    return;
  }

  const valuePath = payload.valuePath.slice(1);
  setOverride(payload.itemKey, valuePath, payload.value);

  const uniforms = model.getUniforms();
  recursiveSet(uniforms, valuePath, payload.value);
  model.setUniforms(uniforms);
});


/***/ }),

/***/ "./src/geometries/cone-geometry.js":
/*!*****************************************!*\
  !*** ./src/geometries/cone-geometry.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ConeGeometry; });
/* harmony import */ var _truncated_cone_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./truncated-cone-geometry */ "./src/geometries/truncated-cone-geometry.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");



class ConeGeometry extends _truncated_cone_geometry__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(props = {}) {
    const {id = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["uid"])('cone-geometry'), radius = 1, cap = true} = props;
    super({
      ...props,
      id,
      topRadius: 0,
      topCap: Boolean(cap),
      bottomCap: Boolean(cap),
      bottomRadius: radius
    });
  }
}


/***/ }),

/***/ "./src/geometries/cube-geometry.js":
/*!*****************************************!*\
  !*** ./src/geometries/cube-geometry.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CubeGeometry; });
/* harmony import */ var _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/geometry */ "./src/geometry/geometry.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");



// prettier-ignore
const CUBE_INDICES = new Uint16Array([
  0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13,
  14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23
]);

// prettier-ignore
const CUBE_POSITIONS = new Float32Array([
  -1,  -1,  1, 1,  -1,  1,  1,  1,  1,  -1,  1,  1,
  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1,  -1,
  -1,  1,  -1,  -1,  1,  1,  1,  1,  1,  1,  1,  -1,
  -1,  -1,  -1,  1,  -1,  -1,  1,  -1,  1,  -1,  -1,  1,
  1,  -1,  -1,  1,  1,  -1,  1,  1,  1,  1,  -1,  1,
  -1,  -1,  -1,  -1,  -1,  1,  -1,  1,  1,  -1,  1,  -1
]);

// TODO - could be Uint8
// prettier-ignore
const CUBE_NORMALS = new Float32Array([
  // Front face
  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,
  // Back face
  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,
  // Top face
  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,
  // Bottom face
  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,
  // Right face
  1,  0,  0,  1,  0,  0,  1,  0,  0,  1,  0,  0,
  // Left face
  -1,  0,  0,  -1,  0,  0,  -1,  0,  0,  -1,  0,  0
]);

// prettier-ignore
const CUBE_TEX_COORDS = new Float32Array([
  // Front face
  0,  0,  1,  0,  1,  1,  0,  1,
  // Back face
  1,  0,  1,  1,  0,  1,  0,  0,
  // Top face
  0,  1,  0,  0,  1,  0,  1,  1,
  // Bottom face
  1,  1,  0,  1,  0,  0,  1,  0,
  // Right face
  1,  0,  1,  1,  0,  1,  0,  0,
  // Left face
  0,  0,  1,  0,  1,  1,  0,  1
]);

const ATTRIBUTES = {
  POSITION: {size: 3, value: new Float32Array(CUBE_POSITIONS)},
  NORMAL: {size: 3, value: new Float32Array(CUBE_NORMALS)},
  TEXCOORD_0: {size: 2, value: new Float32Array(CUBE_TEX_COORDS)}
};

class CubeGeometry extends _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(props = {}) {
    const {id = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["uid"])('cube-geometry')} = props;
    super({
      ...props,
      id,
      indices: {size: 1, value: new Uint16Array(CUBE_INDICES)},
      attributes: {...ATTRIBUTES, ...props.attributes}
    });
  }
}


/***/ }),

/***/ "./src/geometries/cylinder-geometry.js":
/*!*********************************************!*\
  !*** ./src/geometries/cylinder-geometry.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CylinderGeometry; });
/* harmony import */ var _truncated_cone_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./truncated-cone-geometry */ "./src/geometries/truncated-cone-geometry.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");



class CylinderGeometry extends _truncated_cone_geometry__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(props = {}) {
    const {id = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["uid"])('cylinder-geometry'), radius = 1} = props;
    super({
      ...props,
      id,
      bottomRadius: radius,
      topRadius: radius
    });
  }
}


/***/ }),

/***/ "./src/geometries/ico-sphere-geometry.js":
/*!***********************************************!*\
  !*** ./src/geometries/ico-sphere-geometry.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return IcoSphereGeometry; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _geometry_geometry__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/geometry */ "./src/geometry/geometry.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");




/* eslint-disable comma-spacing, max-statements, complexity */

const ICO_POSITIONS = [-1, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, -1, 0, 1, 0, 0];
const ICO_INDICES = [3, 4, 5, 3, 5, 1, 3, 1, 0, 3, 0, 4, 4, 0, 2, 4, 2, 5, 2, 0, 1, 5, 2, 1];

class IcoSphereGeometry extends _geometry_geometry__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(props = {}) {
    const {id = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["uid"])('ico-sphere-geometry')} = props;
    const {indices, attributes} = tesselateIcosaHedron(props);
    super({
      ...props,
      id,
      indices,
      attributes: {...attributes, ...props.attributes}
    });
  }
}

function tesselateIcosaHedron(props) {
  const {iterations = 0} = props;

  const PI = Math.PI;
  const PI2 = PI * 2;

  const positions = [...ICO_POSITIONS];
  let indices = [...ICO_INDICES];

  positions.push();
  indices.push();

  const getMiddlePoint = (() => {
    const pointMemo = {};

    return (i1, i2) => {
      i1 *= 3;
      i2 *= 3;
      const mini = i1 < i2 ? i1 : i2;
      const maxi = i1 > i2 ? i1 : i2;
      const key = `${mini}|${maxi}`;

      if (key in pointMemo) {
        return pointMemo[key];
      }

      const x1 = positions[i1];
      const y1 = positions[i1 + 1];
      const z1 = positions[i1 + 2];
      const x2 = positions[i2];
      const y2 = positions[i2 + 1];
      const z2 = positions[i2 + 2];
      let xm = (x1 + x2) / 2;
      let ym = (y1 + y2) / 2;
      let zm = (z1 + z2) / 2;
      const len = Math.sqrt(xm * xm + ym * ym + zm * zm);

      xm /= len;
      ym /= len;
      zm /= len;

      positions.push(xm, ym, zm);

      return (pointMemo[key] = positions.length / 3 - 1);
    };
  })();

  for (let i = 0; i < iterations; i++) {
    const indices2 = [];
    for (let j = 0; j < indices.length; j += 3) {
      const a = getMiddlePoint(indices[j + 0], indices[j + 1]);
      const b = getMiddlePoint(indices[j + 1], indices[j + 2]);
      const c = getMiddlePoint(indices[j + 2], indices[j + 0]);

      indices2.push(c, indices[j + 0], a, a, indices[j + 1], b, b, indices[j + 2], c, a, b, c);
    }
    indices = indices2;
  }

  // Calculate texCoords and normals
  const normals = new Array(positions.length);
  const texCoords = new Array((positions.length / 3) * 2);

  const l = indices.length;
  for (let i = l - 3; i >= 0; i -= 3) {
    const i1 = indices[i + 0];
    const i2 = indices[i + 1];
    const i3 = indices[i + 2];
    const in1 = i1 * 3;
    const in2 = i2 * 3;
    const in3 = i3 * 3;
    const iu1 = i1 * 2;
    const iu2 = i2 * 2;
    const iu3 = i3 * 2;
    const x1 = positions[in1 + 0];
    const y1 = positions[in1 + 1];
    const z1 = positions[in1 + 2];
    const theta1 = Math.acos(z1 / Math.sqrt(x1 * x1 + y1 * y1 + z1 * z1));
    const phi1 = Math.atan2(y1, x1) + PI;
    const v1 = theta1 / PI;
    const u1 = 1 - phi1 / PI2;
    const x2 = positions[in2 + 0];
    const y2 = positions[in2 + 1];
    const z2 = positions[in2 + 2];
    const theta2 = Math.acos(z2 / Math.sqrt(x2 * x2 + y2 * y2 + z2 * z2));
    const phi2 = Math.atan2(y2, x2) + PI;
    const v2 = theta2 / PI;
    const u2 = 1 - phi2 / PI2;
    const x3 = positions[in3 + 0];
    const y3 = positions[in3 + 1];
    const z3 = positions[in3 + 2];
    const theta3 = Math.acos(z3 / Math.sqrt(x3 * x3 + y3 * y3 + z3 * z3));
    const phi3 = Math.atan2(y3, x3) + PI;
    const v3 = theta3 / PI;
    const u3 = 1 - phi3 / PI2;
    const vec1 = [x3 - x2, y3 - y2, z3 - z2];
    const vec2 = [x1 - x2, y1 - y2, z1 - z2];
    const normal = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"](vec1).cross(vec2).normalize();
    let newIndex;

    if (
      (u1 === 0 || u2 === 0 || u3 === 0) &&
      (u1 === 0 || u1 > 0.5) &&
      (u2 === 0 || u2 > 0.5) &&
      (u3 === 0 || u3 > 0.5)
    ) {
      positions.push(positions[in1 + 0], positions[in1 + 1], positions[in1 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v1;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;

      positions.push(positions[in2 + 0], positions[in2 + 1], positions[in2 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v2;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;

      positions.push(positions[in3 + 0], positions[in3 + 1], positions[in3 + 2]);
      newIndex = positions.length / 3 - 1;
      indices.push(newIndex);
      texCoords[newIndex * 2 + 0] = 1;
      texCoords[newIndex * 2 + 1] = v3;
      normals[newIndex * 3 + 0] = normal.x;
      normals[newIndex * 3 + 1] = normal.y;
      normals[newIndex * 3 + 2] = normal.z;
    }

    normals[in1 + 0] = normals[in2 + 0] = normals[in3 + 0] = normal.x;
    normals[in1 + 1] = normals[in2 + 1] = normals[in3 + 1] = normal.y;
    normals[in1 + 2] = normals[in2 + 2] = normals[in3 + 2] = normal.z;

    texCoords[iu1 + 0] = u1;
    texCoords[iu1 + 1] = v1;

    texCoords[iu2 + 0] = u2;
    texCoords[iu2 + 1] = v2;

    texCoords[iu3 + 0] = u3;
    texCoords[iu3 + 1] = v3;
  }

  return {
    indices: {size: 1, value: new Uint16Array(indices)},
    attributes: {
      POSITION: {size: 3, value: new Float32Array(positions)},
      NORMAL: {size: 3, value: new Float32Array(normals)},
      TEXCOORD_0: {size: 2, value: new Float32Array(texCoords)}
    }
  };
}


/***/ }),

/***/ "./src/geometries/plane-geometry.js":
/*!******************************************!*\
  !*** ./src/geometries/plane-geometry.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PlaneGeometry; });
/* harmony import */ var _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/geometry */ "./src/geometry/geometry.js");
/* harmony import */ var _geometry_geometry_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../geometry/geometry-utils */ "./src/geometry/geometry-utils.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");




class PlaneGeometry extends _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(props = {}) {
    const {id = Object(_utils__WEBPACK_IMPORTED_MODULE_2__["uid"])('plane-geometry')} = props;

    const {indices, attributes} = tesselatePlane(props);
    super({
      ...props,
      id,
      indices,
      attributes: {...attributes, ...props.attributes}
    });
  }
}

// Primitives inspired by TDL http://code.google.com/p/webglsamples/,
// copyright 2011 Google Inc. new BSD License
// (http://www.opensource.org/licenses/bsd-license.php).
/* eslint-disable max-statements, complexity */
/* eslint-disable complexity, max-statements */
function tesselatePlane(props) {
  const {type = 'x,y', offset = 0, flipCull = false, unpack = false} = props;

  const coords = type.split(',');
  // width, height
  let c1len = props[`${coords[0]}len`] || 1;
  const c2len = props[`${coords[1]}len`] || 1;
  // subdivisionsWidth, subdivisionsDepth
  const subdivisions1 = props[`n${coords[0]}`] || 1;
  const subdivisions2 = props[`n${coords[1]}`] || 1;
  const numVertices = (subdivisions1 + 1) * (subdivisions2 + 1);

  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);

  if (flipCull) {
    c1len = -c1len;
  }

  let i2 = 0;
  let i3 = 0;
  for (let z = 0; z <= subdivisions2; z++) {
    for (let x = 0; x <= subdivisions1; x++) {
      const u = x / subdivisions1;
      const v = z / subdivisions2;
      texCoords[i2 + 0] = flipCull ? 1 - u : u;
      texCoords[i2 + 1] = v;

      switch (type) {
        case 'x,y':
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = c2len * v - c2len * 0.5;
          positions[i3 + 2] = offset;

          normals[i3 + 0] = 0;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = flipCull ? 1 : -1;
          break;

        case 'x,z':
          positions[i3 + 0] = c1len * u - c1len * 0.5;
          positions[i3 + 1] = offset;
          positions[i3 + 2] = c2len * v - c2len * 0.5;

          normals[i3 + 0] = 0;
          normals[i3 + 1] = flipCull ? 1 : -1;
          normals[i3 + 2] = 0;
          break;

        case 'y,z':
          positions[i3 + 0] = offset;
          positions[i3 + 1] = c1len * u - c1len * 0.5;
          positions[i3 + 2] = c2len * v - c2len * 0.5;

          normals[i3 + 0] = flipCull ? 1 : -1;
          normals[i3 + 1] = 0;
          normals[i3 + 2] = 0;
          break;

        default:
          throw new Error('PlaneGeometry: unknown type');
      }

      i2 += 2;
      i3 += 3;
    }
  }

  const numVertsAcross = subdivisions1 + 1;
  const indices = new Uint16Array(subdivisions1 * subdivisions2 * 6);

  for (let z = 0; z < subdivisions2; z++) {
    for (let x = 0; x < subdivisions1; x++) {
      const index = (z * subdivisions1 + x) * 6;
      // Make triangle 1 of quad.
      indices[index + 0] = (z + 0) * numVertsAcross + x;
      indices[index + 1] = (z + 1) * numVertsAcross + x;
      indices[index + 2] = (z + 0) * numVertsAcross + x + 1;

      // Make triangle 2 of quad.
      indices[index + 3] = (z + 1) * numVertsAcross + x;
      indices[index + 4] = (z + 1) * numVertsAcross + x + 1;
      indices[index + 5] = (z + 0) * numVertsAcross + x + 1;
    }
  }

  const geometry = {
    indices: {size: 1, value: indices},
    attributes: {
      POSITION: {size: 3, value: positions},
      NORMAL: {size: 3, value: normals},
      TEXCOORD_0: {size: 2, value: texCoords}
    }
  };

  // Optionally, unpack indexed geometry
  return unpack ? Object(_geometry_geometry_utils__WEBPACK_IMPORTED_MODULE_1__["unpackIndexedGeometry"])(geometry) : geometry;
}


/***/ }),

/***/ "./src/geometries/sphere-geometry.js":
/*!*******************************************!*\
  !*** ./src/geometries/sphere-geometry.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return SphereGeometry; });
/* harmony import */ var _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/geometry */ "./src/geometry/geometry.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");



class SphereGeometry extends _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(props = {}) {
    const {id = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["uid"])('sphere-geometry')} = props;
    const {indices, attributes} = tesselateSphere(props);
    super({
      ...props,
      id,
      indices,
      attributes: {...attributes, ...props.attributes}
    });
  }
}

// Primitives inspired by TDL http://code.google.com/p/webglsamples/,
// copyright 2011 Google Inc. new BSD License
// (http://www.opensource.org/licenses/bsd-license.php).
/* eslint-disable max-statements, complexity */
function tesselateSphere(props) {
  const {nlat = 10, nlong = 10} = props;
  let {radius = 1} = props;

  const startLat = 0;
  const endLat = Math.PI;
  const latRange = endLat - startLat;
  const startLong = 0;
  const endLong = 2 * Math.PI;
  const longRange = endLong - startLong;
  const numVertices = (nlat + 1) * (nlong + 1);

  if (typeof radius === 'number') {
    const value = radius;
    radius = (n1, n2, n3, u, v) => value;
  }

  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);
  const indices = new Uint16Array(nlat * nlong * 6);

  // Create positions, normals and texCoords
  for (let y = 0; y <= nlat; y++) {
    for (let x = 0; x <= nlong; x++) {
      const u = x / nlong;
      const v = y / nlat;

      const index = x + y * (nlong + 1);
      const i2 = index * 2;
      const i3 = index * 3;

      const theta = longRange * u;
      const phi = latRange * v;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      const sinPhi = Math.sin(phi);
      const cosPhi = Math.cos(phi);
      const ux = cosTheta * sinPhi;
      const uy = cosPhi;
      const uz = sinTheta * sinPhi;

      const r = radius(ux, uy, uz, u, v);

      positions[i3 + 0] = r * ux;
      positions[i3 + 1] = r * uy;
      positions[i3 + 2] = r * uz;

      normals[i3 + 0] = ux;
      normals[i3 + 1] = uy;
      normals[i3 + 2] = uz;

      texCoords[i2 + 0] = u;
      texCoords[i2 + 1] = 1 - v;
    }
  }

  // Create indices
  const numVertsAround = nlat + 1;
  for (let x = 0; x < nlat; x++) {
    for (let y = 0; y < nlong; y++) {
      const index = (x * nlong + y) * 6;

      indices[index + 0] = y * numVertsAround + x;
      indices[index + 1] = y * numVertsAround + x + 1;
      indices[index + 2] = (y + 1) * numVertsAround + x;

      indices[index + 3] = (y + 1) * numVertsAround + x;
      indices[index + 4] = y * numVertsAround + x + 1;
      indices[index + 5] = (y + 1) * numVertsAround + x + 1;
    }
  }

  return {
    indices: {size: 1, value: indices},
    attributes: {
      POSITION: {size: 3, value: positions},
      NORMAL: {size: 3, value: normals},
      TEXCOORD_0: {size: 2, value: texCoords}
    }
  };
}


/***/ }),

/***/ "./src/geometries/truncated-cone-geometry.js":
/*!***************************************************!*\
  !*** ./src/geometries/truncated-cone-geometry.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TruncatedConeGeometry; });
/* harmony import */ var _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../geometry/geometry */ "./src/geometry/geometry.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");



const INDEX_OFFSETS = {
  x: [2, 0, 1],
  y: [0, 1, 2],
  z: [1, 2, 0]
};

class TruncatedConeGeometry extends _geometry_geometry__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(props = {}) {
    const {id = Object(_utils__WEBPACK_IMPORTED_MODULE_1__["uid"])('truncated-code-geometry')} = props;
    const {indices, attributes} = tesselateTruncatedCone(props);
    super({
      ...props,
      id,
      indices,
      attributes: {...attributes, ...props.attributes}
    });
  }
}

// Primitives inspired by TDL http://code.google.com/p/webglsamples/,
// copyright 2011 Google Inc. new BSD License
// (http://www.opensource.org/licenses/bsd-license.php).
/* eslint-disable max-statements, complexity */
function tesselateTruncatedCone(props) {
  const {
    bottomRadius = 0,
    topRadius = 0,
    height = 1,
    nradial = 10,
    nvertical = 10,
    verticalAxis = 'y',
    topCap = false,
    bottomCap = false
  } = props;

  const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
  const numVertices = (nradial + 1) * (nvertical + 1 + extra);

  const slant = Math.atan2(bottomRadius - topRadius, height);
  const msin = Math.sin;
  const mcos = Math.cos;
  const mpi = Math.PI;
  const cosSlant = mcos(slant);
  const sinSlant = msin(slant);
  const start = topCap ? -2 : 0;
  const end = nvertical + (bottomCap ? 2 : 0);
  const vertsAroundEdge = nradial + 1;

  const indices = new Uint16Array(nradial * (nvertical + extra) * 6);
  const indexOffset = INDEX_OFFSETS[verticalAxis];

  const positions = new Float32Array(numVertices * 3);
  const normals = new Float32Array(numVertices * 3);
  const texCoords = new Float32Array(numVertices * 2);

  let i3 = 0;
  let i2 = 0;
  for (let i = start; i <= end; i++) {
    let v = i / nvertical;
    let y = height * v;
    let ringRadius;

    if (i < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (i > nvertical) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius + (topRadius - bottomRadius) * (i / nvertical);
    }
    if (i === -2 || i === nvertical + 2) {
      ringRadius = 0;
      v = 0;
    }
    y -= height / 2;
    for (let j = 0; j < vertsAroundEdge; j++) {
      const sin = msin((j * mpi * 2) / nradial);
      const cos = mcos((j * mpi * 2) / nradial);

      positions[i3 + indexOffset[0]] = sin * ringRadius;
      positions[i3 + indexOffset[1]] = y;
      positions[i3 + indexOffset[2]] = cos * ringRadius;

      normals[i3 + indexOffset[0]] = i < 0 || i > nvertical ? 0 : sin * cosSlant;
      normals[i3 + indexOffset[1]] = i < 0 ? -1 : i > nvertical ? 1 : sinSlant;
      normals[i3 + indexOffset[2]] = i < 0 || i > nvertical ? 0 : cos * cosSlant;

      texCoords[i2 + 0] = j / nradial;
      texCoords[i2 + 1] = v;

      i2 += 2;
      i3 += 3;
    }
  }

  for (let i = 0; i < nvertical + extra; i++) {
    for (let j = 0; j < nradial; j++) {
      const index = (i * nradial + j) * 6;
      indices[index + 0] = vertsAroundEdge * (i + 0) + 0 + j;
      indices[index + 1] = vertsAroundEdge * (i + 0) + 1 + j;
      indices[index + 2] = vertsAroundEdge * (i + 1) + 1 + j;
      indices[index + 3] = vertsAroundEdge * (i + 0) + 0 + j;
      indices[index + 4] = vertsAroundEdge * (i + 1) + 1 + j;
      indices[index + 5] = vertsAroundEdge * (i + 1) + 0 + j;
    }
  }

  return {
    indices,
    attributes: {
      POSITION: {size: 3, value: positions},
      NORMAL: {size: 3, value: normals},
      TEXCOORD_0: {size: 2, value: texCoords}
    }
  };
}


/***/ }),

/***/ "./src/geometry/geometry-utils.js":
/*!****************************************!*\
  !*** ./src/geometry/geometry-utils.js ***!
  \****************************************/
/*! exports provided: unpackIndexedGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unpackIndexedGeometry", function() { return unpackIndexedGeometry; });
function unpackIndexedGeometry(geometry) {
  const {indices, attributes} = geometry;
  if (!indices) {
    return geometry;
  }

  const vertexCount = indices.value.length;
  const unpackedAttributes = {};

  for (const attributeName in attributes) {
    const attribute = attributes[attributeName];
    const {constant, value, size} = attribute;
    if (constant || !size) {
      continue; // eslint-disable-line
    }
    const unpackedValue = new value.constructor(vertexCount * size);
    for (let x = 0; x < vertexCount; ++x) {
      const index = indices.value[x];
      for (let i = 0; i < size; i++) {
        unpackedValue[x * size + i] = value[index * size + i];
      }
    }
    unpackedAttributes[attributeName] = {size, value: unpackedValue};
  }

  return {
    attributes: Object.assign({}, attributes, unpackedAttributes)
  };
}


/***/ }),

/***/ "./src/geometry/geometry.js":
/*!**********************************!*\
  !*** ./src/geometry/geometry.js ***!
  \**********************************/
/*! exports provided: DRAW_MODE, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DRAW_MODE", function() { return DRAW_MODE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Geometry; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");


// Rendering primitives - specify how to extract primitives from vertices.
// NOTE: These are numerically identical to the corresponding WebGL/OpenGL constants
const DRAW_MODE = {
  POINTS: 0x0000, // draw single points.
  LINES: 0x0001, // draw lines. Each vertex connects to the one after it.
  LINE_LOOP: 0x0002, // draw lines. Each set of two vertices is treated as a separate line segment.
  LINE_STRIP: 0x0003, // draw a connected group of line segments from the first vertex to the last
  TRIANGLES: 0x0004, // draw triangles. Each set of three vertices creates a separate triangle.
  TRIANGLE_STRIP: 0x0005, // draw a connected group of triangles.
  TRIANGLE_FAN: 0x0006 // draw a connected group of triangles.
  // Each vertex connects to the previous and the first vertex in the fan.
};

class Geometry {
  static get DRAW_MODE() {
    return DRAW_MODE;
  }

  constructor(props = {}) {
    const {
      id = Object(_utils__WEBPACK_IMPORTED_MODULE_0__["uid"])('geometry'),
      drawMode = DRAW_MODE.TRIANGLES,
      attributes = {},
      indices = null,
      vertexCount = null
    } = props;

    this.id = id;
    this.drawMode = drawMode | 0;
    this.attributes = {};
    this.userData = {};

    this._setAttributes(attributes, indices);

    this.vertexCount = vertexCount || this._calculateVertexCount(this.attributes, this.indices);

    // stubRemovedMethods(this, [
    //   'setNeedsRedraw', 'needsRedraw', 'setAttributes'
    // ], 'Immutable');

    // stubRemovedMethods(this, [
    //   'hasAttribute', 'getAttribute', 'getArray'
    // ], 'Use geometry.attributes and geometry.indices');

    // deprecateMethods(this, ['getAttributes'])
  }

  get mode() {
    return this.drawMode;
  }

  getVertexCount() {
    return this.vertexCount;
  }

  // Return an object with all attributes plus indices added as a field.
  getAttributes() {
    return this.indices ? {indices: this.indices, ...this.attributes} : this.attributes;
  }

  // PRIVATE

  _print(attributeName) {
    return `Geometry ${this.id} attribute ${attributeName}`;
  }

  // Attribute
  // value: typed array
  // type: indices, vertices, uvs
  // size: elements per vertex
  // target: WebGL buffer type (string or constant)
  _setAttributes(attributes, indices) {
    if (indices) {
      this.indices = ArrayBuffer.isView(indices) ? {value: indices, size: 1} : indices;
    }

    for (const attributeName in attributes) {
      let attribute = attributes[attributeName];

      // Wrap "unwrapped" arrays and try to autodetect their type
      attribute = ArrayBuffer.isView(attribute) ? {value: attribute} : attribute;

      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(
        ArrayBuffer.isView(attribute.value),
        `${this._print(attributeName)}: must be typed array or object with value as typed array`
      );

      if ((attributeName === 'POSITION' || attributeName === 'positions') && !attribute.size) {
        attribute.size = 3;
      }

      // Move indices to separate field
      if (attributeName === 'indices') {
        Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(!this.indices);
        this.indices = attribute;
      } else {
        this.attributes[attributeName] = attribute;
      }
    }

    if (this.indices && this.indices.isIndexed !== undefined) {
      this.indices = Object.assign({}, this.indices);
      delete this.indices.isIndexed;
    }

    return this;
  }

  _calculateVertexCount(attributes, indices) {
    if (indices) {
      return indices.value.length;
    }
    let vertexCount = Infinity;
    for (const attributeName in attributes) {
      const attribute = attributes[attributeName];
      const {value, size, constant} = attribute;
      if (!constant && value && size >= 1) {
        vertexCount = Math.min(vertexCount, value.length / size);
      }
    }

    Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(Number.isFinite(vertexCount));
    return vertexCount;
  }
}


/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! exports provided: isWebGL, isWebGL2, lumaStats, createGLContext, destroyGLContext, resizeGLContext, setGLContextDefaults, getContextInfo, getGLContextInfo, getContextLimits, FEATURES, hasFeature, hasFeatures, getFeatures, canCompileGLGSExtension, cloneTextureFrom, getKeyValue, getKey, cssToDeviceRatio, cssToDevicePixels, setContextDefaults, glGetDebugInfo, trackContextState, resetParameters, getParameter, getParameters, setParameter, setParameters, withParameters, getModifiedParameters, Buffer, Shader, VertexShader, FragmentShader, Program, Framebuffer, Renderbuffer, Texture2D, TextureCube, clear, clearBuffer, readPixelsToArray, readPixelsToBuffer, copyToDataUrl, copyToImage, copyToTexture, blit, Query, Texture3D, TransformFeedback, VertexArrayObject, VertexArray, UniformBufferLayout, setPathPrefix, loadFile, loadImage, _Accessor, _clearBuffer, Geometry, Material, AmbientLight, DirectionalLight, PointLight, AnimationLoop, encodePickingColor, decodePickingColor, getNullPickingColor, Model, Transform, ClipSpace, ProgramManager, _ShaderCache, _AnimationLoopProxy, _MultiPassRenderer, _RenderState, _Pass, _CompositePass, _ClearPass, _RenderPass, _CopyPass, _TexturePass, _ShaderModulePass, ConeGeometry, CubeGeometry, CylinderGeometry, IcoSphereGeometry, PlaneGeometry, SphereGeometry, TruncatedConeGeometry, PhongMaterial, PBRMaterial, ScenegraphNode, GroupNode, ModelNode, CameraNode, registerShaderModules, setDefaultShaderModules, getDefaultShaderModules, assembleShaders, createShaderHook, createModuleInjection, combineInjects, normalizeShaderModule, fp32, fp64, project, lights, dirlight, picking, diffuse, gouraudlighting, phonglighting, pbr, _transform, MODULAR_SHADERS, getQualifierDetails, getPassthroughFS, typeToChannelSuffix, typeToChannelCount, convertToVec4, log, assert, uid, self, window, global, document */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../webgl/src/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWebGL", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["isWebGL"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isWebGL2", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lumaStats", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["lumaStats"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createGLContext", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["createGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "destroyGLContext", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["destroyGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resizeGLContext", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["resizeGLContext"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setGLContextDefaults", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["setGLContextDefaults"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContextInfo", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["getContextInfo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getGLContextInfo", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["getGLContextInfo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContextLimits", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["getContextLimits"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FEATURES", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["FEATURES"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasFeature", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["hasFeature"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hasFeatures", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["hasFeatures"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getFeatures", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["getFeatures"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "canCompileGLGSExtension", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["canCompileGLGSExtension"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cloneTextureFrom", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["cloneTextureFrom"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getKeyValue", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["getKeyValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getKey", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["getKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cssToDeviceRatio", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["cssToDeviceRatio"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "cssToDevicePixels", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["cssToDevicePixels"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setContextDefaults", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["setGLContextDefaults"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "glGetDebugInfo", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["getContextDebugInfo"]; });

/* harmony import */ var _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl-state-tracker */ "../webgl-state-tracker/src/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "trackContextState", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__["trackContextState"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resetParameters", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__["resetParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getParameter", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__["getParameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getParameters", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__["getParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setParameter", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__["setParameter"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setParameters", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__["setParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "withParameters", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__["withParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getModifiedParameters", function() { return _luma_gl_webgl_state_tracker__WEBPACK_IMPORTED_MODULE_1__["getModifiedParameters"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Buffer", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Buffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Shader", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Shader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VertexShader", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["VertexShader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FragmentShader", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["FragmentShader"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Program", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Program"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Framebuffer", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Framebuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Renderbuffer", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Renderbuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Texture2D", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Texture2D"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TextureCube", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["TextureCube"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clear", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["clear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "clearBuffer", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["clearBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readPixelsToArray", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["readPixelsToArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "readPixelsToBuffer", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["readPixelsToBuffer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToDataUrl", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["copyToDataUrl"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToImage", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["copyToImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "copyToTexture", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["copyToTexture"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "blit", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["blit"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Query", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Query"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Texture3D", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Texture3D"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransformFeedback", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["TransformFeedback"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VertexArrayObject", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["VertexArrayObject"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VertexArray", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["VertexArray"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UniformBufferLayout", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["UniformBufferLayout"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setPathPrefix", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["setPathPrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadFile", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["loadFile"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "loadImage", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["loadImage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_Accessor", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Accessor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_clearBuffer", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["clearBuffer"]; });

/* harmony import */ var _geometry_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./geometry/geometry */ "./src/geometry/geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Geometry", function() { return _geometry_geometry__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _materials_material__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./materials/material */ "./src/materials/material.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Material", function() { return _materials_material__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _lighting_light_source__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lighting/light-source */ "./src/lighting/light-source.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AmbientLight", function() { return _lighting_light_source__WEBPACK_IMPORTED_MODULE_4__["AmbientLight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() { return _lighting_light_source__WEBPACK_IMPORTED_MODULE_4__["DirectionalLight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PointLight", function() { return _lighting_light_source__WEBPACK_IMPORTED_MODULE_4__["PointLight"]; });

/* harmony import */ var _lib_animation_loop__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/animation-loop */ "./src/lib/animation-loop.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AnimationLoop", function() { return _lib_animation_loop__WEBPACK_IMPORTED_MODULE_5__["default"]; });

/* harmony import */ var _lib_picking_colors__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/picking-colors */ "./src/lib/picking-colors.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encodePickingColor", function() { return _lib_picking_colors__WEBPACK_IMPORTED_MODULE_6__["encodePickingColor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "decodePickingColor", function() { return _lib_picking_colors__WEBPACK_IMPORTED_MODULE_6__["decodePickingColor"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getNullPickingColor", function() { return _lib_picking_colors__WEBPACK_IMPORTED_MODULE_6__["getNullPickingColor"]; });

/* harmony import */ var _lib_model__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/model */ "./src/lib/model.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Model", function() { return _lib_model__WEBPACK_IMPORTED_MODULE_7__["default"]; });

/* harmony import */ var _lib_transform_transform__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/transform/transform */ "./src/lib/transform/transform.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Transform", function() { return _lib_transform_transform__WEBPACK_IMPORTED_MODULE_8__["default"]; });

/* harmony import */ var _lib_clip_space__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/clip-space */ "./src/lib/clip-space.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ClipSpace", function() { return _lib_clip_space__WEBPACK_IMPORTED_MODULE_9__["default"]; });

/* harmony import */ var _resource_management_program_manager__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./resource-management/program-manager */ "./src/resource-management/program-manager.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ProgramManager", function() { return _resource_management_program_manager__WEBPACK_IMPORTED_MODULE_10__["default"]; });

/* harmony import */ var _lib_shader_cache__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/shader-cache */ "./src/lib/shader-cache.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_ShaderCache", function() { return _lib_shader_cache__WEBPACK_IMPORTED_MODULE_11__["default"]; });

/* harmony import */ var _lib_animation_loop_proxy__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./lib/animation-loop-proxy */ "./src/lib/animation-loop-proxy.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_AnimationLoopProxy", function() { return _lib_animation_loop_proxy__WEBPACK_IMPORTED_MODULE_12__["default"]; });

/* harmony import */ var _multipass_multi_pass_renderer__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./multipass/multi-pass-renderer */ "./src/multipass/multi-pass-renderer.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_MultiPassRenderer", function() { return _multipass_multi_pass_renderer__WEBPACK_IMPORTED_MODULE_13__["default"]; });

/* harmony import */ var _multipass_render_state__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./multipass/render-state */ "./src/multipass/render-state.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_RenderState", function() { return _multipass_render_state__WEBPACK_IMPORTED_MODULE_14__["default"]; });

/* harmony import */ var _multipass_pass__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./multipass/pass */ "./src/multipass/pass.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_Pass", function() { return _multipass_pass__WEBPACK_IMPORTED_MODULE_15__["default"]; });

/* harmony import */ var _multipass_composite_pass__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./multipass/composite-pass */ "./src/multipass/composite-pass.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_CompositePass", function() { return _multipass_composite_pass__WEBPACK_IMPORTED_MODULE_16__["default"]; });

/* harmony import */ var _multipass_clear_pass__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./multipass/clear-pass */ "./src/multipass/clear-pass.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_ClearPass", function() { return _multipass_clear_pass__WEBPACK_IMPORTED_MODULE_17__["default"]; });

/* harmony import */ var _multipass_render_pass__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./multipass/render-pass */ "./src/multipass/render-pass.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_RenderPass", function() { return _multipass_render_pass__WEBPACK_IMPORTED_MODULE_18__["default"]; });

/* harmony import */ var _multipass_copy_pass__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./multipass/copy-pass */ "./src/multipass/copy-pass.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_CopyPass", function() { return _multipass_copy_pass__WEBPACK_IMPORTED_MODULE_19__["default"]; });

/* harmony import */ var _multipass_texture_pass__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./multipass/texture-pass */ "./src/multipass/texture-pass.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_TexturePass", function() { return _multipass_texture_pass__WEBPACK_IMPORTED_MODULE_20__["default"]; });

/* harmony import */ var _multipass_shader_module_pass__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./multipass/shader-module-pass */ "./src/multipass/shader-module-pass.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_ShaderModulePass", function() { return _multipass_shader_module_pass__WEBPACK_IMPORTED_MODULE_21__["default"]; });

/* harmony import */ var _geometries_cone_geometry__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./geometries/cone-geometry */ "./src/geometries/cone-geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() { return _geometries_cone_geometry__WEBPACK_IMPORTED_MODULE_22__["default"]; });

/* harmony import */ var _geometries_cube_geometry__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./geometries/cube-geometry */ "./src/geometries/cube-geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CubeGeometry", function() { return _geometries_cube_geometry__WEBPACK_IMPORTED_MODULE_23__["default"]; });

/* harmony import */ var _geometries_cylinder_geometry__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./geometries/cylinder-geometry */ "./src/geometries/cylinder-geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() { return _geometries_cylinder_geometry__WEBPACK_IMPORTED_MODULE_24__["default"]; });

/* harmony import */ var _geometries_ico_sphere_geometry__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./geometries/ico-sphere-geometry */ "./src/geometries/ico-sphere-geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IcoSphereGeometry", function() { return _geometries_ico_sphere_geometry__WEBPACK_IMPORTED_MODULE_25__["default"]; });

/* harmony import */ var _geometries_plane_geometry__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./geometries/plane-geometry */ "./src/geometries/plane-geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return _geometries_plane_geometry__WEBPACK_IMPORTED_MODULE_26__["default"]; });

/* harmony import */ var _geometries_sphere_geometry__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./geometries/sphere-geometry */ "./src/geometries/sphere-geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return _geometries_sphere_geometry__WEBPACK_IMPORTED_MODULE_27__["default"]; });

/* harmony import */ var _geometries_truncated_cone_geometry__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./geometries/truncated-cone-geometry */ "./src/geometries/truncated-cone-geometry.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TruncatedConeGeometry", function() { return _geometries_truncated_cone_geometry__WEBPACK_IMPORTED_MODULE_28__["default"]; });

/* harmony import */ var _materials_phong_material__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./materials/phong-material */ "./src/materials/phong-material.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PhongMaterial", function() { return _materials_phong_material__WEBPACK_IMPORTED_MODULE_29__["default"]; });

/* harmony import */ var _materials_pbr_material__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./materials/pbr-material */ "./src/materials/pbr-material.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PBRMaterial", function() { return _materials_pbr_material__WEBPACK_IMPORTED_MODULE_30__["default"]; });

/* harmony import */ var _scenegraph_nodes_scenegraph_node__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./scenegraph/nodes/scenegraph-node */ "./src/scenegraph/nodes/scenegraph-node.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ScenegraphNode", function() { return _scenegraph_nodes_scenegraph_node__WEBPACK_IMPORTED_MODULE_31__["default"]; });

/* harmony import */ var _scenegraph_nodes_group_node__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./scenegraph/nodes/group-node */ "./src/scenegraph/nodes/group-node.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "GroupNode", function() { return _scenegraph_nodes_group_node__WEBPACK_IMPORTED_MODULE_32__["default"]; });

/* harmony import */ var _scenegraph_nodes_model_node__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./scenegraph/nodes/model-node */ "./src/scenegraph/nodes/model-node.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ModelNode", function() { return _scenegraph_nodes_model_node__WEBPACK_IMPORTED_MODULE_33__["default"]; });

/* harmony import */ var _scenegraph_nodes_camera_node__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./scenegraph/nodes/camera-node */ "./src/scenegraph/nodes/camera-node.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CameraNode", function() { return _scenegraph_nodes_camera_node__WEBPACK_IMPORTED_MODULE_34__["default"]; });

/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! @luma.gl/shadertools */ "../shadertools/src/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "registerShaderModules", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["registerShaderModules"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "setDefaultShaderModules", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["setDefaultShaderModules"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDefaultShaderModules", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["getDefaultShaderModules"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assembleShaders", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["assembleShaders"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createShaderHook", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["createShaderHook"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "createModuleInjection", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["createModuleInjection"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "combineInjects", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["combineInjects"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "normalizeShaderModule", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["normalizeShaderModule"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp32", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["fp32"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fp64", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["fp64"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "project", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["project"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "lights", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["lights"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "dirlight", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["dirlight"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "picking", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["picking"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "diffuse", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["diffuse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "gouraudlighting", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["gouraudlighting"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "phonglighting", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["phonglighting"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pbr", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["pbr"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_transform", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["_transform"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MODULAR_SHADERS", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["MODULAR_SHADERS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getQualifierDetails", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["getQualifierDetails"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getPassthroughFS", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["getPassthroughFS"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "typeToChannelSuffix", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["typeToChannelSuffix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "typeToChannelCount", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["typeToChannelCount"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "convertToVec4", function() { return _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_35__["convertToVec4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["log"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["assert"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uid", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["uid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["document"]; });

// CORE MODULE EXPORTS FOR LUMA.GL

// WEBGL CONTEXT




// WEBGL1 OBJECTS/FUNCTIONS




// CORE - WEBGL INDEPENDENT




// LIB






// Resource Management


// Experimental core exports



// Multipass Rendering








// export {default as _MaskPass} from './multipass/mask-pass';
// export {default as _ClearMaskPass} from './multipass/clearmask-pass';


// export {default as _Canvas} from './multipass/canvas';

// Geometries








// Materials



// SCENEGRAPH

// Core nodes





// TODO/CLEAN UP FOR V7
//  We should have a minimal set of forwarding exports from shadertools (ideally none)
//  Analyze risk of breaking apps


// UTILS: undocumented API for other luma.gl modules



/***/ }),

/***/ "./src/lib/animation-loop-proxy.js":
/*!*****************************************!*\
  !*** ./src/lib/animation-loop-proxy.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationLoopProxy; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../webgl/src/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");
/* global window, Worker */




function initializeCanvas(_self, canvas) {
  const eventHandlers = new Map();

  canvas.addEventListener = (type, handler) => {
    _self.postMessage({command: 'addEventListener', type});
    if (!eventHandlers.has(type)) {
      eventHandlers.set(type, []);
    }
    eventHandlers.get(type).push(handler);
  };
  canvas.removeEventListener = (type, handler) => {
    _self.postMessage({command: 'removeEventListener', type});
    const handlers = eventHandlers.get(type);
    if (handlers) {
      handlers.splice(handlers.indexOf(handler), 1);
    }
  };
  canvas.dispatchEvent = (type, event) => {
    const handlers = eventHandlers.get(type);
    if (handlers) {
      handlers.forEach(handler => handler(event));
    }
  };

  _self.canvas = canvas;
}

class AnimationLoopProxy {
  // Create the script for the rendering worker.
  // @param opts {object} - options to construct an AnimationLoop instance
  static createWorker(animationLoop) {
    return self => {
      animationLoop.setProps({
        // Prevent the animation loop from trying to access DOM properties
        useDevicePixels: false,
        autoResizeDrawingBuffer: false
      });

      self.canvas = null;
      self.onmessage = evt => {
        const message = evt.data;
        switch (message.command) {
          case 'start':
            initializeCanvas(self, message.opts.canvas);
            animationLoop.start(message.opts);
            break;

          case 'stop':
            animationLoop.stop();
            break;

          case 'resize':
            self.canvas.width = message.width;
            self.canvas.height = message.height;
            break;

          case 'event':
            self.canvas.dispatchEvent(message.type, message.event);
            break;

          default:
        }
      };
    };
  }

  /*
   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
   */
  constructor(worker, opts = {}) {
    const {
      onInitialize = () => {},
      onFinalize = () => {},
      useDevicePixels = true,
      autoResizeDrawingBuffer = true
    } = opts;

    this.props = {
      onInitialize,
      onFinalize
    };

    this.setProps({
      autoResizeDrawingBuffer,
      useDevicePixels
    });

    // state
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(worker instanceof Worker);
    this.worker = worker;
    this.canvas = null;
    this.width = null;
    this.height = null;

    this._running = false;
    this._animationFrameId = null;

    // bind methods
    this._onMessage = this._onMessage.bind(this);
    this._onEvent = this._onEvent.bind(this);
    this._updateFrame = this._updateFrame.bind(this);
  }

  setProps(props) {
    if ('autoResizeDrawingBuffer' in props) {
      this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
    }
    if ('useDevicePixels' in props) {
      this.useDevicePixels = props.useDevicePixels;
    }
    return this;
  }

  /* Public methods */

  // Starts a render loop if not already running
  start(opts = {}) {
    if (this._running) {
      return this;
    }
    this._running = true;
    // console.debug(`Starting ${this.constructor.name}`);
    this.worker.onmessage = this._onMessage;

    // Wait for start promise before rendering frame
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["getPageLoadPromise"])()
      .then(() => {
        if (!this._running) {
          return null;
        }
        this._createAndTransferCanvas(opts);
        return this.props.onInitialize(this);
      })
      .then(() => {
        if (this._running) {
          this._animationFrameId = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["requestAnimationFrame"])(this._updateFrame);
        }
      });
    return this;
  }

  // Stops a render loop if already running, finalizing
  stop() {
    if (this._running) {
      Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["cancelAnimationFrame"])(this._animationFrameId);
      this._animationFrameId = null;
      this._running = false;
      this.props.onFinalize(this);
    }
    this.worker.postMessage({command: 'stop'});
    return this;
  }

  // PRIVATE METHODS

  _onMessage(evt) {
    switch (evt.data.command) {
      case 'addEventListener':
        this.canvas.addEventListener(evt.data.type, this._onEvent);
        break;

      case 'removeEventListener':
        this.canvas.removeEventListener(evt.data.type, this._onEvent);
        break;

      default:
    }
  }

  _onEvent(evt) {
    // TODO: get access to gl context and use 'cssToDevicePixels'
    const devicePixelRatio = this.useDevicePixels ? window.devicePixelRatio || 1 : 1;
    const type = evt.type;

    const safeEvent = {};
    for (const key in evt) {
      let value = evt[key];
      const valueType = typeof value;
      if (key === 'offsetX' || key === 'offsetY') {
        value *= devicePixelRatio;
      }
      if (valueType === 'number' || valueType === 'boolean' || valueType === 'string') {
        safeEvent[key] = value;
      }
    }

    this.worker.postMessage({
      command: 'event',
      type,
      event: safeEvent
    });
  }

  _updateFrame() {
    this._resizeCanvasDrawingBuffer();
    this._animationFrameId = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["requestAnimationFrame"])(this._updateFrame);
  }

  _createAndTransferCanvas(opts) {
    // Create a canvas on the main thread
    const screenCanvas = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["getCanvas"])(opts);

    // Create an offscreen canvas controlling the main canvas
    if (!screenCanvas.transferControlToOffscreen) {
      _utils__WEBPACK_IMPORTED_MODULE_1__["log"].error('OffscreenCanvas is not available in your browser.')();
    }
    const offscreenCanvas = screenCanvas.transferControlToOffscreen();

    // Transfer the offscreen canvas to the worker
    this.worker.postMessage(
      {
        command: 'start',
        opts: Object.assign({}, opts, {canvas: offscreenCanvas})
      },
      [offscreenCanvas]
    );

    // store the main canvas on the local thread
    this.canvas = screenCanvas;
  }

  _resizeCanvasDrawingBuffer() {
    if (this.autoResizeDrawingBuffer) {
      // TODO: get access to gl context and use 'cssToDevicePixels'
      const devicePixelRatio = this.useDevicePixels ? window.devicePixelRatio || 1 : 1;
      const width = Math.ceil(this.canvas.clientWidth * devicePixelRatio);
      const height = Math.ceil(this.canvas.clientHeight * devicePixelRatio);

      if (this.width !== width || this.height !== height) {
        this.width = width;
        this.height = height;
        this.worker.postMessage({
          command: 'resize',
          width,
          height
        });
      }
    }
  }
}


/***/ }),

/***/ "./src/lib/animation-loop.js":
/*!***********************************!*\
  !*** ./src/lib/animation-loop.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimationLoop; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../webgl/src/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");
/* global OffscreenCanvas */




let statIdCounter = 0;

class AnimationLoop {
  /*
   * @param {HTMLCanvasElement} canvas - if provided, width and height will be passed to context
   */
  constructor(props = {}) {
    const {
      onCreateContext = opts => Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["createGLContext"])(opts),
      onAddHTML = null,
      onInitialize = () => {},
      onRender = () => {},
      onFinalize = () => {},

      gl = null,
      glOptions = {},
      debug = false,

      createFramebuffer = false,

      // view parameters
      autoResizeViewport = true,
      autoResizeDrawingBuffer = true,
      stats = _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["lumaStats"].get(`animation-loop-${statIdCounter++}`)
    } = props;

    let {useDevicePixels = true} = props;

    if ('useDevicePixelRatio' in props) {
      _utils__WEBPACK_IMPORTED_MODULE_1__["log"].deprecated('useDevicePixelRatio', 'useDevicePixels')();
      useDevicePixels = props.useDevicePixelRatio;
    }

    this.props = {
      onCreateContext,
      onAddHTML,
      onInitialize,
      onRender,
      onFinalize,

      gl,
      glOptions,
      debug,
      createFramebuffer
    };

    // state
    this.gl = gl;
    this.needsRedraw = null;
    this.timeline = null;
    this.stats = stats;
    this.cpuTime = this.stats.get('CPU Time');
    this.gpuTime = this.stats.get('GPU Time');
    this.frameRate = this.stats.get('Frame Rate');

    this._initialized = false;
    this._running = false;
    this._animationFrameId = null;
    this._nextFramePromise = null;
    this._resolveNextFrame = null;
    this._cpuStartTime = 0;

    this.setProps({
      autoResizeViewport,
      autoResizeDrawingBuffer,
      useDevicePixels
    });

    // Bind methods
    this.start = this.start.bind(this);
    this.stop = this.stop.bind(this);

    this._onMousemove = this._onMousemove.bind(this);
    this._onMouseleave = this._onMouseleave.bind(this);
  }

  delete() {
    this.stop();
    this._setDisplay(null);
  }

  setNeedsRedraw(reason) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(typeof reason === 'string');
    this.needsRedraw = this.needsRedraw || reason;
    return this;
  }

  setProps(props) {
    if ('autoResizeViewport' in props) {
      this.autoResizeViewport = props.autoResizeViewport;
    }
    if ('autoResizeDrawingBuffer' in props) {
      this.autoResizeDrawingBuffer = props.autoResizeDrawingBuffer;
    }
    if ('useDevicePixels' in props) {
      this.useDevicePixels = props.useDevicePixels;
    }
    return this;
  }

  // Starts a render loop if not already running
  // @param {Object} context - contains frame specific info (E.g. tick, width, height, etc)
  start(opts = {}) {
    if (this._running) {
      return this;
    }
    this._running = true;
    // console.debug(`Starting ${this.constructor.name}`);
    // Wait for start promise before rendering frame
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["getPageLoadPromise"])()
      .then(() => {
        if (!this._running || this._initialized) {
          return null;
        }

        // Create the WebGL context
        this._createWebGLContext(opts);
        this._createFramebuffer();
        this._startEventHandling();

        // Initialize the callback data
        this._initializeCallbackData();
        this._updateCallbackData();

        // Default viewport setup, in case onInitialize wants to render
        this._resizeCanvasDrawingBuffer();
        this._resizeViewport();

        this._gpuTimeQuery = _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Query"].isSupported(this.gl, ['timers']) ? new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Query"](this.gl) : null;

        this._initialized = true;

        // Note: onIntialize can return a promise (in case it needs to load resources)
        return this.onInitialize(this.animationProps);
      })
      .then(appContext => {
        if (this._running) {
          this._addCallbackData(appContext || {});
          if (appContext !== false) {
            this._startLoop();
          }
        }
      });
    return this;
  }

  // Redraw now
  redraw() {
    this._beginTimers();

    this._setupFrame();
    this._updateCallbackData();

    this._renderFrame(this.animationProps);

    // clear needsRedraw flag
    this._clearNeedsRedraw();

    // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/commit
    // Chrome's offscreen canvas does not require gl.commit
    if (this.offScreen && this.gl.commit) {
      this.gl.commit();
    }

    if (this._resolveNextFrame) {
      this._resolveNextFrame(this);
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
    }

    this._endTimers();

    return this;
  }

  // Stops a render loop if already running, finalizing
  stop() {
    // console.debug(`Stopping ${this.constructor.name}`);
    if (this._running) {
      this._finalizeCallbackData();
      Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["cancelAnimationFrame"])(this._animationFrameId);
      this._nextFramePromise = null;
      this._resolveNextFrame = null;
      this._animationFrameId = null;
      this._running = false;
    }
    return this;
  }

  attachTimeline(timeline) {
    this.timeline = timeline;

    return this.timeline;
  }

  detachTimeline() {
    this.timeline = null;
  }

  waitForRender() {
    this.setNeedsRedraw('waitForRender');

    if (!this._nextFramePromise) {
      this._nextFramePromise = new Promise(resolve => {
        this._resolveNextFrame = resolve;
      });
    }
    return this._nextFramePromise;
  }

  async toDataURL() {
    this.setNeedsRedraw('toDataURL');

    await this.waitForRender();

    return this.gl.canvas.toDataURL();
  }

  onCreateContext(...args) {
    return this.props.onCreateContext(...args);
  }

  onInitialize(...args) {
    return this.props.onInitialize(...args);
  }

  onRender(...args) {
    return this.props.onRender(...args);
  }

  onFinalize(...args) {
    return this.props.onFinalize(...args);
  }

  // DEPRECATED/REMOVED METHODS

  getHTMLControlValue(id, defaultValue = 1) {
    const element = document.getElementById(id);
    return element ? Number(element.value) : defaultValue;
  }

  // Update parameters
  setViewParameters() {
    _utils__WEBPACK_IMPORTED_MODULE_1__["log"].removed('AnimationLoop.setViewParameters', 'AnimationLoop.setProps')();
    return this;
  }

  // PRIVATE METHODS

  _startLoop() {
    const renderFrame = () => {
      if (!this._running) {
        return;
      }
      this.redraw();
      this._animationFrameId = this._requestAnimationFrame(renderFrame);
    };

    // cancel any pending renders to ensure only one loop can ever run
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["cancelAnimationFrame"])(this._animationFrameId);
    this._animationFrameId = this._requestAnimationFrame(renderFrame);
  }

  // PRIVATE METHODS

  _setDisplay(display) {
    if (this.display) {
      this.display.delete();
      this.display.animationLoop = null;
    }

    // store animation loop on the display
    if (display) {
      display.animationLoop = this;
    }

    this.display = display;
  }

  _requestAnimationFrame(renderFrameCallback) {
    // E.g. VR display has a separate animation frame to sync with headset
    if (this.display && this.display.requestAnimationFrame(renderFrameCallback)) {
      return;
    }

    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["requestAnimationFrame"])(renderFrameCallback);
  }

  // Called on each frame, can be overridden to call onRender multiple times
  // to support e.g. stereoscopic rendering
  _renderFrame(...args) {
    // Allow e.g. VR display to render multiple frames.
    if (this.display) {
      this.display._renderFrame(...args);
      return;
    }

    // call callback
    this.onRender(...args);
    // end callback
  }

  _clearNeedsRedraw() {
    this.needsRedraw = null;
  }

  _setupFrame() {
    if (this._onSetupFrame) {
      // call callback
      this._onSetupFrame(this.animationProps);
      // end callback
    } else {
      this._resizeCanvasDrawingBuffer();
      this._resizeViewport();
      this._resizeFramebuffer();
    }
  }

  // Initialize the  object that will be passed to app callbacks
  _initializeCallbackData() {
    this.animationProps = {
      gl: this.gl,

      stop: this.stop,
      canvas: this.gl.canvas,
      framebuffer: this.framebuffer,

      // Initial values
      useDevicePixels: this.useDevicePixels,
      needsRedraw: null,

      // Animation props
      startTime: Date.now(),
      engineTime: 0,
      tick: 0,
      tock: 0,

      // Timeline time for back compatibility
      time: 0,

      // Experimental
      _timeline: this.timeline,
      _loop: this,
      _animationLoop: this,
      _mousePosition: null // Event props
    };
  }

  // Update the context object that will be passed to app callbacks
  _updateCallbackData() {
    const {width, height, aspect} = this._getSizeAndAspect();
    if (width !== this.animationProps.width || height !== this.animationProps.height) {
      this.setNeedsRedraw('drawing buffer resized');
    }
    if (aspect !== this.animationProps.aspect) {
      this.setNeedsRedraw('drawing buffer aspect changed');
    }

    this.animationProps.width = width;
    this.animationProps.height = height;
    this.animationProps.aspect = aspect;

    this.animationProps.needsRedraw = this.needsRedraw;

    // Update time properties
    this.animationProps.engineTime = Date.now() - this.animationProps.startTime;

    if (this.timeline) {
      this.timeline.update(this.animationProps.engineTime);
    }

    this.animationProps.tick = Math.floor((this.animationProps.time / 1000) * 60);
    this.animationProps.tock++;

    // For back compatibility
    this.animationProps.time = this.timeline
      ? this.timeline.getTime()
      : this.animationProps.engineTime;

    // experimental
    this.animationProps._offScreen = this.offScreen;
  }

  _finalizeCallbackData() {
    // call callback
    this.onFinalize(this.animationProps);
    // end callback
  }

  // Add application's data to the app context object
  _addCallbackData(appContext) {
    if (typeof appContext === 'object' && appContext !== null) {
      this.animationProps = Object.assign({}, this.animationProps, appContext);
    }
  }

  // Either uses supplied or existing context, or calls provided callback to create one
  _createWebGLContext(opts) {
    this.offScreen =
      opts.canvas &&
      typeof OffscreenCanvas !== 'undefined' &&
      opts.canvas instanceof OffscreenCanvas;

    // Create the WebGL context if necessary
    opts = Object.assign({}, opts, this.props.glOptions);
    this.gl = this.props.gl ? Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["instrumentGLContext"])(this.props.gl, opts) : this.onCreateContext(opts);

    if (!Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["isWebGL"])(this.gl)) {
      throw new Error('AnimationLoop.onCreateContext - illegal context returned');
    }

    // Reset the WebGL context.
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["resetParameters"])(this.gl);

    this._createInfoDiv();
  }

  _createInfoDiv() {
    if (this.gl.canvas && this.props.onAddHTML) {
      /* global document */
      const wrapperDiv = document.createElement('div');
      document.body.appendChild(wrapperDiv);
      wrapperDiv.style.position = 'relative';
      const div = document.createElement('div');
      div.style.position = 'absolute';
      div.style.left = '10px';
      div.style.bottom = '10px';
      div.style.width = '300px';
      div.style.background = 'white';
      wrapperDiv.appendChild(this.gl.canvas);
      wrapperDiv.appendChild(div);
      const html = this.props.onAddHTML(div);
      if (html) {
        div.innerHTML = html;
      }
    }
  }

  _getSizeAndAspect() {
    // https://webglfundamentals.org/webgl/lessons/webgl-resizing-the-canvas.html
    const width = this.gl.drawingBufferWidth;
    const height = this.gl.drawingBufferHeight;

    // https://webglfundamentals.org/webgl/lessons/webgl-anti-patterns.html
    let aspect = 1;
    const {canvas} = this.gl;

    if (canvas && canvas.clientHeight) {
      aspect = canvas.clientWidth / canvas.clientHeight;
    } else if (width > 0 && height > 0) {
      aspect = width / height;
    }

    return {width, height, aspect};
  }

  // Default viewport setup
  _resizeViewport() {
    if (this.autoResizeViewport) {
      this.gl.viewport(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight);
    }
  }

  // Resize the render buffer of the canvas to match canvas client size
  // Optionally multiplying with devicePixel ratio
  _resizeCanvasDrawingBuffer() {
    if (this.autoResizeDrawingBuffer) {
      Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["resizeGLContext"])(this.gl, {useDevicePixels: this.useDevicePixels});
    }
  }

  // TBD - deprecated?
  _createFramebuffer() {
    // Setup default framebuffer
    if (this.props.createFramebuffer) {
      this.framebuffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Framebuffer"](this.gl);
    }
  }

  _resizeFramebuffer() {
    if (this.framebuffer) {
      this.framebuffer.resize({
        width: this.gl.drawingBufferWidth,
        height: this.gl.drawingBufferHeight
      });
    }
  }

  _beginTimers() {
    this.frameRate.timeEnd();
    this.frameRate.timeStart();

    // Check if timer for last frame has completed.
    // GPU timer results are never available in the same
    // frame they are captured.
    if (
      this._gpuTimeQuery &&
      this._gpuTimeQuery.isResultAvailable() &&
      !this._gpuTimeQuery.isTimerDisjoint()
    ) {
      this.stats.get('GPU Time').addTime(this._gpuTimeQuery.getTimerMilliseconds());
    }

    if (this._gpuTimeQuery) {
      // GPU time query start
      this._gpuTimeQuery.beginTimeElapsedQuery();
    }

    this.cpuTime.timeStart();
  }

  _endTimers() {
    this.cpuTime.timeEnd();

    if (this._gpuTimeQuery) {
      // GPU time query end. Results will be available on next frame.
      this._gpuTimeQuery.end();
    }
  }

  // Event handling

  _startEventHandling() {
    const {canvas} = this.gl;
    if (canvas) {
      canvas.addEventListener('mousemove', this._onMousemove);
      canvas.addEventListener('mouseleave', this._onMouseleave);
    }
  }

  _onMousemove(e) {
    this.animationProps._mousePosition = [e.offsetX, e.offsetY];
  }
  _onMouseleave(e) {
    this.animationProps._mousePosition = null;
  }
}


/***/ }),

/***/ "./src/lib/base-model.js":
/*!*******************************!*\
  !*** ./src/lib/base-model.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BaseModel; });
/* harmony import */ var _resource_management_program_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resource-management/program-manager */ "./src/resource-management/program-manager.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../webgl/src/index.js");
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/shadertools */ "../shadertools/src/index.js");
/* harmony import */ var _debug_seer_integration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../debug/seer-integration */ "./src/debug/seer-integration.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");
/* eslint-disable complexity */
// Shared code between Model and MeshModel







const LOG_DRAW_PRIORITY = 2;
const LOG_DRAW_TIMEOUT = 10000;

// Model abstract O3D Class
class BaseModel {
  constructor(gl, props = {}) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["isWebGL"])(gl));
    const {id = Object(_utils__WEBPACK_IMPORTED_MODULE_4__["uid"])('base-model')} = props;
    this.id = id;
    this.gl = gl;
    this.id = props.id || Object(_utils__WEBPACK_IMPORTED_MODULE_4__["uid"])('Model');
    this.lastLogTime = 0; // TODO - move to probe.gl
    this.initialize(props);
  }

  initialize(props) {
    this.props = {};

    if (props.shaderCache) {
      _utils__WEBPACK_IMPORTED_MODULE_4__["log"].warn('ShaderCache property is deprecated')();
    }

    this.programManager = props.programManager || _resource_management_program_manager__WEBPACK_IMPORTED_MODULE_0__["default"].getDefaultProgramManager(this.gl);
    this._programManagerState = -1;
    this._managedProgram = false;

    const {program = null, vs, fs, modules, defines, inject, varyings, bufferMode} = props;

    this.programProps = {program, vs, fs, modules, defines, inject, varyings, bufferMode};
    this.program = null;
    this.vertexArray = null;
    this._programDirty = true;

    // Initialize state
    this.userData = {};
    this.needsRedraw = true;

    // Attributes and buffers
    // Model manages auto Buffer creation from typed arrays
    this._attributes = {}; // All attributes
    this.attributes = {}; // User defined attributes

    // Model manages uniform animation
    this.uniforms = {};
    this.animatedUniforms = {};
    this.animated = false;
    this.animationLoop = null; // if set, used as source for animationProps

    this.timerQueryEnabled = false;
    this.timeElapsedQuery = undefined;
    this.lastQueryReturned = true;

    this.stats = {
      accumulatedFrameTime: 0,
      averageFrameTime: 0,
      profileFrameCount: 0
    };

    // picking options
    this.pickable = true;

    this._checkProgram();

    this._setBaseModelProps(props);

    this.setUniforms(
      Object.assign(
        {},
        this.getModuleUniforms(props.moduleSettings) // Get unforms for supplied parameters
      )
    );
  }

  setProps(props) {
    this._setBaseModelProps(props);
  }

  delete() {
    // delete all attributes created by this model
    // TODO - should buffer deletes be handled by vertex array?
    for (const key in this._attributes) {
      if (this._attributes[key] !== this.attributes[key]) {
        this._attributes[key].delete();
      }
    }

    if (this._managedProgram) {
      this.programManager.release(this.program);
    }

    this.vertexArray.delete();

    Object(_debug_seer_integration__WEBPACK_IMPORTED_MODULE_3__["removeModel"])(this.id);
  }

  // GETTERS

  isAnimated() {
    return this.animated;
  }

  getProgram() {
    return this.program;
  }

  setProgram(props) {
    this.programProps = Object.assign({}, props);
    this._programDirty = true;
  }

  getUniforms() {
    return this.uniforms;
  }

  // SETTERS

  // TODO - should actually set the uniforms
  setUniforms(uniforms = {}) {
    // Let Seer override edited uniforms
    uniforms = Object.assign({}, uniforms);
    Object(_debug_seer_integration__WEBPACK_IMPORTED_MODULE_3__["getOverrides"])(this.id, uniforms);

    // Resolve any animated uniforms so that we have an initial value
    uniforms = this._extractAnimatedUniforms(uniforms);

    Object.assign(this.uniforms, uniforms);

    return this;
  }

  getModuleUniforms(opts) {
    this._checkProgram();

    const getUniforms = this.programManager.getUniforms(this.program);

    if (getUniforms) {
      return getUniforms(opts);
    }

    return {};
  }

  updateModuleSettings(opts) {
    const uniforms = this.getModuleUniforms(opts || {});
    return this.setUniforms(uniforms);
  }

  // DRAW CALLS

  clear(opts) {
    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["clear"])(this.program.gl, opts);
    return this;
  }

  /* eslint-disable max-statements  */
  drawGeometry(opts = {}) {
    // Lazy update program and vertex array
    this._checkProgram();

    const {
      moduleSettings = null,
      framebuffer,
      uniforms = {},
      attributes = {},
      transformFeedback = this.transformFeedback,
      parameters = {},
      vertexArray = this.vertexArray,
      animationProps
    } = opts;

    Object(_debug_seer_integration__WEBPACK_IMPORTED_MODULE_3__["addModel"])(this);

    // Update model with any just provided attributes, settings or uniforms
    this.setAttributes(attributes);
    this.updateModuleSettings(moduleSettings);
    this.setUniforms(uniforms);

    // Animate any function valued uniforms
    this._refreshAnimationProps(animationProps);

    const logPriority = this._logDrawCallStart(2);

    const drawParams = this.vertexArray.getDrawParams(this.props);
    if (drawParams.isInstanced && !this.isInstanced) {
      _utils__WEBPACK_IMPORTED_MODULE_4__["log"].warn('Found instanced attributes on non-instanced model', this.id)();
    }

    const {isIndexed, indexType, indexOffset} = drawParams;
    const {isInstanced, instanceCount} = this;

    const noop = () => {};
    const {onBeforeRender = noop, onAfterRender = noop} = this.props;

    onBeforeRender();

    this._timerQueryStart();

    this.program.setUniforms(this.uniforms);

    const didDraw = this.program.draw(
      Object.assign({}, opts, {
        logPriority,
        uniforms: null, // Already set (may contain "function values" not understood by Program)
        framebuffer,
        parameters,
        drawMode: this.getDrawMode(),
        vertexCount: this.getVertexCount(),
        vertexArray,
        transformFeedback,
        isIndexed,
        indexType,
        isInstanced,
        instanceCount,
        offset: isIndexed ? indexOffset : 0
      })
    );

    this._timerQueryEnd();

    onAfterRender();

    this._logDrawCallEnd(logPriority, vertexArray, framebuffer);

    return didDraw;
  }
  /* eslint-enable max-statements  */

  // PRIVATE METHODS

  // eslint-disable-next-line max-statements, complexity
  _setBaseModelProps(props) {
    Object.assign(this.props, props);

    if ('uniforms' in props) {
      this.setUniforms(props.uniforms);
    }

    if ('pickable' in props) {
      this.pickable = props.pickable;
    }

    // if ('onBeforeRender' in props) {}
    // if ('onAfterRender' in props) {}

    // Experimental props
    if ('timerQueryEnabled' in props) {
      this.timerQueryEnabled = props.timerQueryEnabled && _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Query"].isSupported(this.gl, ['timers']);
      if (props.timerQueryEnabled && !this.timerQueryEnabled) {
        _utils__WEBPACK_IMPORTED_MODULE_4__["log"].warn('GPU timer not supported')();
      }
    }

    if ('_animationProps' in props) {
      this._setAnimationProps(props._animationProps);
    }

    if ('_animationLoop' in props) {
      this.animationLoop = props._animationLoop;
    }
  }

  _checkProgram(shaderCache = null) {
    const needsUpdate =
      this._programDirty || this.programManager.stateHash !== this._programManagerState;

    if (!needsUpdate) {
      return;
    }

    let {program} = this.programProps;

    if (program) {
      this._managedProgram = false;
    } else {
      const {
        // TODO(Tarek): Are these actually used anywhere?
        vs = _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__["MODULAR_SHADERS"].vs,
        fs = _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__["MODULAR_SHADERS"].fs,
        modules,
        inject,
        defines,
        varyings,
        bufferMode
      } = this.programProps;
      program = this.programManager.get({vs, fs, modules, inject, defines, varyings, bufferMode});
      if (this.program && this._managedProgram) {
        this.programManager.release(this.program);
      }
      this._programManagerState = this.programManager.stateHash;
      this._managedProgram = true;
    }

    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(program instanceof _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Program"], 'Model needs a program');

    this._programDirty = false;

    if (program === this.program) {
      return;
    }

    this.program = program;

    if (this.vertexArray) {
      this.vertexArray.setProps({program: this.program, attributes: this.vertexArray.attributes});
    } else {
      this.vertexArray = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["VertexArray"](this.gl, {program: this.program});
    }

    // Make sure we have some reasonable default uniforms in place
    this.setUniforms(
      Object.assign(
        {},
        this.getModuleUniforms() // Get all default uniforms,
      )
    );
  }

  // Refreshes animated uniforms, attempting to get animated props from animationLoop if registered
  _refreshAnimationProps(animationProps) {
    // Try to read animationProps
    animationProps = animationProps || (this.animationLoop && this.animationLoop.animationProps);
    if (animationProps) {
      this._setAnimationProps(animationProps);
    }
  }

  // Calculate new values for any function uniforms based on supplied animationProps
  _evaluateAnimateUniforms(animationProps) {
    if (!this.animated) {
      return {};
    }
    const animatedUniforms = {};
    for (const uniformName in this.animatedUniforms) {
      const valueFunction = this.animatedUniforms[uniformName];
      animatedUniforms[uniformName] = valueFunction(animationProps);
    }
    return animatedUniforms;
  }

  // Extracts a list of function valued uniforms, so we can update them before each draw call
  // Also removes such uniforms from the returned list
  _extractAnimatedUniforms(uniforms) {
    let foundAnimated = false;

    // Keep our animatedUniforms map up-to-date
    for (const uniformName in uniforms) {
      const newValue = uniforms[uniformName];
      if (typeof newValue === 'function') {
        this.animatedUniforms[uniformName] = newValue;
        foundAnimated = true;
      } else {
        delete this.animatedUniforms[uniformName];
      }
    }

    // Update animated flag: `Model` is animated if any uniforms are animated (i.e. functions)
    this.animated = !Object(_utils__WEBPACK_IMPORTED_MODULE_4__["isObjectEmpty"])(this.animatedUniforms);

    if (!foundAnimated) {
      return uniforms;
    }

    // If animated uniforms were found, remove them from ordinary uniform list
    // `Program` class can't (and shouldn't) handle function valued uniforms
    const staticUniforms = {};
    for (const uniformName in uniforms) {
      if (!this.animatedUniforms[uniformName]) {
        staticUniforms[uniformName] = uniforms[uniformName];
      }
    }
    return staticUniforms;
  }

  // Timer Queries

  _timerQueryStart() {
    if (this.timerQueryEnabled === true) {
      if (!this.timeElapsedQuery) {
        this.timeElapsedQuery = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Query"](this.gl);
      }
      if (this.lastQueryReturned) {
        this.lastQueryReturned = false;
        this.timeElapsedQuery.beginTimeElapsedQuery();
      }
    }
  }

  _timerQueryEnd() {
    if (this.timerQueryEnabled === true) {
      this.timeElapsedQuery.end();
      // TODO: Skip results if 'gl.getParameter(this.ext.GPU_DISJOINT_EXT)' returns false
      // should this be incorporated into Query object?
      if (this.timeElapsedQuery.isResultAvailable()) {
        this.lastQueryReturned = true;
        const elapsedTime = this.timeElapsedQuery.getTimerMilliseconds();

        // Update stats (e.g. for seer)
        this.stats.lastFrameTime = elapsedTime;
        this.stats.accumulatedFrameTime += elapsedTime;
        this.stats.profileFrameCount++;
        this.stats.averageFrameTime =
          this.stats.accumulatedFrameTime / this.stats.profileFrameCount;

        // Log stats
        _utils__WEBPACK_IMPORTED_MODULE_4__["log"].log(
          LOG_DRAW_PRIORITY,
          `\
GPU time ${this.program.id}: ${this.stats.lastFrameTime}ms \
average ${this.stats.averageFrameTime}ms \
accumulated: ${this.stats.accumulatedFrameTime}ms \
count: ${this.stats.profileFrameCount}`
        )();
      }
    }
  }

  _logDrawCallStart(priority) {
    const logDrawTimeout = priority > 3 ? 0 : LOG_DRAW_TIMEOUT;
    if (_utils__WEBPACK_IMPORTED_MODULE_4__["log"].priority < priority || Date.now() - this.lastLogTime < logDrawTimeout) {
      return undefined;
    }

    this.lastLogTime = Date.now();

    _utils__WEBPACK_IMPORTED_MODULE_4__["log"].group(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`, {collapsed: _utils__WEBPACK_IMPORTED_MODULE_4__["log"].priority <= 2})();

    return priority;
  }

  _logDrawCallEnd(priority, vertexArray, uniforms, framebuffer) {
    // HACK: priority === undefined means logDrawCallStart didn't run
    if (priority === undefined) {
      return;
    }

    const attributeTable = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["getDebugTableForVertexArray"])({
      vertexArray,
      header: `${this.id} attributes`,
      attributes: this._attributes
    });

    const {table: uniformTable, unusedTable, unusedCount} = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["getDebugTableForUniforms"])({
      header: `${this.id} uniforms`,
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, uniforms)
    });

    // log missing uniforms
    const {table: missingTable, count: missingCount} = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["getDebugTableForUniforms"])({
      header: `${this.id} uniforms`,
      program: this.program,
      uniforms: Object.assign({}, this.program.uniforms, uniforms),
      undefinedOnly: true
    });

    if (missingCount > 0) {
      _utils__WEBPACK_IMPORTED_MODULE_4__["log"].log('MISSING UNIFORMS', Object.keys(missingTable))();
      // log.table(priority, missingTable)();
    }
    if (unusedCount > 0) {
      _utils__WEBPACK_IMPORTED_MODULE_4__["log"].log('UNUSED UNIFORMS', Object.keys(unusedTable))();
      // log.log(priority, 'Unused uniforms ', unusedTable)();
    }

    const configTable = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["getDebugTableForProgramConfiguration"])(this.vertexArray.configuration);

    _utils__WEBPACK_IMPORTED_MODULE_4__["log"].table(priority, attributeTable)();

    _utils__WEBPACK_IMPORTED_MODULE_4__["log"].table(priority, uniformTable)();

    _utils__WEBPACK_IMPORTED_MODULE_4__["log"].table(priority + 1, configTable)();

    Object(_debug_seer_integration__WEBPACK_IMPORTED_MODULE_3__["logModel"])(this, uniforms);

    if (framebuffer) {
      framebuffer.log({priority: LOG_DRAW_PRIORITY, message: `Rendered to ${framebuffer.id}`});
    }

    _utils__WEBPACK_IMPORTED_MODULE_4__["log"].groupEnd(LOG_DRAW_PRIORITY, `>>> DRAWING MODEL ${this.id}`)();
  }
}


/***/ }),

/***/ "./src/lib/clip-space.js":
/*!*******************************!*\
  !*** ./src/lib/clip-space.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClipSpace; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _lib_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/model */ "./src/lib/model.js");
/* harmony import */ var _geometry_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry/geometry */ "./src/geometry/geometry.js");
// ClipSpace




const CLIPSPACE_VERTEX_SHADER = `\
attribute vec2 aClipSpacePosition;
attribute vec2 aTexCoord;
attribute vec2 aCoordinate;

varying vec2 position;
varying vec2 coordinate;
varying vec2 uv;

void main(void) {
  gl_Position = vec4(aClipSpacePosition, 0., 1.);
  position = aClipSpacePosition;
  coordinate = aCoordinate;
  uv = aTexCoord;
}
`;

/* eslint-disable indent, no-multi-spaces */
const POSITIONS = [-1, -1, 1, -1, -1, 1, 1, 1];

class ClipSpace extends _lib_model__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(gl, opts) {
    const TEX_COORDS = POSITIONS.map(coord => (coord === -1 ? 0 : coord));

    super(
      gl,
      Object.assign({}, opts, {
        vs: CLIPSPACE_VERTEX_SHADER,
        geometry: new _geometry_geometry__WEBPACK_IMPORTED_MODULE_2__["default"]({
          drawMode: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TRIANGLE_STRIP,
          vertexCount: 4,
          attributes: {
            aClipSpacePosition: {size: 2, value: new Float32Array(POSITIONS)},
            aTexCoord: {size: 2, value: new Float32Array(TEX_COORDS)},
            aCoordinate: {size: 2, value: new Float32Array(TEX_COORDS)}
          }
        })
      })
    );
    this.setVertexCount(4);
  }
}


/***/ }),

/***/ "./src/lib/model-utils.js":
/*!********************************!*\
  !*** ./src/lib/model-utils.js ***!
  \********************************/
/*! exports provided: getBuffersFromGeometry, inferAttributeAccessor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBuffersFromGeometry", function() { return getBuffersFromGeometry; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inferAttributeAccessor", function() { return inferAttributeAccessor; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../webgl/src/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");




// Support for mapping new geometries with glTF attribute names to "classic" luma.gl shader names
const GLTF_TO_LUMA_ATTRIBUTE_MAP = {
  POSITION: 'positions',
  NORMAL: 'normals',
  COLOR_0: 'colors',
  TEXCOORD_0: 'texCoords',
  TEXCOORD_1: 'texCoords1',
  TEXCOORD_2: 'texCoords2'
};

function getBuffersFromGeometry(gl, geometry, options) {
  const buffers = {};
  let indices = geometry.indices;

  for (const name in geometry.attributes) {
    const attribute = geometry.attributes[name];
    const remappedName = mapAttributeName(name, options);

    if (name === 'indices') {
      indices = attribute;
    } else if (attribute.constant) {
      buffers[remappedName] = attribute.value;
    } else {
      const typedArray = attribute.value;
      // Create accessor by copying the attribute and removing `value``
      const accessor = {...attribute};
      delete accessor.value;
      buffers[remappedName] = [new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Buffer"](gl, typedArray), accessor];

      inferAttributeAccessor(name, accessor);
    }
  }

  if (indices) {
    const data = indices.value || indices;
    Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(
      data instanceof Uint16Array || data instanceof Uint32Array,
      'attribute array for "indices" must be of integer type'
    );
    const accessor = {
      size: 1,
      isIndexed: indices.isIndexed === undefined ? true : indices.isIndexed
    };
    buffers.indices = [
      new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Buffer"](gl, {
        data,
        target: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.ELEMENT_ARRAY_BUFFER
      }),
      accessor
    ];
  }

  return buffers;
}

function mapAttributeName(name, options) {
  const {attributeMap = GLTF_TO_LUMA_ATTRIBUTE_MAP} = options || {};
  return (attributeMap && attributeMap[name]) || name;
}

// Check for well known attribute names
// eslint-disable-next-line complexity
function inferAttributeAccessor(attributeName, attribute) {
  let category;
  switch (attributeName) {
    case 'texCoords':
    case 'texCoord1':
    case 'texCoord2':
    case 'texCoord3':
      category = 'uvs';
      break;
    case 'vertices':
    case 'positions':
    case 'normals':
    case 'pickingColors':
      category = 'vectors';
      break;
    default:
  }

  // Check for categorys
  switch (category) {
    case 'vectors':
      attribute.size = attribute.size || 3;
      break;
    case 'uvs':
      attribute.size = attribute.size || 2;
      break;
    default:
  }

  Object(_utils__WEBPACK_IMPORTED_MODULE_2__["assert"])(Number.isFinite(attribute.size), `attribute ${attributeName} needs size`);
}


/***/ }),

/***/ "./src/lib/model.js":
/*!**************************!*\
  !*** ./src/lib/model.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Model; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../webgl/src/index.js");
/* harmony import */ var _model_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./model-utils */ "./src/lib/model-utils.js");
/* harmony import */ var _base_model__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./base-model */ "./src/lib/base-model.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");






const ERR_MODEL_PARAMS = 'Model needs drawMode and vertexCount';

class Model extends _base_model__WEBPACK_IMPORTED_MODULE_3__["default"] {
  constructor(gl, props = {}) {
    // Deduce a helpful id
    const {id = Object(_utils__WEBPACK_IMPORTED_MODULE_4__["uid"])('model')} = props;
    super(gl, {...props, id});
  }

  initialize(props) {
    super.initialize(props);

    this.drawMode = props.drawMode !== undefined ? props.drawMode : _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TRIANGLES;
    this.vertexCount = props.vertexCount || 0;

    // Track buffers created by setGeometry
    this.geometryBuffers = {};

    // geometry might have set drawMode and vertexCount
    this.isInstanced = props.isInstanced || props.instanced;

    this._setModelProps(props);

    // TODO - just to unbreak deck.gl 7.0-beta, remove as soon as updated
    this.geometry = {};

    // assert(program || program instanceof Program);
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(this.drawMode !== undefined && Number.isFinite(this.vertexCount), ERR_MODEL_PARAMS);
  }

  setProps(props) {
    super.setProps(props);
    this._setModelProps(props);
  }

  delete() {
    super.delete();

    this._deleteGeometryBuffers();
  }

  // GETTERS

  getDrawMode() {
    return this.drawMode;
  }

  getVertexCount() {
    return this.vertexCount;
  }

  getInstanceCount() {
    return this.instanceCount;
  }

  getAttributes() {
    return this.attributes;
  }

  // SETTERS

  setDrawMode(drawMode) {
    this.drawMode = drawMode;
    return this;
  }

  setVertexCount(vertexCount) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(Number.isFinite(vertexCount));
    this.vertexCount = vertexCount;
    return this;
  }

  setInstanceCount(instanceCount) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(Number.isFinite(instanceCount));
    this.instanceCount = instanceCount;
    return this;
  }

  setGeometry(geometry) {
    this.drawMode = geometry.drawMode;
    this.vertexCount = geometry.getVertexCount();

    this._deleteGeometryBuffers();

    this.geometryBuffers = Object(_model_utils__WEBPACK_IMPORTED_MODULE_2__["getBuffersFromGeometry"])(this.gl, geometry);
    this.vertexArray.setAttributes(this.geometryBuffers);
    return this;
  }

  setAttributes(attributes = {}) {
    // Avoid setting needsRedraw if no attributes
    if (Object(_utils__WEBPACK_IMPORTED_MODULE_4__["isObjectEmpty"])(attributes)) {
      return this;
    }

    const normalizedAttributes = {};
    for (const name in attributes) {
      const attribute = attributes[name];
      // The `getValue` call provides support for deck.gl `Attribute` class
      // TODO - remove once deck refactoring completes
      normalizedAttributes[name] = attribute.getValue ? attribute.getValue() : attribute;
    }

    this.vertexArray.setAttributes(normalizedAttributes);
    return this;
  }

  // DRAW CALLS

  draw(options = {}) {
    return this.drawGeometry(options);
  }

  // Draw call for transform feedback
  transform(opts = {}) {
    const {discard = true, feedbackBuffers, unbindModels = []} = opts;

    let {parameters} = opts;

    if (feedbackBuffers) {
      this._setFeedbackBuffers(feedbackBuffers);
    }

    if (discard) {
      parameters = Object.assign({}, parameters, {[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.RASTERIZER_DISCARD]: discard});
    }

    unbindModels.forEach(model => model.vertexArray.unbindBuffers());
    try {
      this.draw(Object.assign({}, opts, {parameters}));
    } finally {
      unbindModels.forEach(model => model.vertexArray.bindBuffers());
    }

    return this;
  }

  // DEPRECATED METHODS

  render(uniforms = {}) {
    _utils__WEBPACK_IMPORTED_MODULE_4__["log"].warn('Model.render() is deprecated. Use Model.setUniforms() and Model.draw()')();
    return this.setUniforms(uniforms).draw();
  }

  // PRIVATE METHODS

  _setModelProps(props) {
    // params
    // if ('drawMode' in props) {
    //   this.drawMode = getDrawMode(props.drawMode);
    // }
    // if ('vertexCount' in props) {
    //   this.vertexCount = props.vertexCount;
    // }
    if ('instanceCount' in props) {
      this.instanceCount = props.instanceCount;
    }
    if ('geometry' in props) {
      this.setGeometry(props.geometry);
    }

    // webgl settings
    if ('attributes' in props) {
      this.setAttributes(props.attributes);
    }
    if ('_feedbackBuffers' in props) {
      this._setFeedbackBuffers(props._feedbackBuffers);
    }
  }

  _deleteGeometryBuffers() {
    for (const name in this.geometryBuffers) {
      // Buffer is raw value (for indices) or first element of [buffer, accessor] pair
      const buffer = this.geometryBuffers[name][0] || this.geometryBuffers[name];
      if (buffer instanceof _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Buffer"]) {
        buffer.delete();
      }
    }
  }

  // Updates (evaluates) all function valued uniforms based on a new set of animationProps
  // experimental
  _setAnimationProps(animationProps) {
    if (this.animated) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_4__["assert"])(animationProps, 'Model.draw(): animated uniforms but no animationProps');
      const animatedUniforms = this._evaluateAnimateUniforms(animationProps);
      Object.assign(this.uniforms, animatedUniforms);
    }
  }

  // Transform Feedback

  _setFeedbackBuffers(feedbackBuffers = {}) {
    // Avoid setting needsRedraw if no feedbackBuffers
    if (Object(_utils__WEBPACK_IMPORTED_MODULE_4__["isObjectEmpty"])(feedbackBuffers)) {
      return this;
    }

    const {gl} = this.program;
    this.transformFeedback =
      this.transformFeedback ||
      new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["TransformFeedback"](gl, {
        program: this.program
      });

    this.transformFeedback.setBuffers(feedbackBuffers);
    return this;
  }
}


/***/ }),

/***/ "./src/lib/picking-colors.js":
/*!***********************************!*\
  !*** ./src/lib/picking-colors.js ***!
  \***********************************/
/*! exports provided: encodePickingColor, decodePickingColor, getNullPickingColor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodePickingColor", function() { return encodePickingColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodePickingColor", function() { return decodePickingColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNullPickingColor", function() { return getNullPickingColor; });
const NULL_PICKING_COLOR = new Uint8Array([0, 0, 0]);

// Encodes an index as a Uint8Array([r, g, b]) format picking color
function encodePickingColor(i) {
  return [(i + 1) & 255, ((i + 1) >> 8) & 255, ((i + 1) >> 16) & 255];
}

// Decodes a picking color in [r, g, b] format to an index
function decodePickingColor(color) {
  // assert(color instanceof Uint8Array);
  const [i1, i2, i3] = color;
  // 1 was added to seperate from no selection
  const index = i1 + i2 * 256 + i3 * 65536 - 1;
  return index;
}

// Return picking color representing no item at that pixel
function getNullPickingColor() {
  return NULL_PICKING_COLOR;
}


/***/ }),

/***/ "./src/lib/shader-cache.js":
/*!*********************************!*\
  !*** ./src/lib/shader-cache.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShaderCache; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../webgl/src/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");



class ShaderCache {
  /**
   * A cache of compiled shaders, keyed by shader source strings.
   * Compilation of long shaders can be time consuming.
   * By using this class, the application can ensure that each shader
   * is only compiled once.
   */
  constructor({gl, _cachePrograms = false} = {}) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(gl);
    this.gl = gl;
    this.vertexShaders = {};
    this.fragmentShaders = {};
    this.programs = {};
    this._cachePrograms = _cachePrograms;
  }

  /**
   * Deletes shader references
   * @return {ShaderCache} - returns this for chaining
   */
  delete() {
    // TODO - requires reference counting to avoid deleting shaders in use
    return this;
  }

  /**
   * Returns a compiled `VertexShader` object corresponding to the supplied
   * GLSL source code string, if possible from cache.
   *
   * @param {WebGLRenderingContext} gl - gl context
   * @param {String} source - Source code for shader
   * @return {VertexShader} - a compiled vertex shader
   */
  getVertexShader(gl, source) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(typeof source === 'string');
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(this._compareContexts(gl, this.gl));

    let shader = this.vertexShaders[source];
    if (!shader) {
      shader = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["VertexShader"](gl, source);
      this.vertexShaders[source] = shader;
    }
    return shader;
  }

  /**
   * Returns a compiled `VertexShader` object corresponding to the supplied
   * GLSL source code string, if possible from cache.
   * @param {WebGLRenderingContext} gl - gl context
   * @param {String} source - Source code for shader
   * @return {FragmentShader} - a compiled fragment shader, possibly from chache
   */
  getFragmentShader(gl, source) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(typeof source === 'string');
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(this._compareContexts(gl, this.gl));

    let shader = this.fragmentShaders[source];
    if (!shader) {
      shader = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["FragmentShader"](gl, source);
      this.fragmentShaders[source] = shader;
    }
    return shader;
  }

  // Retrive Shaders from cache if exists, otherwise create new instance.
  getProgram(gl, opts) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(this._compareContexts(gl, this.gl));
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(typeof opts.vs === 'string');
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(typeof opts.fs === 'string');
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(typeof opts.id === 'string');

    const cacheKey = this._getProgramKey(opts);
    let program = this.programs[cacheKey];
    if (program) {
      this._resetProgram(program);
      return program;
    }

    program = this._createNewProgram(gl, opts);

    // Check if program can be cached
    // Program caching is experimental and expects
    // each Model to have a unique-id (wich is used in key generation)
    if (this._cachePrograms && this._checkProgramProp(program)) {
      program._isCached = true;
      this.programs[cacheKey] = program;
    }

    return program;
  }

  _getProgramKey(opts) {
    return `${opts.id}-${opts.vs}-${opts.fs}`;
  }

  _checkProgramProp(program) {
    // Check for transform feedback props (varyings, etc), we can't key such programs for now
    return !program.varyings;
  }

  _createNewProgram(gl, opts) {
    const {vs, fs} = opts;
    const vertexShader = this.getVertexShader(gl, vs);
    const fragmentShader = this.getFragmentShader(gl, fs);
    return new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Program"](
      this.gl,
      Object.assign({}, opts, {
        vs: vertexShader,
        fs: fragmentShader
      })
    );
  }

  _resetProgram(program, opts) {
    program.reset();
  }

  // Handle debug contexts
  _compareContexts(gl1, gl2) {
    return (gl1.gl || gl1) === (gl2.gl || gl2);
  }
}


/***/ }),

/***/ "./src/lib/transform/buffer-transform.js":
/*!***********************************************!*\
  !*** ./src/lib/transform/buffer-transform.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return BufferTransform; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../webgl/src/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/utils/index.js");



class BufferTransform {
  constructor(gl, props = {}) {
    this.gl = gl;
    this.currentIndex = 0;
    this.feedbackMap = {};
    this.varyings = null; // varyings array
    this.bindings = []; // each element is an object : {sourceBuffers, feedbackBuffers, transformFeedback}

    this.resources = {}; // resources to be deleted

    this._initialize(props);
    Object.seal(this);
  }

  setupResources(opts) {
    for (const binding of this.bindings) {
      this._setupTransformFeedback(binding, opts);
    }
  }

  updateModelProps(props = {}) {
    const {varyings} = this;
    if (varyings.length > 0) {
      props = Object.assign({}, props, {varyings});
    }
    return props;
  }

  getDrawOptions(opts = {}) {
    const binding = this.bindings[this.currentIndex];
    const {sourceBuffers, transformFeedback} = binding;
    const attributes = Object.assign({}, sourceBuffers, opts.attributes);

    return {attributes, transformFeedback};
  }

  swap() {
    if (this.feedbackMap) {
      this.currentIndex = this._getNextIndex();
      return true;
    }
    return false;
  }

  // update source and/or feedbackBuffers
  update(opts = {}) {
    this._setupBuffers(opts);
  }

  // returns current feedbackBuffer of given name
  getBuffer(varyingName) {
    const {feedbackBuffers} = this.bindings[this.currentIndex];
    const bufferOrParams = varyingName ? feedbackBuffers[varyingName] : null;
    if (!bufferOrParams) {
      return null;
    }
    return bufferOrParams instanceof _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Buffer"] ? bufferOrParams : bufferOrParams.buffer;
  }

  getData({varyingName} = {}) {
    const buffer = this.getBuffer(varyingName);
    if (buffer) {
      return buffer.getData();
    }
    return null;
  }

  // Delete owned resources.
  delete() {
    for (const name in this.resources) {
      this.resources[name].delete();
    }
  }

  // Private

  _initialize(props = {}) {
    this._setupBuffers(props);
    this.varyings = props.varyings || Object.keys(this.bindings[this.currentIndex].feedbackBuffers);
    if (this.varyings.length > 0) {
      // if writting to buffers make sure it is WebGL2
      Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["isWebGL2"])(this.gl));
    }
  }

  // auto create feedback buffers if requested
  _getFeedbackBuffers(props) {
    const {sourceBuffers = {}} = props;
    const feedbackBuffers = {};
    if (this.bindings[this.currentIndex]) {
      // this gurantees a partial feedback buffer set doesn't update
      // previously set buffers during auto creation mode.
      Object.assign(feedbackBuffers, this.bindings[this.currentIndex].feedbackBuffers);
    }
    if (this.feedbackMap) {
      // feedbackMap is defined as sourceBuffer as key and feedbackBuffer name as object
      for (const sourceName in this.feedbackMap) {
        const feedbackName = this.feedbackMap[sourceName];
        if (sourceName in sourceBuffers) {
          feedbackBuffers[feedbackName] = sourceName;
        }
      }
    }
    Object.assign(feedbackBuffers, props.feedbackBuffers);
    for (const bufferName in feedbackBuffers) {
      const bufferOrRef = feedbackBuffers[bufferName];
      if (typeof bufferOrRef === 'string') {
        // Create new buffer with same layout and settings as source buffer
        const sourceBuffer = sourceBuffers[bufferOrRef];
        const {byteLength, usage, accessor} = sourceBuffer;
        feedbackBuffers[bufferName] = this._createNewBuffer(bufferName, {
          byteLength,
          usage,
          accessor
        });
      }
    }

    return feedbackBuffers;
  }

  _setupBuffers(props = {}) {
    const {sourceBuffers = null} = props;
    Object.assign(this.feedbackMap, props.feedbackMap);
    const feedbackBuffers = this._getFeedbackBuffers(props);
    this._updateBindings({sourceBuffers, feedbackBuffers});
  }

  _setupTransformFeedback(binding, {model}) {
    const {program} = model;
    binding.transformFeedback = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["TransformFeedback"](this.gl, {
      program,
      buffers: binding.feedbackBuffers
    });
  }

  _updateBindings(opts) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
    if (this.feedbackMap) {
      const {sourceBuffers, feedbackBuffers} = this._swapBuffers(this.bindings[this.currentIndex]);
      const nextIndex = this._getNextIndex();
      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
        sourceBuffers,
        feedbackBuffers
      });
    }
  }

  _updateBinding(binding, opts) {
    if (!binding) {
      return {
        sourceBuffers: Object.assign({}, opts.sourceBuffers),
        feedbackBuffers: Object.assign({}, opts.feedbackBuffers)
      };
    }
    Object.assign(binding.sourceBuffers, opts.sourceBuffers);
    Object.assign(binding.feedbackBuffers, opts.feedbackBuffers);
    if (binding.transformFeedback) {
      binding.transformFeedback.setBuffers(binding.feedbackBuffers);
    }
    return binding;
  }

  _swapBuffers(opts) {
    if (!this.feedbackMap) {
      return null;
    }
    const sourceBuffers = Object.assign({}, opts.sourceBuffers);
    const feedbackBuffers = Object.assign({}, opts.feedbackBuffers);
    for (const srcName in this.feedbackMap) {
      const dstName = this.feedbackMap[srcName];
      sourceBuffers[srcName] = opts.feedbackBuffers[dstName];
      feedbackBuffers[dstName] = opts.sourceBuffers[srcName];

      // make sure the new destination buffer is a Buffer object
      Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(feedbackBuffers[dstName] instanceof _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Buffer"]);
    }
    return {sourceBuffers, feedbackBuffers};
  }

  // Create a buffer and add to list of buffers to be deleted.
  _createNewBuffer(name, opts) {
    const buffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Buffer"](this.gl, opts);
    if (this.resources[name]) {
      this.resources[name].delete();
    }
    this.resources[name] = buffer;
    return buffer;
  }

  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }
}


/***/ }),

/***/ "./src/lib/transform/texture-transform.js":
/*!************************************************!*\
  !*** ./src/lib/transform/texture-transform.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TextureTransform; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../webgl/src/index.js");
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @luma.gl/shadertools */ "../shadertools/src/index.js");
/* harmony import */ var _transform_shader_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./transform-shader-utils */ "./src/lib/transform/transform-shader-utils.js");





// TODO: move these constants to transform-shader-utils
// Texture parameters needed so sample can precisely pick pixel for given element id.
const SRC_TEX_PARAMETER_OVERRIDES = {
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MIN_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.NEAREST,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MAG_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.NEAREST,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_WRAP_S]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CLAMP_TO_EDGE,
  [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_WRAP_T]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CLAMP_TO_EDGE
};
const FS_OUTPUT_VARIABLE = 'transform_output';

class TextureTransform {
  constructor(gl, props = {}) {
    this.gl = gl;
    this.currentIndex = 0;
    this._swapTexture = null;
    this.targetTextureVarying = null;
    this.targetTextureType = null;
    this.samplerTextureMap = null;
    this.bindings = []; // each element is an object : {sourceTextures, targetTexture, framebuffer}

    this.resources = {}; // resources to be deleted

    this._initialize(props);
    Object.seal(this);
  }

  updateModelProps(props = {}) {
    const updatedModelProps = this._processVertexShader(props);
    return Object.assign({}, props, updatedModelProps);
  }

  getDrawOptions(opts = {}) {
    const {sourceTextures, framebuffer, targetTexture} = this.bindings[this.currentIndex];

    const attributes = Object.assign({}, opts.attributes);
    const uniforms = Object.assign({}, opts.uniforms);
    const parameters = Object.assign({}, opts.parameters);
    let discard = opts.discard;

    if (this.hasSourceTextures || this.hasTargetTexture) {
      attributes.transform_elementID = this.elementIDBuffer;

      for (const sampler in this.samplerTextureMap) {
        const textureName = this.samplerTextureMap[sampler];
        uniforms[sampler] = sourceTextures[textureName];
      }
      this._setSourceTextureParameters();
      // get texture size uniforms
      const sizeUniforms = Object(_transform_shader_utils__WEBPACK_IMPORTED_MODULE_3__["getSizeUniforms"])({
        sourceTextureMap: sourceTextures,
        targetTextureVarying: this.targetTextureVarying,
        targetTexture
      });
      Object.assign(uniforms, sizeUniforms);
    }

    if (this.hasTargetTexture) {
      discard = false;
      parameters.viewport = [0, 0, framebuffer.width, framebuffer.height];
    }

    return {attributes, framebuffer, uniforms, discard, parameters};
  }

  swap() {
    if (this._swapTexture) {
      this.currentIndex = this._getNextIndex();
      return true;
    }
    return false;
  }

  // update source and/or feedbackBuffers
  update(opts = {}) {
    this._setupTextures(opts);
  }

  // returns current target texture
  getTargetTexture() {
    const {targetTexture} = this.bindings[this.currentIndex];
    return targetTexture;
  }

  getData({packed = false} = {}) {
    const {framebuffer} = this.bindings[this.currentIndex];
    const pixels = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["readPixelsToArray"])(framebuffer);

    if (!packed) {
      return pixels;
    }

    // readPixels returns 4 elements for each pixel, pack the elements when requested
    const ArrayType = pixels.constructor;
    const channelCount = Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__["typeToChannelCount"])(this.targetTextureType);
    const packedPixels = new ArrayType((pixels.length * channelCount) / 4);
    let packCount = 0;
    for (let i = 0; i < pixels.length; i += 4) {
      for (let j = 0; j < channelCount; j++) {
        packedPixels[packCount++] = pixels[i + j];
      }
    }
    return packedPixels;
  }

  // returns current framebuffer object that is being used.
  getFramebuffer() {
    const currentResources = this.bindings[this.currentIndex];
    return currentResources.framebuffer;
  }

  // Delete owned resources.
  delete() {
    if (this.ownTexture) {
      this.ownTexture.delete();
    }
    if (this.elementIDBuffer) {
      this.elementIDBuffer.delete();
    }
  }

  // Private

  _initialize(props = {}) {
    const {_targetTextureVarying, _swapTexture} = props;
    this._swapTexture = _swapTexture;
    this.targetTextureVarying = _targetTextureVarying;
    this.hasTargetTexture = _targetTextureVarying;
    this._setupTextures(props);
  }

  // auto create target texture if requested
  _createTargetTexture(props) {
    const {sourceTextures, textureOrReference} = props;
    if (textureOrReference instanceof _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Texture2D"]) {
      return textureOrReference;
    }
    // 'targetTexture' is a reference souce texture.
    const refTexture = sourceTextures[textureOrReference];
    if (!refTexture) {
      return null;
    }

    // save reference texture name, when corresponding source texture is updated
    // we also update target texture.
    this._targetRefTexName = textureOrReference;

    return this._createNewTexture(refTexture);
  }

  _setupTextures(props = {}) {
    const {_sourceTextures = {}, _targetTexture} = props;
    const targetTexture = this._createTargetTexture({
      sourceTextures: _sourceTextures,
      textureOrReference: _targetTexture
    });
    this.hasSourceTextures =
      this.hasSourceTextures || (_sourceTextures && Object.keys(_sourceTextures).length > 0);
    this._updateBindings({sourceTextures: _sourceTextures, targetTexture});
    if ('elementCount' in props) {
      this._updateElementIDBuffer(props.elementCount);
    }
  }

  _updateElementIDBuffer(elementCount) {
    if (typeof elementCount !== 'number' || this.elementCount >= elementCount) {
      return;
    }
    // NOTE: using float so this will work with GLSL 1.0 shaders.
    const elementIds = new Float32Array(elementCount);
    elementIds.forEach((_, index, array) => {
      array[index] = index;
    });
    if (!this.elementIDBuffer) {
      this.elementIDBuffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Buffer"](this.gl, {
        data: elementIds,
        accessor: {size: 1}
      });
    } else {
      this.elementIDBuffer.setData({data: elementIds});
    }
    this.elementCount = elementCount;
  }

  _updateBindings(opts) {
    this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], opts);
    if (this._swapTexture) {
      const {sourceTextures, targetTexture} = this._swapTextures(this.bindings[this.currentIndex]);
      const nextIndex = this._getNextIndex();
      this.bindings[nextIndex] = this._updateBinding(this.bindings[nextIndex], {
        sourceTextures,
        targetTexture
      });
    }
  }

  _updateBinding(binding, opts) {
    const {sourceTextures, targetTexture} = opts;
    if (!binding) {
      binding = {
        sourceTextures: {},
        targetTexture: null
      };
    }
    Object.assign(binding.sourceTextures, sourceTextures);
    if (targetTexture) {
      binding.targetTexture = targetTexture;

      const {width, height} = targetTexture;
      const {framebuffer} = binding;
      if (framebuffer) {
        // First update texture without re-sizing attachments
        framebuffer.update({
          attachments: {[_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0]: targetTexture},
          resizeAttachments: false
        });
        // Resize to new taget texture size
        framebuffer.resize({width, height});
      } else {
        binding.framebuffer = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Framebuffer"](this.gl, {
          id: `${this.id || 'transform'}-framebuffer`,
          width,
          height,
          attachments: {
            [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.COLOR_ATTACHMENT0]: targetTexture
          }
        });
      }
    }
    return binding;
  }

  // set texture filtering parameters on source textures.
  _setSourceTextureParameters() {
    const index = this.currentIndex;
    const {sourceTextures} = this.bindings[index];
    for (const name in sourceTextures) {
      sourceTextures[name].setParameters(SRC_TEX_PARAMETER_OVERRIDES);
    }
  }

  _swapTextures(opts) {
    if (!this._swapTexture) {
      return null;
    }
    const sourceTextures = Object.assign({}, opts.sourceTextures);
    sourceTextures[this._swapTexture] = opts.targetTexture;

    const targetTexture = opts.sourceTextures[this._swapTexture];

    return {sourceTextures, targetTexture};
  }

  // Create a buffer and add to list of buffers to be deleted.
  _createNewTexture(refTexture) {
    const texture = Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["cloneTextureFrom"])(refTexture, {
      parameters: {
        [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MIN_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.NEAREST,
        [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_MAG_FILTER]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.NEAREST,
        [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_WRAP_S]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CLAMP_TO_EDGE,
        [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.TEXTURE_WRAP_T]: _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.CLAMP_TO_EDGE
      },
      pixelStore: {
        [_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.UNPACK_FLIP_Y_WEBGL]: false
      }
    });

    // thre can only be one target texture
    if (this.ownTexture) {
      this.ownTexture.delete();
    }
    this.ownTexture = texture;

    return texture;
  }

  _getNextIndex() {
    return (this.currentIndex + 1) % 2;
  }

  // build and return shader releated parameters
  _processVertexShader(props = {}) {
    const {sourceTextures, targetTexture} = this.bindings[this.currentIndex];
    const {vs, uniforms, targetTextureType, inject, samplerTextureMap} = Object(_transform_shader_utils__WEBPACK_IMPORTED_MODULE_3__["updateForTextures"])({
      vs: props.vs,
      sourceTextureMap: sourceTextures,
      targetTextureVarying: this.targetTextureVarying,
      targetTexture
    });
    const combinedInject = Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__["combineInjects"])([props.inject || {}, inject]);
    this.targetTextureType = targetTextureType;
    this.samplerTextureMap = samplerTextureMap;
    const fs =
      props._fs ||
      Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__["getPassthroughFS"])({
        version: Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["getShaderVersion"])(vs),
        input: this.targetTextureVarying,
        inputType: targetTextureType,
        output: FS_OUTPUT_VARIABLE
      });
    const modules =
      this.hasSourceTextures || this.targetTextureVarying
        ? [_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_2__["_transform"]].concat(props.modules || [])
        : props.modules;
    return {vs, fs, modules, uniforms, inject: combinedInject};
  }
}


/***/ }),

/***/ "./src/lib/transform/transform-shader-utils.js":
/*!*****************************************************!*\
  !*** ./src/lib/transform/transform-shader-utils.js ***!
  \*****************************************************/
/*! exports provided: updateForTextures, getSizeUniforms, getVaryingType, processAttributeDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "updateForTextures", function() { return updateForTextures; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getSizeUniforms", function() { return getSizeUniforms; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getVaryingType", function() { return getVaryingType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "processAttributeDefinition", function() { return processAttributeDefinition; });
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils */ "./src/utils/index.js");
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/shadertools */ "../shadertools/src/index.js");



const SAMPLER_UNIFORM_PREFIX = 'transform_uSampler_';
const SIZE_UNIFORM_PREFIX = 'transform_uSize_';
const VS_POS_VARIABLE = 'transform_position';

// Scan provided vertex shader
// for each texture attribute, inject sampler instructions and build uniforms for sampler
// for texture target, get varying type and inject position instruction
function updateForTextures({vs, sourceTextureMap, targetTextureVarying, targetTexture}) {
  const texAttributeNames = Object.keys(sourceTextureMap);
  let sourceCount = texAttributeNames.length;
  let targetTextureType = null;
  const samplerTextureMap = {};
  let updatedVs = vs;
  let finalInject = {};

  if (sourceCount > 0 || targetTextureVarying) {
    const vsLines = updatedVs.split('\n');
    const updateVsLines = vsLines.slice();
    vsLines.forEach((line, index, lines) => {
      // TODO add early exit
      if (sourceCount > 0) {
        const updated = processAttributeDefinition(line, sourceTextureMap);
        if (updated) {
          const {updatedLine, inject} = updated;
          updateVsLines[index] = updatedLine;
          // sampleInstructions.push(sampleInstruction);
          finalInject = Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__["combineInjects"])([finalInject, inject]);
          Object.assign(samplerTextureMap, updated.samplerTextureMap);
          sourceCount--;
        }
      }
      if (targetTextureVarying && !targetTextureType) {
        targetTextureType = getVaryingType(line, targetTextureVarying);
      }
    });

    if (targetTextureVarying) {
      Object(_utils__WEBPACK_IMPORTED_MODULE_0__["assert"])(targetTexture);
      const sizeName = `${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`;

      const uniformDeclaration = `uniform vec2 ${sizeName};\n`;
      const posInstructions = `\
     vec2 ${VS_POS_VARIABLE} = transform_getPos(${sizeName});
     gl_Position = vec4(${VS_POS_VARIABLE}, 0, 1.);\n`;
      const inject = {
        'vs:#decl': uniformDeclaration,
        'vs:#main-start': posInstructions
      };
      finalInject = Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__["combineInjects"])([finalInject, inject]);
    }
    updatedVs = updateVsLines.join('\n');
  }
  return {
    // updated vertex shader (commented texture attribute definition)
    vs: updatedVs,
    // type (float, vec2, vec3 of vec4) target texture varying
    targetTextureType,
    // required vertex and fragment shader injects
    inject: finalInject,
    // map of sampler name to texture name, can be used to set attributes
    // usefull when swapping textures, as source and destination texture change when swap is called.
    samplerTextureMap
  };
}

// builds and returns an object contaning size uniform for each texture
function getSizeUniforms({sourceTextureMap, targetTextureVarying, targetTexture}) {
  const uniforms = {};
  let width;
  let height;
  if (targetTextureVarying) {
    ({width, height} = targetTexture);
    uniforms[`${SIZE_UNIFORM_PREFIX}${targetTextureVarying}`] = [width, height];
  }
  for (const textureName in sourceTextureMap) {
    ({width, height} = sourceTextureMap[textureName]);
    uniforms[`${SIZE_UNIFORM_PREFIX}${textureName}`] = [width, height];
  }
  return uniforms;
}

// Checks if provided line is defining an attribute, if so returns details otherwise null
function getAttributeDefinition(line) {
  return Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__["getQualifierDetails"])(line, ['attribute', 'in']);
}

function getSamplerDeclerations(textureName) {
  const samplerName = `${SAMPLER_UNIFORM_PREFIX}${textureName}`;
  const sizeName = `${SIZE_UNIFORM_PREFIX}${textureName}`;
  const uniformDeclerations = `\
  uniform sampler2D ${samplerName};
  uniform vec2 ${sizeName};`;
  return {samplerName, sizeName, uniformDeclerations};
}

// Return size (float, vec2 etc) of a given varying, null if doens't exist.
function getVaryingType(line, varying) {
  const qualaiferDetails = Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__["getQualifierDetails"])(line, ['varying', 'out']);
  if (!qualaiferDetails) {
    return null;
  }
  return qualaiferDetails.name === varying ? qualaiferDetails.type : null;
}

// build required definitions, sample instructions for each texture attribute
function processAttributeDefinition(line, textureMap) {
  const samplerTextureMap = {};
  const attributeData = getAttributeDefinition(line);
  if (!attributeData) {
    return null;
  }
  const {type, name} = attributeData;
  if (name && textureMap[name]) {
    // eslint-disable-next-line no-useless-escape
    const updatedLine = `\// ${line} => Replaced by Transform with a sampler`;
    const {samplerName, sizeName, uniformDeclerations} = getSamplerDeclerations(name);

    const channels = Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__["typeToChannelSuffix"])(type);
    const sampleInstruction = `  ${type} ${name} = transform_getInput(${samplerName}, ${sizeName}).${channels};\n`;

    samplerTextureMap[samplerName] = name;
    const inject = {
      'vs:#decl': uniformDeclerations,
      'vs:#main-start': sampleInstruction
    };

    // samplerNameMap
    return {
      // update vertex shader line.
      updatedLine,
      // inject object with sampler instructions.
      inject,
      // sampler name to texture name map
      samplerTextureMap
    };
  }
  return null;
}


/***/ }),

/***/ "./src/lib/transform/transform.js":
/*!****************************************!*\
  !*** ./src/lib/transform/transform.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Transform; });
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/constants */ "../constants/src/index.js");
/* harmony import */ var _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_luma_gl_constants__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/shadertools */ "../shadertools/src/index.js");
/* harmony import */ var _buffer_transform__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buffer-transform */ "./src/lib/transform/buffer-transform.js");
/* harmony import */ var _texture_transform__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./texture-transform */ "./src/lib/transform/texture-transform.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @luma.gl/webgl */ "../webgl/src/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils */ "./src/utils/index.js");
/* harmony import */ var _model__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../model */ "./src/lib/model.js");









// takes source and target buffers/textures and setsup the pipeline
class Transform {
  static isSupported(gl) {
    // TODO : differentiate writting to buffer vs not
    return Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__["isWebGL2"])(gl);
  }

  constructor(gl, props = {}) {
    this.gl = gl;
    this.model = null;
    this.elementCount = 0;
    this.bufferTransform = null;
    this.textureTransform = null;
    this.elementIDBuffer = null;
    this._initialize(props);
    Object.seal(this);
  }

  // Delete owned resources.
  delete() {
    const {model, bufferTransform, textureTransform} = this;
    if (model) {
      model.delete();
    }
    if (bufferTransform) {
      bufferTransform.delete();
    }
    if (textureTransform) {
      textureTransform.delete();
    }
  }

  // Run one transform loop.
  run(opts = {}) {
    const {clearRenderTarget = true} = opts;

    const updatedOpts = this._updateDrawOptions(opts);

    if (clearRenderTarget && updatedOpts.framebuffer) {
      updatedOpts.framebuffer.clear({color: true});
    }

    this.model.transform(updatedOpts);
  }

  // swap resources if a map is provided
  swap() {
    let swapped = false;
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      swapped = swapped || resourceTransform.swap();
    }
    Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(swapped, 'Nothing to swap');
  }

  // Return Buffer object for given varying name.
  getBuffer(varyingName = null) {
    return this.bufferTransform && this.bufferTransform.getBuffer(varyingName);
  }

  // Return data either from Buffer or from Texture
  getData(opts = {}) {
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      const data = resourceTransform.getData(opts);
      if (data) {
        return data;
      }
    }
    return null;
  }

  // Return framebuffer object if rendering to textures
  getFramebuffer() {
    return this.textureTransform && this.textureTransform.getFramebuffer();
  }

  // Update some or all buffer/texture bindings.
  update(opts = {}) {
    if ('elementCount' in opts) {
      this.model.setVertexCount(opts.elementCount);
    }
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      resourceTransform.update(opts);
    }
  }

  // Private

  _initialize(props = {}) {
    const {gl} = this;
    this._buildResourceTransforms(gl, props);

    props = this._updateModelProps(props);
    this.model = new _model__WEBPACK_IMPORTED_MODULE_6__["default"](
      gl,
      Object.assign({}, props, {
        fs: props.fs || Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_1__["getPassthroughFS"])({version: Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_4__["getShaderVersion"])(props.vs)}),
        id: props.id || 'transform-model',
        drawMode: props.drawMode || _luma_gl_constants__WEBPACK_IMPORTED_MODULE_0___default.a.POINTS,
        vertexCount: props.elementCount
      })
    );

    /* eslint-disable no-unused-expressions */
    this.bufferTransform && this.bufferTransform.setupResources({model: this.model});
    /* eslint-enable no-unused-expressions */
  }

  _updateModelProps(props) {
    let updatedProps = Object.assign({}, props);
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      updatedProps = resourceTransform.updateModelProps(updatedProps);
    }
    return updatedProps;
  }

  _buildResourceTransforms(gl, props) {
    if (canCreateBufferTransform(props)) {
      this.bufferTransform = new _buffer_transform__WEBPACK_IMPORTED_MODULE_2__["default"](gl, props);
    }
    if (canCreateTextureTransform(props)) {
      this.textureTransform = new _texture_transform__WEBPACK_IMPORTED_MODULE_3__["default"](gl, props);
    }
    Object(_utils__WEBPACK_IMPORTED_MODULE_5__["assert"])(
      this.bufferTransform || this.textureTransform,
      'must provide source/feedback buffers or source/target textures'
    );
  }

  _updateDrawOptions(opts) {
    let updatedOpts = Object.assign({}, opts);
    const resourceTransforms = [this.bufferTransform, this.textureTransform].filter(Boolean);
    for (const resourceTransform of resourceTransforms) {
      updatedOpts = Object.assign(updatedOpts, resourceTransform.getDrawOptions(updatedOpts));
    }
    return updatedOpts;
  }
}

// Helper Methods

function canCreateBufferTransform(props) {
  if (
    !Object(_utils__WEBPACK_IMPORTED_MODULE_5__["isObjectEmpty"])(props.sourceBuffers) ||
    !Object(_utils__WEBPACK_IMPORTED_MODULE_5__["isObjectEmpty"])(props.feedbackBuffers) ||
    (props.varyings && props.varyings.length > 0)
  ) {
    return true;
  }
  return false;
}

function canCreateTextureTransform(props) {
  if (
    !Object(_utils__WEBPACK_IMPORTED_MODULE_5__["isObjectEmpty"])(props._sourceTextures) ||
    props._targetTexture ||
    props._targetTextureVarying
  ) {
    return true;
  }

  return false;
}


/***/ }),

/***/ "./src/lighting/light-source.js":
/*!**************************************!*\
  !*** ./src/lighting/light-source.js ***!
  \**************************************/
/*! exports provided: AmbientLight, DirectionalLight, PointLight */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLight", function() { return AmbientLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() { return DirectionalLight; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLight", function() { return PointLight; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils */ "./src/utils/index.js");



// default light source parameters
const DEFAULT_LIGHT_COLOR = [255, 255, 255];
const DEFAULT_LIGHT_INTENSITY = 1.0;
const DEFAULT_ATTENUATION = [0, 0, 1];

const DEFAULT_LIGHT_DIRECTION = [0.0, 0.0, -1.0];

const DEFAULT_LIGHT_POSITION = [0.0, 0.0, 1.0];

// glTF lights reference:
// https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_lights_punctual

class Light {
  constructor(props = {}) {
    this.id = props.id || Object(_utils__WEBPACK_IMPORTED_MODULE_1__["uid"])('light');
    const {color = DEFAULT_LIGHT_COLOR} = props;
    this.color = color;
    const {intensity = DEFAULT_LIGHT_INTENSITY} = props;
    this.intensity = intensity;
  }
}

class AmbientLight extends Light {
  constructor(props = {}) {
    super(props);
    this.type = 'ambient';
  }
}

class DirectionalLight extends Light {
  constructor(props = {}) {
    super(props);
    this.type = 'directional';
    const {direction = DEFAULT_LIGHT_DIRECTION} = props;
    this.direction = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"](direction).normalize().toArray();
  }
}

class PointLight extends Light {
  constructor(props = {}) {
    super(props);
    this.type = 'point';
    const {position = DEFAULT_LIGHT_POSITION} = props;
    this.position = position;
    this.attenuation = this._getAttenuation(props);
  }

  // PRIVATE

  // Helper: Extracts attenuation from either `props.attenuation`` or `props.intensity``
  // Supports both sophisticated light model and the classic intensity prop
  _getAttenuation(props) {
    if ('attenuation' in props) {
      return props.attenuation;
    }
    if ('intensity' in props) {
      return [0, 0, props.intensity];
    }
    return DEFAULT_ATTENUATION;
  }
}


/***/ }),

/***/ "./src/materials/material.js":
/*!***********************************!*\
  !*** ./src/materials/material.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Material; });
class Material {}


/***/ }),

/***/ "./src/materials/pbr-material.js":
/*!***************************************!*\
  !*** ./src/materials/pbr-material.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PBRMaterial; });
/* harmony import */ var _material__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./material */ "./src/materials/material.js");


class PBRMaterial extends _material__WEBPACK_IMPORTED_MODULE_0__["default"] {}


/***/ }),

/***/ "./src/materials/phong-material.js":
/*!*****************************************!*\
  !*** ./src/materials/phong-material.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PhongMaterial; });
/* harmony import */ var _material__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./material */ "./src/materials/material.js");


const defaultProps = {
  ambient: 0.35,
  diffuse: 0.6,
  shininess: 32,
  specularColor: [30, 30, 30]
};

class PhongMaterial extends _material__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(props) {
    super(props);
    props = Object.assign({}, defaultProps, props);
    Object.assign(this, props);
  }
}


/***/ }),

/***/ "./src/multipass/clear-pass.js":
/*!*************************************!*\
  !*** ./src/multipass/clear-pass.js ***!
  \*************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ClearPass; });
/* harmony import */ var _pass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pass */ "./src/multipass/pass.js");
//
// A pass that clears the input buffer or the screen.
//
// Attribution: This class and the multipass system were inspired by
// the THREE.js EffectComposer and *Pass classes



class ClearPass extends _pass__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(gl, props = {}) {
    super(gl, Object.assign({id: 'clear-pass'}, props));
  }

  // TODO - add support for colors, align with model.clear and framebuffer.clear
  // TODO - integrate with luma.gl clear, make sure right buffer is cleared
  _renderPass() {
    const {gl} = this;
    const {clearBits = gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT} = this.props;
    gl.clear(clearBits);
  }
}


/***/ }),

/***/ "./src/multipass/composite-pass.js":
/*!*****************************************!*\
  !*** ./src/multipass/composite-pass.js ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CompositePass; });
/* harmony import */ var _pass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pass */ "./src/multipass/pass.js");
//
// A composite render pass.
//
// Attribution: This class and the multipass system were inspired by
// the THREE.js EffectComposer and *Pass classes



class CompositePass extends _pass__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(gl, props = {}) {
    props = Array.isArray(props) ? {passes: props} : props;
    super(gl, Object.assign({id: 'composite-pass'}, props));
  }

  // Override render() to just forward the call
  render(...args) {
    const {passes = []} = this.props;
    for (const pass of passes) {
      pass.render(...args);
    }
  }

  delete() {
    // Delete any resources crated
  }
}


/***/ }),

/***/ "./src/multipass/copy-pass.js":
/*!************************************!*\
  !*** ./src/multipass/copy-pass.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CopyPass; });
/* harmony import */ var _lib_clip_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/clip-space */ "./src/lib/clip-space.js");
/* harmony import */ var _pass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pass */ "./src/multipass/pass.js");
//
// A pass that disables stencil test.
//
// Attribution: This class and the multipass system were inspired by
// the THREE.js EffectComposer and *Pass classes




const fs = `\
uniform sampler2D uDiffuseSampler;
uniform float uOpacity;

varying vec2 uv;

void main() {
  vec4 texel = texture2D(uDiffuseSampler, uv);
  gl_FragColor = uOpacity * texel;
}
`;

class CopyPass extends _pass__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(gl, props = {}) {
    super(gl, Object.assign({id: 'copy-pass', swap: true}, props));
    this.clipspace = new _lib_clip_space__WEBPACK_IMPORTED_MODULE_0__["default"](gl, {id: 'copy-pass', fs});
  }

  delete() {
    super.delete();
    this.clipspace.delete();
  }

  _renderPass({inputBuffer}) {
    const {opacity = 1.0} = this.props;

    this.clipspace.draw({
      uniforms: {
        uDiffuseSampler: inputBuffer,
        uOpacity: opacity
      },
      parameters: {
        depthWrite: false,
        depthTest: false
      }
    });
  }
}


/***/ }),

/***/ "./src/multipass/multi-pass-renderer.js":
/*!**********************************************!*\
  !*** ./src/multipass/multi-pass-renderer.js ***!
  \**********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MultiPassRenderer; });
/* harmony import */ var _composite_pass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./composite-pass */ "./src/multipass/composite-pass.js");
/* harmony import */ var _render_state__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./render-state */ "./src/multipass/render-state.js");
//
// A top-level composite render pass, that manages render state
//
// Attribution: This class and the multipass system were inspired by
// the THREE.js EffectComposer and *Pass classes




class MultiPassRenderer extends _composite_pass__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(gl, props = {}) {
    props = Array.isArray(props) ? {passes: props} : props;
    super(gl, Object.assign({id: 'multi-pass'}, props));
    this.renderState = new _render_state__WEBPACK_IMPORTED_MODULE_1__["default"](gl, props);
  }

  // Override render() to just forward the call
  render(animationProps) {
    this.renderState.reset();
    const {passes = []} = this.props;
    for (const pass of passes) {
      pass.render(this.renderState, animationProps);
    }
    return this;
  }

  delete() {
    this.renderState.delete();
    super.delete();
  }
}


/***/ }),

/***/ "./src/multipass/pass.js":
/*!*******************************!*\
  !*** ./src/multipass/pass.js ***!
  \*******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Pass; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../webgl/src/index.js");
//
// A base render pass.
//
// Attribution: This class and the multipass system were inspired by
// the THREE.js EffectComposer and *Pass classes



class Pass {
  constructor(gl, props = {}) {
    const {id = 'pass'} = props;
    this.id = id; // id of this pass
    this.gl = gl;
    this.props = {enabled: true, screen: false, swap: false};
    Object.assign(this.props, props);
  }

  setProps(props) {
    Object.assign(this.props, props);
  }

  render(renderState, animationProps) {
    if (!this.props.enabled) {
      return;
    }

    const gl = this.gl;

    const renderParams = {
      gl,
      outputBuffer: renderState.writeBuffer,
      inputBuffer: renderState.readBuffer,
      animationProps,
      swapBuffers: () => renderState._swapFramebuffers()
    };

    // TODO: Calirfy/Fix : is `screen` or `swap` must be true at this point
    // if so comment. We can also remove `enabled` from props and deduce that based on these two flags
    if (this.props.screen) {
      renderParams.inputBuffer = renderParams.outputBuffer;
      renderParams.outputBuffer = _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Framebuffer"].getDefaultFramebuffer(gl);
    } else if (this.props.swap) {
      renderParams.inputBuffer = renderState.writeBuffer;
      renderParams.outputBuffer = renderState.readBuffer;
    }

    Object(_luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["withParameters"])(gl, {framebuffer: renderParams.outputBuffer}, () =>
      this._renderPass(renderParams)
    );

    if (this.props.debug) {
      renderParams.outputBuffer.log(1, this.id);
    }

    if (this.props.swap) {
      renderState._swapFramebuffers();
    }
  }

  delete() {
    // Delete any resources crated
  }

  /**
   * Renders the effect.
   * This is an abstract method that should be overridden.
   * @param {Framebuffer} inputBuffer - Frame buffer that contains the result of the previous pass
   * @param {Framebuffer} outputBuffer - Frame buffer that serves as the output render target
   */
  _renderPass({gl, inputBuffer, outputBuffer, animationProps}) {
    // assert(false, 'Draw/render methods not implemented!');
  }
}


/***/ }),

/***/ "./src/multipass/render-pass.js":
/*!**************************************!*\
  !*** ./src/multipass/render-pass.js ***!
  \**************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderPass; });
/* harmony import */ var _pass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pass */ "./src/multipass/pass.js");
//
// A pass that renders a given scene directly on screen or into the read buffer
// for further processing.
//
// Attribution: This class and the multipass system were inspired by
// the THREE.js EffectComposer and *Pass classes



class RenderPass extends _pass__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(gl, props = {}) {
    super(gl, Object.assign({id: 'render-pass'}, props));
  }

  _renderPass({animationProps}) {
    const {models = [], drawParams} = this.props;
    for (const model of models) {
      model.draw(Object.assign({}, drawParams, {animationProps}));
    }
  }
}


/***/ }),

/***/ "./src/multipass/render-state.js":
/*!***************************************!*\
  !*** ./src/multipass/render-state.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RenderState; });
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../webgl/src/index.js");
//
// Render state helper class for the multi pass system
//
// Attribution: This class and the multipass system were inspired by
// the THREE.js EffectComposer and *Pass classes



class RenderState {
  constructor(gl, props = {}) {
    this.gl = gl;

    this.framebuffer1 = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Framebuffer"](gl, {id: 'multi-pass-1', stencil: true});
    this.framebuffer2 = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["Framebuffer"](gl, {id: 'multi-pass-2', stencil: true});

    this.reset();
  }

  reset() {
    this.framebuffer1.resize();
    this.framebuffer2.resize();

    this.writeBuffer = this.framebuffer1;
    this.readBuffer = this.framebuffer2;

    this.maskActive = false;
  }

  delete() {
    this.framebuffer1.delete();
    this.framebuffer2.delete();
  }

  _swapFramebuffers() {
    const tmp = this.readBuffer;
    this.readBuffer = this.writeBuffer;
    this.writeBuffer = tmp;
  }
}


/***/ }),

/***/ "./src/multipass/shader-module-pass.js":
/*!*********************************************!*\
  !*** ./src/multipass/shader-module-pass.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShaderModulePass; });
/* harmony import */ var _pass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pass */ "./src/multipass/pass.js");
/* harmony import */ var _composite_pass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./composite-pass */ "./src/multipass/composite-pass.js");
/* harmony import */ var _lib_clip_space__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/clip-space */ "./src/lib/clip-space.js");
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @luma.gl/shadertools */ "../shadertools/src/index.js");
//
// A pass that renders a given texture into screen space
//







class ShaderModuleSinglePass extends _pass__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(gl, props = {}) {
    super(gl, Object.assign({swap: true}, props));
  }

  _renderPass({inputBuffer, swapBuffers}) {
    this.props.model.setUniforms(this.props);

    // swapBuffers();
    this.props.model.draw({
      uniforms: {
        texture: inputBuffer,
        texSize: [inputBuffer.width, inputBuffer.height]
      },
      parameters: {
        depthWrite: false,
        depthTest: false
      }
    });
  }
}

class ShaderModulePass extends _composite_pass__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(gl, module, props = {}) {
    const id = `${module.name}-pass`;
    Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_3__["normalizeShaderModule"])(module);
    const passes = normalizePasses(gl, module, id, props);
    super(gl, Object.assign({id, passes}, props));
    this.module = module;
  }

  _renderPass({inputBuffer, swapBuffers}) {
    let first = true;
    for (const pass of this.props.passes) {
      if (!first) {
        swapBuffers();
      }
      first = false;
      const {uniforms, model} = pass.props;
      if (uniforms) {
        model.setUniforms(uniforms);
      }
      // swapBuffers();
      model.draw({
        uniforms: {
          texture: inputBuffer,
          texSize: [inputBuffer.width, inputBuffer.height]
        },
        parameters: {
          depthWrite: false,
          depthTest: false
        }
      });
    }
  }
}

function normalizePasses(gl, module, id, props) {
  if (module.filter || module.sampler) {
    const fs = getFragmentShaderForRenderPass(module);
    const pass = new ShaderModuleSinglePass(gl, {
      id,
      model: getModel(gl, module, fs, id, props),
      uniforms: null
    });
    return [pass];
  }

  const passes = module.passes || [];
  return passes.map(pass => {
    const fs = getFragmentShaderForRenderPass(module, pass);
    const idn = `${id}-${passes.length + 1}`;

    return new ShaderModuleSinglePass(
      gl,
      Object.assign(
        {
          id: idn,
          model: getModel(gl, module, fs, idn, props),
          uniforms: pass.uniforms
        },
        props
      )
    );
  });
}

function getModel(gl, module, fs, id, props) {
  const model = new _lib_clip_space__WEBPACK_IMPORTED_MODULE_2__["default"](gl, {id, fs, modules: [module]});

  const uniforms = Object.assign(module.getUniforms(), module.getUniforms(props));

  model.setUniforms(uniforms);
  return model;
}

const FILTER_FS_TEMPLATE = func => `\
uniform sampler2D texture;
uniform vec2 texSize;

varying vec2 position;
varying vec2 coordinate;
varying vec2 uv;

void main() {
  vec2 texCoord = coordinate;

  gl_FragColor = texture2D(texture, texCoord);
  gl_FragColor = ${func}(gl_FragColor, texSize, texCoord);
}
`;

const SAMPLER_FS_TEMPLATE = func => `\
uniform sampler2D texture;
uniform vec2 texSize;

varying vec2 position;
varying vec2 coordinate;
varying vec2 uv;

void main() {
  vec2 texCoord = coordinate;

  gl_FragColor = ${func}(texture, texSize, texCoord);
}
`;

function getFragmentShaderForRenderPass(module, pass = module) {
  if (pass.filter) {
    const func = typeof pass.filter === 'string' ? pass.filter : `${module.name}_filterColor`;
    return FILTER_FS_TEMPLATE(func);
  }

  if (pass.sampler) {
    const func = typeof pass.sampler === 'string' ? pass.sampler : `${module.name}_sampleColor`;
    return SAMPLER_FS_TEMPLATE(func);
  }

  // console.error(`${module.name} no fragment shader generated`);
  return null;
}


/***/ }),

/***/ "./src/multipass/texture-pass.js":
/*!***************************************!*\
  !*** ./src/multipass/texture-pass.js ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TexturePass; });
/* harmony import */ var _lib_clip_space__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/clip-space */ "./src/lib/clip-space.js");
/* harmony import */ var _pass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./pass */ "./src/multipass/pass.js");
//
// A pass that renders a given texture into screen space
//
// Attribution: This class and the multipass system were inspired by
// the THREE.js EffectComposer and *Pass classes




const fs = `\
uniform sampler2D uDiffuseSampler;
uniform float uOpacity;
varying vec2 uv;

void main() {
  vec4 texel = texture2D(uDiffuseSampler, uv);
  gl_FragColor = uOpacity * texel;
}
`;

class TexturePass extends _pass__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(gl, options = {}) {
    super(gl, Object.assign({id: 'texture-pass'}, options));
    const {texture, opacity = 1.0} = options;
    this.clipspace = new _lib_clip_space__WEBPACK_IMPORTED_MODULE_0__["default"](gl, {
      id: 'texture-pass',
      fs,
      uniforms: {
        uDiffuseSampler: texture,
        uOpacity: opacity
      }
    });
  }

  delete() {
    this.clipspace.delete();
    super.delete();
  }

  _renderPass() {
    this.clipspace.draw({
      parameters: {
        depthWrite: false,
        depthTest: false
      }
    });
  }
}


/***/ }),

/***/ "./src/resource-management/program-manager.js":
/*!****************************************************!*\
  !*** ./src/resource-management/program-manager.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ProgramManager; });
/* harmony import */ var _luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/shadertools */ "../shadertools/src/index.js");
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @luma.gl/webgl */ "../webgl/src/index.js");



class ProgramManager {
  static getDefaultProgramManager(gl) {
    gl.luma = gl.luma || {};
    gl.luma.defaultProgramManager = gl.luma.defaultProgramManager || new ProgramManager(gl);

    return gl.luma.defaultProgramManager;
  }

  constructor(gl) {
    this.gl = gl;

    this._programCache = {};
    this._getUniforms = {};
    this._registeredModules = {};
    this._moduleInjections = {
      vs: {},
      fs: {}
    };
    this._hookFunctions = {
      vs: {},
      fs: {}
    };
    this._defaultModules = [];

    this._hashes = {};
    this._hashCounter = 0;
    this.stateHash = 0; // Used change hashing if hooks are modified
    this._useCounts = {};
  }

  addDefaultModule(module) {
    if (!this._defaultModules.find(m => m.name === module.name)) {
      this._defaultModules.push(module);
    }

    this.stateHash++;
  }

  removeDefaultModule(module) {
    const moduleName = typeof module === 'string' ? module : module.name;
    this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);
    this.stateHash++;
  }

  addModuleInjection(module, opts) {
    const moduleName = typeof module === 'string' ? module : module.name;
    const {hook, injection, order = 0} = opts;
    const shaderStage = hook.slice(0, 2);

    const moduleInjections = this._moduleInjections[shaderStage];
    moduleInjections[moduleName] = moduleInjections[moduleName] || {};

    moduleInjections[moduleName][hook] = {
      injection,
      order
    };

    this.stateHash++;
  }

  addShaderHook(hook, opts = {}) {
    hook = hook.trim();
    const [stage, signature] = hook.split(':');
    const name = hook.replace(/\(.+/, '');
    this._hookFunctions[stage][name] = Object.assign(opts, {signature});

    this.stateHash++;
  }

  get(props = {}) {
    const {vs = '', fs = '', defines = {}, inject = {}, varyings = [], bufferMode = 0x8c8d} = props; // varyings/bufferMode for xform feedback, 0x8c8d = SEPARATE_ATTRIBS

    const modules = this._getModuleList(props.modules); // Combine with default modules

    const vsHash = this._getHash(vs);
    const fsHash = this._getHash(fs);
    const moduleHashes = modules.map(m => this._getHash(typeof m === 'string' ? m : m.name)).sort();
    const varyingHashes = varyings.map(v => this._getHash(v));

    const defineKeys = Object.keys(defines).sort();
    const injectKeys = Object.keys(inject).sort();
    const defineHashes = [];
    const injectHashes = [];

    for (const key of defineKeys) {
      defineHashes.push(this._getHash(key));
      defineHashes.push(this._getHash(defines[key]));
    }

    for (const key of injectKeys) {
      injectHashes.push(this._getHash(key));
      injectHashes.push(this._getHash(inject[key]));
    }

    const hash = `${vsHash}/${fsHash}D${defineHashes.join('/')}M${moduleHashes.join(
      '/'
    )}I${injectHashes.join('/')}V${varyingHashes.join('/')}H${this.stateHash}B${bufferMode}`;

    if (!this._programCache[hash]) {
      const assembled = Object(_luma_gl_shadertools__WEBPACK_IMPORTED_MODULE_0__["assembleShaders"])(this.gl, {
        vs,
        fs,
        modules,
        inject,
        defines,
        hookFunctions: this._hookFunctions,
        moduleInjections: this._moduleInjections
      });

      this._programCache[hash] = new _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_1__["Program"](this.gl, {
        hash,
        vs: assembled.vs,
        fs: assembled.fs,
        varyings,
        bufferMode
      });

      this._getUniforms[hash] = assembled.getUniforms || (x => {});
      this._useCounts[hash] = 0;
    }

    this._useCounts[hash]++;

    return this._programCache[hash];
  }

  getUniforms(program) {
    return this._getUniforms[program.hash] || null;
  }

  release(program) {
    const hash = program.hash;
    this._useCounts[hash]--;

    if (this._useCounts[hash] === 0) {
      this._programCache[hash].delete();
      delete this._programCache[hash];
      delete this._getUniforms[hash];
      delete this._useCounts[hash];
    }
  }

  _getHash(key) {
    if (this._hashes[key] === undefined) {
      this._hashes[key] = this._hashCounter++;
    }

    return this._hashes[key];
  }

  // Dedup and combine with default modules
  _getModuleList(appModules = []) {
    const modules = new Array(this._defaultModules.length + appModules.length);
    const seen = {};
    let count = 0;

    for (let i = 0, len = this._defaultModules.length; i < len; ++i) {
      const module = this._defaultModules[i];
      const name = typeof module === 'string' ? module : module.name;
      modules[count++] = module;
      seen[name] = true;
    }

    for (let i = 0, len = appModules.length; i < len; ++i) {
      const module = appModules[i];
      const name = typeof module === 'string' ? module : module.name;
      if (!seen[name]) {
        modules[count++] = module;
        seen[name] = true;
      }
    }

    modules.length = count;

    return modules;
  }
}


/***/ }),

/***/ "./src/scenegraph/nodes/camera-node.js":
/*!*********************************************!*\
  !*** ./src/scenegraph/nodes/camera-node.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CameraNode; });
/* harmony import */ var _scenegraph_node__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./scenegraph-node */ "./src/scenegraph/nodes/scenegraph-node.js");


class CameraNode extends _scenegraph_node__WEBPACK_IMPORTED_MODULE_0__["default"] {
  constructor(props = {}) {
    super(props);
    this.projectionMatrix = props.projectionMatrix;
  }
}


/***/ }),

/***/ "./src/scenegraph/nodes/group-node.js":
/*!********************************************!*\
  !*** ./src/scenegraph/nodes/group-node.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return GroupNode; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/utils/index.js");
/* harmony import */ var _scenegraph_node__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scenegraph-node */ "./src/scenegraph/nodes/scenegraph-node.js");




class GroupNode extends _scenegraph_node__WEBPACK_IMPORTED_MODULE_2__["default"] {
  constructor(props = {}) {
    props = Array.isArray(props) ? {children: props} : props;
    const {children = []} = props;
    _utils__WEBPACK_IMPORTED_MODULE_1__["log"].assert(
      children.every(child => child instanceof _scenegraph_node__WEBPACK_IMPORTED_MODULE_2__["default"]),
      'every child must an instance of ScenegraphNode'
    );
    super(props);
    this.children = children;
  }

  // Unpacks arrays and nested arrays of children
  add(...children) {
    for (const child of children) {
      if (Array.isArray(child)) {
        this.add(...child);
      } else {
        this.children.push(child);
      }
    }
    return this;
  }

  remove(child) {
    const children = this.children;
    const indexOf = children.indexOf(child);
    if (indexOf > -1) {
      children.splice(indexOf, 1);
    }
    return this;
  }

  removeAll() {
    this.children = [];
    return this;
  }

  delete() {
    this.children.forEach(child => child.delete());
    this.removeAll();
    super.delete();
  }

  traverse(visitor, {worldMatrix = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]()} = {}) {
    const modelMatrix = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"](worldMatrix).multiplyRight(this.matrix);

    for (const child of this.children) {
      if (child instanceof GroupNode) {
        child.traverse(visitor, {worldMatrix: modelMatrix});
      } else {
        visitor(child, {worldMatrix: modelMatrix});
      }
    }
  }

  traverseReverse(visitor, opts) {
    _utils__WEBPACK_IMPORTED_MODULE_1__["log"].warn('traverseReverse is not reverse')();
    return this.traverse(visitor, opts);
  }
}


/***/ }),

/***/ "./src/scenegraph/nodes/model-node.js":
/*!********************************************!*\
  !*** ./src/scenegraph/nodes/model-node.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ModelNode; });
/* harmony import */ var _lib_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lib/model */ "./src/lib/model.js");
/* harmony import */ var _scenegraph_node__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./scenegraph-node */ "./src/scenegraph/nodes/scenegraph-node.js");



class ModelNode extends _scenegraph_node__WEBPACK_IMPORTED_MODULE_1__["default"] {
  constructor(gl, props = {}) {
    super(props);

    // pverride callbacks to make sure we call them with this
    this.onBeforeRender = null;
    this.AfterRender = null;

    // Create new Model or used supplied Model
    if (gl instanceof _lib_model__WEBPACK_IMPORTED_MODULE_0__["default"]) {
      this.model = gl;
      this._setModelNodeProps(props);
    } else {
      this.model = new _lib_model__WEBPACK_IMPORTED_MODULE_0__["default"](gl, props);
    }

    this.managedResources = props.managedResources || [];
  }

  setProps(props) {
    super.setProps(props);
    this._setModelNodeProps(props);
    return this;
  }

  delete() {
    if (this.model) {
      this.model.delete();
      this.model = null;
    }

    this.managedResources.forEach(resource => resource.delete());
    this.managedResources = [];
  }

  // Forward node methods
  draw(...args) {
    // Return value indicates if something was actually drawn
    return this.model.draw(...args);
  }

  setUniforms(...args) {
    this.model.setUniforms(...args);
    return this;
  }

  setAttributes(...args) {
    this.model.setAttributes(...args);
    return this;
  }

  updateModuleSettings(...args) {
    this.model.updateModuleSettings(...args);
    return this;
  }

  // PRIVATE

  _setModelNodeProps(props) {
    this.model.setProps(props);
  }
}


/***/ }),

/***/ "./src/scenegraph/nodes/scenegraph-node.js":
/*!*************************************************!*\
  !*** ./src/scenegraph/nodes/scenegraph-node.js ***!
  \*************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ScenegraphNode; });
/* harmony import */ var math_gl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! math.gl */ "../../node_modules/math.gl/dist/esm/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils */ "./src/utils/index.js");



class ScenegraphNode {
  constructor(props = {}) {
    const {id} = props;

    this.id = id || Object(_utils__WEBPACK_IMPORTED_MODULE_1__["uid"])(this.constructor.name);

    this.display = true; // whether to display the object at all
    this.position = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
    this.rotation = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"]();
    this.scale = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Vector3"](1, 1, 1);
    this.matrix = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"]();
    this.userData = {};

    this.props = {};
    this._setScenegraphNodeProps(props);
  }

  delete() {}

  setProps(props) {
    this._setScenegraphNodeProps(props);
    return this;
  }

  toString() {
    return `{type: ScenegraphNode, id: ${this.id})}`;
  }

  setPosition(position) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(position.length === 3, 'setPosition requires vector argument');
    this.position = position;
    return this;
  }

  setRotation(rotation) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(rotation.length === 3, 'setRotation requires vector argument');
    this.rotation = rotation;
    return this;
  }

  setScale(scale) {
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(scale.length === 3, 'setScale requires vector argument');
    this.scale = scale;
    return this;
  }

  setMatrix(matrix, copyMatrix = true) {
    if (copyMatrix) {
      this.matrix.copy(matrix);
    } else {
      this.matrix = matrix;
    }
  }

  setMatrixComponents({position, rotation, scale, update = true}) {
    if (position) {
      this.setPosition(position);
    }
    if (rotation) {
      this.setRotation(rotation);
    }
    if (scale) {
      this.setScale(scale);
    }
    if (update) {
      this.updateMatrix();
    }
    return this;
  }

  updateMatrix() {
    const pos = this.position;
    const rot = this.rotation;
    const scale = this.scale;

    this.matrix.identity();
    this.matrix.translate(pos);
    this.matrix.rotateXYZ(rot);
    this.matrix.scale(scale);
    return this;
  }

  update({position, rotation, scale} = {}) {
    if (position) {
      this.setPosition(position);
    }
    if (rotation) {
      this.setRotation(rotation);
    }
    if (scale) {
      this.setScale(scale);
    }
    this.updateMatrix();
    return this;
  }

  getCoordinateUniforms(viewMatrix, modelMatrix) {
    // TODO - solve multiple class problem
    // assert(viewMatrix instanceof Matrix4);
    Object(_utils__WEBPACK_IMPORTED_MODULE_1__["assert"])(viewMatrix);
    modelMatrix = modelMatrix || this.matrix;
    const worldMatrix = new math_gl__WEBPACK_IMPORTED_MODULE_0__["Matrix4"](viewMatrix).multiplyRight(modelMatrix);
    const worldInverse = worldMatrix.invert();
    const worldInverseTranspose = worldInverse.transpose();

    return {
      viewMatrix,
      modelMatrix,
      objectMatrix: modelMatrix,
      worldMatrix,
      worldInverseMatrix: worldInverse,
      worldInverseTransposeMatrix: worldInverseTranspose
    };
  }

  // TODO - copied code, not yet vetted
  /*
  transform() {
    if (!this.parent) {
      this.endPosition.set(this.position);
      this.endRotation.set(this.rotation);
      this.endScale.set(this.scale);
    } else {
      const parent = this.parent;
      this.endPosition.set(this.position.add(parent.endPosition));
      this.endRotation.set(this.rotation.add(parent.endRotation));
      this.endScale.set(this.scale.add(parent.endScale));
    }

    const ch = this.children;
    for (let i = 0; i < ch.length; ++i) {
      ch[i].transform();
    }

    return this;
  }
  */

  _setScenegraphNodeProps(props) {
    if ('display' in props) {
      this.display = props.display;
    }

    if ('position' in props) {
      this.setPosition(props.position);
    }
    if ('rotation' in props) {
      this.setRotation(props.rotation);
    }
    if ('scale' in props) {
      this.setScale(props.scale);
    }

    // Matrix overwrites other props
    if ('matrix' in props) {
      this.setMatrix(props.matrix);
    }

    Object.assign(this.props, props);
  }
}


/***/ }),

/***/ "./src/utils/index.js":
/*!****************************!*\
  !*** ./src/utils/index.js ***!
  \****************************/
/*! exports provided: assert, log, uid, isObjectEmpty, self, window, global, document */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @luma.gl/webgl */ "../webgl/src/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "assert", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["assert"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "log", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["log"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "uid", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["uid"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isObjectEmpty", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["isObjectEmpty"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "self", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["self"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "window", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["window"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "global", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["global"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "document", function() { return _luma_gl_webgl__WEBPACK_IMPORTED_MODULE_0__["document"]; });





/***/ }),

/***/ 0:
/*!*******************************!*\
  !*** asciify-image (ignored) ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
});