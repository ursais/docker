{"version":3,"sources":["../../../src/lib/shader-cache.js"],"names":["VertexShader","FragmentShader","Program","assert","ShaderCache","constructor","gl","_cachePrograms","vertexShaders","fragmentShaders","programs","delete","getVertexShader","source","_compareContexts","shader","getFragmentShader","getProgram","opts","vs","fs","id","cacheKey","_getProgramKey","program","_resetProgram","_createNewProgram","_checkProgramProp","_isCached","varyings","vertexShader","fragmentShader","Object","assign","reset","gl1","gl2"],"mappings":"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","sourcesContent":["import {VertexShader, FragmentShader, Program} from '@luma.gl/webgl';\nimport {assert} from '../utils';\n\nexport default class ShaderCache {\n  /**\n   * A cache of compiled shaders, keyed by shader source strings.\n   * Compilation of long shaders can be time consuming.\n   * By using this class, the application can ensure that each shader\n   * is only compiled once.\n   */\n  constructor({gl, _cachePrograms = false} = {}) {\n    assert(gl);\n    this.gl = gl;\n    this.vertexShaders = {};\n    this.fragmentShaders = {};\n    this.programs = {};\n    this._cachePrograms = _cachePrograms;\n  }\n\n  /**\n   * Deletes shader references\n   * @return {ShaderCache} - returns this for chaining\n   */\n  delete() {\n    // TODO - requires reference counting to avoid deleting shaders in use\n    return this;\n  }\n\n  /**\n   * Returns a compiled `VertexShader` object corresponding to the supplied\n   * GLSL source code string, if possible from cache.\n   *\n   * @param {WebGLRenderingContext} gl - gl context\n   * @param {String} source - Source code for shader\n   * @return {VertexShader} - a compiled vertex shader\n   */\n  getVertexShader(gl, source) {\n    assert(typeof source === 'string');\n    assert(this._compareContexts(gl, this.gl));\n\n    let shader = this.vertexShaders[source];\n    if (!shader) {\n      shader = new VertexShader(gl, source);\n      this.vertexShaders[source] = shader;\n    }\n    return shader;\n  }\n\n  /**\n   * Returns a compiled `VertexShader` object corresponding to the supplied\n   * GLSL source code string, if possible from cache.\n   * @param {WebGLRenderingContext} gl - gl context\n   * @param {String} source - Source code for shader\n   * @return {FragmentShader} - a compiled fragment shader, possibly from chache\n   */\n  getFragmentShader(gl, source) {\n    assert(typeof source === 'string');\n    assert(this._compareContexts(gl, this.gl));\n\n    let shader = this.fragmentShaders[source];\n    if (!shader) {\n      shader = new FragmentShader(gl, source);\n      this.fragmentShaders[source] = shader;\n    }\n    return shader;\n  }\n\n  // Retrive Shaders from cache if exists, otherwise create new instance.\n  getProgram(gl, opts) {\n    assert(this._compareContexts(gl, this.gl));\n    assert(typeof opts.vs === 'string');\n    assert(typeof opts.fs === 'string');\n    assert(typeof opts.id === 'string');\n\n    const cacheKey = this._getProgramKey(opts);\n    let program = this.programs[cacheKey];\n    if (program) {\n      this._resetProgram(program);\n      return program;\n    }\n\n    program = this._createNewProgram(gl, opts);\n\n    // Check if program can be cached\n    // Program caching is experimental and expects\n    // each Model to have a unique-id (wich is used in key generation)\n    if (this._cachePrograms && this._checkProgramProp(program)) {\n      program._isCached = true;\n      this.programs[cacheKey] = program;\n    }\n\n    return program;\n  }\n\n  _getProgramKey(opts) {\n    return `${opts.id}-${opts.vs}-${opts.fs}`;\n  }\n\n  _checkProgramProp(program) {\n    // Check for transform feedback props (varyings, etc), we can't key such programs for now\n    return !program.varyings;\n  }\n\n  _createNewProgram(gl, opts) {\n    const {vs, fs} = opts;\n    const vertexShader = this.getVertexShader(gl, vs);\n    const fragmentShader = this.getFragmentShader(gl, fs);\n    return new Program(\n      this.gl,\n      Object.assign({}, opts, {\n        vs: vertexShader,\n        fs: fragmentShader\n      })\n    );\n  }\n\n  _resetProgram(program, opts) {\n    program.reset();\n  }\n\n  // Handle debug contexts\n  _compareContexts(gl1, gl2) {\n    return (gl1.gl || gl1) === (gl2.gl || gl2);\n  }\n}\n"],"file":"shader-cache.js"}