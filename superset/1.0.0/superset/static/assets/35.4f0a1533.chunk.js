(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[35],{

/***/ "./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ParallelCoordinates.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ParallelCoordinates.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3 */ \"./node_modules/d3/d3.js\");\n/* harmony import */ var d3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(d3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @superset-ui/core */ \"./node_modules/@superset-ui/core/esm/color/SequentialSchemeRegistrySingleton.js\");\n/* harmony import */ var _vendor_parcoords_d3_parcoords__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vendor/parcoords/d3.parcoords */ \"./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.js\");\n/* harmony import */ var _vendor_parcoords_divgrid__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./vendor/parcoords/divgrid */ \"./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/divgrid.js\");\n/* harmony import */ var _vendor_parcoords_d3_parcoords_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./vendor/parcoords/d3.parcoords.css */ \"./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\");\n/* harmony import */ var _vendor_parcoords_d3_parcoords_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_vendor_parcoords_d3_parcoords_css__WEBPACK_IMPORTED_MODULE_5__);\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n/* eslint-disable react/sort-prop-types */\n\n\n\n\n\n\nconst propTypes = {\n  // Standard tabular data [{ fieldName1: value1, fieldName2: value2 }]\n  data: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object),\n  width: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  height: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.number,\n  colorMetric: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  includeSeries: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool,\n  linearColorScheme: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  metrics: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string),\n  series: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.string,\n  showDatatable: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.bool\n};\n\nfunction ParallelCoordinates(element, props) {\n  const {\n    data,\n    width,\n    height,\n    colorMetric,\n    includeSeries,\n    linearColorScheme,\n    metrics,\n    series,\n    showDatatable\n  } = props;\n  const cols = includeSeries ? [series].concat(metrics) : metrics;\n  const ttypes = {};\n  ttypes[series] = 'string';\n  metrics.forEach(v => {\n    ttypes[v] = 'number';\n  });\n  const colorScale = colorMetric ? Object(_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__[\"default\"])().get(linearColorScheme).createLinearScale(d3__WEBPACK_IMPORTED_MODULE_0___default.a.extent(data, d => d[colorMetric])) : () => 'grey';\n\n  const color = d => colorScale(d[colorMetric]);\n\n  const container = d3__WEBPACK_IMPORTED_MODULE_0___default.a.select(element).classed('superset-legacy-chart-parallel-coordinates', true);\n  container.selectAll('*').remove();\n  const effHeight = showDatatable ? height / 2 : height;\n  const div = container.append('div').style('height', `${effHeight}px`).classed('parcoords', true);\n  const chart = Object(_vendor_parcoords_d3_parcoords__WEBPACK_IMPORTED_MODULE_3__[\"default\"])()(div.node()).width(width).color(color).alpha(0.5).composite('darken').height(effHeight).data(data).dimensions(cols).types(ttypes).render().createAxes().shadows().reorderable().brushMode('1D-axes');\n\n  if (showDatatable) {\n    // create data table, row hover highlighting\n    const grid = Object(_vendor_parcoords_divgrid__WEBPACK_IMPORTED_MODULE_4__[\"default\"])();\n    container.append('div').style('height', `${effHeight}px`).datum(data).call(grid).classed('parcoords grid', true).selectAll('.row').on({\n      mouseover(d) {\n        chart.highlight([d]);\n      },\n\n      mouseout: chart.unhighlight\n    }); // update data table on brush event\n\n    chart.on('brush', d => {\n      d3__WEBPACK_IMPORTED_MODULE_0___default.a.select('.grid').datum(d).call(grid).selectAll('.row').on({\n        mouseover(dd) {\n          chart.highlight([dd]);\n        },\n\n        mouseout: chart.unhighlight\n      });\n    });\n  }\n}\n\nParallelCoordinates.displayName = 'ParallelCoordinates';\nParallelCoordinates.propTypes = propTypes;\n/* harmony default export */ __webpack_exports__[\"default\"] = (ParallelCoordinates);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL1BhcmFsbGVsQ29vcmRpbmF0ZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL1BhcmFsbGVsQ29vcmRpbmF0ZXMuanM/ZDA0YyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L3NvcnQtcHJvcC10eXBlcyAqL1xuaW1wb3J0IGQzIGZyb20gJ2QzJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgeyBnZXRTZXF1ZW50aWFsU2NoZW1lUmVnaXN0cnkgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgcGFyY29vcmRzIGZyb20gJy4vdmVuZG9yL3BhcmNvb3Jkcy9kMy5wYXJjb29yZHMnO1xuaW1wb3J0IGRpdmdyaWQgZnJvbSAnLi92ZW5kb3IvcGFyY29vcmRzL2RpdmdyaWQnO1xuaW1wb3J0ICcuL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmNzcyc7XG5jb25zdCBwcm9wVHlwZXMgPSB7XG4gIC8vIFN0YW5kYXJkIHRhYnVsYXIgZGF0YSBbeyBmaWVsZE5hbWUxOiB2YWx1ZTEsIGZpZWxkTmFtZTI6IHZhbHVlMiB9XVxuICBkYXRhOiBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub2JqZWN0KSxcbiAgd2lkdGg6IFByb3BUeXBlcy5udW1iZXIsXG4gIGhlaWdodDogUHJvcFR5cGVzLm51bWJlcixcbiAgY29sb3JNZXRyaWM6IFByb3BUeXBlcy5zdHJpbmcsXG4gIGluY2x1ZGVTZXJpZXM6IFByb3BUeXBlcy5ib29sLFxuICBsaW5lYXJDb2xvclNjaGVtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgbWV0cmljczogUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnN0cmluZyksXG4gIHNlcmllczogUHJvcFR5cGVzLnN0cmluZyxcbiAgc2hvd0RhdGF0YWJsZTogUHJvcFR5cGVzLmJvb2xcbn07XG5cbmZ1bmN0aW9uIFBhcmFsbGVsQ29vcmRpbmF0ZXMoZWxlbWVudCwgcHJvcHMpIHtcbiAgY29uc3Qge1xuICAgIGRhdGEsXG4gICAgd2lkdGgsXG4gICAgaGVpZ2h0LFxuICAgIGNvbG9yTWV0cmljLFxuICAgIGluY2x1ZGVTZXJpZXMsXG4gICAgbGluZWFyQ29sb3JTY2hlbWUsXG4gICAgbWV0cmljcyxcbiAgICBzZXJpZXMsXG4gICAgc2hvd0RhdGF0YWJsZVxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IGNvbHMgPSBpbmNsdWRlU2VyaWVzID8gW3Nlcmllc10uY29uY2F0KG1ldHJpY3MpIDogbWV0cmljcztcbiAgY29uc3QgdHR5cGVzID0ge307XG4gIHR0eXBlc1tzZXJpZXNdID0gJ3N0cmluZyc7XG4gIG1ldHJpY3MuZm9yRWFjaCh2ID0+IHtcbiAgICB0dHlwZXNbdl0gPSAnbnVtYmVyJztcbiAgfSk7XG4gIGNvbnN0IGNvbG9yU2NhbGUgPSBjb2xvck1ldHJpYyA/IGdldFNlcXVlbnRpYWxTY2hlbWVSZWdpc3RyeSgpLmdldChsaW5lYXJDb2xvclNjaGVtZSkuY3JlYXRlTGluZWFyU2NhbGUoZDMuZXh0ZW50KGRhdGEsIGQgPT4gZFtjb2xvck1ldHJpY10pKSA6ICgpID0+ICdncmV5JztcblxuICBjb25zdCBjb2xvciA9IGQgPT4gY29sb3JTY2FsZShkW2NvbG9yTWV0cmljXSk7XG5cbiAgY29uc3QgY29udGFpbmVyID0gZDMuc2VsZWN0KGVsZW1lbnQpLmNsYXNzZWQoJ3N1cGVyc2V0LWxlZ2FjeS1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcycsIHRydWUpO1xuICBjb250YWluZXIuc2VsZWN0QWxsKCcqJykucmVtb3ZlKCk7XG4gIGNvbnN0IGVmZkhlaWdodCA9IHNob3dEYXRhdGFibGUgPyBoZWlnaHQgLyAyIDogaGVpZ2h0O1xuICBjb25zdCBkaXYgPSBjb250YWluZXIuYXBwZW5kKCdkaXYnKS5zdHlsZSgnaGVpZ2h0JywgYCR7ZWZmSGVpZ2h0fXB4YCkuY2xhc3NlZCgncGFyY29vcmRzJywgdHJ1ZSk7XG4gIGNvbnN0IGNoYXJ0ID0gcGFyY29vcmRzKCkoZGl2Lm5vZGUoKSkud2lkdGgod2lkdGgpLmNvbG9yKGNvbG9yKS5hbHBoYSgwLjUpLmNvbXBvc2l0ZSgnZGFya2VuJykuaGVpZ2h0KGVmZkhlaWdodCkuZGF0YShkYXRhKS5kaW1lbnNpb25zKGNvbHMpLnR5cGVzKHR0eXBlcykucmVuZGVyKCkuY3JlYXRlQXhlcygpLnNoYWRvd3MoKS5yZW9yZGVyYWJsZSgpLmJydXNoTW9kZSgnMUQtYXhlcycpO1xuXG4gIGlmIChzaG93RGF0YXRhYmxlKSB7XG4gICAgLy8gY3JlYXRlIGRhdGEgdGFibGUsIHJvdyBob3ZlciBoaWdobGlnaHRpbmdcbiAgICBjb25zdCBncmlkID0gZGl2Z3JpZCgpO1xuICAgIGNvbnRhaW5lci5hcHBlbmQoJ2RpdicpLnN0eWxlKCdoZWlnaHQnLCBgJHtlZmZIZWlnaHR9cHhgKS5kYXR1bShkYXRhKS5jYWxsKGdyaWQpLmNsYXNzZWQoJ3BhcmNvb3JkcyBncmlkJywgdHJ1ZSkuc2VsZWN0QWxsKCcucm93Jykub24oe1xuICAgICAgbW91c2VvdmVyKGQpIHtcbiAgICAgICAgY2hhcnQuaGlnaGxpZ2h0KFtkXSk7XG4gICAgICB9LFxuXG4gICAgICBtb3VzZW91dDogY2hhcnQudW5oaWdobGlnaHRcbiAgICB9KTsgLy8gdXBkYXRlIGRhdGEgdGFibGUgb24gYnJ1c2ggZXZlbnRcblxuICAgIGNoYXJ0Lm9uKCdicnVzaCcsIGQgPT4ge1xuICAgICAgZDMuc2VsZWN0KCcuZ3JpZCcpLmRhdHVtKGQpLmNhbGwoZ3JpZCkuc2VsZWN0QWxsKCcucm93Jykub24oe1xuICAgICAgICBtb3VzZW92ZXIoZGQpIHtcbiAgICAgICAgICBjaGFydC5oaWdobGlnaHQoW2RkXSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgbW91c2VvdXQ6IGNoYXJ0LnVuaGlnaGxpZ2h0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG5QYXJhbGxlbENvb3JkaW5hdGVzLmRpc3BsYXlOYW1lID0gJ1BhcmFsbGVsQ29vcmRpbmF0ZXMnO1xuUGFyYWxsZWxDb29yZGluYXRlcy5wcm9wVHlwZXMgPSBwcm9wVHlwZXM7XG5leHBvcnQgZGVmYXVsdCBQYXJhbGxlbENvb3JkaW5hdGVzOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ParallelCoordinates.js\n");

/***/ }),

/***/ "./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ReactParallelCoordinates.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ReactParallelCoordinates.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @superset-ui/core */ \"./node_modules/@superset-ui/core/esm/chart/components/reactify.js\");\n/* harmony import */ var _superset_ui_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @superset-ui/core */ \"./node_modules/@superset-ui/core/esm/style/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _ParallelCoordinates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ParallelCoordinates */ \"./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ParallelCoordinates.js\");\n/* harmony import */ var _emotion_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @emotion/react */ \"./node_modules/@emotion/react/dist/emotion-react.browser.esm.js\");\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n\n\n\nconst ReactComponent = Object(_superset_ui_core__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(_ParallelCoordinates__WEBPACK_IMPORTED_MODULE_4__[\"default\"]);\n\nconst ParallelCoordianes = ({\n  className,\n  ...otherProps\n}) => Object(_emotion_react__WEBPACK_IMPORTED_MODULE_5__[\"jsx\"])(\"div\", {\n  className: className\n}, Object(_emotion_react__WEBPACK_IMPORTED_MODULE_5__[\"jsx\"])(ReactComponent, otherProps));\n\nParallelCoordianes.propTypes = {\n  className: prop_types__WEBPACK_IMPORTED_MODULE_3___default.a.string.isRequired\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (Object(_superset_ui_core__WEBPACK_IMPORTED_MODULE_2__[\"styled\"])(ParallelCoordianes)`\n  .superset-legacy-chart-parallel-coordinates {\n    div.grid {\n      overflow: auto;\n      div.row {\n        &:hover {\n          background-color: #ccc;\n        }\n      }\n    }\n  }\n`);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL1JlYWN0UGFyYWxsZWxDb29yZGluYXRlcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJzZXQtdWkvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9lc20vUmVhY3RQYXJhbGxlbENvb3JkaW5hdGVzLmpzPzZkNWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBMaWNlbnNlZCB0byB0aGUgQXBhY2hlIFNvZnR3YXJlIEZvdW5kYXRpb24gKEFTRikgdW5kZXIgb25lXG4gKiBvciBtb3JlIGNvbnRyaWJ1dG9yIGxpY2Vuc2UgYWdyZWVtZW50cy4gIFNlZSB0aGUgTk9USUNFIGZpbGVcbiAqIGRpc3RyaWJ1dGVkIHdpdGggdGhpcyB3b3JrIGZvciBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gKiByZWdhcmRpbmcgY29weXJpZ2h0IG93bmVyc2hpcC4gIFRoZSBBU0YgbGljZW5zZXMgdGhpcyBmaWxlXG4gKiB0byB5b3UgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlXG4gKiBcIkxpY2Vuc2VcIik7IHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2VcbiAqIHdpdGggdGhlIExpY2Vuc2UuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZyxcbiAqIHNvZnR3YXJlIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuXG4gKiBcIkFTIElTXCIgQkFTSVMsIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWVxuICogS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlXG4gKiBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kIGxpbWl0YXRpb25zXG4gKiB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHN0eWxlZCwgcmVhY3RpZnkgfSBmcm9tICdAc3VwZXJzZXQtdWkvY29yZSc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IENvbXBvbmVudCBmcm9tICcuL1BhcmFsbGVsQ29vcmRpbmF0ZXMnO1xuaW1wb3J0IHsganN4IGFzIF9fX0Vtb3Rpb25KU1ggfSBmcm9tIFwiQGVtb3Rpb24vcmVhY3RcIjtcbmNvbnN0IFJlYWN0Q29tcG9uZW50ID0gcmVhY3RpZnkoQ29tcG9uZW50KTtcblxuY29uc3QgUGFyYWxsZWxDb29yZGlhbmVzID0gKHtcbiAgY2xhc3NOYW1lLFxuICAuLi5vdGhlclByb3BzXG59KSA9PiBfX19FbW90aW9uSlNYKFwiZGl2XCIsIHtcbiAgY2xhc3NOYW1lOiBjbGFzc05hbWVcbn0sIF9fX0Vtb3Rpb25KU1goUmVhY3RDb21wb25lbnQsIG90aGVyUHJvcHMpKTtcblxuUGFyYWxsZWxDb29yZGlhbmVzLnByb3BUeXBlcyA9IHtcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWRcbn07XG5leHBvcnQgZGVmYXVsdCBzdHlsZWQoUGFyYWxsZWxDb29yZGlhbmVzKWBcbiAgLnN1cGVyc2V0LWxlZ2FjeS1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcyB7XG4gICAgZGl2LmdyaWQge1xuICAgICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgICBkaXYucm93IHtcbiAgICAgICAgJjpob3ZlciB7XG4gICAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogI2NjYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuYDsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/ReactParallelCoordinates.js\n");

/***/ }),

/***/ "./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var content = __webpack_require__(/*! !../../../../../css-loader??ref--7-1!./d3.parcoords.css */ \"./node_modules/css-loader/index.js?!./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\");\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(/*! ../../../../../style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\")(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJzZXQtdWkvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9lc20vdmVuZG9yL3BhcmNvb3Jkcy9kMy5wYXJjb29yZHMuY3NzP2QyYzQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzPz9yZWYtLTctMSEuL2QzLnBhcmNvb3Jkcy5jc3NcIik7XG5cbmlmICh0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIHtcbiAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xufVxuXG52YXIgb3B0aW9ucyA9IHt9XG5cbm9wdGlvbnMuaW5zZXJ0ID0gXCJoZWFkXCI7XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi8uLi9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcblxuaWYgKGNvbnRlbnQubG9jYWxzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG59XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\n");

/***/ }),

/***/ "./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.js":
/*!*****************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.js ***!
  \*****************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* [LICENSE TBD] */\n\n/* eslint-disable */\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (config) {\n  var __ = {\n    data: [],\n    highlighted: [],\n    dimensions: [],\n    dimensionTitles: {},\n    dimensionTitleRotation: 0,\n    types: {},\n    brushed: false,\n    brushedColor: null,\n    alphaOnBrushed: 0.0,\n    mode: 'default',\n    rate: 20,\n    width: 600,\n    height: 300,\n    margin: {\n      top: 24,\n      right: 0,\n      bottom: 12,\n      left: 0\n    },\n    nullValueSeparator: 'undefined',\n    // set to \"top\" or \"bottom\"\n    nullValueSeparatorPadding: {\n      top: 8,\n      right: 0,\n      bottom: 8,\n      left: 0\n    },\n    color: '#069',\n    composite: 'source-over',\n    alpha: 0.7,\n    bundlingStrength: 0.5,\n    bundleDimension: null,\n    smoothness: 0.0,\n    showControlPoints: false,\n    hideAxis: []\n  };\n  extend(__, config);\n\n  var pc = function (selection) {\n    selection = pc.selection = d3.select(selection);\n    __.width = selection[0][0].clientWidth;\n    __.height = selection[0][0].clientHeight; // canvas data layers\n\n    ['marks', 'foreground', 'brushed', 'highlight'].forEach(function (layer) {\n      canvas[layer] = selection.append('canvas').attr('class', layer)[0][0];\n      ctx[layer] = canvas[layer].getContext('2d');\n    }); // svg tick and brush layers\n\n    pc.svg = selection.append('svg').attr('width', __.width).attr('height', __.height).append('svg:g').attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')');\n    return pc;\n  };\n\n  var events = d3.dispatch.apply(this, ['render', 'resize', 'highlight', 'brush', 'brushend', 'axesreorder'].concat(d3.keys(__))),\n      w = function () {\n    return __.width - __.margin.right - __.margin.left;\n  },\n      h = function () {\n    return __.height - __.margin.top - __.margin.bottom;\n  },\n      flags = {\n    brushable: false,\n    reorderable: false,\n    axes: false,\n    interactive: false,\n    debug: false\n  },\n      xscale = d3.scale.ordinal(),\n      yscale = {},\n      dragging = {},\n      line = d3.svg.line(),\n      axis = d3.svg.axis().orient('left').ticks(5),\n      g,\n      // groups for axes, brushes\n  ctx = {},\n      canvas = {},\n      clusterCentroids = []; // side effects for setters\n\n\n  var side_effects = d3.dispatch.apply(this, d3.keys(__)).on('composite', function (d) {\n    ctx.foreground.globalCompositeOperation = d.value;\n    ctx.brushed.globalCompositeOperation = d.value;\n  }).on('alpha', function (d) {\n    ctx.foreground.globalAlpha = d.value;\n    ctx.brushed.globalAlpha = d.value;\n  }).on('brushedColor', function (d) {\n    ctx.brushed.strokeStyle = d.value;\n  }).on('width', function (d) {\n    pc.resize();\n  }).on('height', function (d) {\n    pc.resize();\n  }).on('margin', function (d) {\n    pc.resize();\n  }).on('rate', function (d) {\n    brushedQueue.rate(d.value);\n    foregroundQueue.rate(d.value);\n  }).on('dimensions', function (d) {\n    xscale.domain(__.dimensions);\n\n    if (flags.interactive) {\n      pc.render().updateAxes();\n    }\n  }).on('bundleDimension', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    if (typeof d.value === 'number') {\n      if (d.value < __.dimensions.length) {\n        __.bundleDimension = __.dimensions[d.value];\n      } else if (d.value < __.hideAxis.length) {\n        __.bundleDimension = __.hideAxis[d.value];\n      }\n    } else {\n      __.bundleDimension = d.value;\n    }\n\n    __.clusterCentroids = compute_cluster_centroids(__.bundleDimension);\n  }).on('hideAxis', function (d) {\n    if (!__.dimensions.length) pc.detectDimensions();\n    pc.dimensions(without(__.dimensions, d.value));\n  }); // expose the state of the chart\n\n  pc.state = __;\n  pc.flags = flags; // create getter/setters\n\n  getset(pc, __, events); // expose events\n\n  d3.rebind(pc, events, 'on'); // getter/setter with event firing\n\n  function getset(obj, state, events) {\n    d3.keys(state).forEach(function (key) {\n      obj[key] = function (x) {\n        if (!arguments.length) {\n          return state[key];\n        }\n\n        var old = state[key];\n        state[key] = x;\n        side_effects[key].call(pc, {\n          value: x,\n          previous: old\n        });\n        events[key].call(pc, {\n          value: x,\n          previous: old\n        });\n        return obj;\n      };\n    });\n  }\n\n  function extend(target, source) {\n    for (var key in source) {\n      target[key] = source[key];\n    }\n\n    return target;\n  }\n\n  function without(arr, item) {\n    return arr.filter(function (elem) {\n      return item.indexOf(elem) === -1;\n    });\n  }\n  /** adjusts an axis' default range [h()+1, 1] if a NullValueSeparator is set */\n\n\n  function getRange() {\n    if (__.nullValueSeparator == 'bottom') {\n      return [h() + 1 - __.nullValueSeparatorPadding.bottom - __.nullValueSeparatorPadding.top, 1];\n    } else if (__.nullValueSeparator == 'top') {\n      return [h() + 1, 1 + __.nullValueSeparatorPadding.bottom + __.nullValueSeparatorPadding.top];\n    }\n\n    return [h() + 1, 1];\n  }\n\n  pc.autoscale = function () {\n    // yscale\n    var defaultScales = {\n      date: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return d[k] ? d[k].getTime() : null;\n        }); // special case if single value\n\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.time.scale().domain(extent).range(getRange());\n      },\n      number: function (k) {\n        var extent = d3.extent(__.data, function (d) {\n          return +d[k];\n        }); // special case if single value\n\n        if (extent[0] === extent[1]) {\n          return d3.scale.ordinal().domain([extent[0]]).rangePoints(getRange());\n        }\n\n        return d3.scale.linear().domain(extent).range(getRange());\n      },\n      string: function (k) {\n        var counts = {},\n            domain = []; // Let's get the count for each value so that we can sort the domain based\n        // on the number of items for each value.\n\n        __.data.map(function (p) {\n          if (p[k] === undefined && __.nullValueSeparator !== 'undefined') {\n            return; // null values will be drawn beyond the horizontal null value separator!\n          }\n\n          if (counts[p[k]] === undefined) {\n            counts[p[k]] = 1;\n          } else {\n            counts[p[k]] = counts[p[k]] + 1;\n          }\n        });\n\n        domain = Object.getOwnPropertyNames(counts).sort(function (a, b) {\n          return counts[a] - counts[b];\n        });\n        return d3.scale.ordinal().domain(domain).rangePoints(getRange());\n      }\n    };\n\n    __.dimensions.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    });\n\n    __.hideAxis.forEach(function (k) {\n      yscale[k] = defaultScales[__.types[k]](k);\n    }); // xscale\n\n\n    xscale.rangePoints([0, w()], 1); // canvas sizes\n\n    pc.selection.selectAll('canvas').style('margin-top', __.margin.top + 'px').style('margin-left', __.margin.left + 'px').attr('width', w() + 2).attr('height', h() + 2); // default styles, needs to be set when canvas width changes\n\n    ctx.foreground.strokeStyle = __.color;\n    ctx.foreground.lineWidth = 1.4;\n    ctx.foreground.globalCompositeOperation = __.composite;\n    ctx.foreground.globalAlpha = __.alpha;\n    ctx.brushed.strokeStyle = __.brushedColor;\n    ctx.brushed.lineWidth = 1.4;\n    ctx.brushed.globalCompositeOperation = __.composite;\n    ctx.brushed.globalAlpha = __.alpha;\n    ctx.highlight.lineWidth = 3;\n    return this;\n  };\n\n  pc.scale = function (d, domain) {\n    yscale[d].domain(domain);\n    return this;\n  };\n\n  pc.flip = function (d) {\n    //yscale[d].domain().reverse();         // does not work\n    yscale[d].domain(yscale[d].domain().reverse()); // works\n\n    return this;\n  };\n\n  pc.commonScale = function (global, type) {\n    var t = type || 'number';\n\n    if (typeof global === 'undefined') {\n      global = true;\n    } // scales of the same type\n\n\n    var scales = __.dimensions.concat(__.hideAxis).filter(function (p) {\n      return __.types[p] == t;\n    });\n\n    if (global) {\n      var extent = d3.extent(scales.map(function (p, i) {\n        return yscale[p].domain();\n      }).reduce(function (a, b) {\n        return a.concat(b);\n      }));\n      scales.forEach(function (d) {\n        yscale[d].domain(extent);\n      });\n    } else {\n      scales.forEach(function (k) {\n        yscale[k].domain(d3.extent(__.data, function (d) {\n          return +d[k];\n        }));\n      });\n    } // update centroids\n\n\n    if (__.bundleDimension !== null) {\n      pc.bundleDimension(__.bundleDimension);\n    }\n\n    return this;\n  };\n\n  pc.detectDimensions = function () {\n    pc.types(pc.detectDimensionTypes(__.data));\n    pc.dimensions(d3.keys(pc.types()));\n    return this;\n  }; // a better \"typeof\" from this post: http://stackoverflow.com/questions/7390426/better-way-to-get-type-of-a-javascript-variable\n\n\n  pc.toType = function (v) {\n    return {}.toString.call(v).match(/\\s([a-zA-Z]+)/)[1].toLowerCase();\n  }; // try to coerce to number before returning type\n\n\n  pc.toTypeCoerceNumbers = function (v) {\n    if (parseFloat(v) == v && v != null) {\n      return 'number';\n    }\n\n    return pc.toType(v);\n  }; // attempt to determine types of each dimension based on first row of data\n\n\n  pc.detectDimensionTypes = function (data) {\n    var types = {};\n    d3.keys(data[0]).forEach(function (col) {\n      types[col] = pc.toTypeCoerceNumbers(data[0][col]);\n    });\n    return types;\n  };\n\n  pc.render = function () {\n    // try to autodetect dimensions and create scales\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.render[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  pc.renderBrushed = function () {\n    if (!__.dimensions.length) pc.detectDimensions();\n    if (!(__.dimensions[0] in yscale)) pc.autoscale();\n\n    pc.renderBrushed[__.mode]();\n\n    events.render.call(this);\n    return this;\n  };\n\n  function isBrushed() {\n    if (__.brushed && __.brushed.length !== __.data.length) return true;\n    var object = brush.currentMode().brushState();\n\n    for (var key in object) {\n      if (object.hasOwnProperty(key)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  pc.render.default = function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n    pc.renderBrushed.default();\n\n    __.data.forEach(path_foreground);\n  };\n\n  var foregroundQueue = d3.renderQueue(path_foreground).rate(50).clear(function () {\n    pc.clear('foreground');\n    pc.clear('highlight');\n  });\n\n  pc.render.queue = function () {\n    pc.renderBrushed.queue();\n    foregroundQueue(__.data);\n  };\n\n  pc.renderBrushed.default = function () {\n    pc.clear('brushed');\n\n    if (isBrushed()) {\n      __.brushed.forEach(path_brushed);\n    }\n  };\n\n  var brushedQueue = d3.renderQueue(path_brushed).rate(50).clear(function () {\n    pc.clear('brushed');\n  });\n\n  pc.renderBrushed.queue = function () {\n    if (isBrushed()) {\n      brushedQueue(__.brushed);\n    } else {\n      brushedQueue([]); // This is needed to clear the currently brushed items\n    }\n  };\n\n  function compute_cluster_centroids(d) {\n    var clusterCentroids = d3.map();\n    var clusterCounts = d3.map(); // determine clusterCounts\n\n    __.data.forEach(function (row) {\n      var scaled = yscale[d](row[d]);\n\n      if (!clusterCounts.has(scaled)) {\n        clusterCounts.set(scaled, 0);\n      }\n\n      var count = clusterCounts.get(scaled);\n      clusterCounts.set(scaled, count + 1);\n    });\n\n    __.data.forEach(function (row) {\n      __.dimensions.map(function (p, i) {\n        var scaled = yscale[d](row[d]);\n\n        if (!clusterCentroids.has(scaled)) {\n          var map = d3.map();\n          clusterCentroids.set(scaled, map);\n        }\n\n        if (!clusterCentroids.get(scaled).has(p)) {\n          clusterCentroids.get(scaled).set(p, 0);\n        }\n\n        var value = clusterCentroids.get(scaled).get(p);\n        value += yscale[p](row[p]) / clusterCounts.get(scaled);\n        clusterCentroids.get(scaled).set(p, value);\n      });\n    });\n\n    return clusterCentroids;\n  }\n\n  function compute_centroids(row) {\n    var centroids = [];\n    var p = __.dimensions;\n    var cols = p.length;\n    var a = 0.5; // center between axes\n\n    for (var i = 0; i < cols; ++i) {\n      // centroids on 'real' axes\n      var x = position(p[i]);\n      var y = yscale[p[i]](row[p[i]]);\n      centroids.push($V([x, y])); // centroids on 'virtual' axes\n\n      if (i < cols - 1) {\n        var cx = x + a * (position(p[i + 1]) - x);\n        var cy = y + a * (yscale[p[i + 1]](row[p[i + 1]]) - y);\n\n        if (__.bundleDimension !== null) {\n          var leftCentroid = __.clusterCentroids.get(yscale[__.bundleDimension](row[__.bundleDimension])).get(p[i]);\n\n          var rightCentroid = __.clusterCentroids.get(yscale[__.bundleDimension](row[__.bundleDimension])).get(p[i + 1]);\n\n          var centroid = 0.5 * (leftCentroid + rightCentroid);\n          cy = centroid + (1 - __.bundlingStrength) * (cy - centroid);\n        }\n\n        centroids.push($V([cx, cy]));\n      }\n    }\n\n    return centroids;\n  }\n\n  function compute_control_points(centroids) {\n    var cols = centroids.length;\n    var a = __.smoothness;\n    var cps = [];\n    cps.push(centroids[0]);\n    cps.push($V([centroids[0].e(1) + a * 2 * (centroids[1].e(1) - centroids[0].e(1)), centroids[0].e(2)]));\n\n    for (var col = 1; col < cols - 1; ++col) {\n      var mid = centroids[col];\n      var left = centroids[col - 1];\n      var right = centroids[col + 1];\n      var diff = left.subtract(right);\n      cps.push(mid.add(diff.x(a)));\n      cps.push(mid);\n      cps.push(mid.subtract(diff.x(a)));\n    }\n\n    cps.push($V([centroids[cols - 1].e(1) + a * 2 * (centroids[cols - 2].e(1) - centroids[cols - 1].e(1)), centroids[cols - 1].e(2)]));\n    cps.push(centroids[cols - 1]);\n    return cps;\n  }\n\n  pc.shadows = function () {\n    flags.shadows = true;\n    pc.alphaOnBrushed(0.1);\n    pc.render();\n    return this;\n  }; // draw dots with radius r on the axis line where data intersects\n\n\n  pc.axisDots = function (r) {\n    var r = r || 0.1;\n    var ctx = pc.ctx.marks;\n    var startAngle = 0;\n    var endAngle = 2 * Math.PI;\n    ctx.globalAlpha = d3.min([1 / Math.pow(__.data.length, 1 / 2), 1]);\n\n    __.data.forEach(function (d) {\n      __.dimensions.map(function (p, i) {\n        ctx.beginPath();\n        ctx.arc(position(p), yscale[p](d[p]), r, startAngle, endAngle);\n        ctx.stroke();\n        ctx.fill();\n      });\n    });\n\n    return this;\n  }; // draw single cubic bezier curve\n\n\n  function single_curve(d, ctx) {\n    var centroids = compute_centroids(d);\n    var cps = compute_control_points(centroids);\n    ctx.moveTo(cps[0].e(1), cps[0].e(2));\n\n    for (var i = 1; i < cps.length; i += 3) {\n      if (__.showControlPoints) {\n        for (var j = 0; j < 3; j += 1) {\n          ctx.fillRect(cps[i + j].e(1), cps[i + j].e(2), 2, 2);\n        }\n      }\n\n      ctx.bezierCurveTo(cps[i].e(1), cps[i].e(2), cps[i + 1].e(1), cps[i + 1].e(2), cps[i + 2].e(1), cps[i + 2].e(2));\n    }\n  } // draw single polyline\n\n\n  function color_path(d, ctx) {\n    ctx.beginPath();\n\n    if (__.bundleDimension !== null && __.bundlingStrength > 0 || __.smoothness > 0) {\n      single_curve(d, ctx);\n    } else {\n      single_path(d, ctx);\n    }\n\n    ctx.stroke();\n  } // draw many polylines of the same color\n\n\n  function paths(data, ctx) {\n    ctx.clearRect(-1, -1, w() + 2, h() + 2);\n    ctx.beginPath();\n    data.forEach(function (d) {\n      if (__.bundleDimension !== null && __.bundlingStrength > 0 || __.smoothness > 0) {\n        single_curve(d, ctx);\n      } else {\n        single_path(d, ctx);\n      }\n    });\n    ctx.stroke();\n  } // returns the y-position just beyond the separating null value line\n\n\n  function getNullPosition() {\n    if (__.nullValueSeparator == 'bottom') {\n      return h() + 1;\n    } else if (__.nullValueSeparator == 'top') {\n      return 1;\n    } else {\n      console.log(\"A value is NULL, but nullValueSeparator is not set; set it to 'bottom' or 'top'.\");\n    }\n\n    return h() + 1;\n  }\n\n  function single_path(d, ctx) {\n    __.dimensions.map(function (p, i) {\n      if (i == 0) {\n        ctx.moveTo(position(p), typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n      } else {\n        ctx.lineTo(position(p), typeof d[p] == 'undefined' ? getNullPosition() : yscale[p](d[p]));\n      }\n    });\n  }\n\n  function path_brushed(d, i) {\n    if (__.brushedColor !== null) {\n      ctx.brushed.strokeStyle = d3.functor(__.brushedColor)(d, i);\n    } else {\n      ctx.brushed.strokeStyle = d3.functor(__.color)(d, i);\n    }\n\n    return color_path(d, ctx.brushed);\n  }\n\n  function path_foreground(d, i) {\n    ctx.foreground.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.foreground);\n  }\n\n  function path_highlight(d, i) {\n    ctx.highlight.strokeStyle = d3.functor(__.color)(d, i);\n    return color_path(d, ctx.highlight);\n  }\n\n  pc.clear = function (layer) {\n    ctx[layer].clearRect(0, 0, w() + 2, h() + 2); // This will make sure that the foreground items are transparent\n    // without the need for changing the opacity style of the foreground canvas\n    // as this would stop the css styling from working\n\n    if (layer === 'brushed' && isBrushed()) {\n      ctx.brushed.fillStyle = pc.selection.style('background-color');\n      ctx.brushed.globalAlpha = 1 - __.alphaOnBrushed;\n      ctx.brushed.fillRect(0, 0, w() + 2, h() + 2);\n      ctx.brushed.globalAlpha = __.alpha;\n    }\n\n    return this;\n  };\n\n  d3.rebind(pc, axis, 'ticks', 'orient', 'tickValues', 'tickSubdivide', 'tickSize', 'tickPadding', 'tickFormat');\n\n  function flipAxisAndUpdatePCP(dimension) {\n    var g = pc.svg.selectAll('.dimension');\n    pc.flip(dimension);\n    d3.select(this.parentElement).transition().duration(1100).call(axis.scale(yscale[dimension]));\n    pc.render();\n  }\n\n  function rotateLabels() {\n    var delta = d3.event.deltaY;\n    delta = delta < 0 ? -5 : delta;\n    delta = delta > 0 ? 5 : delta;\n    __.dimensionTitleRotation += delta;\n    pc.svg.selectAll('text.label').attr('transform', 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')');\n    d3.event.preventDefault();\n  }\n\n  function dimensionLabels(d) {\n    return d in __.dimensionTitles ? __.dimensionTitles[d] : d; // dimension display names\n  }\n\n  pc.createAxes = function () {\n    if (g) pc.removeAxes(); // Add a group element for each dimension.\n\n    g = pc.svg.selectAll('.dimension').data(__.dimensions, function (d) {\n      return d;\n    }).enter().append('svg:g').attr('class', 'dimension').attr('transform', function (d) {\n      return 'translate(' + xscale(d) + ')';\n    }); // Add an axis and title.\n\n    g.append('svg:g').attr('class', 'axis').attr('transform', 'translate(0,0)').each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).append('svg:text').attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label'\n    }).text(dimensionLabels).on('dblclick', flipAxisAndUpdatePCP).on('wheel', rotateLabels);\n\n    if (__.nullValueSeparator == 'top') {\n      pc.svg.append('line').attr('x1', 0).attr('y1', 1 + __.nullValueSeparatorPadding.top).attr('x2', w()).attr('y2', 1 + __.nullValueSeparatorPadding.top).attr('stroke-width', 1).attr('stroke', '#777').attr('fill', 'none').attr('shape-rendering', 'crispEdges');\n    } else if (__.nullValueSeparator == 'bottom') {\n      pc.svg.append('line').attr('x1', 0).attr('y1', h() + 1 - __.nullValueSeparatorPadding.bottom).attr('x2', w()).attr('y2', h() + 1 - __.nullValueSeparatorPadding.bottom).attr('stroke-width', 1).attr('stroke', '#777').attr('fill', 'none').attr('shape-rendering', 'crispEdges');\n    }\n\n    flags.axes = true;\n    return this;\n  };\n\n  pc.removeAxes = function () {\n    g.remove();\n    return this;\n  };\n\n  pc.updateAxes = function () {\n    var g_data = pc.svg.selectAll('.dimension').data(__.dimensions); // Enter\n\n    g_data.enter().append('svg:g').attr('class', 'dimension').attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).style('opacity', 0).append('svg:g').attr('class', 'axis').attr('transform', 'translate(0,0)').each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    }).append('svg:text').attr({\n      'text-anchor': 'middle',\n      y: 0,\n      transform: 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')',\n      x: 0,\n      class: 'label'\n    }).text(dimensionLabels).on('dblclick', flipAxisAndUpdatePCP).on('wheel', rotateLabels); // Update\n\n    g_data.attr('opacity', 0);\n    g_data.select('.axis').transition().duration(1100).each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n    g_data.select('.label').transition().duration(1100).text(dimensionLabels).attr('transform', 'translate(0,-5) rotate(' + __.dimensionTitleRotation + ')'); // Exit\n\n    g_data.exit().remove();\n    g = pc.svg.selectAll('.dimension');\n    g.transition().duration(1100).attr('transform', function (p) {\n      return 'translate(' + position(p) + ')';\n    }).style('opacity', 1);\n    pc.svg.selectAll('.axis').transition().duration(1100).each(function (d) {\n      d3.select(this).call(axis.scale(yscale[d]));\n    });\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n\n    if (pc.brushMode() !== 'None') {\n      var mode = pc.brushMode();\n      pc.brushMode('None');\n      pc.brushMode(mode);\n    }\n\n    return this;\n  }; // Jason Davies, http://bl.ocks.org/1341281\n\n\n  pc.reorderable = function () {\n    if (!g) pc.createAxes();\n    g.style('cursor', 'move').call(d3.behavior.drag().on('dragstart', function (d) {\n      dragging[d] = this.__origin__ = xscale(d);\n    }).on('drag', function (d) {\n      dragging[d] = Math.min(w(), Math.max(0, this.__origin__ += d3.event.dx));\n\n      __.dimensions.sort(function (a, b) {\n        return position(a) - position(b);\n      });\n\n      xscale.domain(__.dimensions);\n      pc.render();\n      g.attr('transform', function (d) {\n        return 'translate(' + position(d) + ')';\n      });\n    }).on('dragend', function (d) {\n      // Let's see if the order has changed and send out an event if so.\n      var i = 0,\n          j = __.dimensions.indexOf(d),\n          elem = this,\n          parent = this.parentElement;\n\n      while ((elem = elem.previousElementSibling) != null) ++i;\n\n      if (i !== j) {\n        events.axesreorder.call(pc, __.dimensions); // We now also want to reorder the actual dom elements that represent\n        // the axes. That is, the g.dimension elements. If we don't do this,\n        // we get a weird and confusing transition when updateAxes is called.\n        // This is due to the fact that, initially the nth g.dimension element\n        // represents the nth axis. However, after a manual reordering,\n        // without reordering the dom elements, the nth dom elements no longer\n        // necessarily represents the nth axis.\n        //\n        // i is the original index of the dom element\n        // j is the new index of the dom element\n\n        if (i > j) {\n          // Element moved left\n          parent.insertBefore(this, parent.children[j - 1]);\n        } else {\n          // Element moved right\n          if (j + 1 < parent.children.length) {\n            parent.insertBefore(this, parent.children[j + 1]);\n          } else {\n            parent.appendChild(this);\n          }\n        }\n      }\n\n      delete this.__origin__;\n      delete dragging[d];\n      d3.select(this).transition().attr('transform', 'translate(' + xscale(d) + ')');\n      pc.render();\n    }));\n    flags.reorderable = true;\n    return this;\n  }; // Reorder dimensions, such that the highest value (visually) is on the left and\n  // the lowest on the right. Visual values are determined by the data values in\n  // the given row.\n\n\n  pc.reorder = function (rowdata) {\n    var dims = __.dimensions.slice(0);\n\n    __.dimensions.sort(function (a, b) {\n      var pixelDifference = yscale[a](rowdata[a]) - yscale[b](rowdata[b]); // Array.sort is not necessarily stable, this means that if pixelDifference is zero\n      // the ordering of dimensions might change unexpectedly. This is solved by sorting on\n      // variable name in that case.\n\n      if (pixelDifference === 0) {\n        return a.localeCompare(b);\n      } // else\n\n\n      return pixelDifference;\n    }); // NOTE: this is relatively cheap given that:\n    // number of dimensions < number of data items\n    // Thus we check equality of order to prevent rerendering when this is the case.\n\n\n    var reordered = false;\n    dims.some(function (val, index) {\n      reordered = val !== __.dimensions[index];\n      return reordered;\n    });\n\n    if (reordered) {\n      xscale.domain(__.dimensions);\n\n      var highlighted = __.highlighted.slice(0);\n\n      pc.unhighlight();\n      g.transition().duration(1500).attr('transform', function (d) {\n        return 'translate(' + xscale(d) + ')';\n      });\n      pc.render(); // pc.highlight() does not check whether highlighted is length zero, so we do that here.\n\n      if (highlighted.length !== 0) {\n        pc.highlight(highlighted);\n      }\n    }\n  }; // pairs of adjacent dimensions\n\n\n  pc.adjacent_pairs = function (arr) {\n    var ret = [];\n\n    for (var i = 0; i < arr.length - 1; i += 1) {\n      ret.push([arr[i], arr[i + 1]]);\n    }\n\n    return ret;\n  };\n\n  var brush = {\n    modes: {\n      None: {\n        install: function (pc) {},\n        // Nothing to be done.\n        uninstall: function (pc) {},\n        // Nothing to be done.\n        selected: function () {\n          return [];\n        },\n        // Nothing to return\n        brushState: function () {\n          return {};\n        }\n      }\n    },\n    mode: 'None',\n    predicate: 'AND',\n    currentMode: function () {\n      return this.modes[this.mode];\n    }\n  }; // This function can be used for 'live' updates of brushes. That is, during the\n  // specification of a brush, this method can be called to update the view.\n  //\n  // @param newSelection - The new set of data items that is currently contained\n  //                       by the brushes\n\n  function brushUpdated(newSelection) {\n    __.brushed = newSelection;\n    events.brush.call(pc, __.brushed);\n    pc.renderBrushed();\n  }\n\n  function brushPredicate(predicate) {\n    if (!arguments.length) {\n      return brush.predicate;\n    }\n\n    predicate = String(predicate).toUpperCase();\n\n    if (predicate !== 'AND' && predicate !== 'OR') {\n      throw 'Invalid predicate ' + predicate;\n    }\n\n    brush.predicate = predicate;\n    __.brushed = brush.currentMode().selected();\n    pc.renderBrushed();\n    return pc;\n  }\n\n  pc.brushModes = function () {\n    return Object.getOwnPropertyNames(brush.modes);\n  };\n\n  pc.brushMode = function (mode) {\n    if (arguments.length === 0) {\n      return brush.mode;\n    }\n\n    if (pc.brushModes().indexOf(mode) === -1) {\n      throw 'pc.brushmode: Unsupported brush mode: ' + mode;\n    } // Make sure that we don't trigger unnecessary events by checking if the mode\n    // actually changes.\n\n\n    if (mode !== brush.mode) {\n      // When changing brush modes, the first thing we need to do is clearing any\n      // brushes from the current mode, if any.\n      if (brush.mode !== 'None') {\n        pc.brushReset();\n      } // Next, we need to 'uninstall' the current brushMode.\n\n\n      brush.modes[brush.mode].uninstall(pc); // Finally, we can install the requested one.\n\n      brush.mode = mode;\n      brush.modes[brush.mode].install();\n\n      if (mode === 'None') {\n        delete pc.brushPredicate;\n      } else {\n        pc.brushPredicate = brushPredicate;\n      }\n    }\n\n    return pc;\n  }; // brush mode: 1D-Axes\n\n\n  (function () {\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    } // data within extents\n\n\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n          extents = actives.map(function (p) {\n        return brushes[p].extent();\n      }); // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n\n\n      if (actives.length === 0) return __.data; // test if within range\n\n      var within = {\n        date: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return extents[dimension][0] <= yscale[p](d[p]) && yscale[p](d[p]) <= extents[dimension][1];\n          } else {\n            return extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1];\n          }\n        },\n        number: function (d, p, dimension) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return extents[dimension][0] <= yscale[p](d[p]) && yscale[p](d[p]) <= extents[dimension][1];\n          } else {\n            return extents[dimension][0] <= d[p] && d[p] <= extents[dimension][1];\n          }\n        },\n        string: function (d, p, dimension) {\n          return extents[dimension][0] <= yscale[p](d[p]) && yscale[p](d[p]) <= extents[dimension][1];\n        }\n      };\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return within[__.types[p]](d, p, dimension);\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents(extents) {\n      if (typeof extents === 'undefined') {\n        var extents = {};\n\n        __.dimensions.forEach(function (d) {\n          var brush = brushes[d];\n\n          if (brush !== undefined && !brush.empty()) {\n            var extent = brush.extent();\n            extent.sort(d3.ascending);\n            extents[d] = extent;\n          }\n        });\n\n        return extents;\n      } else {\n        //first get all the brush selections\n        var brushSelections = {};\n        g.selectAll('.brush').each(function (d) {\n          brushSelections[d] = d3.select(this);\n        }); // loop over each dimension and update appropriately (if it was passed in through extents)\n\n        __.dimensions.forEach(function (d) {\n          if (extents[d] === undefined) {\n            return;\n          }\n\n          var brush = brushes[d];\n\n          if (brush !== undefined) {\n            //update the extent\n            brush.extent(extents[d]); //redraw the brush\n\n            brush(brushSelections[d]); //fire some events\n\n            brush.event(brushSelections[d]);\n          }\n        }); //redraw the chart\n\n\n        pc.renderBrushed();\n      }\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.brush();\n      brush.y(yscale[axis]).on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).on('brush', function () {\n        brushUpdated(selected());\n      }).on('brushend', function () {\n        events.brushend.call(pc, __.brushed);\n      });\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes(); // Add and store a brush for each axis.\n\n      g.append('svg:g').attr('class', 'brush').each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).selectAll('rect').style('visibility', null).attr('x', -15).attr('width', 30);\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents\n    };\n  })(); // brush mode: 2D-strums\n  // bl.ocks.org/syntagmatic/5441022\n\n\n  (function () {\n    var strums = {},\n        strumRect;\n\n    function drawStrum(strum, activePoint) {\n      var svg = pc.selection.select('svg').select('g#strums'),\n          id = strum.dims.i,\n          points = [strum.p1, strum.p2],\n          line = svg.selectAll('line#strum-' + id).data([strum]),\n          circles = svg.selectAll('circle#strum-' + id).data(points),\n          drag = d3.behavior.drag();\n      line.enter().append('line').attr('id', 'strum-' + id).attr('class', 'strum');\n      line.attr('x1', function (d) {\n        return d.p1[0];\n      }).attr('y1', function (d) {\n        return d.p1[1];\n      }).attr('x2', function (d) {\n        return d.p2[0];\n      }).attr('y2', function (d) {\n        return d.p2[1];\n      }).attr('stroke', 'black').attr('stroke-width', 2);\n      drag.on('drag', function (d, i) {\n        var ev = d3.event;\n        i = i + 1;\n        strum['p' + i][0] = Math.min(Math.max(strum.minX + 1, ev.x), strum.maxX);\n        strum['p' + i][1] = Math.min(Math.max(strum.minY, ev.y), strum.maxY);\n        drawStrum(strum, i - 1);\n      }).on('dragend', onDragEnd());\n      circles.enter().append('circle').attr('id', 'strum-' + id).attr('class', 'strum');\n      circles.attr('cx', function (d) {\n        return d[0];\n      }).attr('cy', function (d) {\n        return d[1];\n      }).attr('r', 5).style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = {\n        i: -1,\n        left: undefined,\n        right: undefined\n      };\n\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the sturm was started.\n      // This will determine the freedom of movement, because a strum can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n            dims,\n            strum;\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n        dims = dimensionsForPoint(p), strum = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h()\n        };\n        strums[dims.i] = strum;\n        strums.active = dims.i; // Make sure that the point is within the bounds\n\n        strum.p1[0] = Math.min(Math.max(strum.minX, p[0]), strum.maxX);\n        strum.p2 = strum.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n            strum = strums[strums.active]; // Make sure that the point is within the bounds\n\n        strum.p2[0] = Math.min(Math.max(strum.minX + 1, ev.x - __.margin.left), strum.maxX);\n        strum.p2[1] = Math.min(Math.max(strum.minY, ev.y - __.margin.top), strum.maxY);\n        drawStrum(strum, 1);\n      };\n    }\n\n    function containmentTest(strum, width) {\n      var p1 = [strum.p1[0] - strum.minX, strum.p1[1] - strum.minX],\n          p2 = [strum.p2[0] - strum.minX, strum.p2[1] - strum.minX],\n          m1 = 1 - width / p1[0],\n          b1 = p1[1] * (1 - m1),\n          m2 = 1 - width / p2[0],\n          b2 = p2[1] * (1 - m2); // test if point falls between lines\n\n      return function (p) {\n        var x = p[0],\n            y = p[1],\n            y1 = m1 * x + b1,\n            y2 = m2 * x + b2;\n\n        if (y > Math.min(y1, y2) && y < Math.max(y1, y2)) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(strums),\n          brushed = __.data; // Get the ids of the currently active strums.\n\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var strum = strums[id],\n            test = containmentTest(strum, strums.width(id)),\n            d1 = strum.dims.left,\n            d2 = strum.dims.right,\n            y1 = yscale[d1],\n            y2 = yscale[d2],\n            point = [y1(d[d1]) - strum.minX, y2(d[d2]) - strum.minX];\n        return test(point);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var strum = strums[strums.active],\n          svg = pc.selection.select('svg').select('g#strums');\n      delete strums[strums.active];\n      strums.active = undefined;\n      svg.selectAll('line#strum-' + strum.dims.i).remove();\n      svg.selectAll('circle#strum-' + strum.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n            strum = strums[strums.active]; // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n\n        if (strum && strum.p1[0] === strum.p2[0] && strum.p1[1] === strum.p2[1]) {\n          removeStrum(strums);\n        }\n\n        brushed = selected(strums);\n        strums.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(strums) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        });\n        ids.forEach(function (d) {\n          strums.active = d;\n          removeStrum(strums);\n        });\n        onDragEnd(strums)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag(); // Map of current strums. Strums are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n\n      strums.active = undefined; // Returns the width of the PC segment where currently a strum is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n\n      strums.width = function (id) {\n        var strum = strums[id];\n\n        if (strum === undefined) {\n          return undefined;\n        }\n\n        return strum.maxX - strum.minX;\n      };\n\n      pc.on('axesreorder.strums', function () {\n        var ids = Object.getOwnPropertyNames(strums).filter(function (d) {\n          return !isNaN(d);\n        }); // Checks if the first dimension is directly left of the second dimension.\n\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ? i + i < length && __.dimensions[i + 1] === second : false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some strums, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = strums[d].dims;\n            strums.active = d; // If the two dimensions of the current strum are not next to each other\n            // any more, than we'll need to remove the strum. Otherwise we keep it.\n\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(strums);\n            }\n          });\n          onDragEnd(strums)();\n        }\n      }); // Add a new svg group in which we draw the strums.\n\n      pc.selection.select('svg').append('g').attr('id', 'strums').attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')'); // Install the required brushReset function\n\n      pc.brushReset = brushReset(strums);\n      drag.on('dragstart', onDragStart(strums)).on('drag', onDrag(strums)).on('dragend', onDragEnd(strums)); // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n\n      strumRect = pc.selection.select('svg').insert('rect', 'g#strums').attr('id', 'strum-events').attr('x', __.margin.left).attr('y', __.margin.top).attr('width', w()).attr('height', h() + 2).style('opacity', 0).call(drag);\n    }\n\n    brush.modes['2D-strums'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#strums').remove();\n        pc.selection.select('svg').select('rect#strum-events').remove();\n        pc.on('axesreorder.strums', undefined);\n        delete pc.brushReset;\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return strums;\n      }\n    };\n  })(); // brush mode: 1D-Axes with multiple extents\n  // requires d3.svg.multibrush\n\n\n  (function () {\n    if (typeof d3.svg.multibrush !== 'function') {\n      return;\n    }\n\n    var brushes = {};\n\n    function is_brushed(p) {\n      return !brushes[p].empty();\n    } // data within extents\n\n\n    function selected() {\n      var actives = __.dimensions.filter(is_brushed),\n          extents = actives.map(function (p) {\n        return brushes[p].extent();\n      }); // We don't want to return the full data set when there are no axes brushed.\n      // Actually, when there are no axes brushed, by definition, no items are\n      // selected. So, let's avoid the filtering and just return false.\n      //if (actives.length === 0) return false;\n      // Resolves broken examples for now. They expect to get the full dataset back from empty brushes\n\n\n      if (actives.length === 0) return __.data; // test if within range\n\n      var within = {\n        date: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        number: function (d, p, dimension, b) {\n          if (typeof yscale[p].rangePoints === 'function') {\n            // if it is ordinal\n            return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n          } else {\n            return b[0] <= d[p] && d[p] <= b[1];\n          }\n        },\n        string: function (d, p, dimension, b) {\n          return b[0] <= yscale[p](d[p]) && yscale[p](d[p]) <= b[1];\n        }\n      };\n      return __.data.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return actives.every(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n\n          case 'OR':\n            return actives.some(function (p, dimension) {\n              return extents[dimension].some(function (b) {\n                return within[__.types[p]](d, p, dimension, b);\n              });\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function brushExtents() {\n      var extents = {};\n\n      __.dimensions.forEach(function (d) {\n        var brush = brushes[d];\n\n        if (brush !== undefined && !brush.empty()) {\n          var extent = brush.extent();\n          extents[d] = extent;\n        }\n      });\n\n      return extents;\n    }\n\n    function brushFor(axis) {\n      var brush = d3.svg.multibrush();\n      brush.y(yscale[axis]).on('brushstart', function () {\n        if (d3.event.sourceEvent !== null) {\n          d3.event.sourceEvent.stopPropagation();\n        }\n      }).on('brush', function () {\n        brushUpdated(selected());\n      }).on('brushend', function () {\n        // d3.svg.multibrush clears extents just before calling 'brushend'\n        // so we have to update here again.\n        // This fixes issue #103 for now, but should be changed in d3.svg.multibrush\n        // to avoid unnecessary computation.\n        brushUpdated(selected());\n        events.brushend.call(pc, __.brushed);\n      }).extentAdaption(function (selection) {\n        selection.style('visibility', null).attr('x', -15).attr('width', 30);\n      }).resizeAdaption(function (selection) {\n        selection.selectAll('rect').attr('x', -15).attr('width', 30);\n      });\n      brushes[axis] = brush;\n      return brush;\n    }\n\n    function brushReset(dimension) {\n      __.brushed = false;\n\n      if (g) {\n        g.selectAll('.brush').each(function (d) {\n          d3.select(this).call(brushes[d].clear());\n        });\n        pc.renderBrushed();\n      }\n\n      return this;\n    }\n\n    function install() {\n      if (!g) pc.createAxes(); // Add and store a brush for each axis.\n\n      g.append('svg:g').attr('class', 'brush').each(function (d) {\n        d3.select(this).call(brushFor(d));\n      }).selectAll('rect').style('visibility', null).attr('x', -15).attr('width', 30);\n      pc.brushExtents = brushExtents;\n      pc.brushReset = brushReset;\n      return pc;\n    }\n\n    brush.modes['1D-axes-multi'] = {\n      install: install,\n      uninstall: function () {\n        g.selectAll('.brush').remove();\n        brushes = {};\n        delete pc.brushExtents;\n        delete pc.brushReset;\n      },\n      selected: selected,\n      brushState: brushExtents\n    };\n  })(); // brush mode: angular\n  // code based on 2D.strums.js\n\n\n  (function () {\n    var arcs = {},\n        strumRect;\n\n    function drawStrum(arc, activePoint) {\n      var svg = pc.selection.select('svg').select('g#arcs'),\n          id = arc.dims.i,\n          points = [arc.p2, arc.p3],\n          line = svg.selectAll('line#arc-' + id).data([{\n        p1: arc.p1,\n        p2: arc.p2\n      }, {\n        p1: arc.p1,\n        p2: arc.p3\n      }]),\n          circles = svg.selectAll('circle#arc-' + id).data(points),\n          drag = d3.behavior.drag(),\n          path = svg.selectAll('path#arc-' + id).data([arc]);\n      path.enter().append('path').attr('id', 'arc-' + id).attr('class', 'arc').style('fill', 'orange').style('opacity', 0.5);\n      path.attr('d', arc.arc).attr('transform', 'translate(' + arc.p1[0] + ',' + arc.p1[1] + ')');\n      line.enter().append('line').attr('id', 'arc-' + id).attr('class', 'arc');\n      line.attr('x1', function (d) {\n        return d.p1[0];\n      }).attr('y1', function (d) {\n        return d.p1[1];\n      }).attr('x2', function (d) {\n        return d.p2[0];\n      }).attr('y2', function (d) {\n        return d.p2[1];\n      }).attr('stroke', 'black').attr('stroke-width', 2);\n      drag.on('drag', function (d, i) {\n        var ev = d3.event,\n            angle = 0;\n        i = i + 2;\n        arc['p' + i][0] = Math.min(Math.max(arc.minX + 1, ev.x), arc.maxX);\n        arc['p' + i][1] = Math.min(Math.max(arc.minY, ev.y), arc.maxY);\n        angle = i === 3 ? arcs.startAngle(id) : arcs.endAngle(id);\n\n        if (arc.startAngle < Math.PI && arc.endAngle < Math.PI && angle < Math.PI || arc.startAngle >= Math.PI && arc.endAngle >= Math.PI && angle >= Math.PI) {\n          if (i === 2) {\n            arc.endAngle = angle;\n            arc.arc.endAngle(angle);\n          } else if (i === 3) {\n            arc.startAngle = angle;\n            arc.arc.startAngle(angle);\n          }\n        }\n\n        drawStrum(arc, i - 2);\n      }).on('dragend', onDragEnd());\n      circles.enter().append('circle').attr('id', 'arc-' + id).attr('class', 'arc');\n      circles.attr('cx', function (d) {\n        return d[0];\n      }).attr('cy', function (d) {\n        return d[1];\n      }).attr('r', 5).style('opacity', function (d, i) {\n        return activePoint !== undefined && i === activePoint ? 0.8 : 0;\n      }).on('mouseover', function () {\n        d3.select(this).style('opacity', 0.8);\n      }).on('mouseout', function () {\n        d3.select(this).style('opacity', 0);\n      }).call(drag);\n    }\n\n    function dimensionsForPoint(p) {\n      var dims = {\n        i: -1,\n        left: undefined,\n        right: undefined\n      };\n\n      __.dimensions.some(function (dim, i) {\n        if (xscale(dim) < p[0]) {\n          var next = __.dimensions[i + 1];\n          dims.i = i;\n          dims.left = dim;\n          dims.right = next;\n          return false;\n        }\n\n        return true;\n      });\n\n      if (dims.left === undefined) {\n        // Event on the left side of the first axis.\n        dims.i = 0;\n        dims.left = __.dimensions[0];\n        dims.right = __.dimensions[1];\n      } else if (dims.right === undefined) {\n        // Event on the right side of the last axis\n        dims.i = __.dimensions.length - 1;\n        dims.right = dims.left;\n        dims.left = __.dimensions[__.dimensions.length - 2];\n      }\n\n      return dims;\n    }\n\n    function onDragStart() {\n      // First we need to determine between which two axes the arc was started.\n      // This will determine the freedom of movement, because a arc can\n      // logically only happen between two axes, so no movement outside these axes\n      // should be allowed.\n      return function () {\n        var p = d3.mouse(strumRect[0][0]),\n            dims,\n            arc;\n        p[0] = p[0] - __.margin.left;\n        p[1] = p[1] - __.margin.top;\n        dims = dimensionsForPoint(p), arc = {\n          p1: p,\n          dims: dims,\n          minX: xscale(dims.left),\n          maxX: xscale(dims.right),\n          minY: 0,\n          maxY: h(),\n          startAngle: undefined,\n          endAngle: undefined,\n          arc: d3.svg.arc().innerRadius(0)\n        };\n        arcs[dims.i] = arc;\n        arcs.active = dims.i; // Make sure that the point is within the bounds\n\n        arc.p1[0] = Math.min(Math.max(arc.minX, p[0]), arc.maxX);\n        arc.p2 = arc.p1.slice();\n        arc.p3 = arc.p1.slice();\n      };\n    }\n\n    function onDrag() {\n      return function () {\n        var ev = d3.event,\n            arc = arcs[arcs.active]; // Make sure that the point is within the bounds\n\n        arc.p2[0] = Math.min(Math.max(arc.minX + 1, ev.x - __.margin.left), arc.maxX);\n        arc.p2[1] = Math.min(Math.max(arc.minY, ev.y - __.margin.top), arc.maxY);\n        arc.p3 = arc.p2.slice();\n        drawStrum(arc, 1);\n      };\n    } // some helper functions\n\n\n    function hypothenuse(a, b) {\n      return Math.sqrt(a * a + b * b);\n    }\n\n    var rad = function () {\n      var c = Math.PI / 180;\n      return function (angle) {\n        return angle * c;\n      };\n    }();\n\n    var deg = function () {\n      var c = 180 / Math.PI;\n      return function (angle) {\n        return angle * c;\n      };\n    }(); // [0, 2*PI] -> [-PI/2, PI/2]\n\n\n    var signedAngle = function (angle) {\n      var ret = angle;\n\n      if (angle > Math.PI) {\n        ret = angle - 1.5 * Math.PI;\n        ret = angle - 1.5 * Math.PI;\n      } else {\n        ret = angle - 0.5 * Math.PI;\n        ret = angle - 0.5 * Math.PI;\n      }\n\n      return -ret;\n    };\n    /**\n     * angles are stored in radians from in [0, 2*PI], where 0 in 12 o'clock.\n     * However, one can only select lines from 0 to PI, so we compute the\n     * 'signed' angle, where 0 is the horizontal line (3 o'clock), and +/- PI/2\n     * are 12 and 6 o'clock respectively.\n     */\n\n\n    function containmentTest(arc) {\n      var startAngle = signedAngle(arc.startAngle);\n      var endAngle = signedAngle(arc.endAngle);\n\n      if (startAngle > endAngle) {\n        var tmp = startAngle;\n        startAngle = endAngle;\n        endAngle = tmp;\n      } // test if segment angle is contained in angle interval\n\n\n      return function (a) {\n        if (a >= startAngle && a <= endAngle) {\n          return true;\n        }\n\n        return false;\n      };\n    }\n\n    function selected() {\n      var ids = Object.getOwnPropertyNames(arcs),\n          brushed = __.data; // Get the ids of the currently active arcs.\n\n      ids = ids.filter(function (d) {\n        return !isNaN(d);\n      });\n\n      function crossesStrum(d, id) {\n        var arc = arcs[id],\n            test = containmentTest(arc),\n            d1 = arc.dims.left,\n            d2 = arc.dims.right,\n            y1 = yscale[d1],\n            y2 = yscale[d2],\n            a = arcs.width(id),\n            b = y1(d[d1]) - y2(d[d2]),\n            c = hypothenuse(a, b),\n            angle = Math.asin(b / c); // rad in [-PI/2, PI/2]\n\n        return test(angle);\n      }\n\n      if (ids.length === 0) {\n        return brushed;\n      }\n\n      return brushed.filter(function (d) {\n        switch (brush.predicate) {\n          case 'AND':\n            return ids.every(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          case 'OR':\n            return ids.some(function (id) {\n              return crossesStrum(d, id);\n            });\n\n          default:\n            throw 'Unknown brush predicate ' + __.brushPredicate;\n        }\n      });\n    }\n\n    function removeStrum() {\n      var arc = arcs[arcs.active],\n          svg = pc.selection.select('svg').select('g#arcs');\n      delete arcs[arcs.active];\n      arcs.active = undefined;\n      svg.selectAll('line#arc-' + arc.dims.i).remove();\n      svg.selectAll('circle#arc-' + arc.dims.i).remove();\n      svg.selectAll('path#arc-' + arc.dims.i).remove();\n    }\n\n    function onDragEnd() {\n      return function () {\n        var brushed = __.data,\n            arc = arcs[arcs.active]; // Okay, somewhat unexpected, but not totally unsurprising, a mousclick is\n        // considered a drag without move. So we have to deal with that case\n\n        if (arc && arc.p1[0] === arc.p2[0] && arc.p1[1] === arc.p2[1]) {\n          removeStrum(arcs);\n        }\n\n        if (arc) {\n          var angle = arcs.startAngle(arcs.active);\n          arc.startAngle = angle;\n          arc.endAngle = angle;\n          arc.arc.outerRadius(arcs.length(arcs.active)).startAngle(angle).endAngle(angle);\n        }\n\n        brushed = selected(arcs);\n        arcs.active = undefined;\n        __.brushed = brushed;\n        pc.renderBrushed();\n        events.brushend.call(pc, __.brushed);\n      };\n    }\n\n    function brushReset(arcs) {\n      return function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        });\n        ids.forEach(function (d) {\n          arcs.active = d;\n          removeStrum(arcs);\n        });\n        onDragEnd(arcs)();\n      };\n    }\n\n    function install() {\n      var drag = d3.behavior.drag(); // Map of current arcs. arcs are stored per segment of the PC. A segment,\n      // being the area between two axes. The left most area is indexed at 0.\n\n      arcs.active = undefined; // Returns the width of the PC segment where currently a arc is being\n      // placed. NOTE: even though they are evenly spaced in our current\n      // implementation, we keep for when non-even spaced segments are supported as\n      // well.\n\n      arcs.width = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        return arc.maxX - arc.minX;\n      }; // returns angles in [-PI/2, PI/2]\n\n\n      angle = function (p1, p2) {\n        var a = p1[0] - p2[0],\n            b = p1[1] - p2[1],\n            c = hypothenuse(a, b);\n        return Math.asin(b / c);\n      }; // returns angles in [0, 2 * PI]\n\n\n      arcs.endAngle = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p2),\n            uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p2[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.startAngle = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var sAngle = angle(arc.p1, arc.p3),\n            uAngle = -sAngle + Math.PI / 2;\n\n        if (arc.p1[0] > arc.p3[0]) {\n          uAngle = 2 * Math.PI - uAngle;\n        }\n\n        return uAngle;\n      };\n\n      arcs.length = function (id) {\n        var arc = arcs[id];\n\n        if (arc === undefined) {\n          return undefined;\n        }\n\n        var a = arc.p1[0] - arc.p2[0],\n            b = arc.p1[1] - arc.p2[1],\n            c = hypothenuse(a, b);\n        return c;\n      };\n\n      pc.on('axesreorder.arcs', function () {\n        var ids = Object.getOwnPropertyNames(arcs).filter(function (d) {\n          return !isNaN(d);\n        }); // Checks if the first dimension is directly left of the second dimension.\n\n        function consecutive(first, second) {\n          var length = __.dimensions.length;\n          return __.dimensions.some(function (d, i) {\n            return d === first ? i + i < length && __.dimensions[i + 1] === second : false;\n          });\n        }\n\n        if (ids.length > 0) {\n          // We have some arcs, which might need to be removed.\n          ids.forEach(function (d) {\n            var dims = arcs[d].dims;\n            arcs.active = d; // If the two dimensions of the current arc are not next to each other\n            // any more, than we'll need to remove the arc. Otherwise we keep it.\n\n            if (!consecutive(dims.left, dims.right)) {\n              removeStrum(arcs);\n            }\n          });\n          onDragEnd(arcs)();\n        }\n      }); // Add a new svg group in which we draw the arcs.\n\n      pc.selection.select('svg').append('g').attr('id', 'arcs').attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')'); // Install the required brushReset function\n\n      pc.brushReset = brushReset(arcs);\n      drag.on('dragstart', onDragStart(arcs)).on('drag', onDrag(arcs)).on('dragend', onDragEnd(arcs)); // NOTE: The styling needs to be done here and not in the css. This is because\n      //       for 1D brushing, the canvas layers should not listen to\n      //       pointer-events.\n\n      strumRect = pc.selection.select('svg').insert('rect', 'g#arcs').attr('id', 'arc-events').attr('x', __.margin.left).attr('y', __.margin.top).attr('width', w()).attr('height', h() + 2).style('opacity', 0).call(drag);\n    }\n\n    brush.modes['angular'] = {\n      install: install,\n      uninstall: function () {\n        pc.selection.select('svg').select('g#arcs').remove();\n        pc.selection.select('svg').select('rect#arc-events').remove();\n        pc.on('axesreorder.arcs', undefined);\n        delete pc.brushReset;\n        strumRect = undefined;\n      },\n      selected: selected,\n      brushState: function () {\n        return arcs;\n      }\n    };\n  })();\n\n  pc.interactive = function () {\n    flags.interactive = true;\n    return this;\n  }; // expose a few objects\n\n\n  pc.xscale = xscale;\n  pc.yscale = yscale;\n  pc.ctx = ctx;\n  pc.canvas = canvas;\n\n  pc.g = function () {\n    return g;\n  }; // rescale for height, width and margins\n  // TODO currently assumes chart is brushable, and destroys old brushes\n\n\n  pc.resize = function () {\n    // selection size\n    pc.selection.select('svg').attr('width', __.width).attr('height', __.height);\n    pc.svg.attr('transform', 'translate(' + __.margin.left + ',' + __.margin.top + ')'); // FIXME: the current brush state should pass through\n\n    if (flags.brushable) pc.brushReset(); // scales\n\n    pc.autoscale(); // axes, destroys old brushes.\n\n    if (g) pc.createAxes();\n    if (flags.brushable) pc.brushable();\n    if (flags.reorderable) pc.reorderable();\n    events.resize.call(this, {\n      width: __.width,\n      height: __.height,\n      margin: __.margin\n    });\n    return this;\n  }; // highlight an array of data\n\n\n  pc.highlight = function (data) {\n    if (arguments.length === 0) {\n      return __.highlighted;\n    }\n\n    __.highlighted = data;\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', true);\n    data.forEach(path_highlight);\n    events.highlight.call(this, data);\n    return this;\n  }; // clear highlighting\n\n\n  pc.unhighlight = function () {\n    __.highlighted = [];\n    pc.clear('highlight');\n    d3.selectAll([canvas.foreground, canvas.brushed]).classed('faded', false);\n    return this;\n  }; // calculate 2d intersection of line a->b with line c->d\n  // points are objects with x and y properties\n\n\n  pc.intersection = function (a, b, c, d) {\n    return {\n      x: ((a.x * b.y - a.y * b.x) * (c.x - d.x) - (a.x - b.x) * (c.x * d.y - c.y * d.x)) / ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x)),\n      y: ((a.x * b.y - a.y * b.x) * (c.y - d.y) - (a.y - b.y) * (c.x * d.y - c.y * d.x)) / ((a.x - b.x) * (c.y - d.y) - (a.y - b.y) * (c.x - d.x))\n    };\n  };\n\n  function position(d) {\n    var v = dragging[d];\n    return v == null ? xscale(d) : v;\n  }\n\n  pc.version = '0.7.0'; // this descriptive text should live with other introspective methods\n\n  pc.toString = function () {\n    return 'Parallel Coordinates: ' + __.dimensions.length + ' dimensions (' + d3.keys(__.data[0]).length + ' total) , ' + __.data.length + ' rows';\n  };\n\n  return pc;\n});\n\nd3.renderQueue = function (func) {\n  var _queue = [],\n      // data to be rendered\n  _rate = 10,\n      // number of calls per frame\n  _clear = function () {},\n      // clearing function\n  _i = 0; // current iteration\n\n\n  var rq = function (data) {\n    if (data) rq.data(data);\n    rq.invalidate();\n\n    _clear();\n\n    rq.render();\n  };\n\n  rq.render = function () {\n    _i = 0;\n    var valid = true;\n\n    rq.invalidate = function () {\n      valid = false;\n    };\n\n    function doFrame() {\n      if (!valid) return true;\n      if (_i > _queue.length) return true; // Typical d3 behavior is to pass a data item *and* its index. As the\n      // render queue splits the original data set, we'll have to be slightly\n      // more carefull about passing the correct index with the data item.\n\n      var end = Math.min(_i + _rate, _queue.length);\n\n      for (var i = _i; i < end; i += 1) {\n        func(_queue[i], i);\n      }\n\n      _i += _rate;\n    }\n\n    d3.timer(doFrame);\n  };\n\n  rq.data = function (data) {\n    rq.invalidate();\n    _queue = data.slice(0);\n    return rq;\n  };\n\n  rq.rate = function (value) {\n    if (!arguments.length) return _rate;\n    _rate = value;\n    return rq;\n  };\n\n  rq.remaining = function () {\n    return _queue.length - _i;\n  }; // clear the canvas\n\n\n  rq.clear = function (func) {\n    if (!arguments.length) {\n      _clear();\n\n      return rq;\n    }\n\n    _clear = func;\n    return rq;\n  };\n\n  rq.invalidate = function () {};\n\n  return rq;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcnNldC11aS9sZWdhY3ktcGx1Z2luLWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzL2VzbS92ZW5kb3IvcGFyY29vcmRzL2QzLnBhcmNvb3Jkcy5qcz8xNzJjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFtMSUNFTlNFIFRCRF0gKi9cblxuLyogZXNsaW50LWRpc2FibGUgKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIF9fID0ge1xuICAgIGRhdGE6IFtdLFxuICAgIGhpZ2hsaWdodGVkOiBbXSxcbiAgICBkaW1lbnNpb25zOiBbXSxcbiAgICBkaW1lbnNpb25UaXRsZXM6IHt9LFxuICAgIGRpbWVuc2lvblRpdGxlUm90YXRpb246IDAsXG4gICAgdHlwZXM6IHt9LFxuICAgIGJydXNoZWQ6IGZhbHNlLFxuICAgIGJydXNoZWRDb2xvcjogbnVsbCxcbiAgICBhbHBoYU9uQnJ1c2hlZDogMC4wLFxuICAgIG1vZGU6ICdkZWZhdWx0JyxcbiAgICByYXRlOiAyMCxcbiAgICB3aWR0aDogNjAwLFxuICAgIGhlaWdodDogMzAwLFxuICAgIG1hcmdpbjoge1xuICAgICAgdG9wOiAyNCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAxMixcbiAgICAgIGxlZnQ6IDBcbiAgICB9LFxuICAgIG51bGxWYWx1ZVNlcGFyYXRvcjogJ3VuZGVmaW5lZCcsXG4gICAgLy8gc2V0IHRvIFwidG9wXCIgb3IgXCJib3R0b21cIlxuICAgIG51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmc6IHtcbiAgICAgIHRvcDogOCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiA4LFxuICAgICAgbGVmdDogMFxuICAgIH0sXG4gICAgY29sb3I6ICcjMDY5JyxcbiAgICBjb21wb3NpdGU6ICdzb3VyY2Utb3ZlcicsXG4gICAgYWxwaGE6IDAuNyxcbiAgICBidW5kbGluZ1N0cmVuZ3RoOiAwLjUsXG4gICAgYnVuZGxlRGltZW5zaW9uOiBudWxsLFxuICAgIHNtb290aG5lc3M6IDAuMCxcbiAgICBzaG93Q29udHJvbFBvaW50czogZmFsc2UsXG4gICAgaGlkZUF4aXM6IFtdXG4gIH07XG4gIGV4dGVuZChfXywgY29uZmlnKTtcblxuICB2YXIgcGMgPSBmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgc2VsZWN0aW9uID0gcGMuc2VsZWN0aW9uID0gZDMuc2VsZWN0KHNlbGVjdGlvbik7XG4gICAgX18ud2lkdGggPSBzZWxlY3Rpb25bMF1bMF0uY2xpZW50V2lkdGg7XG4gICAgX18uaGVpZ2h0ID0gc2VsZWN0aW9uWzBdWzBdLmNsaWVudEhlaWdodDsgLy8gY2FudmFzIGRhdGEgbGF5ZXJzXG5cbiAgICBbJ21hcmtzJywgJ2ZvcmVncm91bmQnLCAnYnJ1c2hlZCcsICdoaWdobGlnaHQnXS5mb3JFYWNoKGZ1bmN0aW9uIChsYXllcikge1xuICAgICAgY2FudmFzW2xheWVyXSA9IHNlbGVjdGlvbi5hcHBlbmQoJ2NhbnZhcycpLmF0dHIoJ2NsYXNzJywgbGF5ZXIpWzBdWzBdO1xuICAgICAgY3R4W2xheWVyXSA9IGNhbnZhc1tsYXllcl0uZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB9KTsgLy8gc3ZnIHRpY2sgYW5kIGJydXNoIGxheWVyc1xuXG4gICAgcGMuc3ZnID0gc2VsZWN0aW9uLmFwcGVuZCgnc3ZnJykuYXR0cignd2lkdGgnLCBfXy53aWR0aCkuYXR0cignaGVpZ2h0JywgX18uaGVpZ2h0KS5hcHBlbmQoJ3N2ZzpnJykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgX18ubWFyZ2luLmxlZnQgKyAnLCcgKyBfXy5tYXJnaW4udG9wICsgJyknKTtcbiAgICByZXR1cm4gcGM7XG4gIH07XG5cbiAgdmFyIGV2ZW50cyA9IGQzLmRpc3BhdGNoLmFwcGx5KHRoaXMsIFsncmVuZGVyJywgJ3Jlc2l6ZScsICdoaWdobGlnaHQnLCAnYnJ1c2gnLCAnYnJ1c2hlbmQnLCAnYXhlc3Jlb3JkZXInXS5jb25jYXQoZDMua2V5cyhfXykpKSxcbiAgICAgIHcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9fLndpZHRoIC0gX18ubWFyZ2luLnJpZ2h0IC0gX18ubWFyZ2luLmxlZnQ7XG4gIH0sXG4gICAgICBoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfXy5oZWlnaHQgLSBfXy5tYXJnaW4udG9wIC0gX18ubWFyZ2luLmJvdHRvbTtcbiAgfSxcbiAgICAgIGZsYWdzID0ge1xuICAgIGJydXNoYWJsZTogZmFsc2UsXG4gICAgcmVvcmRlcmFibGU6IGZhbHNlLFxuICAgIGF4ZXM6IGZhbHNlLFxuICAgIGludGVyYWN0aXZlOiBmYWxzZSxcbiAgICBkZWJ1ZzogZmFsc2VcbiAgfSxcbiAgICAgIHhzY2FsZSA9IGQzLnNjYWxlLm9yZGluYWwoKSxcbiAgICAgIHlzY2FsZSA9IHt9LFxuICAgICAgZHJhZ2dpbmcgPSB7fSxcbiAgICAgIGxpbmUgPSBkMy5zdmcubGluZSgpLFxuICAgICAgYXhpcyA9IGQzLnN2Zy5heGlzKCkub3JpZW50KCdsZWZ0JykudGlja3MoNSksXG4gICAgICBnLFxuICAgICAgLy8gZ3JvdXBzIGZvciBheGVzLCBicnVzaGVzXG4gIGN0eCA9IHt9LFxuICAgICAgY2FudmFzID0ge30sXG4gICAgICBjbHVzdGVyQ2VudHJvaWRzID0gW107IC8vIHNpZGUgZWZmZWN0cyBmb3Igc2V0dGVyc1xuXG5cbiAgdmFyIHNpZGVfZWZmZWN0cyA9IGQzLmRpc3BhdGNoLmFwcGx5KHRoaXMsIGQzLmtleXMoX18pKS5vbignY29tcG9zaXRlJywgZnVuY3Rpb24gKGQpIHtcbiAgICBjdHguZm9yZWdyb3VuZC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBkLnZhbHVlO1xuICAgIGN0eC5icnVzaGVkLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGQudmFsdWU7XG4gIH0pLm9uKCdhbHBoYScsIGZ1bmN0aW9uIChkKSB7XG4gICAgY3R4LmZvcmVncm91bmQuZ2xvYmFsQWxwaGEgPSBkLnZhbHVlO1xuICAgIGN0eC5icnVzaGVkLmdsb2JhbEFscGhhID0gZC52YWx1ZTtcbiAgfSkub24oJ2JydXNoZWRDb2xvcicsIGZ1bmN0aW9uIChkKSB7XG4gICAgY3R4LmJydXNoZWQuc3Ryb2tlU3R5bGUgPSBkLnZhbHVlO1xuICB9KS5vbignd2lkdGgnLCBmdW5jdGlvbiAoZCkge1xuICAgIHBjLnJlc2l6ZSgpO1xuICB9KS5vbignaGVpZ2h0JywgZnVuY3Rpb24gKGQpIHtcbiAgICBwYy5yZXNpemUoKTtcbiAgfSkub24oJ21hcmdpbicsIGZ1bmN0aW9uIChkKSB7XG4gICAgcGMucmVzaXplKCk7XG4gIH0pLm9uKCdyYXRlJywgZnVuY3Rpb24gKGQpIHtcbiAgICBicnVzaGVkUXVldWUucmF0ZShkLnZhbHVlKTtcbiAgICBmb3JlZ3JvdW5kUXVldWUucmF0ZShkLnZhbHVlKTtcbiAgfSkub24oJ2RpbWVuc2lvbnMnLCBmdW5jdGlvbiAoZCkge1xuICAgIHhzY2FsZS5kb21haW4oX18uZGltZW5zaW9ucyk7XG5cbiAgICBpZiAoZmxhZ3MuaW50ZXJhY3RpdmUpIHtcbiAgICAgIHBjLnJlbmRlcigpLnVwZGF0ZUF4ZXMoKTtcbiAgICB9XG4gIH0pLm9uKCdidW5kbGVEaW1lbnNpb24nLCBmdW5jdGlvbiAoZCkge1xuICAgIGlmICghX18uZGltZW5zaW9ucy5sZW5ndGgpIHBjLmRldGVjdERpbWVuc2lvbnMoKTtcbiAgICBpZiAoIShfXy5kaW1lbnNpb25zWzBdIGluIHlzY2FsZSkpIHBjLmF1dG9zY2FsZSgpO1xuXG4gICAgaWYgKHR5cGVvZiBkLnZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGQudmFsdWUgPCBfXy5kaW1lbnNpb25zLmxlbmd0aCkge1xuICAgICAgICBfXy5idW5kbGVEaW1lbnNpb24gPSBfXy5kaW1lbnNpb25zW2QudmFsdWVdO1xuICAgICAgfSBlbHNlIGlmIChkLnZhbHVlIDwgX18uaGlkZUF4aXMubGVuZ3RoKSB7XG4gICAgICAgIF9fLmJ1bmRsZURpbWVuc2lvbiA9IF9fLmhpZGVBeGlzW2QudmFsdWVdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBfXy5idW5kbGVEaW1lbnNpb24gPSBkLnZhbHVlO1xuICAgIH1cblxuICAgIF9fLmNsdXN0ZXJDZW50cm9pZHMgPSBjb21wdXRlX2NsdXN0ZXJfY2VudHJvaWRzKF9fLmJ1bmRsZURpbWVuc2lvbik7XG4gIH0pLm9uKCdoaWRlQXhpcycsIGZ1bmN0aW9uIChkKSB7XG4gICAgaWYgKCFfXy5kaW1lbnNpb25zLmxlbmd0aCkgcGMuZGV0ZWN0RGltZW5zaW9ucygpO1xuICAgIHBjLmRpbWVuc2lvbnMod2l0aG91dChfXy5kaW1lbnNpb25zLCBkLnZhbHVlKSk7XG4gIH0pOyAvLyBleHBvc2UgdGhlIHN0YXRlIG9mIHRoZSBjaGFydFxuXG4gIHBjLnN0YXRlID0gX187XG4gIHBjLmZsYWdzID0gZmxhZ3M7IC8vIGNyZWF0ZSBnZXR0ZXIvc2V0dGVyc1xuXG4gIGdldHNldChwYywgX18sIGV2ZW50cyk7IC8vIGV4cG9zZSBldmVudHNcblxuICBkMy5yZWJpbmQocGMsIGV2ZW50cywgJ29uJyk7IC8vIGdldHRlci9zZXR0ZXIgd2l0aCBldmVudCBmaXJpbmdcblxuICBmdW5jdGlvbiBnZXRzZXQob2JqLCBzdGF0ZSwgZXZlbnRzKSB7XG4gICAgZDMua2V5cyhzdGF0ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBvYmpba2V5XSA9IGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybiBzdGF0ZVtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9sZCA9IHN0YXRlW2tleV07XG4gICAgICAgIHN0YXRlW2tleV0gPSB4O1xuICAgICAgICBzaWRlX2VmZmVjdHNba2V5XS5jYWxsKHBjLCB7XG4gICAgICAgICAgdmFsdWU6IHgsXG4gICAgICAgICAgcHJldmlvdXM6IG9sZFxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRzW2tleV0uY2FsbChwYywge1xuICAgICAgICAgIHZhbHVlOiB4LFxuICAgICAgICAgIHByZXZpb3VzOiBvbGRcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0ZW5kKHRhcmdldCwgc291cmNlKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aG91dChhcnIsIGl0ZW0pIHtcbiAgICByZXR1cm4gYXJyLmZpbHRlcihmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0uaW5kZXhPZihlbGVtKSA9PT0gLTE7XG4gICAgfSk7XG4gIH1cbiAgLyoqIGFkanVzdHMgYW4gYXhpcycgZGVmYXVsdCByYW5nZSBbaCgpKzEsIDFdIGlmIGEgTnVsbFZhbHVlU2VwYXJhdG9yIGlzIHNldCAqL1xuXG5cbiAgZnVuY3Rpb24gZ2V0UmFuZ2UoKSB7XG4gICAgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAnYm90dG9tJykge1xuICAgICAgcmV0dXJuIFtoKCkgKyAxIC0gX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy5ib3R0b20gLSBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLnRvcCwgMV07XG4gICAgfSBlbHNlIGlmIChfXy5udWxsVmFsdWVTZXBhcmF0b3IgPT0gJ3RvcCcpIHtcbiAgICAgIHJldHVybiBbaCgpICsgMSwgMSArIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcuYm90dG9tICsgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy50b3BdO1xuICAgIH1cblxuICAgIHJldHVybiBbaCgpICsgMSwgMV07XG4gIH1cblxuICBwYy5hdXRvc2NhbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8geXNjYWxlXG4gICAgdmFyIGRlZmF1bHRTY2FsZXMgPSB7XG4gICAgICBkYXRlOiBmdW5jdGlvbiAoaykge1xuICAgICAgICB2YXIgZXh0ZW50ID0gZDMuZXh0ZW50KF9fLmRhdGEsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuIGRba10gPyBkW2tdLmdldFRpbWUoKSA6IG51bGw7XG4gICAgICAgIH0pOyAvLyBzcGVjaWFsIGNhc2UgaWYgc2luZ2xlIHZhbHVlXG5cbiAgICAgICAgaWYgKGV4dGVudFswXSA9PT0gZXh0ZW50WzFdKSB7XG4gICAgICAgICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5kb21haW4oW2V4dGVudFswXV0pLnJhbmdlUG9pbnRzKGdldFJhbmdlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQzLnRpbWUuc2NhbGUoKS5kb21haW4oZXh0ZW50KS5yYW5nZShnZXRSYW5nZSgpKTtcbiAgICAgIH0sXG4gICAgICBudW1iZXI6IGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHZhciBleHRlbnQgPSBkMy5leHRlbnQoX18uZGF0YSwgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gK2Rba107XG4gICAgICAgIH0pOyAvLyBzcGVjaWFsIGNhc2UgaWYgc2luZ2xlIHZhbHVlXG5cbiAgICAgICAgaWYgKGV4dGVudFswXSA9PT0gZXh0ZW50WzFdKSB7XG4gICAgICAgICAgcmV0dXJuIGQzLnNjYWxlLm9yZGluYWwoKS5kb21haW4oW2V4dGVudFswXV0pLnJhbmdlUG9pbnRzKGdldFJhbmdlKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGQzLnNjYWxlLmxpbmVhcigpLmRvbWFpbihleHRlbnQpLnJhbmdlKGdldFJhbmdlKCkpO1xuICAgICAgfSxcbiAgICAgIHN0cmluZzogZnVuY3Rpb24gKGspIHtcbiAgICAgICAgdmFyIGNvdW50cyA9IHt9LFxuICAgICAgICAgICAgZG9tYWluID0gW107IC8vIExldCdzIGdldCB0aGUgY291bnQgZm9yIGVhY2ggdmFsdWUgc28gdGhhdCB3ZSBjYW4gc29ydCB0aGUgZG9tYWluIGJhc2VkXG4gICAgICAgIC8vIG9uIHRoZSBudW1iZXIgb2YgaXRlbXMgZm9yIGVhY2ggdmFsdWUuXG5cbiAgICAgICAgX18uZGF0YS5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgICBpZiAocFtrXSA9PT0gdW5kZWZpbmVkICYmIF9fLm51bGxWYWx1ZVNlcGFyYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gbnVsbCB2YWx1ZXMgd2lsbCBiZSBkcmF3biBiZXlvbmQgdGhlIGhvcml6b250YWwgbnVsbCB2YWx1ZSBzZXBhcmF0b3IhXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvdW50c1twW2tdXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb3VudHNbcFtrXV0gPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb3VudHNbcFtrXV0gPSBjb3VudHNbcFtrXV0gKyAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgZG9tYWluID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY291bnRzKS5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGNvdW50c1thXSAtIGNvdW50c1tiXTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkMy5zY2FsZS5vcmRpbmFsKCkuZG9tYWluKGRvbWFpbikucmFuZ2VQb2ludHMoZ2V0UmFuZ2UoKSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9fLmRpbWVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgeXNjYWxlW2tdID0gZGVmYXVsdFNjYWxlc1tfXy50eXBlc1trXV0oayk7XG4gICAgfSk7XG5cbiAgICBfXy5oaWRlQXhpcy5mb3JFYWNoKGZ1bmN0aW9uIChrKSB7XG4gICAgICB5c2NhbGVba10gPSBkZWZhdWx0U2NhbGVzW19fLnR5cGVzW2tdXShrKTtcbiAgICB9KTsgLy8geHNjYWxlXG5cblxuICAgIHhzY2FsZS5yYW5nZVBvaW50cyhbMCwgdygpXSwgMSk7IC8vIGNhbnZhcyBzaXplc1xuXG4gICAgcGMuc2VsZWN0aW9uLnNlbGVjdEFsbCgnY2FudmFzJykuc3R5bGUoJ21hcmdpbi10b3AnLCBfXy5tYXJnaW4udG9wICsgJ3B4Jykuc3R5bGUoJ21hcmdpbi1sZWZ0JywgX18ubWFyZ2luLmxlZnQgKyAncHgnKS5hdHRyKCd3aWR0aCcsIHcoKSArIDIpLmF0dHIoJ2hlaWdodCcsIGgoKSArIDIpOyAvLyBkZWZhdWx0IHN0eWxlcywgbmVlZHMgdG8gYmUgc2V0IHdoZW4gY2FudmFzIHdpZHRoIGNoYW5nZXNcblxuICAgIGN0eC5mb3JlZ3JvdW5kLnN0cm9rZVN0eWxlID0gX18uY29sb3I7XG4gICAgY3R4LmZvcmVncm91bmQubGluZVdpZHRoID0gMS40O1xuICAgIGN0eC5mb3JlZ3JvdW5kLmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IF9fLmNvbXBvc2l0ZTtcbiAgICBjdHguZm9yZWdyb3VuZC5nbG9iYWxBbHBoYSA9IF9fLmFscGhhO1xuICAgIGN0eC5icnVzaGVkLnN0cm9rZVN0eWxlID0gX18uYnJ1c2hlZENvbG9yO1xuICAgIGN0eC5icnVzaGVkLmxpbmVXaWR0aCA9IDEuNDtcbiAgICBjdHguYnJ1c2hlZC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBfXy5jb21wb3NpdGU7XG4gICAgY3R4LmJydXNoZWQuZ2xvYmFsQWxwaGEgPSBfXy5hbHBoYTtcbiAgICBjdHguaGlnaGxpZ2h0LmxpbmVXaWR0aCA9IDM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgcGMuc2NhbGUgPSBmdW5jdGlvbiAoZCwgZG9tYWluKSB7XG4gICAgeXNjYWxlW2RdLmRvbWFpbihkb21haW4pO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLmZsaXAgPSBmdW5jdGlvbiAoZCkge1xuICAgIC8veXNjYWxlW2RdLmRvbWFpbigpLnJldmVyc2UoKTsgICAgICAgICAvLyBkb2VzIG5vdCB3b3JrXG4gICAgeXNjYWxlW2RdLmRvbWFpbih5c2NhbGVbZF0uZG9tYWluKCkucmV2ZXJzZSgpKTsgLy8gd29ya3NcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLmNvbW1vblNjYWxlID0gZnVuY3Rpb24gKGdsb2JhbCwgdHlwZSkge1xuICAgIHZhciB0ID0gdHlwZSB8fCAnbnVtYmVyJztcblxuICAgIGlmICh0eXBlb2YgZ2xvYmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgZ2xvYmFsID0gdHJ1ZTtcbiAgICB9IC8vIHNjYWxlcyBvZiB0aGUgc2FtZSB0eXBlXG5cblxuICAgIHZhciBzY2FsZXMgPSBfXy5kaW1lbnNpb25zLmNvbmNhdChfXy5oaWRlQXhpcykuZmlsdGVyKGZ1bmN0aW9uIChwKSB7XG4gICAgICByZXR1cm4gX18udHlwZXNbcF0gPT0gdDtcbiAgICB9KTtcblxuICAgIGlmIChnbG9iYWwpIHtcbiAgICAgIHZhciBleHRlbnQgPSBkMy5leHRlbnQoc2NhbGVzLm1hcChmdW5jdGlvbiAocCwgaSkge1xuICAgICAgICByZXR1cm4geXNjYWxlW3BdLmRvbWFpbigpO1xuICAgICAgfSkucmVkdWNlKGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBhLmNvbmNhdChiKTtcbiAgICAgIH0pKTtcbiAgICAgIHNjYWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHlzY2FsZVtkXS5kb21haW4oZXh0ZW50KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzY2FsZXMuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICB5c2NhbGVba10uZG9tYWluKGQzLmV4dGVudChfXy5kYXRhLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiArZFtrXTtcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG4gICAgfSAvLyB1cGRhdGUgY2VudHJvaWRzXG5cblxuICAgIGlmIChfXy5idW5kbGVEaW1lbnNpb24gIT09IG51bGwpIHtcbiAgICAgIHBjLmJ1bmRsZURpbWVuc2lvbihfXy5idW5kbGVEaW1lbnNpb24pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLmRldGVjdERpbWVuc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGMudHlwZXMocGMuZGV0ZWN0RGltZW5zaW9uVHlwZXMoX18uZGF0YSkpO1xuICAgIHBjLmRpbWVuc2lvbnMoZDMua2V5cyhwYy50eXBlcygpKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07IC8vIGEgYmV0dGVyIFwidHlwZW9mXCIgZnJvbSB0aGlzIHBvc3Q6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNzM5MDQyNi9iZXR0ZXItd2F5LXRvLWdldC10eXBlLW9mLWEtamF2YXNjcmlwdC12YXJpYWJsZVxuXG5cbiAgcGMudG9UeXBlID0gZnVuY3Rpb24gKHYpIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbCh2KS5tYXRjaCgvXFxzKFthLXpBLVpdKykvKVsxXS50b0xvd2VyQ2FzZSgpO1xuICB9OyAvLyB0cnkgdG8gY29lcmNlIHRvIG51bWJlciBiZWZvcmUgcmV0dXJuaW5nIHR5cGVcblxuXG4gIHBjLnRvVHlwZUNvZXJjZU51bWJlcnMgPSBmdW5jdGlvbiAodikge1xuICAgIGlmIChwYXJzZUZsb2F0KHYpID09IHYgJiYgdiAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gJ251bWJlcic7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBjLnRvVHlwZSh2KTtcbiAgfTsgLy8gYXR0ZW1wdCB0byBkZXRlcm1pbmUgdHlwZXMgb2YgZWFjaCBkaW1lbnNpb24gYmFzZWQgb24gZmlyc3Qgcm93IG9mIGRhdGFcblxuXG4gIHBjLmRldGVjdERpbWVuc2lvblR5cGVzID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgdHlwZXMgPSB7fTtcbiAgICBkMy5rZXlzKGRhdGFbMF0pLmZvckVhY2goZnVuY3Rpb24gKGNvbCkge1xuICAgICAgdHlwZXNbY29sXSA9IHBjLnRvVHlwZUNvZXJjZU51bWJlcnMoZGF0YVswXVtjb2xdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdHlwZXM7XG4gIH07XG5cbiAgcGMucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHRyeSB0byBhdXRvZGV0ZWN0IGRpbWVuc2lvbnMgYW5kIGNyZWF0ZSBzY2FsZXNcbiAgICBpZiAoIV9fLmRpbWVuc2lvbnMubGVuZ3RoKSBwYy5kZXRlY3REaW1lbnNpb25zKCk7XG4gICAgaWYgKCEoX18uZGltZW5zaW9uc1swXSBpbiB5c2NhbGUpKSBwYy5hdXRvc2NhbGUoKTtcblxuICAgIHBjLnJlbmRlcltfXy5tb2RlXSgpO1xuXG4gICAgZXZlbnRzLnJlbmRlci5jYWxsKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLnJlbmRlckJydXNoZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFfXy5kaW1lbnNpb25zLmxlbmd0aCkgcGMuZGV0ZWN0RGltZW5zaW9ucygpO1xuICAgIGlmICghKF9fLmRpbWVuc2lvbnNbMF0gaW4geXNjYWxlKSkgcGMuYXV0b3NjYWxlKCk7XG5cbiAgICBwYy5yZW5kZXJCcnVzaGVkW19fLm1vZGVdKCk7XG5cbiAgICBldmVudHMucmVuZGVyLmNhbGwodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNCcnVzaGVkKCkge1xuICAgIGlmIChfXy5icnVzaGVkICYmIF9fLmJydXNoZWQubGVuZ3RoICE9PSBfXy5kYXRhLmxlbmd0aCkgcmV0dXJuIHRydWU7XG4gICAgdmFyIG9iamVjdCA9IGJydXNoLmN1cnJlbnRNb2RlKCkuYnJ1c2hTdGF0ZSgpO1xuXG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHBjLnJlbmRlci5kZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgIHBjLmNsZWFyKCdmb3JlZ3JvdW5kJyk7XG4gICAgcGMuY2xlYXIoJ2hpZ2hsaWdodCcpO1xuICAgIHBjLnJlbmRlckJydXNoZWQuZGVmYXVsdCgpO1xuXG4gICAgX18uZGF0YS5mb3JFYWNoKHBhdGhfZm9yZWdyb3VuZCk7XG4gIH07XG5cbiAgdmFyIGZvcmVncm91bmRRdWV1ZSA9IGQzLnJlbmRlclF1ZXVlKHBhdGhfZm9yZWdyb3VuZCkucmF0ZSg1MCkuY2xlYXIoZnVuY3Rpb24gKCkge1xuICAgIHBjLmNsZWFyKCdmb3JlZ3JvdW5kJyk7XG4gICAgcGMuY2xlYXIoJ2hpZ2hsaWdodCcpO1xuICB9KTtcblxuICBwYy5yZW5kZXIucXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGMucmVuZGVyQnJ1c2hlZC5xdWV1ZSgpO1xuICAgIGZvcmVncm91bmRRdWV1ZShfXy5kYXRhKTtcbiAgfTtcblxuICBwYy5yZW5kZXJCcnVzaGVkLmRlZmF1bHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGMuY2xlYXIoJ2JydXNoZWQnKTtcblxuICAgIGlmIChpc0JydXNoZWQoKSkge1xuICAgICAgX18uYnJ1c2hlZC5mb3JFYWNoKHBhdGhfYnJ1c2hlZCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBicnVzaGVkUXVldWUgPSBkMy5yZW5kZXJRdWV1ZShwYXRoX2JydXNoZWQpLnJhdGUoNTApLmNsZWFyKGZ1bmN0aW9uICgpIHtcbiAgICBwYy5jbGVhcignYnJ1c2hlZCcpO1xuICB9KTtcblxuICBwYy5yZW5kZXJCcnVzaGVkLnF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChpc0JydXNoZWQoKSkge1xuICAgICAgYnJ1c2hlZFF1ZXVlKF9fLmJydXNoZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBicnVzaGVkUXVldWUoW10pOyAvLyBUaGlzIGlzIG5lZWRlZCB0byBjbGVhciB0aGUgY3VycmVudGx5IGJydXNoZWQgaXRlbXNcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY29tcHV0ZV9jbHVzdGVyX2NlbnRyb2lkcyhkKSB7XG4gICAgdmFyIGNsdXN0ZXJDZW50cm9pZHMgPSBkMy5tYXAoKTtcbiAgICB2YXIgY2x1c3RlckNvdW50cyA9IGQzLm1hcCgpOyAvLyBkZXRlcm1pbmUgY2x1c3RlckNvdW50c1xuXG4gICAgX18uZGF0YS5mb3JFYWNoKGZ1bmN0aW9uIChyb3cpIHtcbiAgICAgIHZhciBzY2FsZWQgPSB5c2NhbGVbZF0ocm93W2RdKTtcblxuICAgICAgaWYgKCFjbHVzdGVyQ291bnRzLmhhcyhzY2FsZWQpKSB7XG4gICAgICAgIGNsdXN0ZXJDb3VudHMuc2V0KHNjYWxlZCwgMCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb3VudCA9IGNsdXN0ZXJDb3VudHMuZ2V0KHNjYWxlZCk7XG4gICAgICBjbHVzdGVyQ291bnRzLnNldChzY2FsZWQsIGNvdW50ICsgMSk7XG4gICAgfSk7XG5cbiAgICBfXy5kYXRhLmZvckVhY2goZnVuY3Rpb24gKHJvdykge1xuICAgICAgX18uZGltZW5zaW9ucy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgdmFyIHNjYWxlZCA9IHlzY2FsZVtkXShyb3dbZF0pO1xuXG4gICAgICAgIGlmICghY2x1c3RlckNlbnRyb2lkcy5oYXMoc2NhbGVkKSkge1xuICAgICAgICAgIHZhciBtYXAgPSBkMy5tYXAoKTtcbiAgICAgICAgICBjbHVzdGVyQ2VudHJvaWRzLnNldChzY2FsZWQsIG1hcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNsdXN0ZXJDZW50cm9pZHMuZ2V0KHNjYWxlZCkuaGFzKHApKSB7XG4gICAgICAgICAgY2x1c3RlckNlbnRyb2lkcy5nZXQoc2NhbGVkKS5zZXQocCwgMCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmFsdWUgPSBjbHVzdGVyQ2VudHJvaWRzLmdldChzY2FsZWQpLmdldChwKTtcbiAgICAgICAgdmFsdWUgKz0geXNjYWxlW3BdKHJvd1twXSkgLyBjbHVzdGVyQ291bnRzLmdldChzY2FsZWQpO1xuICAgICAgICBjbHVzdGVyQ2VudHJvaWRzLmdldChzY2FsZWQpLnNldChwLCB2YWx1ZSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjbHVzdGVyQ2VudHJvaWRzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZV9jZW50cm9pZHMocm93KSB7XG4gICAgdmFyIGNlbnRyb2lkcyA9IFtdO1xuICAgIHZhciBwID0gX18uZGltZW5zaW9ucztcbiAgICB2YXIgY29scyA9IHAubGVuZ3RoO1xuICAgIHZhciBhID0gMC41OyAvLyBjZW50ZXIgYmV0d2VlbiBheGVzXG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHM7ICsraSkge1xuICAgICAgLy8gY2VudHJvaWRzIG9uICdyZWFsJyBheGVzXG4gICAgICB2YXIgeCA9IHBvc2l0aW9uKHBbaV0pO1xuICAgICAgdmFyIHkgPSB5c2NhbGVbcFtpXV0ocm93W3BbaV1dKTtcbiAgICAgIGNlbnRyb2lkcy5wdXNoKCRWKFt4LCB5XSkpOyAvLyBjZW50cm9pZHMgb24gJ3ZpcnR1YWwnIGF4ZXNcblxuICAgICAgaWYgKGkgPCBjb2xzIC0gMSkge1xuICAgICAgICB2YXIgY3ggPSB4ICsgYSAqIChwb3NpdGlvbihwW2kgKyAxXSkgLSB4KTtcbiAgICAgICAgdmFyIGN5ID0geSArIGEgKiAoeXNjYWxlW3BbaSArIDFdXShyb3dbcFtpICsgMV1dKSAtIHkpO1xuXG4gICAgICAgIGlmIChfXy5idW5kbGVEaW1lbnNpb24gIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgbGVmdENlbnRyb2lkID0gX18uY2x1c3RlckNlbnRyb2lkcy5nZXQoeXNjYWxlW19fLmJ1bmRsZURpbWVuc2lvbl0ocm93W19fLmJ1bmRsZURpbWVuc2lvbl0pKS5nZXQocFtpXSk7XG5cbiAgICAgICAgICB2YXIgcmlnaHRDZW50cm9pZCA9IF9fLmNsdXN0ZXJDZW50cm9pZHMuZ2V0KHlzY2FsZVtfXy5idW5kbGVEaW1lbnNpb25dKHJvd1tfXy5idW5kbGVEaW1lbnNpb25dKSkuZ2V0KHBbaSArIDFdKTtcblxuICAgICAgICAgIHZhciBjZW50cm9pZCA9IDAuNSAqIChsZWZ0Q2VudHJvaWQgKyByaWdodENlbnRyb2lkKTtcbiAgICAgICAgICBjeSA9IGNlbnRyb2lkICsgKDEgLSBfXy5idW5kbGluZ1N0cmVuZ3RoKSAqIChjeSAtIGNlbnRyb2lkKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNlbnRyb2lkcy5wdXNoKCRWKFtjeCwgY3ldKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNlbnRyb2lkcztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVfY29udHJvbF9wb2ludHMoY2VudHJvaWRzKSB7XG4gICAgdmFyIGNvbHMgPSBjZW50cm9pZHMubGVuZ3RoO1xuICAgIHZhciBhID0gX18uc21vb3RobmVzcztcbiAgICB2YXIgY3BzID0gW107XG4gICAgY3BzLnB1c2goY2VudHJvaWRzWzBdKTtcbiAgICBjcHMucHVzaCgkVihbY2VudHJvaWRzWzBdLmUoMSkgKyBhICogMiAqIChjZW50cm9pZHNbMV0uZSgxKSAtIGNlbnRyb2lkc1swXS5lKDEpKSwgY2VudHJvaWRzWzBdLmUoMildKSk7XG5cbiAgICBmb3IgKHZhciBjb2wgPSAxOyBjb2wgPCBjb2xzIC0gMTsgKytjb2wpIHtcbiAgICAgIHZhciBtaWQgPSBjZW50cm9pZHNbY29sXTtcbiAgICAgIHZhciBsZWZ0ID0gY2VudHJvaWRzW2NvbCAtIDFdO1xuICAgICAgdmFyIHJpZ2h0ID0gY2VudHJvaWRzW2NvbCArIDFdO1xuICAgICAgdmFyIGRpZmYgPSBsZWZ0LnN1YnRyYWN0KHJpZ2h0KTtcbiAgICAgIGNwcy5wdXNoKG1pZC5hZGQoZGlmZi54KGEpKSk7XG4gICAgICBjcHMucHVzaChtaWQpO1xuICAgICAgY3BzLnB1c2gobWlkLnN1YnRyYWN0KGRpZmYueChhKSkpO1xuICAgIH1cblxuICAgIGNwcy5wdXNoKCRWKFtjZW50cm9pZHNbY29scyAtIDFdLmUoMSkgKyBhICogMiAqIChjZW50cm9pZHNbY29scyAtIDJdLmUoMSkgLSBjZW50cm9pZHNbY29scyAtIDFdLmUoMSkpLCBjZW50cm9pZHNbY29scyAtIDFdLmUoMildKSk7XG4gICAgY3BzLnB1c2goY2VudHJvaWRzW2NvbHMgLSAxXSk7XG4gICAgcmV0dXJuIGNwcztcbiAgfVxuXG4gIHBjLnNoYWRvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZ3Muc2hhZG93cyA9IHRydWU7XG4gICAgcGMuYWxwaGFPbkJydXNoZWQoMC4xKTtcbiAgICBwYy5yZW5kZXIoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTsgLy8gZHJhdyBkb3RzIHdpdGggcmFkaXVzIHIgb24gdGhlIGF4aXMgbGluZSB3aGVyZSBkYXRhIGludGVyc2VjdHNcblxuXG4gIHBjLmF4aXNEb3RzID0gZnVuY3Rpb24gKHIpIHtcbiAgICB2YXIgciA9IHIgfHwgMC4xO1xuICAgIHZhciBjdHggPSBwYy5jdHgubWFya3M7XG4gICAgdmFyIHN0YXJ0QW5nbGUgPSAwO1xuICAgIHZhciBlbmRBbmdsZSA9IDIgKiBNYXRoLlBJO1xuICAgIGN0eC5nbG9iYWxBbHBoYSA9IGQzLm1pbihbMSAvIE1hdGgucG93KF9fLmRhdGEubGVuZ3RoLCAxIC8gMiksIDFdKTtcblxuICAgIF9fLmRhdGEuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgX18uZGltZW5zaW9ucy5tYXAoZnVuY3Rpb24gKHAsIGkpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguYXJjKHBvc2l0aW9uKHApLCB5c2NhbGVbcF0oZFtwXSksIHIsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTsgLy8gZHJhdyBzaW5nbGUgY3ViaWMgYmV6aWVyIGN1cnZlXG5cblxuICBmdW5jdGlvbiBzaW5nbGVfY3VydmUoZCwgY3R4KSB7XG4gICAgdmFyIGNlbnRyb2lkcyA9IGNvbXB1dGVfY2VudHJvaWRzKGQpO1xuICAgIHZhciBjcHMgPSBjb21wdXRlX2NvbnRyb2xfcG9pbnRzKGNlbnRyb2lkcyk7XG4gICAgY3R4Lm1vdmVUbyhjcHNbMF0uZSgxKSwgY3BzWzBdLmUoMikpO1xuXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjcHMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgIGlmIChfXy5zaG93Q29udHJvbFBvaW50cykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDM7IGogKz0gMSkge1xuICAgICAgICAgIGN0eC5maWxsUmVjdChjcHNbaSArIGpdLmUoMSksIGNwc1tpICsgal0uZSgyKSwgMiwgMik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY3R4LmJlemllckN1cnZlVG8oY3BzW2ldLmUoMSksIGNwc1tpXS5lKDIpLCBjcHNbaSArIDFdLmUoMSksIGNwc1tpICsgMV0uZSgyKSwgY3BzW2kgKyAyXS5lKDEpLCBjcHNbaSArIDJdLmUoMikpO1xuICAgIH1cbiAgfSAvLyBkcmF3IHNpbmdsZSBwb2x5bGluZVxuXG5cbiAgZnVuY3Rpb24gY29sb3JfcGF0aChkLCBjdHgpIHtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICBpZiAoX18uYnVuZGxlRGltZW5zaW9uICE9PSBudWxsICYmIF9fLmJ1bmRsaW5nU3RyZW5ndGggPiAwIHx8IF9fLnNtb290aG5lc3MgPiAwKSB7XG4gICAgICBzaW5nbGVfY3VydmUoZCwgY3R4KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2luZ2xlX3BhdGgoZCwgY3R4KTtcbiAgICB9XG5cbiAgICBjdHguc3Ryb2tlKCk7XG4gIH0gLy8gZHJhdyBtYW55IHBvbHlsaW5lcyBvZiB0aGUgc2FtZSBjb2xvclxuXG5cbiAgZnVuY3Rpb24gcGF0aHMoZGF0YSwgY3R4KSB7XG4gICAgY3R4LmNsZWFyUmVjdCgtMSwgLTEsIHcoKSArIDIsIGgoKSArIDIpO1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIGlmIChfXy5idW5kbGVEaW1lbnNpb24gIT09IG51bGwgJiYgX18uYnVuZGxpbmdTdHJlbmd0aCA+IDAgfHwgX18uc21vb3RobmVzcyA+IDApIHtcbiAgICAgICAgc2luZ2xlX2N1cnZlKGQsIGN0eCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaW5nbGVfcGF0aChkLCBjdHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgfSAvLyByZXR1cm5zIHRoZSB5LXBvc2l0aW9uIGp1c3QgYmV5b25kIHRoZSBzZXBhcmF0aW5nIG51bGwgdmFsdWUgbGluZVxuXG5cbiAgZnVuY3Rpb24gZ2V0TnVsbFBvc2l0aW9uKCkge1xuICAgIGlmIChfXy5udWxsVmFsdWVTZXBhcmF0b3IgPT0gJ2JvdHRvbScpIHtcbiAgICAgIHJldHVybiBoKCkgKyAxO1xuICAgIH0gZWxzZSBpZiAoX18ubnVsbFZhbHVlU2VwYXJhdG9yID09ICd0b3AnKSB7XG4gICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coXCJBIHZhbHVlIGlzIE5VTEwsIGJ1dCBudWxsVmFsdWVTZXBhcmF0b3IgaXMgbm90IHNldDsgc2V0IGl0IHRvICdib3R0b20nIG9yICd0b3AnLlwiKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaCgpICsgMTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNpbmdsZV9wYXRoKGQsIGN0eCkge1xuICAgIF9fLmRpbWVuc2lvbnMubWFwKGZ1bmN0aW9uIChwLCBpKSB7XG4gICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgIGN0eC5tb3ZlVG8ocG9zaXRpb24ocCksIHR5cGVvZiBkW3BdID09ICd1bmRlZmluZWQnID8gZ2V0TnVsbFBvc2l0aW9uKCkgOiB5c2NhbGVbcF0oZFtwXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmxpbmVUbyhwb3NpdGlvbihwKSwgdHlwZW9mIGRbcF0gPT0gJ3VuZGVmaW5lZCcgPyBnZXROdWxsUG9zaXRpb24oKSA6IHlzY2FsZVtwXShkW3BdKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXRoX2JydXNoZWQoZCwgaSkge1xuICAgIGlmIChfXy5icnVzaGVkQ29sb3IgIT09IG51bGwpIHtcbiAgICAgIGN0eC5icnVzaGVkLnN0cm9rZVN0eWxlID0gZDMuZnVuY3RvcihfXy5icnVzaGVkQ29sb3IpKGQsIGkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguYnJ1c2hlZC5zdHJva2VTdHlsZSA9IGQzLmZ1bmN0b3IoX18uY29sb3IpKGQsIGkpO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xvcl9wYXRoKGQsIGN0eC5icnVzaGVkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBhdGhfZm9yZWdyb3VuZChkLCBpKSB7XG4gICAgY3R4LmZvcmVncm91bmQuc3Ryb2tlU3R5bGUgPSBkMy5mdW5jdG9yKF9fLmNvbG9yKShkLCBpKTtcbiAgICByZXR1cm4gY29sb3JfcGF0aChkLCBjdHguZm9yZWdyb3VuZCk7XG4gIH1cblxuICBmdW5jdGlvbiBwYXRoX2hpZ2hsaWdodChkLCBpKSB7XG4gICAgY3R4LmhpZ2hsaWdodC5zdHJva2VTdHlsZSA9IGQzLmZ1bmN0b3IoX18uY29sb3IpKGQsIGkpO1xuICAgIHJldHVybiBjb2xvcl9wYXRoKGQsIGN0eC5oaWdobGlnaHQpO1xuICB9XG5cbiAgcGMuY2xlYXIgPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICBjdHhbbGF5ZXJdLmNsZWFyUmVjdCgwLCAwLCB3KCkgKyAyLCBoKCkgKyAyKTsgLy8gVGhpcyB3aWxsIG1ha2Ugc3VyZSB0aGF0IHRoZSBmb3JlZ3JvdW5kIGl0ZW1zIGFyZSB0cmFuc3BhcmVudFxuICAgIC8vIHdpdGhvdXQgdGhlIG5lZWQgZm9yIGNoYW5naW5nIHRoZSBvcGFjaXR5IHN0eWxlIG9mIHRoZSBmb3JlZ3JvdW5kIGNhbnZhc1xuICAgIC8vIGFzIHRoaXMgd291bGQgc3RvcCB0aGUgY3NzIHN0eWxpbmcgZnJvbSB3b3JraW5nXG5cbiAgICBpZiAobGF5ZXIgPT09ICdicnVzaGVkJyAmJiBpc0JydXNoZWQoKSkge1xuICAgICAgY3R4LmJydXNoZWQuZmlsbFN0eWxlID0gcGMuc2VsZWN0aW9uLnN0eWxlKCdiYWNrZ3JvdW5kLWNvbG9yJyk7XG4gICAgICBjdHguYnJ1c2hlZC5nbG9iYWxBbHBoYSA9IDEgLSBfXy5hbHBoYU9uQnJ1c2hlZDtcbiAgICAgIGN0eC5icnVzaGVkLmZpbGxSZWN0KDAsIDAsIHcoKSArIDIsIGgoKSArIDIpO1xuICAgICAgY3R4LmJydXNoZWQuZ2xvYmFsQWxwaGEgPSBfXy5hbHBoYTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBkMy5yZWJpbmQocGMsIGF4aXMsICd0aWNrcycsICdvcmllbnQnLCAndGlja1ZhbHVlcycsICd0aWNrU3ViZGl2aWRlJywgJ3RpY2tTaXplJywgJ3RpY2tQYWRkaW5nJywgJ3RpY2tGb3JtYXQnKTtcblxuICBmdW5jdGlvbiBmbGlwQXhpc0FuZFVwZGF0ZVBDUChkaW1lbnNpb24pIHtcbiAgICB2YXIgZyA9IHBjLnN2Zy5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKTtcbiAgICBwYy5mbGlwKGRpbWVuc2lvbik7XG4gICAgZDMuc2VsZWN0KHRoaXMucGFyZW50RWxlbWVudCkudHJhbnNpdGlvbigpLmR1cmF0aW9uKDExMDApLmNhbGwoYXhpcy5zY2FsZSh5c2NhbGVbZGltZW5zaW9uXSkpO1xuICAgIHBjLnJlbmRlcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gcm90YXRlTGFiZWxzKCkge1xuICAgIHZhciBkZWx0YSA9IGQzLmV2ZW50LmRlbHRhWTtcbiAgICBkZWx0YSA9IGRlbHRhIDwgMCA/IC01IDogZGVsdGE7XG4gICAgZGVsdGEgPSBkZWx0YSA+IDAgPyA1IDogZGVsdGE7XG4gICAgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArPSBkZWx0YTtcbiAgICBwYy5zdmcuc2VsZWN0QWxsKCd0ZXh0LmxhYmVsJykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLC01KSByb3RhdGUoJyArIF9fLmRpbWVuc2lvblRpdGxlUm90YXRpb24gKyAnKScpO1xuICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gIH1cblxuICBmdW5jdGlvbiBkaW1lbnNpb25MYWJlbHMoZCkge1xuICAgIHJldHVybiBkIGluIF9fLmRpbWVuc2lvblRpdGxlcyA/IF9fLmRpbWVuc2lvblRpdGxlc1tkXSA6IGQ7IC8vIGRpbWVuc2lvbiBkaXNwbGF5IG5hbWVzXG4gIH1cblxuICBwYy5jcmVhdGVBeGVzID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChnKSBwYy5yZW1vdmVBeGVzKCk7IC8vIEFkZCBhIGdyb3VwIGVsZW1lbnQgZm9yIGVhY2ggZGltZW5zaW9uLlxuXG4gICAgZyA9IHBjLnN2Zy5zZWxlY3RBbGwoJy5kaW1lbnNpb24nKS5kYXRhKF9fLmRpbWVuc2lvbnMsIGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gZDtcbiAgICB9KS5lbnRlcigpLmFwcGVuZCgnc3ZnOmcnKS5hdHRyKCdjbGFzcycsICdkaW1lbnNpb24nKS5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHhzY2FsZShkKSArICcpJztcbiAgICB9KTsgLy8gQWRkIGFuIGF4aXMgYW5kIHRpdGxlLlxuXG4gICAgZy5hcHBlbmQoJ3N2ZzpnJykuYXR0cignY2xhc3MnLCAnYXhpcycpLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoMCwwKScpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RdKSk7XG4gICAgfSkuYXBwZW5kKCdzdmc6dGV4dCcpLmF0dHIoe1xuICAgICAgJ3RleHQtYW5jaG9yJzogJ21pZGRsZScsXG4gICAgICB5OiAwLFxuICAgICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDAsLTUpIHJvdGF0ZSgnICsgX18uZGltZW5zaW9uVGl0bGVSb3RhdGlvbiArICcpJyxcbiAgICAgIHg6IDAsXG4gICAgICBjbGFzczogJ2xhYmVsJ1xuICAgIH0pLnRleHQoZGltZW5zaW9uTGFiZWxzKS5vbignZGJsY2xpY2snLCBmbGlwQXhpc0FuZFVwZGF0ZVBDUCkub24oJ3doZWVsJywgcm90YXRlTGFiZWxzKTtcblxuICAgIGlmIChfXy5udWxsVmFsdWVTZXBhcmF0b3IgPT0gJ3RvcCcpIHtcbiAgICAgIHBjLnN2Zy5hcHBlbmQoJ2xpbmUnKS5hdHRyKCd4MScsIDApLmF0dHIoJ3kxJywgMSArIF9fLm51bGxWYWx1ZVNlcGFyYXRvclBhZGRpbmcudG9wKS5hdHRyKCd4MicsIHcoKSkuYXR0cigneTInLCAxICsgX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy50b3ApLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDEpLmF0dHIoJ3N0cm9rZScsICcjNzc3JykuYXR0cignZmlsbCcsICdub25lJykuYXR0cignc2hhcGUtcmVuZGVyaW5nJywgJ2NyaXNwRWRnZXMnKTtcbiAgICB9IGVsc2UgaWYgKF9fLm51bGxWYWx1ZVNlcGFyYXRvciA9PSAnYm90dG9tJykge1xuICAgICAgcGMuc3ZnLmFwcGVuZCgnbGluZScpLmF0dHIoJ3gxJywgMCkuYXR0cigneTEnLCBoKCkgKyAxIC0gX18ubnVsbFZhbHVlU2VwYXJhdG9yUGFkZGluZy5ib3R0b20pLmF0dHIoJ3gyJywgdygpKS5hdHRyKCd5MicsIGgoKSArIDEgLSBfXy5udWxsVmFsdWVTZXBhcmF0b3JQYWRkaW5nLmJvdHRvbSkuYXR0cignc3Ryb2tlLXdpZHRoJywgMSkuYXR0cignc3Ryb2tlJywgJyM3NzcnKS5hdHRyKCdmaWxsJywgJ25vbmUnKS5hdHRyKCdzaGFwZS1yZW5kZXJpbmcnLCAnY3Jpc3BFZGdlcycpO1xuICAgIH1cblxuICAgIGZsYWdzLmF4ZXMgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHBjLnJlbW92ZUF4ZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgZy5yZW1vdmUoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBwYy51cGRhdGVBeGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBnX2RhdGEgPSBwYy5zdmcuc2VsZWN0QWxsKCcuZGltZW5zaW9uJykuZGF0YShfXy5kaW1lbnNpb25zKTsgLy8gRW50ZXJcblxuICAgIGdfZGF0YS5lbnRlcigpLmFwcGVuZCgnc3ZnOmcnKS5hdHRyKCdjbGFzcycsICdkaW1lbnNpb24nKS5hdHRyKCd0cmFuc2Zvcm0nLCBmdW5jdGlvbiAocCkge1xuICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHBvc2l0aW9uKHApICsgJyknO1xuICAgIH0pLnN0eWxlKCdvcGFjaXR5JywgMCkuYXBwZW5kKCdzdmc6ZycpLmF0dHIoJ2NsYXNzJywgJ2F4aXMnKS5hdHRyKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKDAsMCknKS5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChheGlzLnNjYWxlKHlzY2FsZVtkXSkpO1xuICAgIH0pLmFwcGVuZCgnc3ZnOnRleHQnKS5hdHRyKHtcbiAgICAgICd0ZXh0LWFuY2hvcic6ICdtaWRkbGUnLFxuICAgICAgeTogMCxcbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgwLC01KSByb3RhdGUoJyArIF9fLmRpbWVuc2lvblRpdGxlUm90YXRpb24gKyAnKScsXG4gICAgICB4OiAwLFxuICAgICAgY2xhc3M6ICdsYWJlbCdcbiAgICB9KS50ZXh0KGRpbWVuc2lvbkxhYmVscykub24oJ2RibGNsaWNrJywgZmxpcEF4aXNBbmRVcGRhdGVQQ1ApLm9uKCd3aGVlbCcsIHJvdGF0ZUxhYmVscyk7IC8vIFVwZGF0ZVxuXG4gICAgZ19kYXRhLmF0dHIoJ29wYWNpdHknLCAwKTtcbiAgICBnX2RhdGEuc2VsZWN0KCcuYXhpcycpLnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMTAwKS5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChheGlzLnNjYWxlKHlzY2FsZVtkXSkpO1xuICAgIH0pO1xuICAgIGdfZGF0YS5zZWxlY3QoJy5sYWJlbCcpLnRyYW5zaXRpb24oKS5kdXJhdGlvbigxMTAwKS50ZXh0KGRpbWVuc2lvbkxhYmVscykuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgwLC01KSByb3RhdGUoJyArIF9fLmRpbWVuc2lvblRpdGxlUm90YXRpb24gKyAnKScpOyAvLyBFeGl0XG5cbiAgICBnX2RhdGEuZXhpdCgpLnJlbW92ZSgpO1xuICAgIGcgPSBwYy5zdmcuc2VsZWN0QWxsKCcuZGltZW5zaW9uJyk7XG4gICAgZy50cmFuc2l0aW9uKCkuZHVyYXRpb24oMTEwMCkuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyBwb3NpdGlvbihwKSArICcpJztcbiAgICB9KS5zdHlsZSgnb3BhY2l0eScsIDEpO1xuICAgIHBjLnN2Zy5zZWxlY3RBbGwoJy5heGlzJykudHJhbnNpdGlvbigpLmR1cmF0aW9uKDExMDApLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGF4aXMuc2NhbGUoeXNjYWxlW2RdKSk7XG4gICAgfSk7XG4gICAgaWYgKGZsYWdzLmJydXNoYWJsZSkgcGMuYnJ1c2hhYmxlKCk7XG4gICAgaWYgKGZsYWdzLnJlb3JkZXJhYmxlKSBwYy5yZW9yZGVyYWJsZSgpO1xuXG4gICAgaWYgKHBjLmJydXNoTW9kZSgpICE9PSAnTm9uZScpIHtcbiAgICAgIHZhciBtb2RlID0gcGMuYnJ1c2hNb2RlKCk7XG4gICAgICBwYy5icnVzaE1vZGUoJ05vbmUnKTtcbiAgICAgIHBjLmJydXNoTW9kZShtb2RlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTsgLy8gSmFzb24gRGF2aWVzLCBodHRwOi8vYmwub2Nrcy5vcmcvMTM0MTI4MVxuXG5cbiAgcGMucmVvcmRlcmFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFnKSBwYy5jcmVhdGVBeGVzKCk7XG4gICAgZy5zdHlsZSgnY3Vyc29yJywgJ21vdmUnKS5jYWxsKGQzLmJlaGF2aW9yLmRyYWcoKS5vbignZHJhZ3N0YXJ0JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgIGRyYWdnaW5nW2RdID0gdGhpcy5fX29yaWdpbl9fID0geHNjYWxlKGQpO1xuICAgIH0pLm9uKCdkcmFnJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgIGRyYWdnaW5nW2RdID0gTWF0aC5taW4odygpLCBNYXRoLm1heCgwLCB0aGlzLl9fb3JpZ2luX18gKz0gZDMuZXZlbnQuZHgpKTtcblxuICAgICAgX18uZGltZW5zaW9ucy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBwb3NpdGlvbihhKSAtIHBvc2l0aW9uKGIpO1xuICAgICAgfSk7XG5cbiAgICAgIHhzY2FsZS5kb21haW4oX18uZGltZW5zaW9ucyk7XG4gICAgICBwYy5yZW5kZXIoKTtcbiAgICAgIGcuYXR0cigndHJhbnNmb3JtJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHBvc2l0aW9uKGQpICsgJyknO1xuICAgICAgfSk7XG4gICAgfSkub24oJ2RyYWdlbmQnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgLy8gTGV0J3Mgc2VlIGlmIHRoZSBvcmRlciBoYXMgY2hhbmdlZCBhbmQgc2VuZCBvdXQgYW4gZXZlbnQgaWYgc28uXG4gICAgICB2YXIgaSA9IDAsXG4gICAgICAgICAgaiA9IF9fLmRpbWVuc2lvbnMuaW5kZXhPZihkKSxcbiAgICAgICAgICBlbGVtID0gdGhpcyxcbiAgICAgICAgICBwYXJlbnQgPSB0aGlzLnBhcmVudEVsZW1lbnQ7XG5cbiAgICAgIHdoaWxlICgoZWxlbSA9IGVsZW0ucHJldmlvdXNFbGVtZW50U2libGluZykgIT0gbnVsbCkgKytpO1xuXG4gICAgICBpZiAoaSAhPT0gaikge1xuICAgICAgICBldmVudHMuYXhlc3Jlb3JkZXIuY2FsbChwYywgX18uZGltZW5zaW9ucyk7IC8vIFdlIG5vdyBhbHNvIHdhbnQgdG8gcmVvcmRlciB0aGUgYWN0dWFsIGRvbSBlbGVtZW50cyB0aGF0IHJlcHJlc2VudFxuICAgICAgICAvLyB0aGUgYXhlcy4gVGhhdCBpcywgdGhlIGcuZGltZW5zaW9uIGVsZW1lbnRzLiBJZiB3ZSBkb24ndCBkbyB0aGlzLFxuICAgICAgICAvLyB3ZSBnZXQgYSB3ZWlyZCBhbmQgY29uZnVzaW5nIHRyYW5zaXRpb24gd2hlbiB1cGRhdGVBeGVzIGlzIGNhbGxlZC5cbiAgICAgICAgLy8gVGhpcyBpcyBkdWUgdG8gdGhlIGZhY3QgdGhhdCwgaW5pdGlhbGx5IHRoZSBudGggZy5kaW1lbnNpb24gZWxlbWVudFxuICAgICAgICAvLyByZXByZXNlbnRzIHRoZSBudGggYXhpcy4gSG93ZXZlciwgYWZ0ZXIgYSBtYW51YWwgcmVvcmRlcmluZyxcbiAgICAgICAgLy8gd2l0aG91dCByZW9yZGVyaW5nIHRoZSBkb20gZWxlbWVudHMsIHRoZSBudGggZG9tIGVsZW1lbnRzIG5vIGxvbmdlclxuICAgICAgICAvLyBuZWNlc3NhcmlseSByZXByZXNlbnRzIHRoZSBudGggYXhpcy5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gaSBpcyB0aGUgb3JpZ2luYWwgaW5kZXggb2YgdGhlIGRvbSBlbGVtZW50XG4gICAgICAgIC8vIGogaXMgdGhlIG5ldyBpbmRleCBvZiB0aGUgZG9tIGVsZW1lbnRcblxuICAgICAgICBpZiAoaSA+IGopIHtcbiAgICAgICAgICAvLyBFbGVtZW50IG1vdmVkIGxlZnRcbiAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIHBhcmVudC5jaGlsZHJlbltqIC0gMV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEVsZW1lbnQgbW92ZWQgcmlnaHRcbiAgICAgICAgICBpZiAoaiArIDEgPCBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKHRoaXMsIHBhcmVudC5jaGlsZHJlbltqICsgMV0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQodGhpcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGRlbGV0ZSB0aGlzLl9fb3JpZ2luX187XG4gICAgICBkZWxldGUgZHJhZ2dpbmdbZF07XG4gICAgICBkMy5zZWxlY3QodGhpcykudHJhbnNpdGlvbigpLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHhzY2FsZShkKSArICcpJyk7XG4gICAgICBwYy5yZW5kZXIoKTtcbiAgICB9KSk7XG4gICAgZmxhZ3MucmVvcmRlcmFibGUgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBSZW9yZGVyIGRpbWVuc2lvbnMsIHN1Y2ggdGhhdCB0aGUgaGlnaGVzdCB2YWx1ZSAodmlzdWFsbHkpIGlzIG9uIHRoZSBsZWZ0IGFuZFxuICAvLyB0aGUgbG93ZXN0IG9uIHRoZSByaWdodC4gVmlzdWFsIHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZGF0YSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGdpdmVuIHJvdy5cblxuXG4gIHBjLnJlb3JkZXIgPSBmdW5jdGlvbiAocm93ZGF0YSkge1xuICAgIHZhciBkaW1zID0gX18uZGltZW5zaW9ucy5zbGljZSgwKTtcblxuICAgIF9fLmRpbWVuc2lvbnMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgdmFyIHBpeGVsRGlmZmVyZW5jZSA9IHlzY2FsZVthXShyb3dkYXRhW2FdKSAtIHlzY2FsZVtiXShyb3dkYXRhW2JdKTsgLy8gQXJyYXkuc29ydCBpcyBub3QgbmVjZXNzYXJpbHkgc3RhYmxlLCB0aGlzIG1lYW5zIHRoYXQgaWYgcGl4ZWxEaWZmZXJlbmNlIGlzIHplcm9cbiAgICAgIC8vIHRoZSBvcmRlcmluZyBvZiBkaW1lbnNpb25zIG1pZ2h0IGNoYW5nZSB1bmV4cGVjdGVkbHkuIFRoaXMgaXMgc29sdmVkIGJ5IHNvcnRpbmcgb25cbiAgICAgIC8vIHZhcmlhYmxlIG5hbWUgaW4gdGhhdCBjYXNlLlxuXG4gICAgICBpZiAocGl4ZWxEaWZmZXJlbmNlID09PSAwKSB7XG4gICAgICAgIHJldHVybiBhLmxvY2FsZUNvbXBhcmUoYik7XG4gICAgICB9IC8vIGVsc2VcblxuXG4gICAgICByZXR1cm4gcGl4ZWxEaWZmZXJlbmNlO1xuICAgIH0pOyAvLyBOT1RFOiB0aGlzIGlzIHJlbGF0aXZlbHkgY2hlYXAgZ2l2ZW4gdGhhdDpcbiAgICAvLyBudW1iZXIgb2YgZGltZW5zaW9ucyA8IG51bWJlciBvZiBkYXRhIGl0ZW1zXG4gICAgLy8gVGh1cyB3ZSBjaGVjayBlcXVhbGl0eSBvZiBvcmRlciB0byBwcmV2ZW50IHJlcmVuZGVyaW5nIHdoZW4gdGhpcyBpcyB0aGUgY2FzZS5cblxuXG4gICAgdmFyIHJlb3JkZXJlZCA9IGZhbHNlO1xuICAgIGRpbXMuc29tZShmdW5jdGlvbiAodmFsLCBpbmRleCkge1xuICAgICAgcmVvcmRlcmVkID0gdmFsICE9PSBfXy5kaW1lbnNpb25zW2luZGV4XTtcbiAgICAgIHJldHVybiByZW9yZGVyZWQ7XG4gICAgfSk7XG5cbiAgICBpZiAocmVvcmRlcmVkKSB7XG4gICAgICB4c2NhbGUuZG9tYWluKF9fLmRpbWVuc2lvbnMpO1xuXG4gICAgICB2YXIgaGlnaGxpZ2h0ZWQgPSBfXy5oaWdobGlnaHRlZC5zbGljZSgwKTtcblxuICAgICAgcGMudW5oaWdobGlnaHQoKTtcbiAgICAgIGcudHJhbnNpdGlvbigpLmR1cmF0aW9uKDE1MDApLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiAndHJhbnNsYXRlKCcgKyB4c2NhbGUoZCkgKyAnKSc7XG4gICAgICB9KTtcbiAgICAgIHBjLnJlbmRlcigpOyAvLyBwYy5oaWdobGlnaHQoKSBkb2VzIG5vdCBjaGVjayB3aGV0aGVyIGhpZ2hsaWdodGVkIGlzIGxlbmd0aCB6ZXJvLCBzbyB3ZSBkbyB0aGF0IGhlcmUuXG5cbiAgICAgIGlmIChoaWdobGlnaHRlZC5sZW5ndGggIT09IDApIHtcbiAgICAgICAgcGMuaGlnaGxpZ2h0KGhpZ2hsaWdodGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH07IC8vIHBhaXJzIG9mIGFkamFjZW50IGRpbWVuc2lvbnNcblxuXG4gIHBjLmFkamFjZW50X3BhaXJzID0gZnVuY3Rpb24gKGFycikge1xuICAgIHZhciByZXQgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgcmV0LnB1c2goW2FycltpXSwgYXJyW2kgKyAxXV0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgdmFyIGJydXNoID0ge1xuICAgIG1vZGVzOiB7XG4gICAgICBOb25lOiB7XG4gICAgICAgIGluc3RhbGw6IGZ1bmN0aW9uIChwYykge30sXG4gICAgICAgIC8vIE5vdGhpbmcgdG8gYmUgZG9uZS5cbiAgICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAocGMpIHt9LFxuICAgICAgICAvLyBOb3RoaW5nIHRvIGJlIGRvbmUuXG4gICAgICAgIHNlbGVjdGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9LFxuICAgICAgICAvLyBOb3RoaW5nIHRvIHJldHVyblxuICAgICAgICBicnVzaFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBtb2RlOiAnTm9uZScsXG4gICAgcHJlZGljYXRlOiAnQU5EJyxcbiAgICBjdXJyZW50TW9kZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kZXNbdGhpcy5tb2RlXTtcbiAgICB9XG4gIH07IC8vIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgZm9yICdsaXZlJyB1cGRhdGVzIG9mIGJydXNoZXMuIFRoYXQgaXMsIGR1cmluZyB0aGVcbiAgLy8gc3BlY2lmaWNhdGlvbiBvZiBhIGJydXNoLCB0aGlzIG1ldGhvZCBjYW4gYmUgY2FsbGVkIHRvIHVwZGF0ZSB0aGUgdmlldy5cbiAgLy9cbiAgLy8gQHBhcmFtIG5ld1NlbGVjdGlvbiAtIFRoZSBuZXcgc2V0IG9mIGRhdGEgaXRlbXMgdGhhdCBpcyBjdXJyZW50bHkgY29udGFpbmVkXG4gIC8vICAgICAgICAgICAgICAgICAgICAgICBieSB0aGUgYnJ1c2hlc1xuXG4gIGZ1bmN0aW9uIGJydXNoVXBkYXRlZChuZXdTZWxlY3Rpb24pIHtcbiAgICBfXy5icnVzaGVkID0gbmV3U2VsZWN0aW9uO1xuICAgIGV2ZW50cy5icnVzaC5jYWxsKHBjLCBfXy5icnVzaGVkKTtcbiAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gIH1cblxuICBmdW5jdGlvbiBicnVzaFByZWRpY2F0ZShwcmVkaWNhdGUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBicnVzaC5wcmVkaWNhdGU7XG4gICAgfVxuXG4gICAgcHJlZGljYXRlID0gU3RyaW5nKHByZWRpY2F0ZSkudG9VcHBlckNhc2UoKTtcblxuICAgIGlmIChwcmVkaWNhdGUgIT09ICdBTkQnICYmIHByZWRpY2F0ZSAhPT0gJ09SJykge1xuICAgICAgdGhyb3cgJ0ludmFsaWQgcHJlZGljYXRlICcgKyBwcmVkaWNhdGU7XG4gICAgfVxuXG4gICAgYnJ1c2gucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgIF9fLmJydXNoZWQgPSBicnVzaC5jdXJyZW50TW9kZSgpLnNlbGVjdGVkKCk7XG4gICAgcGMucmVuZGVyQnJ1c2hlZCgpO1xuICAgIHJldHVybiBwYztcbiAgfVxuXG4gIHBjLmJydXNoTW9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGJydXNoLm1vZGVzKTtcbiAgfTtcblxuICBwYy5icnVzaE1vZGUgPSBmdW5jdGlvbiAobW9kZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnJ1c2gubW9kZTtcbiAgICB9XG5cbiAgICBpZiAocGMuYnJ1c2hNb2RlcygpLmluZGV4T2YobW9kZSkgPT09IC0xKSB7XG4gICAgICB0aHJvdyAncGMuYnJ1c2htb2RlOiBVbnN1cHBvcnRlZCBicnVzaCBtb2RlOiAnICsgbW9kZTtcbiAgICB9IC8vIE1ha2Ugc3VyZSB0aGF0IHdlIGRvbid0IHRyaWdnZXIgdW5uZWNlc3NhcnkgZXZlbnRzIGJ5IGNoZWNraW5nIGlmIHRoZSBtb2RlXG4gICAgLy8gYWN0dWFsbHkgY2hhbmdlcy5cblxuXG4gICAgaWYgKG1vZGUgIT09IGJydXNoLm1vZGUpIHtcbiAgICAgIC8vIFdoZW4gY2hhbmdpbmcgYnJ1c2ggbW9kZXMsIHRoZSBmaXJzdCB0aGluZyB3ZSBuZWVkIHRvIGRvIGlzIGNsZWFyaW5nIGFueVxuICAgICAgLy8gYnJ1c2hlcyBmcm9tIHRoZSBjdXJyZW50IG1vZGUsIGlmIGFueS5cbiAgICAgIGlmIChicnVzaC5tb2RlICE9PSAnTm9uZScpIHtcbiAgICAgICAgcGMuYnJ1c2hSZXNldCgpO1xuICAgICAgfSAvLyBOZXh0LCB3ZSBuZWVkIHRvICd1bmluc3RhbGwnIHRoZSBjdXJyZW50IGJydXNoTW9kZS5cblxuXG4gICAgICBicnVzaC5tb2Rlc1ticnVzaC5tb2RlXS51bmluc3RhbGwocGMpOyAvLyBGaW5hbGx5LCB3ZSBjYW4gaW5zdGFsbCB0aGUgcmVxdWVzdGVkIG9uZS5cblxuICAgICAgYnJ1c2gubW9kZSA9IG1vZGU7XG4gICAgICBicnVzaC5tb2Rlc1ticnVzaC5tb2RlXS5pbnN0YWxsKCk7XG5cbiAgICAgIGlmIChtb2RlID09PSAnTm9uZScpIHtcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUHJlZGljYXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGMuYnJ1c2hQcmVkaWNhdGUgPSBicnVzaFByZWRpY2F0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcGM7XG4gIH07IC8vIGJydXNoIG1vZGU6IDFELUF4ZXNcblxuXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGJydXNoZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGlzX2JydXNoZWQocCkge1xuICAgICAgcmV0dXJuICFicnVzaGVzW3BdLmVtcHR5KCk7XG4gICAgfSAvLyBkYXRhIHdpdGhpbiBleHRlbnRzXG5cblxuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xuICAgICAgdmFyIGFjdGl2ZXMgPSBfXy5kaW1lbnNpb25zLmZpbHRlcihpc19icnVzaGVkKSxcbiAgICAgICAgICBleHRlbnRzID0gYWN0aXZlcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIGJydXNoZXNbcF0uZXh0ZW50KCk7XG4gICAgICB9KTsgLy8gV2UgZG9uJ3Qgd2FudCB0byByZXR1cm4gdGhlIGZ1bGwgZGF0YSBzZXQgd2hlbiB0aGVyZSBhcmUgbm8gYXhlcyBicnVzaGVkLlxuICAgICAgLy8gQWN0dWFsbHksIHdoZW4gdGhlcmUgYXJlIG5vIGF4ZXMgYnJ1c2hlZCwgYnkgZGVmaW5pdGlvbiwgbm8gaXRlbXMgYXJlXG4gICAgICAvLyBzZWxlY3RlZC4gU28sIGxldCdzIGF2b2lkIHRoZSBmaWx0ZXJpbmcgYW5kIGp1c3QgcmV0dXJuIGZhbHNlLlxuICAgICAgLy9pZiAoYWN0aXZlcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIFJlc29sdmVzIGJyb2tlbiBleGFtcGxlcyBmb3Igbm93LiBUaGV5IGV4cGVjdCB0byBnZXQgdGhlIGZ1bGwgZGF0YXNldCBiYWNrIGZyb20gZW1wdHkgYnJ1c2hlc1xuXG5cbiAgICAgIGlmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIF9fLmRhdGE7IC8vIHRlc3QgaWYgd2l0aGluIHJhbmdlXG5cbiAgICAgIHZhciB3aXRoaW4gPSB7XG4gICAgICAgIGRhdGU6IGZ1bmN0aW9uIChkLCBwLCBkaW1lbnNpb24pIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHlzY2FsZVtwXS5yYW5nZVBvaW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gaWYgaXQgaXMgb3JkaW5hbFxuICAgICAgICAgICAgcmV0dXJuIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGV4dGVudHNbZGltZW5zaW9uXVswXSA8PSBkW3BdICYmIGRbcF0gPD0gZXh0ZW50c1tkaW1lbnNpb25dWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbnVtYmVyOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB5c2NhbGVbcF0ucmFuZ2VQb2ludHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGlmIGl0IGlzIG9yZGluYWxcbiAgICAgICAgICAgIHJldHVybiBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmIHlzY2FsZVtwXShkW3BdKSA8PSBleHRlbnRzW2RpbWVuc2lvbl1bMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0gZFtwXSAmJiBkW3BdIDw9IGV4dGVudHNbZGltZW5zaW9uXVsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN0cmluZzogZnVuY3Rpb24gKGQsIHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgIHJldHVybiBleHRlbnRzW2RpbWVuc2lvbl1bMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmIHlzY2FsZVtwXShkW3BdKSA8PSBleHRlbnRzW2RpbWVuc2lvbl1bMV07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gX18uZGF0YS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgc3dpdGNoIChicnVzaC5wcmVkaWNhdGUpIHtcbiAgICAgICAgICBjYXNlICdBTkQnOlxuICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZXMuZXZlcnkoZnVuY3Rpb24gKHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlICdPUic6XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlcy5zb21lKGZ1bmN0aW9uIChwLCBkaW1lbnNpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHdpdGhpbltfXy50eXBlc1twXV0oZCwgcCwgZGltZW5zaW9uKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICdVbmtub3duIGJydXNoIHByZWRpY2F0ZSAnICsgX18uYnJ1c2hQcmVkaWNhdGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoRXh0ZW50cyhleHRlbnRzKSB7XG4gICAgICBpZiAodHlwZW9mIGV4dGVudHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBleHRlbnRzID0ge307XG5cbiAgICAgICAgX18uZGltZW5zaW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgdmFyIGJydXNoID0gYnJ1c2hlc1tkXTtcblxuICAgICAgICAgIGlmIChicnVzaCAhPT0gdW5kZWZpbmVkICYmICFicnVzaC5lbXB0eSgpKSB7XG4gICAgICAgICAgICB2YXIgZXh0ZW50ID0gYnJ1c2guZXh0ZW50KCk7XG4gICAgICAgICAgICBleHRlbnQuc29ydChkMy5hc2NlbmRpbmcpO1xuICAgICAgICAgICAgZXh0ZW50c1tkXSA9IGV4dGVudDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBleHRlbnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy9maXJzdCBnZXQgYWxsIHRoZSBicnVzaCBzZWxlY3Rpb25zXG4gICAgICAgIHZhciBicnVzaFNlbGVjdGlvbnMgPSB7fTtcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLmVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBicnVzaFNlbGVjdGlvbnNbZF0gPSBkMy5zZWxlY3QodGhpcyk7XG4gICAgICAgIH0pOyAvLyBsb29wIG92ZXIgZWFjaCBkaW1lbnNpb24gYW5kIHVwZGF0ZSBhcHByb3ByaWF0ZWx5IChpZiBpdCB3YXMgcGFzc2VkIGluIHRocm91Z2ggZXh0ZW50cylcblxuICAgICAgICBfXy5kaW1lbnNpb25zLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBpZiAoZXh0ZW50c1tkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGJydXNoID0gYnJ1c2hlc1tkXTtcblxuICAgICAgICAgIGlmIChicnVzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvL3VwZGF0ZSB0aGUgZXh0ZW50XG4gICAgICAgICAgICBicnVzaC5leHRlbnQoZXh0ZW50c1tkXSk7IC8vcmVkcmF3IHRoZSBicnVzaFxuXG4gICAgICAgICAgICBicnVzaChicnVzaFNlbGVjdGlvbnNbZF0pOyAvL2ZpcmUgc29tZSBldmVudHNcblxuICAgICAgICAgICAgYnJ1c2guZXZlbnQoYnJ1c2hTZWxlY3Rpb25zW2RdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pOyAvL3JlZHJhdyB0aGUgY2hhcnRcblxuXG4gICAgICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicnVzaEZvcihheGlzKSB7XG4gICAgICB2YXIgYnJ1c2ggPSBkMy5zdmcuYnJ1c2goKTtcbiAgICAgIGJydXNoLnkoeXNjYWxlW2F4aXNdKS5vbignYnJ1c2hzdGFydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGQzLmV2ZW50LnNvdXJjZUV2ZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgZDMuZXZlbnQuc291cmNlRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgIH0pLm9uKCdicnVzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYnJ1c2hVcGRhdGVkKHNlbGVjdGVkKCkpO1xuICAgICAgfSkub24oJ2JydXNoZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBldmVudHMuYnJ1c2hlbmQuY2FsbChwYywgX18uYnJ1c2hlZCk7XG4gICAgICB9KTtcbiAgICAgIGJydXNoZXNbYXhpc10gPSBicnVzaDtcbiAgICAgIHJldHVybiBicnVzaDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicnVzaFJlc2V0KGRpbWVuc2lvbikge1xuICAgICAgX18uYnJ1c2hlZCA9IGZhbHNlO1xuXG4gICAgICBpZiAoZykge1xuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGJydXNoZXNbZF0uY2xlYXIoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGwoKSB7XG4gICAgICBpZiAoIWcpIHBjLmNyZWF0ZUF4ZXMoKTsgLy8gQWRkIGFuZCBzdG9yZSBhIGJydXNoIGZvciBlYWNoIGF4aXMuXG5cbiAgICAgIGcuYXBwZW5kKCdzdmc6ZycpLmF0dHIoJ2NsYXNzJywgJ2JydXNoJykuZWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICBkMy5zZWxlY3QodGhpcykuY2FsbChicnVzaEZvcihkKSk7XG4gICAgICB9KS5zZWxlY3RBbGwoJ3JlY3QnKS5zdHlsZSgndmlzaWJpbGl0eScsIG51bGwpLmF0dHIoJ3gnLCAtMTUpLmF0dHIoJ3dpZHRoJywgMzApO1xuICAgICAgcGMuYnJ1c2hFeHRlbnRzID0gYnJ1c2hFeHRlbnRzO1xuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQ7XG4gICAgICByZXR1cm4gcGM7XG4gICAgfVxuXG4gICAgYnJ1c2gubW9kZXNbJzFELWF4ZXMnXSA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwsXG4gICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZy5zZWxlY3RBbGwoJy5icnVzaCcpLnJlbW92ZSgpO1xuICAgICAgICBicnVzaGVzID0ge307XG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaEV4dGVudHM7XG4gICAgICAgIGRlbGV0ZSBwYy5icnVzaFJlc2V0O1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIGJydXNoU3RhdGU6IGJydXNoRXh0ZW50c1xuICAgIH07XG4gIH0pKCk7IC8vIGJydXNoIG1vZGU6IDJELXN0cnVtc1xuICAvLyBibC5vY2tzLm9yZy9zeW50YWdtYXRpYy81NDQxMDIyXG5cblxuICAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdHJ1bXMgPSB7fSxcbiAgICAgICAgc3RydW1SZWN0O1xuXG4gICAgZnVuY3Rpb24gZHJhd1N0cnVtKHN0cnVtLCBhY3RpdmVQb2ludCkge1xuICAgICAgdmFyIHN2ZyA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNzdHJ1bXMnKSxcbiAgICAgICAgICBpZCA9IHN0cnVtLmRpbXMuaSxcbiAgICAgICAgICBwb2ludHMgPSBbc3RydW0ucDEsIHN0cnVtLnAyXSxcbiAgICAgICAgICBsaW5lID0gc3ZnLnNlbGVjdEFsbCgnbGluZSNzdHJ1bS0nICsgaWQpLmRhdGEoW3N0cnVtXSksXG4gICAgICAgICAgY2lyY2xlcyA9IHN2Zy5zZWxlY3RBbGwoJ2NpcmNsZSNzdHJ1bS0nICsgaWQpLmRhdGEocG9pbnRzKSxcbiAgICAgICAgICBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpO1xuICAgICAgbGluZS5lbnRlcigpLmFwcGVuZCgnbGluZScpLmF0dHIoJ2lkJywgJ3N0cnVtLScgKyBpZCkuYXR0cignY2xhc3MnLCAnc3RydW0nKTtcbiAgICAgIGxpbmUuYXR0cigneDEnLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5wMVswXTtcbiAgICAgIH0pLmF0dHIoJ3kxJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQucDFbMV07XG4gICAgICB9KS5hdHRyKCd4MicsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnAyWzBdO1xuICAgICAgfSkuYXR0cigneTInLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5wMlsxXTtcbiAgICAgIH0pLmF0dHIoJ3N0cm9rZScsICdibGFjaycpLmF0dHIoJ3N0cm9rZS13aWR0aCcsIDIpO1xuICAgICAgZHJhZy5vbignZHJhZycsIGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgIHZhciBldiA9IGQzLmV2ZW50O1xuICAgICAgICBpID0gaSArIDE7XG4gICAgICAgIHN0cnVtWydwJyArIGldWzBdID0gTWF0aC5taW4oTWF0aC5tYXgoc3RydW0ubWluWCArIDEsIGV2LngpLCBzdHJ1bS5tYXhYKTtcbiAgICAgICAgc3RydW1bJ3AnICsgaV1bMV0gPSBNYXRoLm1pbihNYXRoLm1heChzdHJ1bS5taW5ZLCBldi55KSwgc3RydW0ubWF4WSk7XG4gICAgICAgIGRyYXdTdHJ1bShzdHJ1bSwgaSAtIDEpO1xuICAgICAgfSkub24oJ2RyYWdlbmQnLCBvbkRyYWdFbmQoKSk7XG4gICAgICBjaXJjbGVzLmVudGVyKCkuYXBwZW5kKCdjaXJjbGUnKS5hdHRyKCdpZCcsICdzdHJ1bS0nICsgaWQpLmF0dHIoJ2NsYXNzJywgJ3N0cnVtJyk7XG4gICAgICBjaXJjbGVzLmF0dHIoJ2N4JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGRbMF07XG4gICAgICB9KS5hdHRyKCdjeScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkWzFdO1xuICAgICAgfSkuYXR0cigncicsIDUpLnN0eWxlKCdvcGFjaXR5JywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZVBvaW50ICE9PSB1bmRlZmluZWQgJiYgaSA9PT0gYWN0aXZlUG9pbnQgPyAwLjggOiAwO1xuICAgICAgfSkub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5JywgMC44KTtcbiAgICAgIH0pLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5JywgMCk7XG4gICAgICB9KS5jYWxsKGRyYWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpbWVuc2lvbnNGb3JQb2ludChwKSB7XG4gICAgICB2YXIgZGltcyA9IHtcbiAgICAgICAgaTogLTEsXG4gICAgICAgIGxlZnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcmlnaHQ6IHVuZGVmaW5lZFxuICAgICAgfTtcblxuICAgICAgX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkaW0sIGkpIHtcbiAgICAgICAgaWYgKHhzY2FsZShkaW0pIDwgcFswXSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gX18uZGltZW5zaW9uc1tpICsgMV07XG4gICAgICAgICAgZGltcy5pID0gaTtcbiAgICAgICAgICBkaW1zLmxlZnQgPSBkaW07XG4gICAgICAgICAgZGltcy5yaWdodCA9IG5leHQ7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGRpbXMubGVmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEV2ZW50IG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGZpcnN0IGF4aXMuXG4gICAgICAgIGRpbXMuaSA9IDA7XG4gICAgICAgIGRpbXMubGVmdCA9IF9fLmRpbWVuc2lvbnNbMF07XG4gICAgICAgIGRpbXMucmlnaHQgPSBfXy5kaW1lbnNpb25zWzFdO1xuICAgICAgfSBlbHNlIGlmIChkaW1zLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRXZlbnQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGxhc3QgYXhpc1xuICAgICAgICBkaW1zLmkgPSBfXy5kaW1lbnNpb25zLmxlbmd0aCAtIDE7XG4gICAgICAgIGRpbXMucmlnaHQgPSBkaW1zLmxlZnQ7XG4gICAgICAgIGRpbXMubGVmdCA9IF9fLmRpbWVuc2lvbnNbX18uZGltZW5zaW9ucy5sZW5ndGggLSAyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpbXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EcmFnU3RhcnQoKSB7XG4gICAgICAvLyBGaXJzdCB3ZSBuZWVkIHRvIGRldGVybWluZSBiZXR3ZWVuIHdoaWNoIHR3byBheGVzIHRoZSBzdHVybSB3YXMgc3RhcnRlZC5cbiAgICAgIC8vIFRoaXMgd2lsbCBkZXRlcm1pbmUgdGhlIGZyZWVkb20gb2YgbW92ZW1lbnQsIGJlY2F1c2UgYSBzdHJ1bSBjYW5cbiAgICAgIC8vIGxvZ2ljYWxseSBvbmx5IGhhcHBlbiBiZXR3ZWVuIHR3byBheGVzLCBzbyBubyBtb3ZlbWVudCBvdXRzaWRlIHRoZXNlIGF4ZXNcbiAgICAgIC8vIHNob3VsZCBiZSBhbGxvd2VkLlxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHAgPSBkMy5tb3VzZShzdHJ1bVJlY3RbMF1bMF0pLFxuICAgICAgICAgICAgZGltcyxcbiAgICAgICAgICAgIHN0cnVtO1xuICAgICAgICBwWzBdID0gcFswXSAtIF9fLm1hcmdpbi5sZWZ0O1xuICAgICAgICBwWzFdID0gcFsxXSAtIF9fLm1hcmdpbi50b3A7XG4gICAgICAgIGRpbXMgPSBkaW1lbnNpb25zRm9yUG9pbnQocCksIHN0cnVtID0ge1xuICAgICAgICAgIHAxOiBwLFxuICAgICAgICAgIGRpbXM6IGRpbXMsXG4gICAgICAgICAgbWluWDogeHNjYWxlKGRpbXMubGVmdCksXG4gICAgICAgICAgbWF4WDogeHNjYWxlKGRpbXMucmlnaHQpLFxuICAgICAgICAgIG1pblk6IDAsXG4gICAgICAgICAgbWF4WTogaCgpXG4gICAgICAgIH07XG4gICAgICAgIHN0cnVtc1tkaW1zLmldID0gc3RydW07XG4gICAgICAgIHN0cnVtcy5hY3RpdmUgPSBkaW1zLmk7IC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuXG4gICAgICAgIHN0cnVtLnAxWzBdID0gTWF0aC5taW4oTWF0aC5tYXgoc3RydW0ubWluWCwgcFswXSksIHN0cnVtLm1heFgpO1xuICAgICAgICBzdHJ1bS5wMiA9IHN0cnVtLnAxLnNsaWNlKCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uRHJhZygpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBldiA9IGQzLmV2ZW50LFxuICAgICAgICAgICAgc3RydW0gPSBzdHJ1bXNbc3RydW1zLmFjdGl2ZV07IC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBwb2ludCBpcyB3aXRoaW4gdGhlIGJvdW5kc1xuXG4gICAgICAgIHN0cnVtLnAyWzBdID0gTWF0aC5taW4oTWF0aC5tYXgoc3RydW0ubWluWCArIDEsIGV2LnggLSBfXy5tYXJnaW4ubGVmdCksIHN0cnVtLm1heFgpO1xuICAgICAgICBzdHJ1bS5wMlsxXSA9IE1hdGgubWluKE1hdGgubWF4KHN0cnVtLm1pblksIGV2LnkgLSBfXy5tYXJnaW4udG9wKSwgc3RydW0ubWF4WSk7XG4gICAgICAgIGRyYXdTdHJ1bShzdHJ1bSwgMSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5tZW50VGVzdChzdHJ1bSwgd2lkdGgpIHtcbiAgICAgIHZhciBwMSA9IFtzdHJ1bS5wMVswXSAtIHN0cnVtLm1pblgsIHN0cnVtLnAxWzFdIC0gc3RydW0ubWluWF0sXG4gICAgICAgICAgcDIgPSBbc3RydW0ucDJbMF0gLSBzdHJ1bS5taW5YLCBzdHJ1bS5wMlsxXSAtIHN0cnVtLm1pblhdLFxuICAgICAgICAgIG0xID0gMSAtIHdpZHRoIC8gcDFbMF0sXG4gICAgICAgICAgYjEgPSBwMVsxXSAqICgxIC0gbTEpLFxuICAgICAgICAgIG0yID0gMSAtIHdpZHRoIC8gcDJbMF0sXG4gICAgICAgICAgYjIgPSBwMlsxXSAqICgxIC0gbTIpOyAvLyB0ZXN0IGlmIHBvaW50IGZhbGxzIGJldHdlZW4gbGluZXNcblxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwKSB7XG4gICAgICAgIHZhciB4ID0gcFswXSxcbiAgICAgICAgICAgIHkgPSBwWzFdLFxuICAgICAgICAgICAgeTEgPSBtMSAqIHggKyBiMSxcbiAgICAgICAgICAgIHkyID0gbTIgKiB4ICsgYjI7XG5cbiAgICAgICAgaWYgKHkgPiBNYXRoLm1pbih5MSwgeTIpICYmIHkgPCBNYXRoLm1heCh5MSwgeTIpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xuICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0cnVtcyksXG4gICAgICAgICAgYnJ1c2hlZCA9IF9fLmRhdGE7IC8vIEdldCB0aGUgaWRzIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIHN0cnVtcy5cblxuICAgICAgaWRzID0gaWRzLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gIWlzTmFOKGQpO1xuICAgICAgfSk7XG5cbiAgICAgIGZ1bmN0aW9uIGNyb3NzZXNTdHJ1bShkLCBpZCkge1xuICAgICAgICB2YXIgc3RydW0gPSBzdHJ1bXNbaWRdLFxuICAgICAgICAgICAgdGVzdCA9IGNvbnRhaW5tZW50VGVzdChzdHJ1bSwgc3RydW1zLndpZHRoKGlkKSksXG4gICAgICAgICAgICBkMSA9IHN0cnVtLmRpbXMubGVmdCxcbiAgICAgICAgICAgIGQyID0gc3RydW0uZGltcy5yaWdodCxcbiAgICAgICAgICAgIHkxID0geXNjYWxlW2QxXSxcbiAgICAgICAgICAgIHkyID0geXNjYWxlW2QyXSxcbiAgICAgICAgICAgIHBvaW50ID0gW3kxKGRbZDFdKSAtIHN0cnVtLm1pblgsIHkyKGRbZDJdKSAtIHN0cnVtLm1pblhdO1xuICAgICAgICByZXR1cm4gdGVzdChwb2ludCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBicnVzaGVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJ1c2hlZC5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgc3dpdGNoIChicnVzaC5wcmVkaWNhdGUpIHtcbiAgICAgICAgICBjYXNlICdBTkQnOlxuICAgICAgICAgICAgcmV0dXJuIGlkcy5ldmVyeShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZXNTdHJ1bShkLCBpZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgJ09SJzpcbiAgICAgICAgICAgIHJldHVybiBpZHMuc29tZShmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZXNTdHJ1bShkLCBpZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyAnVW5rbm93biBicnVzaCBwcmVkaWNhdGUgJyArIF9fLmJydXNoUHJlZGljYXRlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZW1vdmVTdHJ1bSgpIHtcbiAgICAgIHZhciBzdHJ1bSA9IHN0cnVtc1tzdHJ1bXMuYWN0aXZlXSxcbiAgICAgICAgICBzdmcgPSBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ2cjc3RydW1zJyk7XG4gICAgICBkZWxldGUgc3RydW1zW3N0cnVtcy5hY3RpdmVdO1xuICAgICAgc3RydW1zLmFjdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHN2Zy5zZWxlY3RBbGwoJ2xpbmUjc3RydW0tJyArIHN0cnVtLmRpbXMuaSkucmVtb3ZlKCk7XG4gICAgICBzdmcuc2VsZWN0QWxsKCdjaXJjbGUjc3RydW0tJyArIHN0cnVtLmRpbXMuaSkucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EcmFnRW5kKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJydXNoZWQgPSBfXy5kYXRhLFxuICAgICAgICAgICAgc3RydW0gPSBzdHJ1bXNbc3RydW1zLmFjdGl2ZV07IC8vIE9rYXksIHNvbWV3aGF0IHVuZXhwZWN0ZWQsIGJ1dCBub3QgdG90YWxseSB1bnN1cnByaXNpbmcsIGEgbW91c2NsaWNrIGlzXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgYSBkcmFnIHdpdGhvdXQgbW92ZS4gU28gd2UgaGF2ZSB0byBkZWFsIHdpdGggdGhhdCBjYXNlXG5cbiAgICAgICAgaWYgKHN0cnVtICYmIHN0cnVtLnAxWzBdID09PSBzdHJ1bS5wMlswXSAmJiBzdHJ1bS5wMVsxXSA9PT0gc3RydW0ucDJbMV0pIHtcbiAgICAgICAgICByZW1vdmVTdHJ1bShzdHJ1bXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJ1c2hlZCA9IHNlbGVjdGVkKHN0cnVtcyk7XG4gICAgICAgIHN0cnVtcy5hY3RpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIF9fLmJydXNoZWQgPSBicnVzaGVkO1xuICAgICAgICBwYy5yZW5kZXJCcnVzaGVkKCk7XG4gICAgICAgIGV2ZW50cy5icnVzaGVuZC5jYWxsKHBjLCBfXy5icnVzaGVkKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnJ1c2hSZXNldChzdHJ1bXMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhzdHJ1bXMpLmZpbHRlcihmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHJldHVybiAhaXNOYU4oZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZHMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgIHN0cnVtcy5hY3RpdmUgPSBkO1xuICAgICAgICAgIHJlbW92ZVN0cnVtKHN0cnVtcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbkRyYWdFbmQoc3RydW1zKSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsKCkge1xuICAgICAgdmFyIGRyYWcgPSBkMy5iZWhhdmlvci5kcmFnKCk7IC8vIE1hcCBvZiBjdXJyZW50IHN0cnVtcy4gU3RydW1zIGFyZSBzdG9yZWQgcGVyIHNlZ21lbnQgb2YgdGhlIFBDLiBBIHNlZ21lbnQsXG4gICAgICAvLyBiZWluZyB0aGUgYXJlYSBiZXR3ZWVuIHR3byBheGVzLiBUaGUgbGVmdCBtb3N0IGFyZWEgaXMgaW5kZXhlZCBhdCAwLlxuXG4gICAgICBzdHJ1bXMuYWN0aXZlID0gdW5kZWZpbmVkOyAvLyBSZXR1cm5zIHRoZSB3aWR0aCBvZiB0aGUgUEMgc2VnbWVudCB3aGVyZSBjdXJyZW50bHkgYSBzdHJ1bSBpcyBiZWluZ1xuICAgICAgLy8gcGxhY2VkLiBOT1RFOiBldmVuIHRob3VnaCB0aGV5IGFyZSBldmVubHkgc3BhY2VkIGluIG91ciBjdXJyZW50XG4gICAgICAvLyBpbXBsZW1lbnRhdGlvbiwgd2Uga2VlcCBmb3Igd2hlbiBub24tZXZlbiBzcGFjZWQgc2VnbWVudHMgYXJlIHN1cHBvcnRlZCBhc1xuICAgICAgLy8gd2VsbC5cblxuICAgICAgc3RydW1zLndpZHRoID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBzdHJ1bSA9IHN0cnVtc1tpZF07XG5cbiAgICAgICAgaWYgKHN0cnVtID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0cnVtLm1heFggLSBzdHJ1bS5taW5YO1xuICAgICAgfTtcblxuICAgICAgcGMub24oJ2F4ZXNyZW9yZGVyLnN0cnVtcycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGlkcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHN0cnVtcykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgICAgfSk7IC8vIENoZWNrcyBpZiB0aGUgZmlyc3QgZGltZW5zaW9uIGlzIGRpcmVjdGx5IGxlZnQgb2YgdGhlIHNlY29uZCBkaW1lbnNpb24uXG5cbiAgICAgICAgZnVuY3Rpb24gY29uc2VjdXRpdmUoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBfXy5kaW1lbnNpb25zLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZCA9PT0gZmlyc3QgPyBpICsgaSA8IGxlbmd0aCAmJiBfXy5kaW1lbnNpb25zW2kgKyAxXSA9PT0gc2Vjb25kIDogZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIHNvbWUgc3RydW1zLCB3aGljaCBtaWdodCBuZWVkIHRvIGJlIHJlbW92ZWQuXG4gICAgICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgIHZhciBkaW1zID0gc3RydW1zW2RdLmRpbXM7XG4gICAgICAgICAgICBzdHJ1bXMuYWN0aXZlID0gZDsgLy8gSWYgdGhlIHR3byBkaW1lbnNpb25zIG9mIHRoZSBjdXJyZW50IHN0cnVtIGFyZSBub3QgbmV4dCB0byBlYWNoIG90aGVyXG4gICAgICAgICAgICAvLyBhbnkgbW9yZSwgdGhhbiB3ZSdsbCBuZWVkIHRvIHJlbW92ZSB0aGUgc3RydW0uIE90aGVyd2lzZSB3ZSBrZWVwIGl0LlxuXG4gICAgICAgICAgICBpZiAoIWNvbnNlY3V0aXZlKGRpbXMubGVmdCwgZGltcy5yaWdodCkpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlU3RydW0oc3RydW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvbkRyYWdFbmQoc3RydW1zKSgpO1xuICAgICAgICB9XG4gICAgICB9KTsgLy8gQWRkIGEgbmV3IHN2ZyBncm91cCBpbiB3aGljaCB3ZSBkcmF3IHRoZSBzdHJ1bXMuXG5cbiAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLmFwcGVuZCgnZycpLmF0dHIoJ2lkJywgJ3N0cnVtcycpLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIF9fLm1hcmdpbi5sZWZ0ICsgJywnICsgX18ubWFyZ2luLnRvcCArICcpJyk7IC8vIEluc3RhbGwgdGhlIHJlcXVpcmVkIGJydXNoUmVzZXQgZnVuY3Rpb25cblxuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQoc3RydW1zKTtcbiAgICAgIGRyYWcub24oJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0KHN0cnVtcykpLm9uKCdkcmFnJywgb25EcmFnKHN0cnVtcykpLm9uKCdkcmFnZW5kJywgb25EcmFnRW5kKHN0cnVtcykpOyAvLyBOT1RFOiBUaGUgc3R5bGluZyBuZWVkcyB0byBiZSBkb25lIGhlcmUgYW5kIG5vdCBpbiB0aGUgY3NzLiBUaGlzIGlzIGJlY2F1c2VcbiAgICAgIC8vICAgICAgIGZvciAxRCBicnVzaGluZywgdGhlIGNhbnZhcyBsYXllcnMgc2hvdWxkIG5vdCBsaXN0ZW4gdG9cbiAgICAgIC8vICAgICAgIHBvaW50ZXItZXZlbnRzLlxuXG4gICAgICBzdHJ1bVJlY3QgPSBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5pbnNlcnQoJ3JlY3QnLCAnZyNzdHJ1bXMnKS5hdHRyKCdpZCcsICdzdHJ1bS1ldmVudHMnKS5hdHRyKCd4JywgX18ubWFyZ2luLmxlZnQpLmF0dHIoJ3knLCBfXy5tYXJnaW4udG9wKS5hdHRyKCd3aWR0aCcsIHcoKSkuYXR0cignaGVpZ2h0JywgaCgpICsgMikuc3R5bGUoJ29wYWNpdHknLCAwKS5jYWxsKGRyYWcpO1xuICAgIH1cblxuICAgIGJydXNoLm1vZGVzWycyRC1zdHJ1bXMnXSA9IHtcbiAgICAgIGluc3RhbGw6IGluc3RhbGwsXG4gICAgICB1bmluc3RhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI3N0cnVtcycpLnJlbW92ZSgpO1xuICAgICAgICBwYy5zZWxlY3Rpb24uc2VsZWN0KCdzdmcnKS5zZWxlY3QoJ3JlY3Qjc3RydW0tZXZlbnRzJykucmVtb3ZlKCk7XG4gICAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5zdHJ1bXMnLCB1bmRlZmluZWQpO1xuICAgICAgICBkZWxldGUgcGMuYnJ1c2hSZXNldDtcbiAgICAgICAgc3RydW1SZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgfSxcbiAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZCxcbiAgICAgIGJydXNoU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHN0cnVtcztcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpOyAvLyBicnVzaCBtb2RlOiAxRC1BeGVzIHdpdGggbXVsdGlwbGUgZXh0ZW50c1xuICAvLyByZXF1aXJlcyBkMy5zdmcubXVsdGlicnVzaFxuXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIGQzLnN2Zy5tdWx0aWJydXNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJydXNoZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGlzX2JydXNoZWQocCkge1xuICAgICAgcmV0dXJuICFicnVzaGVzW3BdLmVtcHR5KCk7XG4gICAgfSAvLyBkYXRhIHdpdGhpbiBleHRlbnRzXG5cblxuICAgIGZ1bmN0aW9uIHNlbGVjdGVkKCkge1xuICAgICAgdmFyIGFjdGl2ZXMgPSBfXy5kaW1lbnNpb25zLmZpbHRlcihpc19icnVzaGVkKSxcbiAgICAgICAgICBleHRlbnRzID0gYWN0aXZlcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgcmV0dXJuIGJydXNoZXNbcF0uZXh0ZW50KCk7XG4gICAgICB9KTsgLy8gV2UgZG9uJ3Qgd2FudCB0byByZXR1cm4gdGhlIGZ1bGwgZGF0YSBzZXQgd2hlbiB0aGVyZSBhcmUgbm8gYXhlcyBicnVzaGVkLlxuICAgICAgLy8gQWN0dWFsbHksIHdoZW4gdGhlcmUgYXJlIG5vIGF4ZXMgYnJ1c2hlZCwgYnkgZGVmaW5pdGlvbiwgbm8gaXRlbXMgYXJlXG4gICAgICAvLyBzZWxlY3RlZC4gU28sIGxldCdzIGF2b2lkIHRoZSBmaWx0ZXJpbmcgYW5kIGp1c3QgcmV0dXJuIGZhbHNlLlxuICAgICAgLy9pZiAoYWN0aXZlcy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIFJlc29sdmVzIGJyb2tlbiBleGFtcGxlcyBmb3Igbm93LiBUaGV5IGV4cGVjdCB0byBnZXQgdGhlIGZ1bGwgZGF0YXNldCBiYWNrIGZyb20gZW1wdHkgYnJ1c2hlc1xuXG5cbiAgICAgIGlmIChhY3RpdmVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIF9fLmRhdGE7IC8vIHRlc3QgaWYgd2l0aGluIHJhbmdlXG5cbiAgICAgIHZhciB3aXRoaW4gPSB7XG4gICAgICAgIGRhdGU6IGZ1bmN0aW9uIChkLCBwLCBkaW1lbnNpb24sIGIpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHlzY2FsZVtwXS5yYW5nZVBvaW50cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgLy8gaWYgaXQgaXMgb3JkaW5hbFxuICAgICAgICAgICAgcmV0dXJuIGJbMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmIHlzY2FsZVtwXShkW3BdKSA8PSBiWzFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gYlswXSA8PSBkW3BdICYmIGRbcF0gPD0gYlsxXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG51bWJlcjogZnVuY3Rpb24gKGQsIHAsIGRpbWVuc2lvbiwgYikge1xuICAgICAgICAgIGlmICh0eXBlb2YgeXNjYWxlW3BdLnJhbmdlUG9pbnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBpZiBpdCBpcyBvcmRpbmFsXG4gICAgICAgICAgICByZXR1cm4gYlswXSA8PSB5c2NhbGVbcF0oZFtwXSkgJiYgeXNjYWxlW3BdKGRbcF0pIDw9IGJbMV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBiWzBdIDw9IGRbcF0gJiYgZFtwXSA8PSBiWzFdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc3RyaW5nOiBmdW5jdGlvbiAoZCwgcCwgZGltZW5zaW9uLCBiKSB7XG4gICAgICAgICAgcmV0dXJuIGJbMF0gPD0geXNjYWxlW3BdKGRbcF0pICYmIHlzY2FsZVtwXShkW3BdKSA8PSBiWzFdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIF9fLmRhdGEuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHN3aXRjaCAoYnJ1c2gucHJlZGljYXRlKSB7XG4gICAgICAgICAgY2FzZSAnQU5EJzpcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVzLmV2ZXJ5KGZ1bmN0aW9uIChwLCBkaW1lbnNpb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4dGVudHNbZGltZW5zaW9uXS5zb21lKGZ1bmN0aW9uIChiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHdpdGhpbltfXy50eXBlc1twXV0oZCwgcCwgZGltZW5zaW9uLCBiKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgIGNhc2UgJ09SJzpcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVzLnNvbWUoZnVuY3Rpb24gKHAsIGRpbWVuc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4gZXh0ZW50c1tkaW1lbnNpb25dLnNvbWUoZnVuY3Rpb24gKGIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aGluW19fLnR5cGVzW3BdXShkLCBwLCBkaW1lbnNpb24sIGIpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICdVbmtub3duIGJydXNoIHByZWRpY2F0ZSAnICsgX18uYnJ1c2hQcmVkaWNhdGU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoRXh0ZW50cygpIHtcbiAgICAgIHZhciBleHRlbnRzID0ge307XG5cbiAgICAgIF9fLmRpbWVuc2lvbnMuZm9yRWFjaChmdW5jdGlvbiAoZCkge1xuICAgICAgICB2YXIgYnJ1c2ggPSBicnVzaGVzW2RdO1xuXG4gICAgICAgIGlmIChicnVzaCAhPT0gdW5kZWZpbmVkICYmICFicnVzaC5lbXB0eSgpKSB7XG4gICAgICAgICAgdmFyIGV4dGVudCA9IGJydXNoLmV4dGVudCgpO1xuICAgICAgICAgIGV4dGVudHNbZF0gPSBleHRlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gZXh0ZW50cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicnVzaEZvcihheGlzKSB7XG4gICAgICB2YXIgYnJ1c2ggPSBkMy5zdmcubXVsdGlicnVzaCgpO1xuICAgICAgYnJ1c2gueSh5c2NhbGVbYXhpc10pLm9uKCdicnVzaHN0YXJ0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBkMy5ldmVudC5zb3VyY2VFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgfSkub24oJ2JydXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBicnVzaFVwZGF0ZWQoc2VsZWN0ZWQoKSk7XG4gICAgICB9KS5vbignYnJ1c2hlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGQzLnN2Zy5tdWx0aWJydXNoIGNsZWFycyBleHRlbnRzIGp1c3QgYmVmb3JlIGNhbGxpbmcgJ2JydXNoZW5kJ1xuICAgICAgICAvLyBzbyB3ZSBoYXZlIHRvIHVwZGF0ZSBoZXJlIGFnYWluLlxuICAgICAgICAvLyBUaGlzIGZpeGVzIGlzc3VlICMxMDMgZm9yIG5vdywgYnV0IHNob3VsZCBiZSBjaGFuZ2VkIGluIGQzLnN2Zy5tdWx0aWJydXNoXG4gICAgICAgIC8vIHRvIGF2b2lkIHVubmVjZXNzYXJ5IGNvbXB1dGF0aW9uLlxuICAgICAgICBicnVzaFVwZGF0ZWQoc2VsZWN0ZWQoKSk7XG4gICAgICAgIGV2ZW50cy5icnVzaGVuZC5jYWxsKHBjLCBfXy5icnVzaGVkKTtcbiAgICAgIH0pLmV4dGVudEFkYXB0aW9uKGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICAgICAgc2VsZWN0aW9uLnN0eWxlKCd2aXNpYmlsaXR5JywgbnVsbCkuYXR0cigneCcsIC0xNSkuYXR0cignd2lkdGgnLCAzMCk7XG4gICAgICB9KS5yZXNpemVBZGFwdGlvbihmdW5jdGlvbiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbi5zZWxlY3RBbGwoJ3JlY3QnKS5hdHRyKCd4JywgLTE1KS5hdHRyKCd3aWR0aCcsIDMwKTtcbiAgICAgIH0pO1xuICAgICAgYnJ1c2hlc1theGlzXSA9IGJydXNoO1xuICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJydXNoUmVzZXQoZGltZW5zaW9uKSB7XG4gICAgICBfXy5icnVzaGVkID0gZmFsc2U7XG5cbiAgICAgIGlmIChnKSB7XG4gICAgICAgIGcuc2VsZWN0QWxsKCcuYnJ1c2gnKS5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgZDMuc2VsZWN0KHRoaXMpLmNhbGwoYnJ1c2hlc1tkXS5jbGVhcigpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgIGlmICghZykgcGMuY3JlYXRlQXhlcygpOyAvLyBBZGQgYW5kIHN0b3JlIGEgYnJ1c2ggZm9yIGVhY2ggYXhpcy5cblxuICAgICAgZy5hcHBlbmQoJ3N2ZzpnJykuYXR0cignY2xhc3MnLCAnYnJ1c2gnKS5lYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIGQzLnNlbGVjdCh0aGlzKS5jYWxsKGJydXNoRm9yKGQpKTtcbiAgICAgIH0pLnNlbGVjdEFsbCgncmVjdCcpLnN0eWxlKCd2aXNpYmlsaXR5JywgbnVsbCkuYXR0cigneCcsIC0xNSkuYXR0cignd2lkdGgnLCAzMCk7XG4gICAgICBwYy5icnVzaEV4dGVudHMgPSBicnVzaEV4dGVudHM7XG4gICAgICBwYy5icnVzaFJlc2V0ID0gYnJ1c2hSZXNldDtcbiAgICAgIHJldHVybiBwYztcbiAgICB9XG5cbiAgICBicnVzaC5tb2Rlc1snMUQtYXhlcy1tdWx0aSddID0ge1xuICAgICAgaW5zdGFsbDogaW5zdGFsbCxcbiAgICAgIHVuaW5zdGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICBnLnNlbGVjdEFsbCgnLmJydXNoJykucmVtb3ZlKCk7XG4gICAgICAgIGJydXNoZXMgPSB7fTtcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoRXh0ZW50cztcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUmVzZXQ7XG4gICAgICB9LFxuICAgICAgc2VsZWN0ZWQ6IHNlbGVjdGVkLFxuICAgICAgYnJ1c2hTdGF0ZTogYnJ1c2hFeHRlbnRzXG4gICAgfTtcbiAgfSkoKTsgLy8gYnJ1c2ggbW9kZTogYW5ndWxhclxuICAvLyBjb2RlIGJhc2VkIG9uIDJELnN0cnVtcy5qc1xuXG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYXJjcyA9IHt9LFxuICAgICAgICBzdHJ1bVJlY3Q7XG5cbiAgICBmdW5jdGlvbiBkcmF3U3RydW0oYXJjLCBhY3RpdmVQb2ludCkge1xuICAgICAgdmFyIHN2ZyA9IHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNhcmNzJyksXG4gICAgICAgICAgaWQgPSBhcmMuZGltcy5pLFxuICAgICAgICAgIHBvaW50cyA9IFthcmMucDIsIGFyYy5wM10sXG4gICAgICAgICAgbGluZSA9IHN2Zy5zZWxlY3RBbGwoJ2xpbmUjYXJjLScgKyBpZCkuZGF0YShbe1xuICAgICAgICBwMTogYXJjLnAxLFxuICAgICAgICBwMjogYXJjLnAyXG4gICAgICB9LCB7XG4gICAgICAgIHAxOiBhcmMucDEsXG4gICAgICAgIHAyOiBhcmMucDNcbiAgICAgIH1dKSxcbiAgICAgICAgICBjaXJjbGVzID0gc3ZnLnNlbGVjdEFsbCgnY2lyY2xlI2FyYy0nICsgaWQpLmRhdGEocG9pbnRzKSxcbiAgICAgICAgICBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpLFxuICAgICAgICAgIHBhdGggPSBzdmcuc2VsZWN0QWxsKCdwYXRoI2FyYy0nICsgaWQpLmRhdGEoW2FyY10pO1xuICAgICAgcGF0aC5lbnRlcigpLmFwcGVuZCgncGF0aCcpLmF0dHIoJ2lkJywgJ2FyYy0nICsgaWQpLmF0dHIoJ2NsYXNzJywgJ2FyYycpLnN0eWxlKCdmaWxsJywgJ29yYW5nZScpLnN0eWxlKCdvcGFjaXR5JywgMC41KTtcbiAgICAgIHBhdGguYXR0cignZCcsIGFyYy5hcmMpLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIGFyYy5wMVswXSArICcsJyArIGFyYy5wMVsxXSArICcpJyk7XG4gICAgICBsaW5lLmVudGVyKCkuYXBwZW5kKCdsaW5lJykuYXR0cignaWQnLCAnYXJjLScgKyBpZCkuYXR0cignY2xhc3MnLCAnYXJjJyk7XG4gICAgICBsaW5lLmF0dHIoJ3gxJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQucDFbMF07XG4gICAgICB9KS5hdHRyKCd5MScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkLnAxWzFdO1xuICAgICAgfSkuYXR0cigneDInLCBmdW5jdGlvbiAoZCkge1xuICAgICAgICByZXR1cm4gZC5wMlswXTtcbiAgICAgIH0pLmF0dHIoJ3kyJywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGQucDJbMV07XG4gICAgICB9KS5hdHRyKCdzdHJva2UnLCAnYmxhY2snKS5hdHRyKCdzdHJva2Utd2lkdGgnLCAyKTtcbiAgICAgIGRyYWcub24oJ2RyYWcnLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgICB2YXIgZXYgPSBkMy5ldmVudCxcbiAgICAgICAgICAgIGFuZ2xlID0gMDtcbiAgICAgICAgaSA9IGkgKyAyO1xuICAgICAgICBhcmNbJ3AnICsgaV1bMF0gPSBNYXRoLm1pbihNYXRoLm1heChhcmMubWluWCArIDEsIGV2LngpLCBhcmMubWF4WCk7XG4gICAgICAgIGFyY1sncCcgKyBpXVsxXSA9IE1hdGgubWluKE1hdGgubWF4KGFyYy5taW5ZLCBldi55KSwgYXJjLm1heFkpO1xuICAgICAgICBhbmdsZSA9IGkgPT09IDMgPyBhcmNzLnN0YXJ0QW5nbGUoaWQpIDogYXJjcy5lbmRBbmdsZShpZCk7XG5cbiAgICAgICAgaWYgKGFyYy5zdGFydEFuZ2xlIDwgTWF0aC5QSSAmJiBhcmMuZW5kQW5nbGUgPCBNYXRoLlBJICYmIGFuZ2xlIDwgTWF0aC5QSSB8fCBhcmMuc3RhcnRBbmdsZSA+PSBNYXRoLlBJICYmIGFyYy5lbmRBbmdsZSA+PSBNYXRoLlBJICYmIGFuZ2xlID49IE1hdGguUEkpIHtcbiAgICAgICAgICBpZiAoaSA9PT0gMikge1xuICAgICAgICAgICAgYXJjLmVuZEFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgICBhcmMuYXJjLmVuZEFuZ2xlKGFuZ2xlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGkgPT09IDMpIHtcbiAgICAgICAgICAgIGFyYy5zdGFydEFuZ2xlID0gYW5nbGU7XG4gICAgICAgICAgICBhcmMuYXJjLnN0YXJ0QW5nbGUoYW5nbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRyYXdTdHJ1bShhcmMsIGkgLSAyKTtcbiAgICAgIH0pLm9uKCdkcmFnZW5kJywgb25EcmFnRW5kKCkpO1xuICAgICAgY2lyY2xlcy5lbnRlcigpLmFwcGVuZCgnY2lyY2xlJykuYXR0cignaWQnLCAnYXJjLScgKyBpZCkuYXR0cignY2xhc3MnLCAnYXJjJyk7XG4gICAgICBjaXJjbGVzLmF0dHIoJ2N4JywgZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuIGRbMF07XG4gICAgICB9KS5hdHRyKCdjeScsIGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHJldHVybiBkWzFdO1xuICAgICAgfSkuYXR0cigncicsIDUpLnN0eWxlKCdvcGFjaXR5JywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgICAgcmV0dXJuIGFjdGl2ZVBvaW50ICE9PSB1bmRlZmluZWQgJiYgaSA9PT0gYWN0aXZlUG9pbnQgPyAwLjggOiAwO1xuICAgICAgfSkub24oJ21vdXNlb3ZlcicsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5JywgMC44KTtcbiAgICAgIH0pLm9uKCdtb3VzZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZDMuc2VsZWN0KHRoaXMpLnN0eWxlKCdvcGFjaXR5JywgMCk7XG4gICAgICB9KS5jYWxsKGRyYWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRpbWVuc2lvbnNGb3JQb2ludChwKSB7XG4gICAgICB2YXIgZGltcyA9IHtcbiAgICAgICAgaTogLTEsXG4gICAgICAgIGxlZnQ6IHVuZGVmaW5lZCxcbiAgICAgICAgcmlnaHQ6IHVuZGVmaW5lZFxuICAgICAgfTtcblxuICAgICAgX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkaW0sIGkpIHtcbiAgICAgICAgaWYgKHhzY2FsZShkaW0pIDwgcFswXSkge1xuICAgICAgICAgIHZhciBuZXh0ID0gX18uZGltZW5zaW9uc1tpICsgMV07XG4gICAgICAgICAgZGltcy5pID0gaTtcbiAgICAgICAgICBkaW1zLmxlZnQgPSBkaW07XG4gICAgICAgICAgZGltcy5yaWdodCA9IG5leHQ7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9KTtcblxuICAgICAgaWYgKGRpbXMubGVmdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIEV2ZW50IG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIGZpcnN0IGF4aXMuXG4gICAgICAgIGRpbXMuaSA9IDA7XG4gICAgICAgIGRpbXMubGVmdCA9IF9fLmRpbWVuc2lvbnNbMF07XG4gICAgICAgIGRpbXMucmlnaHQgPSBfXy5kaW1lbnNpb25zWzFdO1xuICAgICAgfSBlbHNlIGlmIChkaW1zLnJpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRXZlbnQgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIGxhc3QgYXhpc1xuICAgICAgICBkaW1zLmkgPSBfXy5kaW1lbnNpb25zLmxlbmd0aCAtIDE7XG4gICAgICAgIGRpbXMucmlnaHQgPSBkaW1zLmxlZnQ7XG4gICAgICAgIGRpbXMubGVmdCA9IF9fLmRpbWVuc2lvbnNbX18uZGltZW5zaW9ucy5sZW5ndGggLSAyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGRpbXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EcmFnU3RhcnQoKSB7XG4gICAgICAvLyBGaXJzdCB3ZSBuZWVkIHRvIGRldGVybWluZSBiZXR3ZWVuIHdoaWNoIHR3byBheGVzIHRoZSBhcmMgd2FzIHN0YXJ0ZWQuXG4gICAgICAvLyBUaGlzIHdpbGwgZGV0ZXJtaW5lIHRoZSBmcmVlZG9tIG9mIG1vdmVtZW50LCBiZWNhdXNlIGEgYXJjIGNhblxuICAgICAgLy8gbG9naWNhbGx5IG9ubHkgaGFwcGVuIGJldHdlZW4gdHdvIGF4ZXMsIHNvIG5vIG1vdmVtZW50IG91dHNpZGUgdGhlc2UgYXhlc1xuICAgICAgLy8gc2hvdWxkIGJlIGFsbG93ZWQuXG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcCA9IGQzLm1vdXNlKHN0cnVtUmVjdFswXVswXSksXG4gICAgICAgICAgICBkaW1zLFxuICAgICAgICAgICAgYXJjO1xuICAgICAgICBwWzBdID0gcFswXSAtIF9fLm1hcmdpbi5sZWZ0O1xuICAgICAgICBwWzFdID0gcFsxXSAtIF9fLm1hcmdpbi50b3A7XG4gICAgICAgIGRpbXMgPSBkaW1lbnNpb25zRm9yUG9pbnQocCksIGFyYyA9IHtcbiAgICAgICAgICBwMTogcCxcbiAgICAgICAgICBkaW1zOiBkaW1zLFxuICAgICAgICAgIG1pblg6IHhzY2FsZShkaW1zLmxlZnQpLFxuICAgICAgICAgIG1heFg6IHhzY2FsZShkaW1zLnJpZ2h0KSxcbiAgICAgICAgICBtaW5ZOiAwLFxuICAgICAgICAgIG1heFk6IGgoKSxcbiAgICAgICAgICBzdGFydEFuZ2xlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZW5kQW5nbGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICBhcmM6IGQzLnN2Zy5hcmMoKS5pbm5lclJhZGl1cygwKVxuICAgICAgICB9O1xuICAgICAgICBhcmNzW2RpbXMuaV0gPSBhcmM7XG4gICAgICAgIGFyY3MuYWN0aXZlID0gZGltcy5pOyAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBib3VuZHNcblxuICAgICAgICBhcmMucDFbMF0gPSBNYXRoLm1pbihNYXRoLm1heChhcmMubWluWCwgcFswXSksIGFyYy5tYXhYKTtcbiAgICAgICAgYXJjLnAyID0gYXJjLnAxLnNsaWNlKCk7XG4gICAgICAgIGFyYy5wMyA9IGFyYy5wMS5zbGljZSgpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvbkRyYWcoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZXYgPSBkMy5ldmVudCxcbiAgICAgICAgICAgIGFyYyA9IGFyY3NbYXJjcy5hY3RpdmVdOyAvLyBNYWtlIHN1cmUgdGhhdCB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBib3VuZHNcblxuICAgICAgICBhcmMucDJbMF0gPSBNYXRoLm1pbihNYXRoLm1heChhcmMubWluWCArIDEsIGV2LnggLSBfXy5tYXJnaW4ubGVmdCksIGFyYy5tYXhYKTtcbiAgICAgICAgYXJjLnAyWzFdID0gTWF0aC5taW4oTWF0aC5tYXgoYXJjLm1pblksIGV2LnkgLSBfXy5tYXJnaW4udG9wKSwgYXJjLm1heFkpO1xuICAgICAgICBhcmMucDMgPSBhcmMucDIuc2xpY2UoKTtcbiAgICAgICAgZHJhd1N0cnVtKGFyYywgMSk7XG4gICAgICB9O1xuICAgIH0gLy8gc29tZSBoZWxwZXIgZnVuY3Rpb25zXG5cblxuICAgIGZ1bmN0aW9uIGh5cG90aGVudXNlKGEsIGIpIHtcbiAgICAgIHJldHVybiBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG4gICAgfVxuXG4gICAgdmFyIHJhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjID0gTWF0aC5QSSAvIDE4MDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGFuZ2xlICogYztcbiAgICAgIH07XG4gICAgfSgpO1xuXG4gICAgdmFyIGRlZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjID0gMTgwIC8gTWF0aC5QSTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgcmV0dXJuIGFuZ2xlICogYztcbiAgICAgIH07XG4gICAgfSgpOyAvLyBbMCwgMipQSV0gLT4gWy1QSS8yLCBQSS8yXVxuXG5cbiAgICB2YXIgc2lnbmVkQW5nbGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgIHZhciByZXQgPSBhbmdsZTtcblxuICAgICAgaWYgKGFuZ2xlID4gTWF0aC5QSSkge1xuICAgICAgICByZXQgPSBhbmdsZSAtIDEuNSAqIE1hdGguUEk7XG4gICAgICAgIHJldCA9IGFuZ2xlIC0gMS41ICogTWF0aC5QSTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldCA9IGFuZ2xlIC0gMC41ICogTWF0aC5QSTtcbiAgICAgICAgcmV0ID0gYW5nbGUgLSAwLjUgKiBNYXRoLlBJO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gLXJldDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIGFuZ2xlcyBhcmUgc3RvcmVkIGluIHJhZGlhbnMgZnJvbSBpbiBbMCwgMipQSV0sIHdoZXJlIDAgaW4gMTIgbydjbG9jay5cbiAgICAgKiBIb3dldmVyLCBvbmUgY2FuIG9ubHkgc2VsZWN0IGxpbmVzIGZyb20gMCB0byBQSSwgc28gd2UgY29tcHV0ZSB0aGVcbiAgICAgKiAnc2lnbmVkJyBhbmdsZSwgd2hlcmUgMCBpcyB0aGUgaG9yaXpvbnRhbCBsaW5lICgzIG8nY2xvY2spLCBhbmQgKy8tIFBJLzJcbiAgICAgKiBhcmUgMTIgYW5kIDYgbydjbG9jayByZXNwZWN0aXZlbHkuXG4gICAgICovXG5cblxuICAgIGZ1bmN0aW9uIGNvbnRhaW5tZW50VGVzdChhcmMpIHtcbiAgICAgIHZhciBzdGFydEFuZ2xlID0gc2lnbmVkQW5nbGUoYXJjLnN0YXJ0QW5nbGUpO1xuICAgICAgdmFyIGVuZEFuZ2xlID0gc2lnbmVkQW5nbGUoYXJjLmVuZEFuZ2xlKTtcblxuICAgICAgaWYgKHN0YXJ0QW5nbGUgPiBlbmRBbmdsZSkge1xuICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgc3RhcnRBbmdsZSA9IGVuZEFuZ2xlO1xuICAgICAgICBlbmRBbmdsZSA9IHRtcDtcbiAgICAgIH0gLy8gdGVzdCBpZiBzZWdtZW50IGFuZ2xlIGlzIGNvbnRhaW5lZCBpbiBhbmdsZSBpbnRlcnZhbFxuXG5cbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYSkge1xuICAgICAgICBpZiAoYSA+PSBzdGFydEFuZ2xlICYmIGEgPD0gZW5kQW5nbGUpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VsZWN0ZWQoKSB7XG4gICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJjcyksXG4gICAgICAgICAgYnJ1c2hlZCA9IF9fLmRhdGE7IC8vIEdldCB0aGUgaWRzIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIGFyY3MuXG5cbiAgICAgIGlkcyA9IGlkcy5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBjcm9zc2VzU3RydW0oZCwgaWQpIHtcbiAgICAgICAgdmFyIGFyYyA9IGFyY3NbaWRdLFxuICAgICAgICAgICAgdGVzdCA9IGNvbnRhaW5tZW50VGVzdChhcmMpLFxuICAgICAgICAgICAgZDEgPSBhcmMuZGltcy5sZWZ0LFxuICAgICAgICAgICAgZDIgPSBhcmMuZGltcy5yaWdodCxcbiAgICAgICAgICAgIHkxID0geXNjYWxlW2QxXSxcbiAgICAgICAgICAgIHkyID0geXNjYWxlW2QyXSxcbiAgICAgICAgICAgIGEgPSBhcmNzLndpZHRoKGlkKSxcbiAgICAgICAgICAgIGIgPSB5MShkW2QxXSkgLSB5MihkW2QyXSksXG4gICAgICAgICAgICBjID0gaHlwb3RoZW51c2UoYSwgYiksXG4gICAgICAgICAgICBhbmdsZSA9IE1hdGguYXNpbihiIC8gYyk7IC8vIHJhZCBpbiBbLVBJLzIsIFBJLzJdXG5cbiAgICAgICAgcmV0dXJuIHRlc3QoYW5nbGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaWRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYnJ1c2hlZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJydXNoZWQuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHN3aXRjaCAoYnJ1c2gucHJlZGljYXRlKSB7XG4gICAgICAgICAgY2FzZSAnQU5EJzpcbiAgICAgICAgICAgIHJldHVybiBpZHMuZXZlcnkoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcm9zc2VzU3RydW0oZCwgaWQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBjYXNlICdPUic6XG4gICAgICAgICAgICByZXR1cm4gaWRzLnNvbWUoZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBjcm9zc2VzU3RydW0oZCwgaWQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgJ1Vua25vd24gYnJ1c2ggcHJlZGljYXRlICcgKyBfXy5icnVzaFByZWRpY2F0ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVtb3ZlU3RydW0oKSB7XG4gICAgICB2YXIgYXJjID0gYXJjc1thcmNzLmFjdGl2ZV0sXG4gICAgICAgICAgc3ZnID0gcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuc2VsZWN0KCdnI2FyY3MnKTtcbiAgICAgIGRlbGV0ZSBhcmNzW2FyY3MuYWN0aXZlXTtcbiAgICAgIGFyY3MuYWN0aXZlID0gdW5kZWZpbmVkO1xuICAgICAgc3ZnLnNlbGVjdEFsbCgnbGluZSNhcmMtJyArIGFyYy5kaW1zLmkpLnJlbW92ZSgpO1xuICAgICAgc3ZnLnNlbGVjdEFsbCgnY2lyY2xlI2FyYy0nICsgYXJjLmRpbXMuaSkucmVtb3ZlKCk7XG4gICAgICBzdmcuc2VsZWN0QWxsKCdwYXRoI2FyYy0nICsgYXJjLmRpbXMuaSkucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25EcmFnRW5kKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJydXNoZWQgPSBfXy5kYXRhLFxuICAgICAgICAgICAgYXJjID0gYXJjc1thcmNzLmFjdGl2ZV07IC8vIE9rYXksIHNvbWV3aGF0IHVuZXhwZWN0ZWQsIGJ1dCBub3QgdG90YWxseSB1bnN1cnByaXNpbmcsIGEgbW91c2NsaWNrIGlzXG4gICAgICAgIC8vIGNvbnNpZGVyZWQgYSBkcmFnIHdpdGhvdXQgbW92ZS4gU28gd2UgaGF2ZSB0byBkZWFsIHdpdGggdGhhdCBjYXNlXG5cbiAgICAgICAgaWYgKGFyYyAmJiBhcmMucDFbMF0gPT09IGFyYy5wMlswXSAmJiBhcmMucDFbMV0gPT09IGFyYy5wMlsxXSkge1xuICAgICAgICAgIHJlbW92ZVN0cnVtKGFyY3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFyYykge1xuICAgICAgICAgIHZhciBhbmdsZSA9IGFyY3Muc3RhcnRBbmdsZShhcmNzLmFjdGl2ZSk7XG4gICAgICAgICAgYXJjLnN0YXJ0QW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICBhcmMuZW5kQW5nbGUgPSBhbmdsZTtcbiAgICAgICAgICBhcmMuYXJjLm91dGVyUmFkaXVzKGFyY3MubGVuZ3RoKGFyY3MuYWN0aXZlKSkuc3RhcnRBbmdsZShhbmdsZSkuZW5kQW5nbGUoYW5nbGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJ1c2hlZCA9IHNlbGVjdGVkKGFyY3MpO1xuICAgICAgICBhcmNzLmFjdGl2ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgX18uYnJ1c2hlZCA9IGJydXNoZWQ7XG4gICAgICAgIHBjLnJlbmRlckJydXNoZWQoKTtcbiAgICAgICAgZXZlbnRzLmJydXNoZW5kLmNhbGwocGMsIF9fLmJydXNoZWQpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBicnVzaFJlc2V0KGFyY3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpZHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcmNzKS5maWx0ZXIoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICByZXR1cm4gIWlzTmFOKGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWRzLmZvckVhY2goZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICBhcmNzLmFjdGl2ZSA9IGQ7XG4gICAgICAgICAgcmVtb3ZlU3RydW0oYXJjcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbkRyYWdFbmQoYXJjcykoKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbCgpIHtcbiAgICAgIHZhciBkcmFnID0gZDMuYmVoYXZpb3IuZHJhZygpOyAvLyBNYXAgb2YgY3VycmVudCBhcmNzLiBhcmNzIGFyZSBzdG9yZWQgcGVyIHNlZ21lbnQgb2YgdGhlIFBDLiBBIHNlZ21lbnQsXG4gICAgICAvLyBiZWluZyB0aGUgYXJlYSBiZXR3ZWVuIHR3byBheGVzLiBUaGUgbGVmdCBtb3N0IGFyZWEgaXMgaW5kZXhlZCBhdCAwLlxuXG4gICAgICBhcmNzLmFjdGl2ZSA9IHVuZGVmaW5lZDsgLy8gUmV0dXJucyB0aGUgd2lkdGggb2YgdGhlIFBDIHNlZ21lbnQgd2hlcmUgY3VycmVudGx5IGEgYXJjIGlzIGJlaW5nXG4gICAgICAvLyBwbGFjZWQuIE5PVEU6IGV2ZW4gdGhvdWdoIHRoZXkgYXJlIGV2ZW5seSBzcGFjZWQgaW4gb3VyIGN1cnJlbnRcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uLCB3ZSBrZWVwIGZvciB3aGVuIG5vbi1ldmVuIHNwYWNlZCBzZWdtZW50cyBhcmUgc3VwcG9ydGVkIGFzXG4gICAgICAvLyB3ZWxsLlxuXG4gICAgICBhcmNzLndpZHRoID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBhcmMgPSBhcmNzW2lkXTtcblxuICAgICAgICBpZiAoYXJjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFyYy5tYXhYIC0gYXJjLm1pblg7XG4gICAgICB9OyAvLyByZXR1cm5zIGFuZ2xlcyBpbiBbLVBJLzIsIFBJLzJdXG5cblxuICAgICAgYW5nbGUgPSBmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgICAgIHZhciBhID0gcDFbMF0gLSBwMlswXSxcbiAgICAgICAgICAgIGIgPSBwMVsxXSAtIHAyWzFdLFxuICAgICAgICAgICAgYyA9IGh5cG90aGVudXNlKGEsIGIpO1xuICAgICAgICByZXR1cm4gTWF0aC5hc2luKGIgLyBjKTtcbiAgICAgIH07IC8vIHJldHVybnMgYW5nbGVzIGluIFswLCAyICogUEldXG5cblxuICAgICAgYXJjcy5lbmRBbmdsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF07XG5cbiAgICAgICAgaWYgKGFyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzQW5nbGUgPSBhbmdsZShhcmMucDEsIGFyYy5wMiksXG4gICAgICAgICAgICB1QW5nbGUgPSAtc0FuZ2xlICsgTWF0aC5QSSAvIDI7XG5cbiAgICAgICAgaWYgKGFyYy5wMVswXSA+IGFyYy5wMlswXSkge1xuICAgICAgICAgIHVBbmdsZSA9IDIgKiBNYXRoLlBJIC0gdUFuZ2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVBbmdsZTtcbiAgICAgIH07XG5cbiAgICAgIGFyY3Muc3RhcnRBbmdsZSA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYXJjID0gYXJjc1tpZF07XG5cbiAgICAgICAgaWYgKGFyYyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzQW5nbGUgPSBhbmdsZShhcmMucDEsIGFyYy5wMyksXG4gICAgICAgICAgICB1QW5nbGUgPSAtc0FuZ2xlICsgTWF0aC5QSSAvIDI7XG5cbiAgICAgICAgaWYgKGFyYy5wMVswXSA+IGFyYy5wM1swXSkge1xuICAgICAgICAgIHVBbmdsZSA9IDIgKiBNYXRoLlBJIC0gdUFuZ2xlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVBbmdsZTtcbiAgICAgIH07XG5cbiAgICAgIGFyY3MubGVuZ3RoID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBhcmMgPSBhcmNzW2lkXTtcblxuICAgICAgICBpZiAoYXJjID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGEgPSBhcmMucDFbMF0gLSBhcmMucDJbMF0sXG4gICAgICAgICAgICBiID0gYXJjLnAxWzFdIC0gYXJjLnAyWzFdLFxuICAgICAgICAgICAgYyA9IGh5cG90aGVudXNlKGEsIGIpO1xuICAgICAgICByZXR1cm4gYztcbiAgICAgIH07XG5cbiAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5hcmNzJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaWRzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYXJjcykuZmlsdGVyKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgcmV0dXJuICFpc05hTihkKTtcbiAgICAgICAgfSk7IC8vIENoZWNrcyBpZiB0aGUgZmlyc3QgZGltZW5zaW9uIGlzIGRpcmVjdGx5IGxlZnQgb2YgdGhlIHNlY29uZCBkaW1lbnNpb24uXG5cbiAgICAgICAgZnVuY3Rpb24gY29uc2VjdXRpdmUoZmlyc3QsIHNlY29uZCkge1xuICAgICAgICAgIHZhciBsZW5ndGggPSBfXy5kaW1lbnNpb25zLmxlbmd0aDtcbiAgICAgICAgICByZXR1cm4gX18uZGltZW5zaW9ucy5zb21lKGZ1bmN0aW9uIChkLCBpKSB7XG4gICAgICAgICAgICByZXR1cm4gZCA9PT0gZmlyc3QgPyBpICsgaSA8IGxlbmd0aCAmJiBfXy5kaW1lbnNpb25zW2kgKyAxXSA9PT0gc2Vjb25kIDogZmFsc2U7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIHNvbWUgYXJjcywgd2hpY2ggbWlnaHQgbmVlZCB0byBiZSByZW1vdmVkLlxuICAgICAgICAgIGlkcy5mb3JFYWNoKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICB2YXIgZGltcyA9IGFyY3NbZF0uZGltcztcbiAgICAgICAgICAgIGFyY3MuYWN0aXZlID0gZDsgLy8gSWYgdGhlIHR3byBkaW1lbnNpb25zIG9mIHRoZSBjdXJyZW50IGFyYyBhcmUgbm90IG5leHQgdG8gZWFjaCBvdGhlclxuICAgICAgICAgICAgLy8gYW55IG1vcmUsIHRoYW4gd2UnbGwgbmVlZCB0byByZW1vdmUgdGhlIGFyYy4gT3RoZXJ3aXNlIHdlIGtlZXAgaXQuXG5cbiAgICAgICAgICAgIGlmICghY29uc2VjdXRpdmUoZGltcy5sZWZ0LCBkaW1zLnJpZ2h0KSkge1xuICAgICAgICAgICAgICByZW1vdmVTdHJ1bShhcmNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBvbkRyYWdFbmQoYXJjcykoKTtcbiAgICAgICAgfVxuICAgICAgfSk7IC8vIEFkZCBhIG5ldyBzdmcgZ3JvdXAgaW4gd2hpY2ggd2UgZHJhdyB0aGUgYXJjcy5cblxuICAgICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuYXBwZW5kKCdnJykuYXR0cignaWQnLCAnYXJjcycpLmF0dHIoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIF9fLm1hcmdpbi5sZWZ0ICsgJywnICsgX18ubWFyZ2luLnRvcCArICcpJyk7IC8vIEluc3RhbGwgdGhlIHJlcXVpcmVkIGJydXNoUmVzZXQgZnVuY3Rpb25cblxuICAgICAgcGMuYnJ1c2hSZXNldCA9IGJydXNoUmVzZXQoYXJjcyk7XG4gICAgICBkcmFnLm9uKCdkcmFnc3RhcnQnLCBvbkRyYWdTdGFydChhcmNzKSkub24oJ2RyYWcnLCBvbkRyYWcoYXJjcykpLm9uKCdkcmFnZW5kJywgb25EcmFnRW5kKGFyY3MpKTsgLy8gTk9URTogVGhlIHN0eWxpbmcgbmVlZHMgdG8gYmUgZG9uZSBoZXJlIGFuZCBub3QgaW4gdGhlIGNzcy4gVGhpcyBpcyBiZWNhdXNlXG4gICAgICAvLyAgICAgICBmb3IgMUQgYnJ1c2hpbmcsIHRoZSBjYW52YXMgbGF5ZXJzIHNob3VsZCBub3QgbGlzdGVuIHRvXG4gICAgICAvLyAgICAgICBwb2ludGVyLWV2ZW50cy5cblxuICAgICAgc3RydW1SZWN0ID0gcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuaW5zZXJ0KCdyZWN0JywgJ2cjYXJjcycpLmF0dHIoJ2lkJywgJ2FyYy1ldmVudHMnKS5hdHRyKCd4JywgX18ubWFyZ2luLmxlZnQpLmF0dHIoJ3knLCBfXy5tYXJnaW4udG9wKS5hdHRyKCd3aWR0aCcsIHcoKSkuYXR0cignaGVpZ2h0JywgaCgpICsgMikuc3R5bGUoJ29wYWNpdHknLCAwKS5jYWxsKGRyYWcpO1xuICAgIH1cblxuICAgIGJydXNoLm1vZGVzWydhbmd1bGFyJ10gPSB7XG4gICAgICBpbnN0YWxsOiBpbnN0YWxsLFxuICAgICAgdW5pbnN0YWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgnZyNhcmNzJykucmVtb3ZlKCk7XG4gICAgICAgIHBjLnNlbGVjdGlvbi5zZWxlY3QoJ3N2ZycpLnNlbGVjdCgncmVjdCNhcmMtZXZlbnRzJykucmVtb3ZlKCk7XG4gICAgICAgIHBjLm9uKCdheGVzcmVvcmRlci5hcmNzJywgdW5kZWZpbmVkKTtcbiAgICAgICAgZGVsZXRlIHBjLmJydXNoUmVzZXQ7XG4gICAgICAgIHN0cnVtUmVjdCA9IHVuZGVmaW5lZDtcbiAgICAgIH0sXG4gICAgICBzZWxlY3RlZDogc2VsZWN0ZWQsXG4gICAgICBicnVzaFN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmNzO1xuICAgICAgfVxuICAgIH07XG4gIH0pKCk7XG5cbiAgcGMuaW50ZXJhY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgZmxhZ3MuaW50ZXJhY3RpdmUgPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBleHBvc2UgYSBmZXcgb2JqZWN0c1xuXG5cbiAgcGMueHNjYWxlID0geHNjYWxlO1xuICBwYy55c2NhbGUgPSB5c2NhbGU7XG4gIHBjLmN0eCA9IGN0eDtcbiAgcGMuY2FudmFzID0gY2FudmFzO1xuXG4gIHBjLmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGc7XG4gIH07IC8vIHJlc2NhbGUgZm9yIGhlaWdodCwgd2lkdGggYW5kIG1hcmdpbnNcbiAgLy8gVE9ETyBjdXJyZW50bHkgYXNzdW1lcyBjaGFydCBpcyBicnVzaGFibGUsIGFuZCBkZXN0cm95cyBvbGQgYnJ1c2hlc1xuXG5cbiAgcGMucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHNlbGVjdGlvbiBzaXplXG4gICAgcGMuc2VsZWN0aW9uLnNlbGVjdCgnc3ZnJykuYXR0cignd2lkdGgnLCBfXy53aWR0aCkuYXR0cignaGVpZ2h0JywgX18uaGVpZ2h0KTtcbiAgICBwYy5zdmcuYXR0cigndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgX18ubWFyZ2luLmxlZnQgKyAnLCcgKyBfXy5tYXJnaW4udG9wICsgJyknKTsgLy8gRklYTUU6IHRoZSBjdXJyZW50IGJydXNoIHN0YXRlIHNob3VsZCBwYXNzIHRocm91Z2hcblxuICAgIGlmIChmbGFncy5icnVzaGFibGUpIHBjLmJydXNoUmVzZXQoKTsgLy8gc2NhbGVzXG5cbiAgICBwYy5hdXRvc2NhbGUoKTsgLy8gYXhlcywgZGVzdHJveXMgb2xkIGJydXNoZXMuXG5cbiAgICBpZiAoZykgcGMuY3JlYXRlQXhlcygpO1xuICAgIGlmIChmbGFncy5icnVzaGFibGUpIHBjLmJydXNoYWJsZSgpO1xuICAgIGlmIChmbGFncy5yZW9yZGVyYWJsZSkgcGMucmVvcmRlcmFibGUoKTtcbiAgICBldmVudHMucmVzaXplLmNhbGwodGhpcywge1xuICAgICAgd2lkdGg6IF9fLndpZHRoLFxuICAgICAgaGVpZ2h0OiBfXy5oZWlnaHQsXG4gICAgICBtYXJnaW46IF9fLm1hcmdpblxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBoaWdobGlnaHQgYW4gYXJyYXkgb2YgZGF0YVxuXG5cbiAgcGMuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIF9fLmhpZ2hsaWdodGVkO1xuICAgIH1cblxuICAgIF9fLmhpZ2hsaWdodGVkID0gZGF0YTtcbiAgICBwYy5jbGVhcignaGlnaGxpZ2h0Jyk7XG4gICAgZDMuc2VsZWN0QWxsKFtjYW52YXMuZm9yZWdyb3VuZCwgY2FudmFzLmJydXNoZWRdKS5jbGFzc2VkKCdmYWRlZCcsIHRydWUpO1xuICAgIGRhdGEuZm9yRWFjaChwYXRoX2hpZ2hsaWdodCk7XG4gICAgZXZlbnRzLmhpZ2hsaWdodC5jYWxsKHRoaXMsIGRhdGEpO1xuICAgIHJldHVybiB0aGlzO1xuICB9OyAvLyBjbGVhciBoaWdobGlnaHRpbmdcblxuXG4gIHBjLnVuaGlnaGxpZ2h0ID0gZnVuY3Rpb24gKCkge1xuICAgIF9fLmhpZ2hsaWdodGVkID0gW107XG4gICAgcGMuY2xlYXIoJ2hpZ2hsaWdodCcpO1xuICAgIGQzLnNlbGVjdEFsbChbY2FudmFzLmZvcmVncm91bmQsIGNhbnZhcy5icnVzaGVkXSkuY2xhc3NlZCgnZmFkZWQnLCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07IC8vIGNhbGN1bGF0ZSAyZCBpbnRlcnNlY3Rpb24gb2YgbGluZSBhLT5iIHdpdGggbGluZSBjLT5kXG4gIC8vIHBvaW50cyBhcmUgb2JqZWN0cyB3aXRoIHggYW5kIHkgcHJvcGVydGllc1xuXG5cbiAgcGMuaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogKChhLnggKiBiLnkgLSBhLnkgKiBiLngpICogKGMueCAtIGQueCkgLSAoYS54IC0gYi54KSAqIChjLnggKiBkLnkgLSBjLnkgKiBkLngpKSAvICgoYS54IC0gYi54KSAqIChjLnkgLSBkLnkpIC0gKGEueSAtIGIueSkgKiAoYy54IC0gZC54KSksXG4gICAgICB5OiAoKGEueCAqIGIueSAtIGEueSAqIGIueCkgKiAoYy55IC0gZC55KSAtIChhLnkgLSBiLnkpICogKGMueCAqIGQueSAtIGMueSAqIGQueCkpIC8gKChhLnggLSBiLngpICogKGMueSAtIGQueSkgLSAoYS55IC0gYi55KSAqIChjLnggLSBkLngpKVxuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gcG9zaXRpb24oZCkge1xuICAgIHZhciB2ID0gZHJhZ2dpbmdbZF07XG4gICAgcmV0dXJuIHYgPT0gbnVsbCA/IHhzY2FsZShkKSA6IHY7XG4gIH1cblxuICBwYy52ZXJzaW9uID0gJzAuNy4wJzsgLy8gdGhpcyBkZXNjcmlwdGl2ZSB0ZXh0IHNob3VsZCBsaXZlIHdpdGggb3RoZXIgaW50cm9zcGVjdGl2ZSBtZXRob2RzXG5cbiAgcGMudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdQYXJhbGxlbCBDb29yZGluYXRlczogJyArIF9fLmRpbWVuc2lvbnMubGVuZ3RoICsgJyBkaW1lbnNpb25zICgnICsgZDMua2V5cyhfXy5kYXRhWzBdKS5sZW5ndGggKyAnIHRvdGFsKSAsICcgKyBfXy5kYXRhLmxlbmd0aCArICcgcm93cyc7XG4gIH07XG5cbiAgcmV0dXJuIHBjO1xufVxuXG5kMy5yZW5kZXJRdWV1ZSA9IGZ1bmN0aW9uIChmdW5jKSB7XG4gIHZhciBfcXVldWUgPSBbXSxcbiAgICAgIC8vIGRhdGEgdG8gYmUgcmVuZGVyZWRcbiAgX3JhdGUgPSAxMCxcbiAgICAgIC8vIG51bWJlciBvZiBjYWxscyBwZXIgZnJhbWVcbiAgX2NsZWFyID0gZnVuY3Rpb24gKCkge30sXG4gICAgICAvLyBjbGVhcmluZyBmdW5jdGlvblxuICBfaSA9IDA7IC8vIGN1cnJlbnQgaXRlcmF0aW9uXG5cblxuICB2YXIgcnEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmIChkYXRhKSBycS5kYXRhKGRhdGEpO1xuICAgIHJxLmludmFsaWRhdGUoKTtcblxuICAgIF9jbGVhcigpO1xuXG4gICAgcnEucmVuZGVyKCk7XG4gIH07XG5cbiAgcnEucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgIF9pID0gMDtcbiAgICB2YXIgdmFsaWQgPSB0cnVlO1xuXG4gICAgcnEuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGRvRnJhbWUoKSB7XG4gICAgICBpZiAoIXZhbGlkKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChfaSA+IF9xdWV1ZS5sZW5ndGgpIHJldHVybiB0cnVlOyAvLyBUeXBpY2FsIGQzIGJlaGF2aW9yIGlzIHRvIHBhc3MgYSBkYXRhIGl0ZW0gKmFuZCogaXRzIGluZGV4LiBBcyB0aGVcbiAgICAgIC8vIHJlbmRlciBxdWV1ZSBzcGxpdHMgdGhlIG9yaWdpbmFsIGRhdGEgc2V0LCB3ZSdsbCBoYXZlIHRvIGJlIHNsaWdodGx5XG4gICAgICAvLyBtb3JlIGNhcmVmdWxsIGFib3V0IHBhc3NpbmcgdGhlIGNvcnJlY3QgaW5kZXggd2l0aCB0aGUgZGF0YSBpdGVtLlxuXG4gICAgICB2YXIgZW5kID0gTWF0aC5taW4oX2kgKyBfcmF0ZSwgX3F1ZXVlLmxlbmd0aCk7XG5cbiAgICAgIGZvciAodmFyIGkgPSBfaTsgaSA8IGVuZDsgaSArPSAxKSB7XG4gICAgICAgIGZ1bmMoX3F1ZXVlW2ldLCBpKTtcbiAgICAgIH1cblxuICAgICAgX2kgKz0gX3JhdGU7XG4gICAgfVxuXG4gICAgZDMudGltZXIoZG9GcmFtZSk7XG4gIH07XG5cbiAgcnEuZGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcnEuaW52YWxpZGF0ZSgpO1xuICAgIF9xdWV1ZSA9IGRhdGEuc2xpY2UoMCk7XG4gICAgcmV0dXJuIHJxO1xuICB9O1xuXG4gIHJxLnJhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBfcmF0ZTtcbiAgICBfcmF0ZSA9IHZhbHVlO1xuICAgIHJldHVybiBycTtcbiAgfTtcblxuICBycS5yZW1haW5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9xdWV1ZS5sZW5ndGggLSBfaTtcbiAgfTsgLy8gY2xlYXIgdGhlIGNhbnZhc1xuXG5cbiAgcnEuY2xlYXIgPSBmdW5jdGlvbiAoZnVuYykge1xuICAgIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgX2NsZWFyKCk7XG5cbiAgICAgIHJldHVybiBycTtcbiAgICB9XG5cbiAgICBfY2xlYXIgPSBmdW5jO1xuICAgIHJldHVybiBycTtcbiAgfTtcblxuICBycS5pbnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge307XG5cbiAgcmV0dXJuIHJxO1xufTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.js\n");

/***/ }),

/***/ "./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/divgrid.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/divgrid.js ***!
  \************************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* [LICENSE TBD] */\n\n/* eslint-disable */\n// from http://bl.ocks.org/3687826\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (config) {\n  var columns = [];\n\n  var dg = function (selection) {\n    if (columns.length == 0) columns = d3.keys(selection.data()[0][0]); // header\n\n    selection.selectAll('.header').data([true]).enter().append('div').attr('class', 'header');\n    var header = selection.select('.header').selectAll('.cell').data(columns);\n    header.enter().append('div').attr('class', function (d, i) {\n      return 'col-' + i;\n    }).classed('cell', true);\n    selection.selectAll('.header .cell').text(function (d) {\n      return d;\n    });\n    header.exit().remove(); // rows\n\n    var rows = selection.selectAll('.row').data(function (d) {\n      return d;\n    });\n    rows.enter().append('div').attr('class', 'row');\n    rows.exit().remove();\n    var cells = selection.selectAll('.row').selectAll('.cell').data(function (d) {\n      return columns.map(function (col) {\n        return d[col];\n      });\n    }); // cells\n\n    cells.enter().append('div').attr('class', function (d, i) {\n      return 'col-' + i;\n    }).classed('cell', true);\n    cells.exit().remove();\n    selection.selectAll('.cell').text(function (d) {\n      return d;\n    });\n    return dg;\n  };\n\n  dg.columns = function (_) {\n    if (!arguments.length) return columns;\n    columns = _;\n    return this;\n  };\n\n  return dg;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL3ZlbmRvci9wYXJjb29yZHMvZGl2Z3JpZC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJzZXQtdWkvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9lc20vdmVuZG9yL3BhcmNvb3Jkcy9kaXZncmlkLmpzPzA5YTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyogW0xJQ0VOU0UgVEJEXSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLy8gZnJvbSBodHRwOi8vYmwub2Nrcy5vcmcvMzY4NzgyNlxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgY29sdW1ucyA9IFtdO1xuXG4gIHZhciBkZyA9IGZ1bmN0aW9uIChzZWxlY3Rpb24pIHtcbiAgICBpZiAoY29sdW1ucy5sZW5ndGggPT0gMCkgY29sdW1ucyA9IGQzLmtleXMoc2VsZWN0aW9uLmRhdGEoKVswXVswXSk7IC8vIGhlYWRlclxuXG4gICAgc2VsZWN0aW9uLnNlbGVjdEFsbCgnLmhlYWRlcicpLmRhdGEoW3RydWVdKS5lbnRlcigpLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCAnaGVhZGVyJyk7XG4gICAgdmFyIGhlYWRlciA9IHNlbGVjdGlvbi5zZWxlY3QoJy5oZWFkZXInKS5zZWxlY3RBbGwoJy5jZWxsJykuZGF0YShjb2x1bW5zKTtcbiAgICBoZWFkZXIuZW50ZXIoKS5hcHBlbmQoJ2RpdicpLmF0dHIoJ2NsYXNzJywgZnVuY3Rpb24gKGQsIGkpIHtcbiAgICAgIHJldHVybiAnY29sLScgKyBpO1xuICAgIH0pLmNsYXNzZWQoJ2NlbGwnLCB0cnVlKTtcbiAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKCcuaGVhZGVyIC5jZWxsJykudGV4dChmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSk7XG4gICAgaGVhZGVyLmV4aXQoKS5yZW1vdmUoKTsgLy8gcm93c1xuXG4gICAgdmFyIHJvd3MgPSBzZWxlY3Rpb24uc2VsZWN0QWxsKCcucm93JykuZGF0YShmdW5jdGlvbiAoZCkge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfSk7XG4gICAgcm93cy5lbnRlcigpLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCAncm93Jyk7XG4gICAgcm93cy5leGl0KCkucmVtb3ZlKCk7XG4gICAgdmFyIGNlbGxzID0gc2VsZWN0aW9uLnNlbGVjdEFsbCgnLnJvdycpLnNlbGVjdEFsbCgnLmNlbGwnKS5kYXRhKGZ1bmN0aW9uIChkKSB7XG4gICAgICByZXR1cm4gY29sdW1ucy5tYXAoZnVuY3Rpb24gKGNvbCkge1xuICAgICAgICByZXR1cm4gZFtjb2xdO1xuICAgICAgfSk7XG4gICAgfSk7IC8vIGNlbGxzXG5cbiAgICBjZWxscy5lbnRlcigpLmFwcGVuZCgnZGl2JykuYXR0cignY2xhc3MnLCBmdW5jdGlvbiAoZCwgaSkge1xuICAgICAgcmV0dXJuICdjb2wtJyArIGk7XG4gICAgfSkuY2xhc3NlZCgnY2VsbCcsIHRydWUpO1xuICAgIGNlbGxzLmV4aXQoKS5yZW1vdmUoKTtcbiAgICBzZWxlY3Rpb24uc2VsZWN0QWxsKCcuY2VsbCcpLnRleHQoZnVuY3Rpb24gKGQpIHtcbiAgICAgIHJldHVybiBkO1xuICAgIH0pO1xuICAgIHJldHVybiBkZztcbiAgfTtcblxuICBkZy5jb2x1bW5zID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBjb2x1bW5zO1xuICAgIGNvbHVtbnMgPSBfO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBkZztcbn0iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/divgrid.js\n");

/***/ }),

/***/ "./node_modules/css-loader/index.js?!./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css":
/*!******************************************************************************************************************************************************!*\
  !*** ./node_modules/css-loader??ref--7-1!./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css ***!
  \******************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../../../../css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(true);\n// imports\n\n\n// module\nexports.push([module.i, \"/* [LICENSE TBD] */\\n.parcoords svg,\\n.parcoords canvas {\\n  font-size: 12px;\\n  position: absolute;\\n}\\n.parcoords > canvas {\\n  pointer-events: none;\\n}\\n\\n.parcoords text.label {\\n  font: 100%;\\n  font-size: 12px;\\n  cursor: drag;\\n}\\n\\n.parcoords rect.background {\\n  fill: transparent;\\n}\\n.parcoords rect.background:hover {\\n  fill: rgba(120, 120, 120, 0.2);\\n}\\n.parcoords .resize rect {\\n  fill: rgba(0, 0, 0, 0.1);\\n}\\n.parcoords rect.extent {\\n  fill: rgba(255, 255, 255, 0.25);\\n  stroke: rgba(0, 0, 0, 0.6);\\n}\\n.parcoords .axis line,\\n.parcoords .axis path {\\n  fill: none;\\n  stroke: #222;\\n  shape-rendering: crispEdges;\\n}\\n.parcoords canvas {\\n  opacity: 1;\\n  -moz-transition: opacity 0.3s;\\n  -webkit-transition: opacity 0.3s;\\n  -o-transition: opacity 0.3s;\\n}\\n.parcoords canvas.faded {\\n  opacity: 0.25;\\n}\\n.parcoords {\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -khtml-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n  background-color: white;\\n}\\n\\n/* data table styles */\\n.parcoords .row,\\n.parcoords .header {\\n  clear: left;\\n  font-size: 12px;\\n  line-height: 18px;\\n  height: 18px;\\n  margin: 0px;\\n}\\n.parcoords .row:nth-child(odd) {\\n  background: rgba(0, 0, 0, 0.05);\\n}\\n.parcoords .header {\\n  font-weight: bold;\\n}\\n.parcoords .cell {\\n  float: left;\\n  overflow: hidden;\\n  white-space: nowrap;\\n  width: 100px;\\n  height: 18px;\\n}\\n.parcoords .col-0 {\\n  width: 180px;\\n}\\n\", \"\", {\"version\":3,\"sources\":[\"/app/superset-frontend/node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\"],\"names\":[],\"mappings\":\"AAAA,mBAAmB;AACnB;;EAEE,gBAAgB;EAChB,mBAAmB;CACpB;AACD;EACE,qBAAqB;CACtB;;AAED;EACE,WAAW;EACX,gBAAgB;EAChB,aAAa;CACd;;AAED;EACE,kBAAkB;CACnB;AACD;EACE,+BAA+B;CAChC;AACD;EACE,yBAAyB;CAC1B;AACD;EACE,gCAAgC;EAChC,2BAA2B;CAC5B;AACD;;EAEE,WAAW;EACX,aAAa;EACb,4BAA4B;CAC7B;AACD;EACE,WAAW;EACX,8BAA8B;EAC9B,iCAAiC;EACjC,4BAA4B;CAC7B;AACD;EACE,cAAc;CACf;AACD;EACE,4BAA4B;EAC5B,0BAA0B;EAC1B,yBAAyB;EACzB,uBAAuB;EACvB,sBAAsB;EACtB,kBAAkB;EAClB,wBAAwB;CACzB;;AAED,uBAAuB;AACvB;;EAEE,YAAY;EACZ,gBAAgB;EAChB,kBAAkB;EAClB,aAAa;EACb,YAAY;CACb;AACD;EACE,gCAAgC;CACjC;AACD;EACE,kBAAkB;CACnB;AACD;EACE,YAAY;EACZ,iBAAiB;EACjB,oBAAoB;EACpB,aAAa;EACb,aAAa;CACd;AACD;EACE,aAAa;CACd\",\"file\":\"d3.parcoords.css\",\"sourcesContent\":[\"/* [LICENSE TBD] */\\n.parcoords svg,\\n.parcoords canvas {\\n  font-size: 12px;\\n  position: absolute;\\n}\\n.parcoords > canvas {\\n  pointer-events: none;\\n}\\n\\n.parcoords text.label {\\n  font: 100%;\\n  font-size: 12px;\\n  cursor: drag;\\n}\\n\\n.parcoords rect.background {\\n  fill: transparent;\\n}\\n.parcoords rect.background:hover {\\n  fill: rgba(120, 120, 120, 0.2);\\n}\\n.parcoords .resize rect {\\n  fill: rgba(0, 0, 0, 0.1);\\n}\\n.parcoords rect.extent {\\n  fill: rgba(255, 255, 255, 0.25);\\n  stroke: rgba(0, 0, 0, 0.6);\\n}\\n.parcoords .axis line,\\n.parcoords .axis path {\\n  fill: none;\\n  stroke: #222;\\n  shape-rendering: crispEdges;\\n}\\n.parcoords canvas {\\n  opacity: 1;\\n  -moz-transition: opacity 0.3s;\\n  -webkit-transition: opacity 0.3s;\\n  -o-transition: opacity 0.3s;\\n}\\n.parcoords canvas.faded {\\n  opacity: 0.25;\\n}\\n.parcoords {\\n  -webkit-touch-callout: none;\\n  -webkit-user-select: none;\\n  -khtml-user-select: none;\\n  -moz-user-select: none;\\n  -ms-user-select: none;\\n  user-select: none;\\n  background-color: white;\\n}\\n\\n/* data table styles */\\n.parcoords .row,\\n.parcoords .header {\\n  clear: left;\\n  font-size: 12px;\\n  line-height: 18px;\\n  height: 18px;\\n  margin: 0px;\\n}\\n.parcoords .row:nth-child(odd) {\\n  background: rgba(0, 0, 0, 0.05);\\n}\\n.parcoords .header {\\n  font-weight: bold;\\n}\\n.parcoords .cell {\\n  float: left;\\n  overflow: hidden;\\n  white-space: nowrap;\\n  width: 100px;\\n  height: 18px;\\n}\\n.parcoords .col-0 {\\n  width: 180px;\\n}\\n\"],\"sourceRoot\":\"\"}]);\n\n// exports\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz8hLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wbHVnaW4tY2hhcnQtcGFyYWxsZWwtY29vcmRpbmF0ZXMvZXNtL3ZlbmRvci9wYXJjb29yZHMvZDMucGFyY29vcmRzLmNzcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3VwZXJzZXQtdWkvbGVnYWN5LXBsdWdpbi1jaGFydC1wYXJhbGxlbC1jb29yZGluYXRlcy9lc20vdmVuZG9yL3BhcmNvb3Jkcy9kMy5wYXJjb29yZHMuY3NzP2IyZTYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uLy4uLy4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiLyogW0xJQ0VOU0UgVEJEXSAqL1xcbi5wYXJjb29yZHMgc3ZnLFxcbi5wYXJjb29yZHMgY2FudmFzIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG59XFxuLnBhcmNvb3JkcyA+IGNhbnZhcyB7XFxuICBwb2ludGVyLWV2ZW50czogbm9uZTtcXG59XFxuXFxuLnBhcmNvb3JkcyB0ZXh0LmxhYmVsIHtcXG4gIGZvbnQ6IDEwMCU7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBjdXJzb3I6IGRyYWc7XFxufVxcblxcbi5wYXJjb29yZHMgcmVjdC5iYWNrZ3JvdW5kIHtcXG4gIGZpbGw6IHRyYW5zcGFyZW50O1xcbn1cXG4ucGFyY29vcmRzIHJlY3QuYmFja2dyb3VuZDpob3ZlciB7XFxuICBmaWxsOiByZ2JhKDEyMCwgMTIwLCAxMjAsIDAuMik7XFxufVxcbi5wYXJjb29yZHMgLnJlc2l6ZSByZWN0IHtcXG4gIGZpbGw6IHJnYmEoMCwgMCwgMCwgMC4xKTtcXG59XFxuLnBhcmNvb3JkcyByZWN0LmV4dGVudCB7XFxuICBmaWxsOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMjUpO1xcbiAgc3Ryb2tlOiByZ2JhKDAsIDAsIDAsIDAuNik7XFxufVxcbi5wYXJjb29yZHMgLmF4aXMgbGluZSxcXG4ucGFyY29vcmRzIC5heGlzIHBhdGgge1xcbiAgZmlsbDogbm9uZTtcXG4gIHN0cm9rZTogIzIyMjtcXG4gIHNoYXBlLXJlbmRlcmluZzogY3Jpc3BFZGdlcztcXG59XFxuLnBhcmNvb3JkcyBjYW52YXMge1xcbiAgb3BhY2l0eTogMTtcXG4gIC1tb3otdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzO1xcbiAgLXdlYmtpdC10cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XFxuICAtby10cmFuc2l0aW9uOiBvcGFjaXR5IDAuM3M7XFxufVxcbi5wYXJjb29yZHMgY2FudmFzLmZhZGVkIHtcXG4gIG9wYWNpdHk6IDAuMjU7XFxufVxcbi5wYXJjb29yZHMge1xcbiAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xcbiAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1raHRtbC11c2VyLXNlbGVjdDogbm9uZTtcXG4gIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICB1c2VyLXNlbGVjdDogbm9uZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHdoaXRlO1xcbn1cXG5cXG4vKiBkYXRhIHRhYmxlIHN0eWxlcyAqL1xcbi5wYXJjb29yZHMgLnJvdyxcXG4ucGFyY29vcmRzIC5oZWFkZXIge1xcbiAgY2xlYXI6IGxlZnQ7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBsaW5lLWhlaWdodDogMThweDtcXG4gIGhlaWdodDogMThweDtcXG4gIG1hcmdpbjogMHB4O1xcbn1cXG4ucGFyY29vcmRzIC5yb3c6bnRoLWNoaWxkKG9kZCkge1xcbiAgYmFja2dyb3VuZDogcmdiYSgwLCAwLCAwLCAwLjA1KTtcXG59XFxuLnBhcmNvb3JkcyAuaGVhZGVyIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcbn1cXG4ucGFyY29vcmRzIC5jZWxsIHtcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHdoaXRlLXNwYWNlOiBub3dyYXA7XFxuICB3aWR0aDogMTAwcHg7XFxuICBoZWlnaHQ6IDE4cHg7XFxufVxcbi5wYXJjb29yZHMgLmNvbC0wIHtcXG4gIHdpZHRoOiAxODBweDtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9hcHAvc3VwZXJzZXQtZnJvbnRlbmQvbm9kZV9tb2R1bGVzL0BzdXBlcnNldC11aS9sZWdhY3ktcGx1Z2luLWNoYXJ0LXBhcmFsbGVsLWNvb3JkaW5hdGVzL2VzbS92ZW5kb3IvcGFyY29vcmRzL2QzLnBhcmNvb3Jkcy5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUEsbUJBQW1CO0FBQ25COztFQUVFLGdCQUFnQjtFQUNoQixtQkFBbUI7Q0FDcEI7QUFDRDtFQUNFLHFCQUFxQjtDQUN0Qjs7QUFFRDtFQUNFLFdBQVc7RUFDWCxnQkFBZ0I7RUFDaEIsYUFBYTtDQUNkOztBQUVEO0VBQ0Usa0JBQWtCO0NBQ25CO0FBQ0Q7RUFDRSwrQkFBK0I7Q0FDaEM7QUFDRDtFQUNFLHlCQUF5QjtDQUMxQjtBQUNEO0VBQ0UsZ0NBQWdDO0VBQ2hDLDJCQUEyQjtDQUM1QjtBQUNEOztFQUVFLFdBQVc7RUFDWCxhQUFhO0VBQ2IsNEJBQTRCO0NBQzdCO0FBQ0Q7RUFDRSxXQUFXO0VBQ1gsOEJBQThCO0VBQzlCLGlDQUFpQztFQUNqQyw0QkFBNEI7Q0FDN0I7QUFDRDtFQUNFLGNBQWM7Q0FDZjtBQUNEO0VBQ0UsNEJBQTRCO0VBQzVCLDBCQUEwQjtFQUMxQix5QkFBeUI7RUFDekIsdUJBQXVCO0VBQ3ZCLHNCQUFzQjtFQUN0QixrQkFBa0I7RUFDbEIsd0JBQXdCO0NBQ3pCOztBQUVELHVCQUF1QjtBQUN2Qjs7RUFFRSxZQUFZO0VBQ1osZ0JBQWdCO0VBQ2hCLGtCQUFrQjtFQUNsQixhQUFhO0VBQ2IsWUFBWTtDQUNiO0FBQ0Q7RUFDRSxnQ0FBZ0M7Q0FDakM7QUFDRDtFQUNFLGtCQUFrQjtDQUNuQjtBQUNEO0VBQ0UsWUFBWTtFQUNaLGlCQUFpQjtFQUNqQixvQkFBb0I7RUFDcEIsYUFBYTtFQUNiLGFBQWE7Q0FDZDtBQUNEO0VBQ0UsYUFBYTtDQUNkXCIsXCJmaWxlXCI6XCJkMy5wYXJjb29yZHMuY3NzXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi8qIFtMSUNFTlNFIFRCRF0gKi9cXG4ucGFyY29vcmRzIHN2ZyxcXG4ucGFyY29vcmRzIGNhbnZhcyB7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxufVxcbi5wYXJjb29yZHMgPiBjYW52YXMge1xcbiAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5wYXJjb29yZHMgdGV4dC5sYWJlbCB7XFxuICBmb250OiAxMDAlO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgY3Vyc29yOiBkcmFnO1xcbn1cXG5cXG4ucGFyY29vcmRzIHJlY3QuYmFja2dyb3VuZCB7XFxuICBmaWxsOiB0cmFuc3BhcmVudDtcXG59XFxuLnBhcmNvb3JkcyByZWN0LmJhY2tncm91bmQ6aG92ZXIge1xcbiAgZmlsbDogcmdiYSgxMjAsIDEyMCwgMTIwLCAwLjIpO1xcbn1cXG4ucGFyY29vcmRzIC5yZXNpemUgcmVjdCB7XFxuICBmaWxsOiByZ2JhKDAsIDAsIDAsIDAuMSk7XFxufVxcbi5wYXJjb29yZHMgcmVjdC5leHRlbnQge1xcbiAgZmlsbDogcmdiYSgyNTUsIDI1NSwgMjU1LCAwLjI1KTtcXG4gIHN0cm9rZTogcmdiYSgwLCAwLCAwLCAwLjYpO1xcbn1cXG4ucGFyY29vcmRzIC5heGlzIGxpbmUsXFxuLnBhcmNvb3JkcyAuYXhpcyBwYXRoIHtcXG4gIGZpbGw6IG5vbmU7XFxuICBzdHJva2U6ICMyMjI7XFxuICBzaGFwZS1yZW5kZXJpbmc6IGNyaXNwRWRnZXM7XFxufVxcbi5wYXJjb29yZHMgY2FudmFzIHtcXG4gIG9wYWNpdHk6IDE7XFxuICAtbW96LXRyYW5zaXRpb246IG9wYWNpdHkgMC4zcztcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzO1xcbiAgLW8tdHJhbnNpdGlvbjogb3BhY2l0eSAwLjNzO1xcbn1cXG4ucGFyY29vcmRzIGNhbnZhcy5mYWRlZCB7XFxuICBvcGFjaXR5OiAwLjI1O1xcbn1cXG4ucGFyY29vcmRzIHtcXG4gIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTtcXG4gIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAta2h0bWwtdXNlci1zZWxlY3Q6IG5vbmU7XFxuICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcbiAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcbiAgdXNlci1zZWxlY3Q6IG5vbmU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG59XFxuXFxuLyogZGF0YSB0YWJsZSBzdHlsZXMgKi9cXG4ucGFyY29vcmRzIC5yb3csXFxuLnBhcmNvb3JkcyAuaGVhZGVyIHtcXG4gIGNsZWFyOiBsZWZ0O1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgbGluZS1oZWlnaHQ6IDE4cHg7XFxuICBoZWlnaHQ6IDE4cHg7XFxuICBtYXJnaW46IDBweDtcXG59XFxuLnBhcmNvb3JkcyAucm93Om50aC1jaGlsZChvZGQpIHtcXG4gIGJhY2tncm91bmQ6IHJnYmEoMCwgMCwgMCwgMC4wNSk7XFxufVxcbi5wYXJjb29yZHMgLmhlYWRlciB7XFxuICBmb250LXdlaWdodDogYm9sZDtcXG59XFxuLnBhcmNvb3JkcyAuY2VsbCB7XFxuICBmbG9hdDogbGVmdDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB3aGl0ZS1zcGFjZTogbm93cmFwO1xcbiAgd2lkdGg6IDEwMHB4O1xcbiAgaGVpZ2h0OiAxOHB4O1xcbn1cXG4ucGFyY29vcmRzIC5jb2wtMCB7XFxuICB3aWR0aDogMTgwcHg7XFxufVxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/css-loader/index.js?!./node_modules/@superset-ui/legacy-plugin-chart-parallel-coordinates/esm/vendor/parcoords/d3.parcoords.css\n");

/***/ })

}]);