(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[24],{

/***/ "./node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js ***!
  \******************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return GeoJsonLayer; });\n/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @deck.gl/core */ \"./node_modules/@deck.gl/core/dist/esm/lib/composite-layer.js\");\n/* harmony import */ var _scatterplot_layer_scatterplot_layer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../scatterplot-layer/scatterplot-layer */ \"./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js\");\n/* harmony import */ var _path_layer_path_layer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../path-layer/path-layer */ \"./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js\");\n/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @luma.gl/core */ \"./node_modules/@luma.gl/core/dist/esm/materials/phong-material.js\");\n/* harmony import */ var _solid_polygon_layer_solid_polygon_layer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../solid-polygon-layer/solid-polygon-layer */ \"./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js\");\n/* harmony import */ var _geojson__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./geojson */ \"./node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js\");\n\n\n\n\n\n\n\n\n\n\n\nvar defaultLineColor = [0, 0, 0, 255];\nvar defaultFillColor = [0, 0, 0, 255];\nvar defaultMaterial = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_8__[\"default\"]();\nvar defaultProps = {\n  stroked: true,\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  lineWidthUnits: 'meters',\n  lineWidthScale: 1,\n  lineWidthMinPixels: 0,\n  lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineJointRounded: false,\n  lineMiterLimit: 4,\n  elevationScale: 1,\n  pointRadiusScale: 1,\n  pointRadiusMinPixels: 0,\n  pointRadiusMaxPixels: Number.MAX_SAFE_INTEGER,\n  lineDashJustified: false,\n  fp64: false,\n  getLineColor: {\n    type: 'accessor',\n    value: defaultLineColor\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: defaultFillColor\n  },\n  getRadius: {\n    type: 'accessor',\n    value: 1\n  },\n  getLineWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  getLineDashArray: {\n    type: 'accessor',\n    value: [0, 0]\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  material: defaultMaterial\n};\n\nfunction getCoordinates(f) {\n  return f.geometry.coordinates;\n}\n\nfunction unwrappingAccessor(accessor) {\n  if (typeof accessor !== 'function') return accessor;\n  return function (feature) {\n    return accessor(Object(_geojson__WEBPACK_IMPORTED_MODULE_10__[\"unwrapSourceFeature\"])(feature));\n  };\n}\n\nvar GeoJsonLayer = function (_CompositeLayer) {\n  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(GeoJsonLayer, _CompositeLayer);\n\n  function GeoJsonLayer() {\n    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, GeoJsonLayer);\n\n    return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(GeoJsonLayer).apply(this, arguments));\n  }\n\n  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(GeoJsonLayer, [{\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.state = {\n        features: {}\n      };\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var oldProps = _ref.oldProps,\n          props = _ref.props,\n          changeFlags = _ref.changeFlags;\n\n      if (changeFlags.dataChanged) {\n        var data = props.data;\n        var features = Object(_geojson__WEBPACK_IMPORTED_MODULE_10__[\"getGeojsonFeatures\"])(data);\n        this.state.features = Object(_geojson__WEBPACK_IMPORTED_MODULE_10__[\"separateGeojsonFeatures\"])(features);\n      }\n    }\n  }, {\n    key: \"getPickingInfo\",\n    value: function getPickingInfo(_ref2) {\n      var info = _ref2.info,\n          sourceLayer = _ref2.sourceLayer;\n      return Object.assign(info, {\n        object: info.object ? Object(_geojson__WEBPACK_IMPORTED_MODULE_10__[\"unwrapSourceFeature\"])(info.object) : info.object,\n        index: info.object ? Object(_geojson__WEBPACK_IMPORTED_MODULE_10__[\"unwrapSourceFeatureIndex\"])(info.object) : info.index\n      });\n    }\n  }, {\n    key: \"renderLayers\",\n    value: function renderLayers() {\n      var features = this.state.features;\n      var pointFeatures = features.pointFeatures,\n          lineFeatures = features.lineFeatures,\n          polygonFeatures = features.polygonFeatures,\n          polygonOutlineFeatures = features.polygonOutlineFeatures;\n      var _this$props = this.props,\n          stroked = _this$props.stroked,\n          filled = _this$props.filled,\n          extruded = _this$props.extruded,\n          wireframe = _this$props.wireframe,\n          material = _this$props.material,\n          transitions = _this$props.transitions;\n      var _this$props2 = this.props,\n          lineWidthUnits = _this$props2.lineWidthUnits,\n          lineWidthScale = _this$props2.lineWidthScale,\n          lineWidthMinPixels = _this$props2.lineWidthMinPixels,\n          lineWidthMaxPixels = _this$props2.lineWidthMaxPixels,\n          lineJointRounded = _this$props2.lineJointRounded,\n          lineMiterLimit = _this$props2.lineMiterLimit,\n          pointRadiusScale = _this$props2.pointRadiusScale,\n          pointRadiusMinPixels = _this$props2.pointRadiusMinPixels,\n          pointRadiusMaxPixels = _this$props2.pointRadiusMaxPixels,\n          elevationScale = _this$props2.elevationScale,\n          lineDashJustified = _this$props2.lineDashJustified,\n          fp64 = _this$props2.fp64;\n      var _this$props3 = this.props,\n          getLineColor = _this$props3.getLineColor,\n          getFillColor = _this$props3.getFillColor,\n          getRadius = _this$props3.getRadius,\n          getLineWidth = _this$props3.getLineWidth,\n          getLineDashArray = _this$props3.getLineDashArray,\n          getElevation = _this$props3.getElevation,\n          updateTriggers = _this$props3.updateTriggers;\n      var PolygonFillLayer = this.getSubLayerClass('polygons-fill', _solid_polygon_layer_solid_polygon_layer__WEBPACK_IMPORTED_MODULE_9__[\"default\"]);\n      var PolygonStrokeLayer = this.getSubLayerClass('polygons-stroke', _path_layer_path_layer__WEBPACK_IMPORTED_MODULE_7__[\"default\"]);\n      var LineStringsLayer = this.getSubLayerClass('line-strings', _path_layer_path_layer__WEBPACK_IMPORTED_MODULE_7__[\"default\"]);\n      var PointsLayer = this.getSubLayerClass('points', _scatterplot_layer_scatterplot_layer__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n      var polygonFillLayer = this.shouldRenderSubLayer('polygons-fill', polygonFeatures) && new PolygonFillLayer({\n        fp64: fp64,\n        extruded: extruded,\n        elevationScale: elevationScale,\n        filled: filled,\n        wireframe: wireframe,\n        material: material,\n        getElevation: unwrappingAccessor(getElevation),\n        getFillColor: unwrappingAccessor(getFillColor),\n        getLineColor: unwrappingAccessor(getLineColor),\n        transitions: transitions && {\n          getPolygon: transitions.geometry,\n          getElevation: transitions.getElevation,\n          getFillColor: transitions.getFillColor,\n          getLineColor: transitions.getLineColor\n        }\n      }, this.getSubLayerProps({\n        id: 'polygons-fill',\n        updateTriggers: {\n          getElevation: updateTriggers.getElevation,\n          getFillColor: updateTriggers.getFillColor,\n          getLineColor: updateTriggers.getLineColor\n        }\n      }), {\n        data: polygonFeatures,\n        getPolygon: getCoordinates\n      });\n      var polygonLineLayer = !extruded && stroked && this.shouldRenderSubLayer('polygons-stroke', polygonOutlineFeatures) && new PolygonStrokeLayer({\n        fp64: fp64,\n        widthUnits: lineWidthUnits,\n        widthScale: lineWidthScale,\n        widthMinPixels: lineWidthMinPixels,\n        widthMaxPixels: lineWidthMaxPixels,\n        rounded: lineJointRounded,\n        miterLimit: lineMiterLimit,\n        dashJustified: lineDashJustified,\n        getColor: unwrappingAccessor(getLineColor),\n        getWidth: unwrappingAccessor(getLineWidth),\n        getDashArray: unwrappingAccessor(getLineDashArray),\n        transitions: transitions && {\n          getPath: transitions.geometry,\n          getColor: transitions.getLineColor,\n          getWidth: transitions.getLineWidth\n        }\n      }, this.getSubLayerProps({\n        id: 'polygons-stroke',\n        updateTriggers: {\n          getColor: updateTriggers.getLineColor,\n          getWidth: updateTriggers.getLineWidth,\n          getDashArray: updateTriggers.getLineDashArray\n        }\n      }), {\n        data: polygonOutlineFeatures,\n        getPath: getCoordinates\n      });\n      var pathLayer = this.shouldRenderSubLayer('linestrings', lineFeatures) && new LineStringsLayer({\n        fp64: fp64,\n        widthUnits: lineWidthUnits,\n        widthScale: lineWidthScale,\n        widthMinPixels: lineWidthMinPixels,\n        widthMaxPixels: lineWidthMaxPixels,\n        rounded: lineJointRounded,\n        miterLimit: lineMiterLimit,\n        dashJustified: lineDashJustified,\n        getColor: unwrappingAccessor(getLineColor),\n        getWidth: unwrappingAccessor(getLineWidth),\n        getDashArray: unwrappingAccessor(getLineDashArray),\n        transitions: transitions && {\n          getPath: transitions.geometry,\n          getColor: transitions.getLineColor,\n          getWidth: transitions.getLineWidth\n        }\n      }, this.getSubLayerProps({\n        id: 'line-strings',\n        updateTriggers: {\n          getColor: updateTriggers.getLineColor,\n          getWidth: updateTriggers.getLineWidth,\n          getDashArray: updateTriggers.getLineDashArray\n        }\n      }), {\n        data: lineFeatures,\n        getPath: getCoordinates\n      });\n      var pointLayer = this.shouldRenderSubLayer('points', pointFeatures) && new PointsLayer({\n        fp64: fp64,\n        stroked: stroked,\n        filled: filled,\n        radiusScale: pointRadiusScale,\n        radiusMinPixels: pointRadiusMinPixels,\n        radiusMaxPixels: pointRadiusMaxPixels,\n        lineWidthUnits: lineWidthUnits,\n        lineWidthScale: lineWidthScale,\n        lineWidthMinPixels: lineWidthMinPixels,\n        lineWidthMaxPixels: lineWidthMaxPixels,\n        getFillColor: unwrappingAccessor(getFillColor),\n        getLineColor: unwrappingAccessor(getLineColor),\n        getRadius: unwrappingAccessor(getRadius),\n        getLineWidth: unwrappingAccessor(getLineWidth),\n        transitions: transitions && {\n          getPosition: transitions.geometry,\n          getFillColor: transitions.getFillColor,\n          getLineColor: transitions.getLineColor,\n          getRadius: transitions.getRadius,\n          getLineWidth: transitions.getLineWidth\n        }\n      }, this.getSubLayerProps({\n        id: 'points',\n        updateTriggers: {\n          getFillColor: updateTriggers.getFillColor,\n          getLineColor: updateTriggers.getLineColor,\n          getRadius: updateTriggers.getRadius,\n          getLineWidth: updateTriggers.getLineWidth\n        }\n      }), {\n        data: pointFeatures,\n        getPosition: getCoordinates\n      });\n      return [!extruded && polygonFillLayer, polygonLineLayer, pathLayer, pointLayer, extruded && polygonFillLayer];\n    }\n  }]);\n\n  return GeoJsonLayer;\n}(_deck_gl_core__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n\n\nGeoJsonLayer.layerName = 'GeoJsonLayer';\nGeoJsonLayer.defaultProps = defaultProps;\n//# sourceMappingURL=geojson-layer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL2dlb2pzb24tbGF5ZXIvZ2VvanNvbi1sYXllci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vZ2VvanNvbi1sYXllci9nZW9qc29uLWxheWVyLmpzPzczMDYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjtcbmltcG9ydCBfZ2V0UHJvdG90eXBlT2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mXCI7XG5pbXBvcnQgX2luaGVyaXRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c1wiO1xuaW1wb3J0IHsgQ29tcG9zaXRlTGF5ZXIgfSBmcm9tICdAZGVjay5nbC9jb3JlJztcbmltcG9ydCBTY2F0dGVycGxvdExheWVyIGZyb20gJy4uL3NjYXR0ZXJwbG90LWxheWVyL3NjYXR0ZXJwbG90LWxheWVyJztcbmltcG9ydCBQYXRoTGF5ZXIgZnJvbSAnLi4vcGF0aC1sYXllci9wYXRoLWxheWVyJztcbmltcG9ydCB7IFBob25nTWF0ZXJpYWwgfSBmcm9tICdAbHVtYS5nbC9jb3JlJztcbmltcG9ydCBTb2xpZFBvbHlnb25MYXllciBmcm9tICcuLi9zb2xpZC1wb2x5Z29uLWxheWVyL3NvbGlkLXBvbHlnb24tbGF5ZXInO1xuaW1wb3J0IHsgZ2V0R2VvanNvbkZlYXR1cmVzLCBzZXBhcmF0ZUdlb2pzb25GZWF0dXJlcywgdW53cmFwU291cmNlRmVhdHVyZSwgdW53cmFwU291cmNlRmVhdHVyZUluZGV4IH0gZnJvbSAnLi9nZW9qc29uJztcbnZhciBkZWZhdWx0TGluZUNvbG9yID0gWzAsIDAsIDAsIDI1NV07XG52YXIgZGVmYXVsdEZpbGxDb2xvciA9IFswLCAwLCAwLCAyNTVdO1xudmFyIGRlZmF1bHRNYXRlcmlhbCA9IG5ldyBQaG9uZ01hdGVyaWFsKCk7XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBzdHJva2VkOiB0cnVlLFxuICBmaWxsZWQ6IHRydWUsXG4gIGV4dHJ1ZGVkOiBmYWxzZSxcbiAgd2lyZWZyYW1lOiBmYWxzZSxcbiAgbGluZVdpZHRoVW5pdHM6ICdtZXRlcnMnLFxuICBsaW5lV2lkdGhTY2FsZTogMSxcbiAgbGluZVdpZHRoTWluUGl4ZWxzOiAwLFxuICBsaW5lV2lkdGhNYXhQaXhlbHM6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICBsaW5lSm9pbnRSb3VuZGVkOiBmYWxzZSxcbiAgbGluZU1pdGVyTGltaXQ6IDQsXG4gIGVsZXZhdGlvblNjYWxlOiAxLFxuICBwb2ludFJhZGl1c1NjYWxlOiAxLFxuICBwb2ludFJhZGl1c01pblBpeGVsczogMCxcbiAgcG9pbnRSYWRpdXNNYXhQaXhlbHM6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLFxuICBsaW5lRGFzaEp1c3RpZmllZDogZmFsc2UsXG4gIGZwNjQ6IGZhbHNlLFxuICBnZXRMaW5lQ29sb3I6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBkZWZhdWx0TGluZUNvbG9yXG4gIH0sXG4gIGdldEZpbGxDb2xvcjoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IGRlZmF1bHRGaWxsQ29sb3JcbiAgfSxcbiAgZ2V0UmFkaXVzOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogMVxuICB9LFxuICBnZXRMaW5lV2lkdGg6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiAxXG4gIH0sXG4gIGdldExpbmVEYXNoQXJyYXk6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBbMCwgMF1cbiAgfSxcbiAgZ2V0RWxldmF0aW9uOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogMTAwMFxuICB9LFxuICBtYXRlcmlhbDogZGVmYXVsdE1hdGVyaWFsXG59O1xuXG5mdW5jdGlvbiBnZXRDb29yZGluYXRlcyhmKSB7XG4gIHJldHVybiBmLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xufVxuXG5mdW5jdGlvbiB1bndyYXBwaW5nQWNjZXNzb3IoYWNjZXNzb3IpIHtcbiAgaWYgKHR5cGVvZiBhY2Nlc3NvciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGFjY2Vzc29yO1xuICByZXR1cm4gZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICByZXR1cm4gYWNjZXNzb3IodW53cmFwU291cmNlRmVhdHVyZShmZWF0dXJlKSk7XG4gIH07XG59XG5cbnZhciBHZW9Kc29uTGF5ZXIgPSBmdW5jdGlvbiAoX0NvbXBvc2l0ZUxheWVyKSB7XG4gIF9pbmhlcml0cyhHZW9Kc29uTGF5ZXIsIF9Db21wb3NpdGVMYXllcik7XG5cbiAgZnVuY3Rpb24gR2VvSnNvbkxheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBHZW9Kc29uTGF5ZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihHZW9Kc29uTGF5ZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKEdlb0pzb25MYXllciwgW3tcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICAgIGZlYXR1cmVzOiB7fVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU3RhdGUoX3JlZikge1xuICAgICAgdmFyIG9sZFByb3BzID0gX3JlZi5vbGRQcm9wcyxcbiAgICAgICAgICBwcm9wcyA9IF9yZWYucHJvcHMsXG4gICAgICAgICAgY2hhbmdlRmxhZ3MgPSBfcmVmLmNoYW5nZUZsYWdzO1xuXG4gICAgICBpZiAoY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQpIHtcbiAgICAgICAgdmFyIGRhdGEgPSBwcm9wcy5kYXRhO1xuICAgICAgICB2YXIgZmVhdHVyZXMgPSBnZXRHZW9qc29uRmVhdHVyZXMoZGF0YSk7XG4gICAgICAgIHRoaXMuc3RhdGUuZmVhdHVyZXMgPSBzZXBhcmF0ZUdlb2pzb25GZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldFBpY2tpbmdJbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBpY2tpbmdJbmZvKF9yZWYyKSB7XG4gICAgICB2YXIgaW5mbyA9IF9yZWYyLmluZm8sXG4gICAgICAgICAgc291cmNlTGF5ZXIgPSBfcmVmMi5zb3VyY2VMYXllcjtcbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGluZm8sIHtcbiAgICAgICAgb2JqZWN0OiBpbmZvLm9iamVjdCA/IHVud3JhcFNvdXJjZUZlYXR1cmUoaW5mby5vYmplY3QpIDogaW5mby5vYmplY3QsXG4gICAgICAgIGluZGV4OiBpbmZvLm9iamVjdCA/IHVud3JhcFNvdXJjZUZlYXR1cmVJbmRleChpbmZvLm9iamVjdCkgOiBpbmZvLmluZGV4XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyTGF5ZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckxheWVycygpIHtcbiAgICAgIHZhciBmZWF0dXJlcyA9IHRoaXMuc3RhdGUuZmVhdHVyZXM7XG4gICAgICB2YXIgcG9pbnRGZWF0dXJlcyA9IGZlYXR1cmVzLnBvaW50RmVhdHVyZXMsXG4gICAgICAgICAgbGluZUZlYXR1cmVzID0gZmVhdHVyZXMubGluZUZlYXR1cmVzLFxuICAgICAgICAgIHBvbHlnb25GZWF0dXJlcyA9IGZlYXR1cmVzLnBvbHlnb25GZWF0dXJlcyxcbiAgICAgICAgICBwb2x5Z29uT3V0bGluZUZlYXR1cmVzID0gZmVhdHVyZXMucG9seWdvbk91dGxpbmVGZWF0dXJlcztcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgc3Ryb2tlZCA9IF90aGlzJHByb3BzLnN0cm9rZWQsXG4gICAgICAgICAgZmlsbGVkID0gX3RoaXMkcHJvcHMuZmlsbGVkLFxuICAgICAgICAgIGV4dHJ1ZGVkID0gX3RoaXMkcHJvcHMuZXh0cnVkZWQsXG4gICAgICAgICAgd2lyZWZyYW1lID0gX3RoaXMkcHJvcHMud2lyZWZyYW1lLFxuICAgICAgICAgIG1hdGVyaWFsID0gX3RoaXMkcHJvcHMubWF0ZXJpYWwsXG4gICAgICAgICAgdHJhbnNpdGlvbnMgPSBfdGhpcyRwcm9wcy50cmFuc2l0aW9ucztcbiAgICAgIHZhciBfdGhpcyRwcm9wczIgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGxpbmVXaWR0aFVuaXRzID0gX3RoaXMkcHJvcHMyLmxpbmVXaWR0aFVuaXRzLFxuICAgICAgICAgIGxpbmVXaWR0aFNjYWxlID0gX3RoaXMkcHJvcHMyLmxpbmVXaWR0aFNjYWxlLFxuICAgICAgICAgIGxpbmVXaWR0aE1pblBpeGVscyA9IF90aGlzJHByb3BzMi5saW5lV2lkdGhNaW5QaXhlbHMsXG4gICAgICAgICAgbGluZVdpZHRoTWF4UGl4ZWxzID0gX3RoaXMkcHJvcHMyLmxpbmVXaWR0aE1heFBpeGVscyxcbiAgICAgICAgICBsaW5lSm9pbnRSb3VuZGVkID0gX3RoaXMkcHJvcHMyLmxpbmVKb2ludFJvdW5kZWQsXG4gICAgICAgICAgbGluZU1pdGVyTGltaXQgPSBfdGhpcyRwcm9wczIubGluZU1pdGVyTGltaXQsXG4gICAgICAgICAgcG9pbnRSYWRpdXNTY2FsZSA9IF90aGlzJHByb3BzMi5wb2ludFJhZGl1c1NjYWxlLFxuICAgICAgICAgIHBvaW50UmFkaXVzTWluUGl4ZWxzID0gX3RoaXMkcHJvcHMyLnBvaW50UmFkaXVzTWluUGl4ZWxzLFxuICAgICAgICAgIHBvaW50UmFkaXVzTWF4UGl4ZWxzID0gX3RoaXMkcHJvcHMyLnBvaW50UmFkaXVzTWF4UGl4ZWxzLFxuICAgICAgICAgIGVsZXZhdGlvblNjYWxlID0gX3RoaXMkcHJvcHMyLmVsZXZhdGlvblNjYWxlLFxuICAgICAgICAgIGxpbmVEYXNoSnVzdGlmaWVkID0gX3RoaXMkcHJvcHMyLmxpbmVEYXNoSnVzdGlmaWVkLFxuICAgICAgICAgIGZwNjQgPSBfdGhpcyRwcm9wczIuZnA2NDtcbiAgICAgIHZhciBfdGhpcyRwcm9wczMgPSB0aGlzLnByb3BzLFxuICAgICAgICAgIGdldExpbmVDb2xvciA9IF90aGlzJHByb3BzMy5nZXRMaW5lQ29sb3IsXG4gICAgICAgICAgZ2V0RmlsbENvbG9yID0gX3RoaXMkcHJvcHMzLmdldEZpbGxDb2xvcixcbiAgICAgICAgICBnZXRSYWRpdXMgPSBfdGhpcyRwcm9wczMuZ2V0UmFkaXVzLFxuICAgICAgICAgIGdldExpbmVXaWR0aCA9IF90aGlzJHByb3BzMy5nZXRMaW5lV2lkdGgsXG4gICAgICAgICAgZ2V0TGluZURhc2hBcnJheSA9IF90aGlzJHByb3BzMy5nZXRMaW5lRGFzaEFycmF5LFxuICAgICAgICAgIGdldEVsZXZhdGlvbiA9IF90aGlzJHByb3BzMy5nZXRFbGV2YXRpb24sXG4gICAgICAgICAgdXBkYXRlVHJpZ2dlcnMgPSBfdGhpcyRwcm9wczMudXBkYXRlVHJpZ2dlcnM7XG4gICAgICB2YXIgUG9seWdvbkZpbGxMYXllciA9IHRoaXMuZ2V0U3ViTGF5ZXJDbGFzcygncG9seWdvbnMtZmlsbCcsIFNvbGlkUG9seWdvbkxheWVyKTtcbiAgICAgIHZhciBQb2x5Z29uU3Ryb2tlTGF5ZXIgPSB0aGlzLmdldFN1YkxheWVyQ2xhc3MoJ3BvbHlnb25zLXN0cm9rZScsIFBhdGhMYXllcik7XG4gICAgICB2YXIgTGluZVN0cmluZ3NMYXllciA9IHRoaXMuZ2V0U3ViTGF5ZXJDbGFzcygnbGluZS1zdHJpbmdzJywgUGF0aExheWVyKTtcbiAgICAgIHZhciBQb2ludHNMYXllciA9IHRoaXMuZ2V0U3ViTGF5ZXJDbGFzcygncG9pbnRzJywgU2NhdHRlcnBsb3RMYXllcik7XG4gICAgICB2YXIgcG9seWdvbkZpbGxMYXllciA9IHRoaXMuc2hvdWxkUmVuZGVyU3ViTGF5ZXIoJ3BvbHlnb25zLWZpbGwnLCBwb2x5Z29uRmVhdHVyZXMpICYmIG5ldyBQb2x5Z29uRmlsbExheWVyKHtcbiAgICAgICAgZnA2NDogZnA2NCxcbiAgICAgICAgZXh0cnVkZWQ6IGV4dHJ1ZGVkLFxuICAgICAgICBlbGV2YXRpb25TY2FsZTogZWxldmF0aW9uU2NhbGUsXG4gICAgICAgIGZpbGxlZDogZmlsbGVkLFxuICAgICAgICB3aXJlZnJhbWU6IHdpcmVmcmFtZSxcbiAgICAgICAgbWF0ZXJpYWw6IG1hdGVyaWFsLFxuICAgICAgICBnZXRFbGV2YXRpb246IHVud3JhcHBpbmdBY2Nlc3NvcihnZXRFbGV2YXRpb24pLFxuICAgICAgICBnZXRGaWxsQ29sb3I6IHVud3JhcHBpbmdBY2Nlc3NvcihnZXRGaWxsQ29sb3IpLFxuICAgICAgICBnZXRMaW5lQ29sb3I6IHVud3JhcHBpbmdBY2Nlc3NvcihnZXRMaW5lQ29sb3IpLFxuICAgICAgICB0cmFuc2l0aW9uczogdHJhbnNpdGlvbnMgJiYge1xuICAgICAgICAgIGdldFBvbHlnb246IHRyYW5zaXRpb25zLmdlb21ldHJ5LFxuICAgICAgICAgIGdldEVsZXZhdGlvbjogdHJhbnNpdGlvbnMuZ2V0RWxldmF0aW9uLFxuICAgICAgICAgIGdldEZpbGxDb2xvcjogdHJhbnNpdGlvbnMuZ2V0RmlsbENvbG9yLFxuICAgICAgICAgIGdldExpbmVDb2xvcjogdHJhbnNpdGlvbnMuZ2V0TGluZUNvbG9yXG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuZ2V0U3ViTGF5ZXJQcm9wcyh7XG4gICAgICAgIGlkOiAncG9seWdvbnMtZmlsbCcsXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgZ2V0RWxldmF0aW9uOiB1cGRhdGVUcmlnZ2Vycy5nZXRFbGV2YXRpb24sXG4gICAgICAgICAgZ2V0RmlsbENvbG9yOiB1cGRhdGVUcmlnZ2Vycy5nZXRGaWxsQ29sb3IsXG4gICAgICAgICAgZ2V0TGluZUNvbG9yOiB1cGRhdGVUcmlnZ2Vycy5nZXRMaW5lQ29sb3JcbiAgICAgICAgfVxuICAgICAgfSksIHtcbiAgICAgICAgZGF0YTogcG9seWdvbkZlYXR1cmVzLFxuICAgICAgICBnZXRQb2x5Z29uOiBnZXRDb29yZGluYXRlc1xuICAgICAgfSk7XG4gICAgICB2YXIgcG9seWdvbkxpbmVMYXllciA9ICFleHRydWRlZCAmJiBzdHJva2VkICYmIHRoaXMuc2hvdWxkUmVuZGVyU3ViTGF5ZXIoJ3BvbHlnb25zLXN0cm9rZScsIHBvbHlnb25PdXRsaW5lRmVhdHVyZXMpICYmIG5ldyBQb2x5Z29uU3Ryb2tlTGF5ZXIoe1xuICAgICAgICBmcDY0OiBmcDY0LFxuICAgICAgICB3aWR0aFVuaXRzOiBsaW5lV2lkdGhVbml0cyxcbiAgICAgICAgd2lkdGhTY2FsZTogbGluZVdpZHRoU2NhbGUsXG4gICAgICAgIHdpZHRoTWluUGl4ZWxzOiBsaW5lV2lkdGhNaW5QaXhlbHMsXG4gICAgICAgIHdpZHRoTWF4UGl4ZWxzOiBsaW5lV2lkdGhNYXhQaXhlbHMsXG4gICAgICAgIHJvdW5kZWQ6IGxpbmVKb2ludFJvdW5kZWQsXG4gICAgICAgIG1pdGVyTGltaXQ6IGxpbmVNaXRlckxpbWl0LFxuICAgICAgICBkYXNoSnVzdGlmaWVkOiBsaW5lRGFzaEp1c3RpZmllZCxcbiAgICAgICAgZ2V0Q29sb3I6IHVud3JhcHBpbmdBY2Nlc3NvcihnZXRMaW5lQ29sb3IpLFxuICAgICAgICBnZXRXaWR0aDogdW53cmFwcGluZ0FjY2Vzc29yKGdldExpbmVXaWR0aCksXG4gICAgICAgIGdldERhc2hBcnJheTogdW53cmFwcGluZ0FjY2Vzc29yKGdldExpbmVEYXNoQXJyYXkpLFxuICAgICAgICB0cmFuc2l0aW9uczogdHJhbnNpdGlvbnMgJiYge1xuICAgICAgICAgIGdldFBhdGg6IHRyYW5zaXRpb25zLmdlb21ldHJ5LFxuICAgICAgICAgIGdldENvbG9yOiB0cmFuc2l0aW9ucy5nZXRMaW5lQ29sb3IsXG4gICAgICAgICAgZ2V0V2lkdGg6IHRyYW5zaXRpb25zLmdldExpbmVXaWR0aFxuICAgICAgICB9XG4gICAgICB9LCB0aGlzLmdldFN1YkxheWVyUHJvcHMoe1xuICAgICAgICBpZDogJ3BvbHlnb25zLXN0cm9rZScsXG4gICAgICAgIHVwZGF0ZVRyaWdnZXJzOiB7XG4gICAgICAgICAgZ2V0Q29sb3I6IHVwZGF0ZVRyaWdnZXJzLmdldExpbmVDb2xvcixcbiAgICAgICAgICBnZXRXaWR0aDogdXBkYXRlVHJpZ2dlcnMuZ2V0TGluZVdpZHRoLFxuICAgICAgICAgIGdldERhc2hBcnJheTogdXBkYXRlVHJpZ2dlcnMuZ2V0TGluZURhc2hBcnJheVxuICAgICAgICB9XG4gICAgICB9KSwge1xuICAgICAgICBkYXRhOiBwb2x5Z29uT3V0bGluZUZlYXR1cmVzLFxuICAgICAgICBnZXRQYXRoOiBnZXRDb29yZGluYXRlc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aExheWVyID0gdGhpcy5zaG91bGRSZW5kZXJTdWJMYXllcignbGluZXN0cmluZ3MnLCBsaW5lRmVhdHVyZXMpICYmIG5ldyBMaW5lU3RyaW5nc0xheWVyKHtcbiAgICAgICAgZnA2NDogZnA2NCxcbiAgICAgICAgd2lkdGhVbml0czogbGluZVdpZHRoVW5pdHMsXG4gICAgICAgIHdpZHRoU2NhbGU6IGxpbmVXaWR0aFNjYWxlLFxuICAgICAgICB3aWR0aE1pblBpeGVsczogbGluZVdpZHRoTWluUGl4ZWxzLFxuICAgICAgICB3aWR0aE1heFBpeGVsczogbGluZVdpZHRoTWF4UGl4ZWxzLFxuICAgICAgICByb3VuZGVkOiBsaW5lSm9pbnRSb3VuZGVkLFxuICAgICAgICBtaXRlckxpbWl0OiBsaW5lTWl0ZXJMaW1pdCxcbiAgICAgICAgZGFzaEp1c3RpZmllZDogbGluZURhc2hKdXN0aWZpZWQsXG4gICAgICAgIGdldENvbG9yOiB1bndyYXBwaW5nQWNjZXNzb3IoZ2V0TGluZUNvbG9yKSxcbiAgICAgICAgZ2V0V2lkdGg6IHVud3JhcHBpbmdBY2Nlc3NvcihnZXRMaW5lV2lkdGgpLFxuICAgICAgICBnZXREYXNoQXJyYXk6IHVud3JhcHBpbmdBY2Nlc3NvcihnZXRMaW5lRGFzaEFycmF5KSxcbiAgICAgICAgdHJhbnNpdGlvbnM6IHRyYW5zaXRpb25zICYmIHtcbiAgICAgICAgICBnZXRQYXRoOiB0cmFuc2l0aW9ucy5nZW9tZXRyeSxcbiAgICAgICAgICBnZXRDb2xvcjogdHJhbnNpdGlvbnMuZ2V0TGluZUNvbG9yLFxuICAgICAgICAgIGdldFdpZHRoOiB0cmFuc2l0aW9ucy5nZXRMaW5lV2lkdGhcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5nZXRTdWJMYXllclByb3BzKHtcbiAgICAgICAgaWQ6ICdsaW5lLXN0cmluZ3MnLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgIGdldENvbG9yOiB1cGRhdGVUcmlnZ2Vycy5nZXRMaW5lQ29sb3IsXG4gICAgICAgICAgZ2V0V2lkdGg6IHVwZGF0ZVRyaWdnZXJzLmdldExpbmVXaWR0aCxcbiAgICAgICAgICBnZXREYXNoQXJyYXk6IHVwZGF0ZVRyaWdnZXJzLmdldExpbmVEYXNoQXJyYXlcbiAgICAgICAgfVxuICAgICAgfSksIHtcbiAgICAgICAgZGF0YTogbGluZUZlYXR1cmVzLFxuICAgICAgICBnZXRQYXRoOiBnZXRDb29yZGluYXRlc1xuICAgICAgfSk7XG4gICAgICB2YXIgcG9pbnRMYXllciA9IHRoaXMuc2hvdWxkUmVuZGVyU3ViTGF5ZXIoJ3BvaW50cycsIHBvaW50RmVhdHVyZXMpICYmIG5ldyBQb2ludHNMYXllcih7XG4gICAgICAgIGZwNjQ6IGZwNjQsXG4gICAgICAgIHN0cm9rZWQ6IHN0cm9rZWQsXG4gICAgICAgIGZpbGxlZDogZmlsbGVkLFxuICAgICAgICByYWRpdXNTY2FsZTogcG9pbnRSYWRpdXNTY2FsZSxcbiAgICAgICAgcmFkaXVzTWluUGl4ZWxzOiBwb2ludFJhZGl1c01pblBpeGVscyxcbiAgICAgICAgcmFkaXVzTWF4UGl4ZWxzOiBwb2ludFJhZGl1c01heFBpeGVscyxcbiAgICAgICAgbGluZVdpZHRoVW5pdHM6IGxpbmVXaWR0aFVuaXRzLFxuICAgICAgICBsaW5lV2lkdGhTY2FsZTogbGluZVdpZHRoU2NhbGUsXG4gICAgICAgIGxpbmVXaWR0aE1pblBpeGVsczogbGluZVdpZHRoTWluUGl4ZWxzLFxuICAgICAgICBsaW5lV2lkdGhNYXhQaXhlbHM6IGxpbmVXaWR0aE1heFBpeGVscyxcbiAgICAgICAgZ2V0RmlsbENvbG9yOiB1bndyYXBwaW5nQWNjZXNzb3IoZ2V0RmlsbENvbG9yKSxcbiAgICAgICAgZ2V0TGluZUNvbG9yOiB1bndyYXBwaW5nQWNjZXNzb3IoZ2V0TGluZUNvbG9yKSxcbiAgICAgICAgZ2V0UmFkaXVzOiB1bndyYXBwaW5nQWNjZXNzb3IoZ2V0UmFkaXVzKSxcbiAgICAgICAgZ2V0TGluZVdpZHRoOiB1bndyYXBwaW5nQWNjZXNzb3IoZ2V0TGluZVdpZHRoKSxcbiAgICAgICAgdHJhbnNpdGlvbnM6IHRyYW5zaXRpb25zICYmIHtcbiAgICAgICAgICBnZXRQb3NpdGlvbjogdHJhbnNpdGlvbnMuZ2VvbWV0cnksXG4gICAgICAgICAgZ2V0RmlsbENvbG9yOiB0cmFuc2l0aW9ucy5nZXRGaWxsQ29sb3IsXG4gICAgICAgICAgZ2V0TGluZUNvbG9yOiB0cmFuc2l0aW9ucy5nZXRMaW5lQ29sb3IsXG4gICAgICAgICAgZ2V0UmFkaXVzOiB0cmFuc2l0aW9ucy5nZXRSYWRpdXMsXG4gICAgICAgICAgZ2V0TGluZVdpZHRoOiB0cmFuc2l0aW9ucy5nZXRMaW5lV2lkdGhcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5nZXRTdWJMYXllclByb3BzKHtcbiAgICAgICAgaWQ6ICdwb2ludHMnLFxuICAgICAgICB1cGRhdGVUcmlnZ2Vyczoge1xuICAgICAgICAgIGdldEZpbGxDb2xvcjogdXBkYXRlVHJpZ2dlcnMuZ2V0RmlsbENvbG9yLFxuICAgICAgICAgIGdldExpbmVDb2xvcjogdXBkYXRlVHJpZ2dlcnMuZ2V0TGluZUNvbG9yLFxuICAgICAgICAgIGdldFJhZGl1czogdXBkYXRlVHJpZ2dlcnMuZ2V0UmFkaXVzLFxuICAgICAgICAgIGdldExpbmVXaWR0aDogdXBkYXRlVHJpZ2dlcnMuZ2V0TGluZVdpZHRoXG4gICAgICAgIH1cbiAgICAgIH0pLCB7XG4gICAgICAgIGRhdGE6IHBvaW50RmVhdHVyZXMsXG4gICAgICAgIGdldFBvc2l0aW9uOiBnZXRDb29yZGluYXRlc1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gWyFleHRydWRlZCAmJiBwb2x5Z29uRmlsbExheWVyLCBwb2x5Z29uTGluZUxheWVyLCBwYXRoTGF5ZXIsIHBvaW50TGF5ZXIsIGV4dHJ1ZGVkICYmIHBvbHlnb25GaWxsTGF5ZXJdO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBHZW9Kc29uTGF5ZXI7XG59KENvbXBvc2l0ZUxheWVyKTtcblxuZXhwb3J0IHsgR2VvSnNvbkxheWVyIGFzIGRlZmF1bHQgfTtcbkdlb0pzb25MYXllci5sYXllck5hbWUgPSAnR2VvSnNvbkxheWVyJztcbkdlb0pzb25MYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW9qc29uLWxheWVyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js":
/*!************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js ***!
  \************************************************************************/
/*! exports provided: getGeojsonFeatures, separateGeojsonFeatures, unwrapSourceFeature, unwrapSourceFeatureIndex, validateGeometry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getGeojsonFeatures\", function() { return getGeojsonFeatures; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"separateGeojsonFeatures\", function() { return separateGeojsonFeatures; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unwrapSourceFeature\", function() { return unwrapSourceFeature; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"unwrapSourceFeatureIndex\", function() { return unwrapSourceFeatureIndex; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"validateGeometry\", function() { return validateGeometry; });\n/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @deck.gl/core */ \"./node_modules/@deck.gl/core/dist/esm/utils/log.js\");\n\nfunction getGeojsonFeatures(geojson) {\n  if (Array.isArray(geojson)) {\n    return geojson;\n  }\n\n  _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].assert(geojson.type, 'GeoJSON does not have type');\n\n  switch (geojson.type) {\n    case 'Feature':\n      return [geojson];\n\n    case 'FeatureCollection':\n      _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].assert(Array.isArray(geojson.features), 'GeoJSON does not have features array');\n      return geojson.features;\n\n    default:\n      return [{\n        geometry: geojson\n      }];\n  }\n}\nfunction separateGeojsonFeatures(features) {\n  var separated = {\n    pointFeatures: [],\n    lineFeatures: [],\n    polygonFeatures: [],\n    polygonOutlineFeatures: []\n  };\n\n  for (var featureIndex = 0; featureIndex < features.length; featureIndex++) {\n    var feature = features[featureIndex];\n    _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].assert(feature && feature.geometry, 'GeoJSON does not have geometry');\n    var geometry = feature.geometry;\n    var sourceFeature = {\n      feature: feature,\n      index: featureIndex\n    };\n\n    if (geometry.type === 'GeometryCollection') {\n      _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].assert(Array.isArray(geometry.geometries), 'GeoJSON does not have geometries array');\n      var geometries = geometry.geometries;\n\n      for (var i = 0; i < geometries.length; i++) {\n        var subGeometry = geometries[i];\n        separateGeometry(subGeometry, separated, sourceFeature);\n      }\n    } else {\n      separateGeometry(geometry, separated, sourceFeature);\n    }\n  }\n\n  return separated;\n}\n\nfunction separateGeometry(geometry, separated, sourceFeature) {\n  var type = geometry.type,\n      coordinates = geometry.coordinates;\n  var pointFeatures = separated.pointFeatures,\n      lineFeatures = separated.lineFeatures,\n      polygonFeatures = separated.polygonFeatures,\n      polygonOutlineFeatures = separated.polygonOutlineFeatures;\n\n  if (!validateGeometry(type, coordinates)) {\n    _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].warn(\"\".concat(type, \" coordinates are malformed\"))();\n    return;\n  }\n\n  switch (type) {\n    case 'Point':\n      pointFeatures.push({\n        geometry: geometry,\n        sourceFeature: sourceFeature\n      });\n      break;\n\n    case 'MultiPoint':\n      coordinates.forEach(function (point) {\n        pointFeatures.push({\n          geometry: {\n            type: 'Point',\n            coordinates: point\n          },\n          sourceFeature: sourceFeature\n        });\n      });\n      break;\n\n    case 'LineString':\n      lineFeatures.push({\n        geometry: geometry,\n        sourceFeature: sourceFeature\n      });\n      break;\n\n    case 'MultiLineString':\n      coordinates.forEach(function (path) {\n        lineFeatures.push({\n          geometry: {\n            type: 'LineString',\n            coordinates: path\n          },\n          sourceFeature: sourceFeature\n        });\n      });\n      break;\n\n    case 'Polygon':\n      polygonFeatures.push({\n        geometry: geometry,\n        sourceFeature: sourceFeature\n      });\n      coordinates.forEach(function (path) {\n        polygonOutlineFeatures.push({\n          geometry: {\n            type: 'LineString',\n            coordinates: path\n          },\n          sourceFeature: sourceFeature\n        });\n      });\n      break;\n\n    case 'MultiPolygon':\n      coordinates.forEach(function (polygon) {\n        polygonFeatures.push({\n          geometry: {\n            type: 'Polygon',\n            coordinates: polygon\n          },\n          sourceFeature: sourceFeature\n        });\n        polygon.forEach(function (path) {\n          polygonOutlineFeatures.push({\n            geometry: {\n              type: 'LineString',\n              coordinates: path\n            },\n            sourceFeature: sourceFeature\n          });\n        });\n      });\n      break;\n\n    default:\n  }\n}\n\nfunction unwrapSourceFeature(wrappedFeature) {\n  return wrappedFeature.sourceFeature.feature;\n}\nfunction unwrapSourceFeatureIndex(wrappedFeature) {\n  return wrappedFeature.sourceFeature.index;\n}\nvar COORDINATE_NEST_LEVEL = {\n  Point: 1,\n  MultiPoint: 2,\n  LineString: 2,\n  MultiLineString: 3,\n  Polygon: 3,\n  MultiPolygon: 4\n};\nfunction validateGeometry(type, coordinates) {\n  var nestLevel = COORDINATE_NEST_LEVEL[type];\n  _deck_gl_core__WEBPACK_IMPORTED_MODULE_0__[\"default\"].assert(nestLevel, \"Unknown GeoJSON type \".concat(type));\n\n  while (coordinates && --nestLevel > 0) {\n    coordinates = coordinates[0];\n  }\n\n  return coordinates && Number.isFinite(coordinates[0]);\n}\n//# sourceMappingURL=geojson.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL2dlb2pzb24tbGF5ZXIvZ2VvanNvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vZ2VvanNvbi1sYXllci9nZW9qc29uLmpzPzMzZjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgbG9nIH0gZnJvbSAnQGRlY2suZ2wvY29yZSc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0R2VvanNvbkZlYXR1cmVzKGdlb2pzb24pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZ2VvanNvbikpIHtcbiAgICByZXR1cm4gZ2VvanNvbjtcbiAgfVxuXG4gIGxvZy5hc3NlcnQoZ2VvanNvbi50eXBlLCAnR2VvSlNPTiBkb2VzIG5vdCBoYXZlIHR5cGUnKTtcblxuICBzd2l0Y2ggKGdlb2pzb24udHlwZSkge1xuICAgIGNhc2UgJ0ZlYXR1cmUnOlxuICAgICAgcmV0dXJuIFtnZW9qc29uXTtcblxuICAgIGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcbiAgICAgIGxvZy5hc3NlcnQoQXJyYXkuaXNBcnJheShnZW9qc29uLmZlYXR1cmVzKSwgJ0dlb0pTT04gZG9lcyBub3QgaGF2ZSBmZWF0dXJlcyBhcnJheScpO1xuICAgICAgcmV0dXJuIGdlb2pzb24uZmVhdHVyZXM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGdlb21ldHJ5OiBnZW9qc29uXG4gICAgICB9XTtcbiAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNlcGFyYXRlR2VvanNvbkZlYXR1cmVzKGZlYXR1cmVzKSB7XG4gIHZhciBzZXBhcmF0ZWQgPSB7XG4gICAgcG9pbnRGZWF0dXJlczogW10sXG4gICAgbGluZUZlYXR1cmVzOiBbXSxcbiAgICBwb2x5Z29uRmVhdHVyZXM6IFtdLFxuICAgIHBvbHlnb25PdXRsaW5lRmVhdHVyZXM6IFtdXG4gIH07XG5cbiAgZm9yICh2YXIgZmVhdHVyZUluZGV4ID0gMDsgZmVhdHVyZUluZGV4IDwgZmVhdHVyZXMubGVuZ3RoOyBmZWF0dXJlSW5kZXgrKykge1xuICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZXNbZmVhdHVyZUluZGV4XTtcbiAgICBsb2cuYXNzZXJ0KGZlYXR1cmUgJiYgZmVhdHVyZS5nZW9tZXRyeSwgJ0dlb0pTT04gZG9lcyBub3QgaGF2ZSBnZW9tZXRyeScpO1xuICAgIHZhciBnZW9tZXRyeSA9IGZlYXR1cmUuZ2VvbWV0cnk7XG4gICAgdmFyIHNvdXJjZUZlYXR1cmUgPSB7XG4gICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgaW5kZXg6IGZlYXR1cmVJbmRleFxuICAgIH07XG5cbiAgICBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicpIHtcbiAgICAgIGxvZy5hc3NlcnQoQXJyYXkuaXNBcnJheShnZW9tZXRyeS5nZW9tZXRyaWVzKSwgJ0dlb0pTT04gZG9lcyBub3QgaGF2ZSBnZW9tZXRyaWVzIGFycmF5Jyk7XG4gICAgICB2YXIgZ2VvbWV0cmllcyA9IGdlb21ldHJ5Lmdlb21ldHJpZXM7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvbWV0cmllcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgc3ViR2VvbWV0cnkgPSBnZW9tZXRyaWVzW2ldO1xuICAgICAgICBzZXBhcmF0ZUdlb21ldHJ5KHN1Ykdlb21ldHJ5LCBzZXBhcmF0ZWQsIHNvdXJjZUZlYXR1cmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzZXBhcmF0ZUdlb21ldHJ5KGdlb21ldHJ5LCBzZXBhcmF0ZWQsIHNvdXJjZUZlYXR1cmUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzZXBhcmF0ZWQ7XG59XG5cbmZ1bmN0aW9uIHNlcGFyYXRlR2VvbWV0cnkoZ2VvbWV0cnksIHNlcGFyYXRlZCwgc291cmNlRmVhdHVyZSkge1xuICB2YXIgdHlwZSA9IGdlb21ldHJ5LnR5cGUsXG4gICAgICBjb29yZGluYXRlcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICB2YXIgcG9pbnRGZWF0dXJlcyA9IHNlcGFyYXRlZC5wb2ludEZlYXR1cmVzLFxuICAgICAgbGluZUZlYXR1cmVzID0gc2VwYXJhdGVkLmxpbmVGZWF0dXJlcyxcbiAgICAgIHBvbHlnb25GZWF0dXJlcyA9IHNlcGFyYXRlZC5wb2x5Z29uRmVhdHVyZXMsXG4gICAgICBwb2x5Z29uT3V0bGluZUZlYXR1cmVzID0gc2VwYXJhdGVkLnBvbHlnb25PdXRsaW5lRmVhdHVyZXM7XG5cbiAgaWYgKCF2YWxpZGF0ZUdlb21ldHJ5KHR5cGUsIGNvb3JkaW5hdGVzKSkge1xuICAgIGxvZy53YXJuKFwiXCIuY29uY2F0KHR5cGUsIFwiIGNvb3JkaW5hdGVzIGFyZSBtYWxmb3JtZWRcIikpKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnUG9pbnQnOlxuICAgICAgcG9pbnRGZWF0dXJlcy5wdXNoKHtcbiAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5LFxuICAgICAgICBzb3VyY2VGZWF0dXJlOiBzb3VyY2VGZWF0dXJlXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICBjb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChwb2ludCkge1xuICAgICAgICBwb2ludEZlYXR1cmVzLnB1c2goe1xuICAgICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHBvaW50XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzb3VyY2VGZWF0dXJlOiBzb3VyY2VGZWF0dXJlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgbGluZUZlYXR1cmVzLnB1c2goe1xuICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICAgIHNvdXJjZUZlYXR1cmU6IHNvdXJjZUZlYXR1cmVcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgY29vcmRpbmF0ZXMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICBsaW5lRmVhdHVyZXMucHVzaCh7XG4gICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBwYXRoXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzb3VyY2VGZWF0dXJlOiBzb3VyY2VGZWF0dXJlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgcG9seWdvbkZlYXR1cmVzLnB1c2goe1xuICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnksXG4gICAgICAgIHNvdXJjZUZlYXR1cmU6IHNvdXJjZUZlYXR1cmVcbiAgICAgIH0pO1xuICAgICAgY29vcmRpbmF0ZXMuZm9yRWFjaChmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICBwb2x5Z29uT3V0bGluZUZlYXR1cmVzLnB1c2goe1xuICAgICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICB0eXBlOiAnTGluZVN0cmluZycsXG4gICAgICAgICAgICBjb29yZGluYXRlczogcGF0aFxuICAgICAgICAgIH0sXG4gICAgICAgICAgc291cmNlRmVhdHVyZTogc291cmNlRmVhdHVyZVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgY29vcmRpbmF0ZXMuZm9yRWFjaChmdW5jdGlvbiAocG9seWdvbikge1xuICAgICAgICBwb2x5Z29uRmVhdHVyZXMucHVzaCh7XG4gICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgIHR5cGU6ICdQb2x5Z29uJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBwb2x5Z29uXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzb3VyY2VGZWF0dXJlOiBzb3VyY2VGZWF0dXJlXG4gICAgICAgIH0pO1xuICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgICBwb2x5Z29uT3V0bGluZUZlYXR1cmVzLnB1c2goe1xuICAgICAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxuICAgICAgICAgICAgICBjb29yZGluYXRlczogcGF0aFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNvdXJjZUZlYXR1cmU6IHNvdXJjZUZlYXR1cmVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdW53cmFwU291cmNlRmVhdHVyZSh3cmFwcGVkRmVhdHVyZSkge1xuICByZXR1cm4gd3JhcHBlZEZlYXR1cmUuc291cmNlRmVhdHVyZS5mZWF0dXJlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHVud3JhcFNvdXJjZUZlYXR1cmVJbmRleCh3cmFwcGVkRmVhdHVyZSkge1xuICByZXR1cm4gd3JhcHBlZEZlYXR1cmUuc291cmNlRmVhdHVyZS5pbmRleDtcbn1cbnZhciBDT09SRElOQVRFX05FU1RfTEVWRUwgPSB7XG4gIFBvaW50OiAxLFxuICBNdWx0aVBvaW50OiAyLFxuICBMaW5lU3RyaW5nOiAyLFxuICBNdWx0aUxpbmVTdHJpbmc6IDMsXG4gIFBvbHlnb246IDMsXG4gIE11bHRpUG9seWdvbjogNFxufTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUdlb21ldHJ5KHR5cGUsIGNvb3JkaW5hdGVzKSB7XG4gIHZhciBuZXN0TGV2ZWwgPSBDT09SRElOQVRFX05FU1RfTEVWRUxbdHlwZV07XG4gIGxvZy5hc3NlcnQobmVzdExldmVsLCBcIlVua25vd24gR2VvSlNPTiB0eXBlIFwiLmNvbmNhdCh0eXBlKSk7XG5cbiAgd2hpbGUgKGNvb3JkaW5hdGVzICYmIC0tbmVzdExldmVsID4gMCkge1xuICAgIGNvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXNbMF07XG4gIH1cblxuICByZXR1cm4gY29vcmRpbmF0ZXMgJiYgTnVtYmVyLmlzRmluaXRlKGNvb3JkaW5hdGVzWzBdKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdlb2pzb24uanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"#define SHADER_NAME path-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform float jointType;\\nuniform float miterLimit;\\nuniform float alignMode;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vDashArray;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\nfloat mod2(float a, float b) {\\n  return a - floor(a / b) * b;\\n}\\n\\nfloat round(float x) {\\n  return floor(x + 0.5);\\n}\\nbool dash_isFragInGap() {\\n  float solidLength = vDashArray.x;\\n  float gapLength = vDashArray.y;\\n\\n  float unitLength = solidLength + gapLength;\\n\\n  if (unitLength == 0.0) {\\n    return false;\\n  }\\n\\n  unitLength = mix(\\n    unitLength,\\n    vPathLength / round(vPathLength / unitLength),\\n    alignMode\\n  );\\n\\n  float offset = alignMode * solidLength / 2.0;\\n\\n  return gapLength > 0.0 &&\\n    vPathPosition.y >= 0.0 &&\\n    vPathPosition.y <= vPathLength &&\\n    mod2(vPathPosition.y + offset, unitLength) > solidLength;\\n}\\n\\nvoid main(void) {\\n  if (jointType > 0.0 && vMiterLength > 0.0 && length(vCornerOffset) > 1.0) {\\n    discard;\\n  }\\n  if (jointType == 0.0 && vMiterLength > miterLimit) {\\n    discard;\\n  }\\n  if (vColor.a == 0.0 || dash_isFragInGap()) {\\n    discard;\\n  }\\n  gl_FragColor = vColor;\\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\\n}\\n\");\n//# sourceMappingURL=path-layer-fragment.glsl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3BhdGgtbGF5ZXIvcGF0aC1sYXllci1mcmFnbWVudC5nbHNsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS9wYXRoLWxheWVyL3BhdGgtbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcz82MmUzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBTSEFERVJfTkFNRSBwYXRoLWxheWVyLWZyYWdtZW50LXNoYWRlclxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXG51bmlmb3JtIGZsb2F0IGpvaW50VHlwZTtcXG51bmlmb3JtIGZsb2F0IG1pdGVyTGltaXQ7XFxudW5pZm9ybSBmbG9hdCBhbGlnbk1vZGU7XFxuXFxudmFyeWluZyB2ZWM0IHZDb2xvcjtcXG52YXJ5aW5nIHZlYzIgdkNvcm5lck9mZnNldDtcXG52YXJ5aW5nIGZsb2F0IHZNaXRlckxlbmd0aDtcXG52YXJ5aW5nIHZlYzIgdkRhc2hBcnJheTtcXG52YXJ5aW5nIHZlYzIgdlBhdGhQb3NpdGlvbjtcXG52YXJ5aW5nIGZsb2F0IHZQYXRoTGVuZ3RoO1xcbmZsb2F0IG1vZDIoZmxvYXQgYSwgZmxvYXQgYikge1xcbiAgcmV0dXJuIGEgLSBmbG9vcihhIC8gYikgKiBiO1xcbn1cXG5cXG5mbG9hdCByb3VuZChmbG9hdCB4KSB7XFxuICByZXR1cm4gZmxvb3IoeCArIDAuNSk7XFxufVxcbmJvb2wgZGFzaF9pc0ZyYWdJbkdhcCgpIHtcXG4gIGZsb2F0IHNvbGlkTGVuZ3RoID0gdkRhc2hBcnJheS54O1xcbiAgZmxvYXQgZ2FwTGVuZ3RoID0gdkRhc2hBcnJheS55O1xcblxcbiAgZmxvYXQgdW5pdExlbmd0aCA9IHNvbGlkTGVuZ3RoICsgZ2FwTGVuZ3RoO1xcblxcbiAgaWYgKHVuaXRMZW5ndGggPT0gMC4wKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG5cXG4gIHVuaXRMZW5ndGggPSBtaXgoXFxuICAgIHVuaXRMZW5ndGgsXFxuICAgIHZQYXRoTGVuZ3RoIC8gcm91bmQodlBhdGhMZW5ndGggLyB1bml0TGVuZ3RoKSxcXG4gICAgYWxpZ25Nb2RlXFxuICApO1xcblxcbiAgZmxvYXQgb2Zmc2V0ID0gYWxpZ25Nb2RlICogc29saWRMZW5ndGggLyAyLjA7XFxuXFxuICByZXR1cm4gZ2FwTGVuZ3RoID4gMC4wICYmXFxuICAgIHZQYXRoUG9zaXRpb24ueSA+PSAwLjAgJiZcXG4gICAgdlBhdGhQb3NpdGlvbi55IDw9IHZQYXRoTGVuZ3RoICYmXFxuICAgIG1vZDIodlBhdGhQb3NpdGlvbi55ICsgb2Zmc2V0LCB1bml0TGVuZ3RoKSA+IHNvbGlkTGVuZ3RoO1xcbn1cXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgaWYgKGpvaW50VHlwZSA+IDAuMCAmJiB2TWl0ZXJMZW5ndGggPiAwLjAgJiYgbGVuZ3RoKHZDb3JuZXJPZmZzZXQpID4gMS4wKSB7XFxuICAgIGRpc2NhcmQ7XFxuICB9XFxuICBpZiAoam9pbnRUeXBlID09IDAuMCAmJiB2TWl0ZXJMZW5ndGggPiBtaXRlckxpbWl0KSB7XFxuICAgIGRpc2NhcmQ7XFxuICB9XFxuICBpZiAodkNvbG9yLmEgPT0gMC4wIHx8IGRhc2hfaXNGcmFnSW5HYXAoKSkge1xcbiAgICBkaXNjYXJkO1xcbiAgfVxcbiAgZ2xfRnJhZ0NvbG9yID0gdkNvbG9yO1xcbiAgZ2xfRnJhZ0NvbG9yID0gcGlja2luZ19maWx0ZXJIaWdobGlnaHRDb2xvcihnbF9GcmFnQ29sb3IpO1xcbiAgZ2xfRnJhZ0NvbG9yID0gcGlja2luZ19maWx0ZXJQaWNraW5nQ29sb3IoZ2xfRnJhZ0NvbG9yKTtcXG59XFxuXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLWxheWVyLWZyYWdtZW50Lmdsc2wuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex-64.glsl.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex-64.glsl.js ***!
  \***************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"\\n#define SHADER_NAME path-layer-vertex-shader-64\\n\\nattribute vec3 positions;\\n\\nattribute vec3 instanceStartPositions;\\nattribute vec3 instanceEndPositions;\\nattribute vec4 instanceStartEndPositions64xyLow;\\nattribute vec3 instanceLeftPositions;\\nattribute vec3 instanceRightPositions;\\nattribute vec4 instanceNeighborPositions64xyLow;\\nattribute float instanceStrokeWidths;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\nattribute vec2 instanceDashArrays;\\n\\nuniform float widthScale;\\nuniform float widthMinPixels;\\nuniform float widthMaxPixels;\\nuniform float jointType;\\nuniform float miterLimit;\\n\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vDashArray;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\n\\nconst float EPSILON = 0.001;\\n\\nfloat flipIfTrue(bool flag) {\\n  return -(float(flag) * 2. - 1.);\\n}\\n\\nvec3 lineJoin(vec2 prevPoint64[2], vec2 currPoint64[2], vec2 nextPoint64[2]) {\\n\\n  float widthPixels = clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\\n    widthMinPixels, widthMaxPixels) / 2.0;\\n  float width = project_pixel_size(widthPixels);\\n\\n  vec2 deltaA64[2];\\n  vec2 deltaB64[2];\\n\\n  vec2_sub_fp64(currPoint64, prevPoint64, deltaA64);\\n  vec2_sub_fp64(nextPoint64, currPoint64, deltaB64);\\n\\n  vec2 lengthA64 = vec2_length_fp64(deltaA64);\\n  vec2 lengthB64 = vec2_length_fp64(deltaB64);\\n\\n  vec2 deltaA = vec2(deltaA64[0].x, deltaA64[1].x);\\n  vec2 deltaB = vec2(deltaB64[0].x, deltaB64[1].x);\\n\\n  float lenA = lengthA64.x;\\n  float lenB = lengthB64.x;\\n\\n  vec2 offsetVec;\\n  float offsetScale;\\n  float offsetDirection;\\n  lenA = lenA / width > EPSILON ? lenA : 0.0;\\n  lenB = lenB / width > EPSILON ? lenB : 0.0;\\n  vec2 dirA = lenA > 0. ? deltaA / lenA : vec2(0.0, 0.0);\\n  vec2 dirB = lenB > 0. ? deltaB / lenB : vec2(0.0, 0.0);\\n\\n  vec2 perpA = vec2(-dirA.y, dirA.x);\\n  vec2 perpB = vec2(-dirB.y, dirB.x);\\n  vec2 tangent = vec2(dirA + dirB);\\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\\n  vec2 perp = mix(perpB, perpA, positions.x);\\n  float L = mix(lenB, lenA, positions.x);\\n  float sinHalfA = abs(dot(miterVec, perp));\\n  float cosHalfA = abs(dot(dirA, miterVec));\\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\\n  float cornerPosition = mix(\\n    flipIfTrue(turnsRight == (positions.y > 0.0)),\\n    0.0,\\n    positions.z\\n  );\\n\\n  offsetScale = 1.0 / max(sinHalfA, EPSILON);\\n  cornerPosition *= float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) / width * cosHalfA);\\n  offsetScale = mix(\\n    offsetScale,\\n    min(offsetScale, L / width / max(cosHalfA, EPSILON)),\\n    float(cornerPosition < 0.0)\\n  );\\n\\n  vMiterLength = mix(\\n    offsetScale * cornerPosition,\\n    mix(offsetScale, 0.0, cornerPosition),\\n    step(0.0, cornerPosition)\\n  ) - sinHalfA * jointType;\\n  offsetDirection = mix(\\n    positions.y,\\n    mix(\\n      flipIfTrue(turnsRight),\\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\\n      cornerPosition\\n    ),\\n    step(0.0, cornerPosition)\\n  );\\n  offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\\n  float isStartCap = step(lenA, 1.0e-5);\\n  float isEndCap = step(lenB, 1.0e-5);\\n  float isCap = max(isStartCap, isEndCap);\\n  cornerPosition = isCap * (1.0 - positions.z);\\n  offsetVec = mix(offsetVec, mix(dirB, perpB, cornerPosition), isStartCap);\\n  offsetVec = mix(offsetVec, mix(dirA, perpA, cornerPosition), isEndCap);\\n  offsetScale = mix(\\n    offsetScale,\\n    mix(4.0 * jointType, 1.0, cornerPosition),\\n    isCap\\n  );\\n  vMiterLength = mix(vMiterLength, 1.0 - cornerPosition, isCap);\\n\\n  offsetDirection = mix(\\n    offsetDirection,\\n    mix(flipIfTrue(isStartCap > 0.), positions.y, cornerPosition),\\n    isCap\\n  );\\n\\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\\n  vDashArray = instanceDashArrays;\\n  vPathLength = L / width;\\n  float isEnd = positions.x;\\n  vec2 offsetFromStartOfPath = mix(vCornerOffset, vCornerOffset + deltaA / width, isEnd);\\n  vec2 dir = mix(dirB, dirA, isEnd);\\n  vPathPosition = vec2(\\n    positions.y + positions.z * offsetDirection,\\n    dot(offsetFromStartOfPath, dir)\\n  );\\n\\n  return vec3(vCornerOffset * width, 0.0);\\n}\\n\\nvoid main() {\\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  picking_setPickingColor(instancePickingColors);\\n\\n  float isEnd = positions.x;\\n\\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\\n  vec2 projected_curr_position[2];\\n  project_position_fp64(currPosition.xy, currPosition64xyLow, projected_curr_position);\\n  float projected_curr_position_z = project_size(currPosition.z);\\n\\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\\n  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);\\n\\n  vec2 projected_prev_position[2];\\n  project_position_fp64(prevPosition.xy, prevPosition64xyLow, projected_prev_position);\\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\\n  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);\\n\\n  vec2 projected_next_position[2];\\n  project_position_fp64(nextPosition.xy, nextPosition64xyLow, projected_next_position);\\n\\n  vec3 pos = lineJoin(projected_prev_position, projected_curr_position, projected_next_position);\\n  vec2 vertex_pos_modelspace[4];\\n\\n  vertex_pos_modelspace[0] = sum_fp64(vec2(pos.x, 0.0), projected_curr_position[0]);\\n  vertex_pos_modelspace[1] = sum_fp64(vec2(pos.y, 0.0), projected_curr_position[1]);\\n  vertex_pos_modelspace[2] = vec2(pos.z + projected_curr_position_z, 0.0);\\n  vertex_pos_modelspace[3] = vec2(1.0, 0.0);\\n\\n  gl_Position = project_common_position_to_clipspace_fp64(vertex_pos_modelspace);\\n}\\n\");\n//# sourceMappingURL=path-layer-vertex-64.glsl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3BhdGgtbGF5ZXIvcGF0aC1sYXllci12ZXJ0ZXgtNjQuZ2xzbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vcGF0aC1sYXllci9wYXRoLWxheWVyLXZlcnRleC02NC5nbHNsLmpzP2QzMTQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJcXG4jZGVmaW5lIFNIQURFUl9OQU1FIHBhdGgtbGF5ZXItdmVydGV4LXNoYWRlci02NFxcblxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcXG5cXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlRW5kUG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlU3RhcnRFbmRQb3NpdGlvbnM2NHh5TG93O1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlTGVmdFBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVJpZ2h0UG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlTmVpZ2hib3JQb3NpdGlvbnM2NHh5TG93O1xcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVN0cm9rZVdpZHRocztcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XFxuYXR0cmlidXRlIHZlYzIgaW5zdGFuY2VEYXNoQXJyYXlzO1xcblxcbnVuaWZvcm0gZmxvYXQgd2lkdGhTY2FsZTtcXG51bmlmb3JtIGZsb2F0IHdpZHRoTWluUGl4ZWxzO1xcbnVuaWZvcm0gZmxvYXQgd2lkdGhNYXhQaXhlbHM7XFxudW5pZm9ybSBmbG9hdCBqb2ludFR5cGU7XFxudW5pZm9ybSBmbG9hdCBtaXRlckxpbWl0O1xcblxcbnVuaWZvcm0gZmxvYXQgb3BhY2l0eTtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgdmVjMiB2Q29ybmVyT2Zmc2V0O1xcbnZhcnlpbmcgZmxvYXQgdk1pdGVyTGVuZ3RoO1xcbnZhcnlpbmcgdmVjMiB2RGFzaEFycmF5O1xcbnZhcnlpbmcgdmVjMiB2UGF0aFBvc2l0aW9uO1xcbnZhcnlpbmcgZmxvYXQgdlBhdGhMZW5ndGg7XFxuXFxuY29uc3QgZmxvYXQgRVBTSUxPTiA9IDAuMDAxO1xcblxcbmZsb2F0IGZsaXBJZlRydWUoYm9vbCBmbGFnKSB7XFxuICByZXR1cm4gLShmbG9hdChmbGFnKSAqIDIuIC0gMS4pO1xcbn1cXG5cXG52ZWMzIGxpbmVKb2luKHZlYzIgcHJldlBvaW50NjRbMl0sIHZlYzIgY3VyclBvaW50NjRbMl0sIHZlYzIgbmV4dFBvaW50NjRbMl0pIHtcXG5cXG4gIGZsb2F0IHdpZHRoUGl4ZWxzID0gY2xhbXAocHJvamVjdF9zaXplX3RvX3BpeGVsKGluc3RhbmNlU3Ryb2tlV2lkdGhzICogd2lkdGhTY2FsZSksXFxuICAgIHdpZHRoTWluUGl4ZWxzLCB3aWR0aE1heFBpeGVscykgLyAyLjA7XFxuICBmbG9hdCB3aWR0aCA9IHByb2plY3RfcGl4ZWxfc2l6ZSh3aWR0aFBpeGVscyk7XFxuXFxuICB2ZWMyIGRlbHRhQTY0WzJdO1xcbiAgdmVjMiBkZWx0YUI2NFsyXTtcXG5cXG4gIHZlYzJfc3ViX2ZwNjQoY3VyclBvaW50NjQsIHByZXZQb2ludDY0LCBkZWx0YUE2NCk7XFxuICB2ZWMyX3N1Yl9mcDY0KG5leHRQb2ludDY0LCBjdXJyUG9pbnQ2NCwgZGVsdGFCNjQpO1xcblxcbiAgdmVjMiBsZW5ndGhBNjQgPSB2ZWMyX2xlbmd0aF9mcDY0KGRlbHRhQTY0KTtcXG4gIHZlYzIgbGVuZ3RoQjY0ID0gdmVjMl9sZW5ndGhfZnA2NChkZWx0YUI2NCk7XFxuXFxuICB2ZWMyIGRlbHRhQSA9IHZlYzIoZGVsdGFBNjRbMF0ueCwgZGVsdGFBNjRbMV0ueCk7XFxuICB2ZWMyIGRlbHRhQiA9IHZlYzIoZGVsdGFCNjRbMF0ueCwgZGVsdGFCNjRbMV0ueCk7XFxuXFxuICBmbG9hdCBsZW5BID0gbGVuZ3RoQTY0Lng7XFxuICBmbG9hdCBsZW5CID0gbGVuZ3RoQjY0Lng7XFxuXFxuICB2ZWMyIG9mZnNldFZlYztcXG4gIGZsb2F0IG9mZnNldFNjYWxlO1xcbiAgZmxvYXQgb2Zmc2V0RGlyZWN0aW9uO1xcbiAgbGVuQSA9IGxlbkEgLyB3aWR0aCA+IEVQU0lMT04gPyBsZW5BIDogMC4wO1xcbiAgbGVuQiA9IGxlbkIgLyB3aWR0aCA+IEVQU0lMT04gPyBsZW5CIDogMC4wO1xcbiAgdmVjMiBkaXJBID0gbGVuQSA+IDAuID8gZGVsdGFBIC8gbGVuQSA6IHZlYzIoMC4wLCAwLjApO1xcbiAgdmVjMiBkaXJCID0gbGVuQiA+IDAuID8gZGVsdGFCIC8gbGVuQiA6IHZlYzIoMC4wLCAwLjApO1xcblxcbiAgdmVjMiBwZXJwQSA9IHZlYzIoLWRpckEueSwgZGlyQS54KTtcXG4gIHZlYzIgcGVycEIgPSB2ZWMyKC1kaXJCLnksIGRpckIueCk7XFxuICB2ZWMyIHRhbmdlbnQgPSB2ZWMyKGRpckEgKyBkaXJCKTtcXG4gIHRhbmdlbnQgPSBsZW5ndGgodGFuZ2VudCkgPiAwLiA/IG5vcm1hbGl6ZSh0YW5nZW50KSA6IHBlcnBBO1xcbiAgdmVjMiBtaXRlclZlYyA9IHZlYzIoLXRhbmdlbnQueSwgdGFuZ2VudC54KTtcXG4gIHZlYzIgcGVycCA9IG1peChwZXJwQiwgcGVycEEsIHBvc2l0aW9ucy54KTtcXG4gIGZsb2F0IEwgPSBtaXgobGVuQiwgbGVuQSwgcG9zaXRpb25zLngpO1xcbiAgZmxvYXQgc2luSGFsZkEgPSBhYnMoZG90KG1pdGVyVmVjLCBwZXJwKSk7XFxuICBmbG9hdCBjb3NIYWxmQSA9IGFicyhkb3QoZGlyQSwgbWl0ZXJWZWMpKTtcXG4gIGJvb2wgdHVybnNSaWdodCA9IGRpckEueCAqIGRpckIueSA+IGRpckEueSAqIGRpckIueDtcXG4gIGZsb2F0IGNvcm5lclBvc2l0aW9uID0gbWl4KFxcbiAgICBmbGlwSWZUcnVlKHR1cm5zUmlnaHQgPT0gKHBvc2l0aW9ucy55ID4gMC4wKSksXFxuICAgIDAuMCxcXG4gICAgcG9zaXRpb25zLnpcXG4gICk7XFxuXFxuICBvZmZzZXRTY2FsZSA9IDEuMCAvIG1heChzaW5IYWxmQSwgRVBTSUxPTik7XFxuICBjb3JuZXJQb3NpdGlvbiAqPSBmbG9hdChjb3JuZXJQb3NpdGlvbiA8PSAwLjAgfHwgc2luSGFsZkEgPCBtaW4obGVuQSwgbGVuQikgLyB3aWR0aCAqIGNvc0hhbGZBKTtcXG4gIG9mZnNldFNjYWxlID0gbWl4KFxcbiAgICBvZmZzZXRTY2FsZSxcXG4gICAgbWluKG9mZnNldFNjYWxlLCBMIC8gd2lkdGggLyBtYXgoY29zSGFsZkEsIEVQU0lMT04pKSxcXG4gICAgZmxvYXQoY29ybmVyUG9zaXRpb24gPCAwLjApXFxuICApO1xcblxcbiAgdk1pdGVyTGVuZ3RoID0gbWl4KFxcbiAgICBvZmZzZXRTY2FsZSAqIGNvcm5lclBvc2l0aW9uLFxcbiAgICBtaXgob2Zmc2V0U2NhbGUsIDAuMCwgY29ybmVyUG9zaXRpb24pLFxcbiAgICBzdGVwKDAuMCwgY29ybmVyUG9zaXRpb24pXFxuICApIC0gc2luSGFsZkEgKiBqb2ludFR5cGU7XFxuICBvZmZzZXREaXJlY3Rpb24gPSBtaXgoXFxuICAgIHBvc2l0aW9ucy55LFxcbiAgICBtaXgoXFxuICAgICAgZmxpcElmVHJ1ZSh0dXJuc1JpZ2h0KSxcXG4gICAgICBwb3NpdGlvbnMueSAqIGZsaXBJZlRydWUodHVybnNSaWdodCA9PSAocG9zaXRpb25zLnggPT0gMS4pKSxcXG4gICAgICBjb3JuZXJQb3NpdGlvblxcbiAgICApLFxcbiAgICBzdGVwKDAuMCwgY29ybmVyUG9zaXRpb24pXFxuICApO1xcbiAgb2Zmc2V0VmVjID0gbWl4KG1pdGVyVmVjLCAtdGFuZ2VudCwgc3RlcCgwLjUsIGNvcm5lclBvc2l0aW9uKSk7XFxuICBvZmZzZXRTY2FsZSA9IG1peChvZmZzZXRTY2FsZSwgMS4wIC8gbWF4KGNvc0hhbGZBLCAwLjAwMSksIHN0ZXAoMC41LCBjb3JuZXJQb3NpdGlvbikpO1xcbiAgZmxvYXQgaXNTdGFydENhcCA9IHN0ZXAobGVuQSwgMS4wZS01KTtcXG4gIGZsb2F0IGlzRW5kQ2FwID0gc3RlcChsZW5CLCAxLjBlLTUpO1xcbiAgZmxvYXQgaXNDYXAgPSBtYXgoaXNTdGFydENhcCwgaXNFbmRDYXApO1xcbiAgY29ybmVyUG9zaXRpb24gPSBpc0NhcCAqICgxLjAgLSBwb3NpdGlvbnMueik7XFxuICBvZmZzZXRWZWMgPSBtaXgob2Zmc2V0VmVjLCBtaXgoZGlyQiwgcGVycEIsIGNvcm5lclBvc2l0aW9uKSwgaXNTdGFydENhcCk7XFxuICBvZmZzZXRWZWMgPSBtaXgob2Zmc2V0VmVjLCBtaXgoZGlyQSwgcGVycEEsIGNvcm5lclBvc2l0aW9uKSwgaXNFbmRDYXApO1xcbiAgb2Zmc2V0U2NhbGUgPSBtaXgoXFxuICAgIG9mZnNldFNjYWxlLFxcbiAgICBtaXgoNC4wICogam9pbnRUeXBlLCAxLjAsIGNvcm5lclBvc2l0aW9uKSxcXG4gICAgaXNDYXBcXG4gICk7XFxuICB2TWl0ZXJMZW5ndGggPSBtaXgodk1pdGVyTGVuZ3RoLCAxLjAgLSBjb3JuZXJQb3NpdGlvbiwgaXNDYXApO1xcblxcbiAgb2Zmc2V0RGlyZWN0aW9uID0gbWl4KFxcbiAgICBvZmZzZXREaXJlY3Rpb24sXFxuICAgIG1peChmbGlwSWZUcnVlKGlzU3RhcnRDYXAgPiAwLiksIHBvc2l0aW9ucy55LCBjb3JuZXJQb3NpdGlvbiksXFxuICAgIGlzQ2FwXFxuICApO1xcblxcbiAgdkNvcm5lck9mZnNldCA9IG9mZnNldFZlYyAqIG9mZnNldERpcmVjdGlvbiAqIG9mZnNldFNjYWxlO1xcbiAgdkRhc2hBcnJheSA9IGluc3RhbmNlRGFzaEFycmF5cztcXG4gIHZQYXRoTGVuZ3RoID0gTCAvIHdpZHRoO1xcbiAgZmxvYXQgaXNFbmQgPSBwb3NpdGlvbnMueDtcXG4gIHZlYzIgb2Zmc2V0RnJvbVN0YXJ0T2ZQYXRoID0gbWl4KHZDb3JuZXJPZmZzZXQsIHZDb3JuZXJPZmZzZXQgKyBkZWx0YUEgLyB3aWR0aCwgaXNFbmQpO1xcbiAgdmVjMiBkaXIgPSBtaXgoZGlyQiwgZGlyQSwgaXNFbmQpO1xcbiAgdlBhdGhQb3NpdGlvbiA9IHZlYzIoXFxuICAgIHBvc2l0aW9ucy55ICsgcG9zaXRpb25zLnogKiBvZmZzZXREaXJlY3Rpb24sXFxuICAgIGRvdChvZmZzZXRGcm9tU3RhcnRPZlBhdGgsIGRpcilcXG4gICk7XFxuXFxuICByZXR1cm4gdmVjMyh2Q29ybmVyT2Zmc2V0ICogd2lkdGgsIDAuMCk7XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZDb2xvciA9IHZlYzQoaW5zdGFuY2VDb2xvcnMucmdiLCBpbnN0YW5jZUNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuO1xcbiAgcGlja2luZ19zZXRQaWNraW5nQ29sb3IoaW5zdGFuY2VQaWNraW5nQ29sb3JzKTtcXG5cXG4gIGZsb2F0IGlzRW5kID0gcG9zaXRpb25zLng7XFxuXFxuICB2ZWMzIGN1cnJQb3NpdGlvbiA9IG1peChpbnN0YW5jZVN0YXJ0UG9zaXRpb25zLCBpbnN0YW5jZUVuZFBvc2l0aW9ucywgaXNFbmQpO1xcbiAgdmVjMiBjdXJyUG9zaXRpb242NHh5TG93ID0gbWl4KGluc3RhbmNlU3RhcnRFbmRQb3NpdGlvbnM2NHh5TG93Lnh5LCBpbnN0YW5jZVN0YXJ0RW5kUG9zaXRpb25zNjR4eUxvdy56dywgaXNFbmQpO1xcbiAgdmVjMiBwcm9qZWN0ZWRfY3Vycl9wb3NpdGlvblsyXTtcXG4gIHByb2plY3RfcG9zaXRpb25fZnA2NChjdXJyUG9zaXRpb24ueHksIGN1cnJQb3NpdGlvbjY0eHlMb3csIHByb2plY3RlZF9jdXJyX3Bvc2l0aW9uKTtcXG4gIGZsb2F0IHByb2plY3RlZF9jdXJyX3Bvc2l0aW9uX3ogPSBwcm9qZWN0X3NpemUoY3VyclBvc2l0aW9uLnopO1xcblxcbiAgdmVjMyBwcmV2UG9zaXRpb24gPSBtaXgoaW5zdGFuY2VMZWZ0UG9zaXRpb25zLCBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zLCBpc0VuZCk7XFxuICB2ZWMyIHByZXZQb3NpdGlvbjY0eHlMb3cgPSBtaXgoaW5zdGFuY2VOZWlnaGJvclBvc2l0aW9uczY0eHlMb3cueHksIGluc3RhbmNlU3RhcnRFbmRQb3NpdGlvbnM2NHh5TG93Lnh5LCBpc0VuZCk7XFxuXFxuICB2ZWMyIHByb2plY3RlZF9wcmV2X3Bvc2l0aW9uWzJdO1xcbiAgcHJvamVjdF9wb3NpdGlvbl9mcDY0KHByZXZQb3NpdGlvbi54eSwgcHJldlBvc2l0aW9uNjR4eUxvdywgcHJvamVjdGVkX3ByZXZfcG9zaXRpb24pO1xcbiAgdmVjMyBuZXh0UG9zaXRpb24gPSBtaXgoaW5zdGFuY2VFbmRQb3NpdGlvbnMsIGluc3RhbmNlUmlnaHRQb3NpdGlvbnMsIGlzRW5kKTtcXG4gIHZlYzIgbmV4dFBvc2l0aW9uNjR4eUxvdyA9IG1peChpbnN0YW5jZVN0YXJ0RW5kUG9zaXRpb25zNjR4eUxvdy56dywgaW5zdGFuY2VOZWlnaGJvclBvc2l0aW9uczY0eHlMb3cuencsIGlzRW5kKTtcXG5cXG4gIHZlYzIgcHJvamVjdGVkX25leHRfcG9zaXRpb25bMl07XFxuICBwcm9qZWN0X3Bvc2l0aW9uX2ZwNjQobmV4dFBvc2l0aW9uLnh5LCBuZXh0UG9zaXRpb242NHh5TG93LCBwcm9qZWN0ZWRfbmV4dF9wb3NpdGlvbik7XFxuXFxuICB2ZWMzIHBvcyA9IGxpbmVKb2luKHByb2plY3RlZF9wcmV2X3Bvc2l0aW9uLCBwcm9qZWN0ZWRfY3Vycl9wb3NpdGlvbiwgcHJvamVjdGVkX25leHRfcG9zaXRpb24pO1xcbiAgdmVjMiB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbNF07XFxuXFxuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMF0gPSBzdW1fZnA2NCh2ZWMyKHBvcy54LCAwLjApLCBwcm9qZWN0ZWRfY3Vycl9wb3NpdGlvblswXSk7XFxuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMV0gPSBzdW1fZnA2NCh2ZWMyKHBvcy55LCAwLjApLCBwcm9qZWN0ZWRfY3Vycl9wb3NpdGlvblsxXSk7XFxuICB2ZXJ0ZXhfcG9zX21vZGVsc3BhY2VbMl0gPSB2ZWMyKHBvcy56ICsgcHJvamVjdGVkX2N1cnJfcG9zaXRpb25feiwgMC4wKTtcXG4gIHZlcnRleF9wb3NfbW9kZWxzcGFjZVszXSA9IHZlYzIoMS4wLCAwLjApO1xcblxcbiAgZ2xfUG9zaXRpb24gPSBwcm9qZWN0X2NvbW1vbl9wb3NpdGlvbl90b19jbGlwc3BhY2VfZnA2NCh2ZXJ0ZXhfcG9zX21vZGVsc3BhY2UpO1xcbn1cXG5cIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGgtbGF5ZXItdmVydGV4LTY0Lmdsc2wuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex-64.glsl.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js ***!
  \************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"#define SHADER_NAME path-layer-vertex-shader\\n\\nattribute vec3 positions;\\n\\nattribute vec3 instanceStartPositions;\\nattribute vec3 instanceEndPositions;\\nattribute vec4 instanceStartEndPositions64xyLow;\\nattribute vec3 instanceLeftPositions;\\nattribute vec3 instanceRightPositions;\\nattribute vec4 instanceNeighborPositions64xyLow;\\nattribute float instanceStrokeWidths;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\nattribute vec2 instanceDashArrays;\\n\\nuniform float widthScale;\\nuniform float widthMinPixels;\\nuniform float widthMaxPixels;\\nuniform float jointType;\\nuniform float miterLimit;\\nuniform bool billboard;\\n\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vDashArray;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\n\\nconst float EPSILON = 0.001;\\nconst vec3 ZERO_OFFSET = vec3(0.0);\\n\\nfloat flipIfTrue(bool flag) {\\n  return -(float(flag) * 2. - 1.);\\n}\\nvec3 lineJoin(\\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\\n  float relativePosition, bool isEnd, bool isJoint,\\n  vec2 width\\n) {\\n  vec2 deltaA = (currPoint.xy - prevPoint.xy) / width;\\n  vec2 deltaB = (nextPoint.xy - currPoint.xy) / width;\\n\\n  float lenA = length(deltaA);\\n  float lenB = length(deltaB);\\n  lenA = lenA > EPSILON ? lenA : 0.0;\\n  lenB = lenB > EPSILON ? lenB : 0.0;\\n\\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\\n\\n  vec2 perpA = vec2(-dirA.y, dirA.x);\\n  vec2 perpB = vec2(-dirB.y, dirB.x);\\n  vec2 tangent = vec2(dirA + dirB);\\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\\n  vec2 perp = isEnd ? perpA : perpB;\\n  float L = isEnd ? lenA : lenB;\\n  float sinHalfA = abs(dot(miterVec, perp));\\n  float cosHalfA = abs(dot(dirA, miterVec));\\n\\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\\n\\n  float offsetScale = 1.0 / max(sinHalfA, EPSILON);\\n\\n  float cornerPosition = isJoint ?\\n    0.0 :\\n    flipIfTrue(turnsRight == (relativePosition > 0.0));\\n  cornerPosition *=\\n    float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) * cosHalfA);\\n  if (cornerPosition < 0.0) {\\n    offsetScale = min(offsetScale, L / max(cosHalfA, EPSILON));\\n  }\\n\\n  vMiterLength = cornerPosition >= 0.0 ?\\n    mix(offsetScale, 0.0, cornerPosition) :\\n    offsetScale * cornerPosition;\\n  vMiterLength -= sinHalfA * jointType;\\n\\n  float offsetDirection = mix(\\n    positions.y,\\n    mix(\\n      flipIfTrue(turnsRight),\\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\\n      cornerPosition\\n    ),\\n    step(0.0, cornerPosition)\\n  );\\n\\n  vec2 offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\\n  bool isStartCap = step(0.0, -lenA) > 0.5;\\n  bool isEndCap = step(0.0, -lenB) > 0.5;\\n  bool isCap = isStartCap || isEndCap;\\n  cornerPosition = isCap ? (1.0 - positions.z) : 0.;\\n  if (isStartCap) {\\n    offsetVec = mix(dirB, perpB, cornerPosition);\\n  }\\n  if (isEndCap) {\\n    offsetVec = mix(dirA, perpA, cornerPosition);\\n  }\\n  if (isCap) {\\n    offsetScale = mix(4.0 * jointType, 1.0, cornerPosition);\\n    vMiterLength = 1.0 - cornerPosition;\\n    offsetDirection = mix(flipIfTrue(isStartCap), positions.y, cornerPosition);\\n  }\\n\\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\\n  vDashArray = instanceDashArrays;\\n  vPathLength = L;\\n  vec2 offsetFromStartOfPath = vCornerOffset;\\n  if (isEnd) {\\n    offsetFromStartOfPath += deltaA;\\n  }\\n  vec2 dir = isEnd ? dirA : dirB;\\n  vPathPosition = vec2(\\n    positions.y + positions.z * offsetDirection,\\n    dot(offsetFromStartOfPath, dir)\\n  );\\n\\n  return currPoint + vec3(vCornerOffset * width, 0.0);\\n}\\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\\n\\n  float relativePosition = positions.y;\\n  bool isEnd = positions.x > EPSILON;\\n  bool isJoint = positions.z > EPSILON;\\n\\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\\n    widthMinPixels, widthMaxPixels) / 2.0);\\n\\n  return lineJoin(\\n    prevPoint, currPoint, nextPoint,\\n    relativePosition, isEnd, isJoint,\\n    billboard ? project_pixel_size_to_clipspace(widthPixels) : project_pixel_size(widthPixels)\\n  );\\n}\\nvoid clipLine(inout vec4 position, vec4 refPosition) {\\n  if (position.w < EPSILON) {\\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\\n    position = refPosition + (position - refPosition) * r;\\n  }\\n}\\n\\nvoid main() {\\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity) / 255.;\\n  picking_setPickingColor(instancePickingColors);\\n\\n  float isEnd = positions.x;\\n\\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\\n  vec2 prevPosition64xyLow = mix(instanceNeighborPositions64xyLow.xy, instanceStartEndPositions64xyLow.xy, isEnd);\\n\\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\\n  vec2 currPosition64xyLow = mix(instanceStartEndPositions64xyLow.xy, instanceStartEndPositions64xyLow.zw, isEnd);\\n\\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\\n  vec2 nextPosition64xyLow = mix(instanceStartEndPositions64xyLow.zw, instanceNeighborPositions64xyLow.zw, isEnd);\\n\\n  if (billboard) {\\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64xyLow, ZERO_OFFSET);\\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64xyLow, ZERO_OFFSET);\\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64xyLow, ZERO_OFFSET);\\n\\n    clipLine(prevPositionScreen, currPositionScreen);\\n    clipLine(nextPositionScreen, currPositionScreen);\\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\\n\\n    vec3 pos = lineJoin(\\n      prevPositionScreen.xyz / prevPositionScreen.w,\\n      currPositionScreen.xyz / currPositionScreen.w,\\n      nextPositionScreen.xyz / nextPositionScreen.w\\n    );\\n\\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\\n  } else {\\n    prevPosition = project_position(prevPosition, prevPosition64xyLow);\\n    currPosition = project_position(currPosition, currPosition64xyLow);\\n    nextPosition = project_position(nextPosition, nextPosition64xyLow);\\n\\n    vec3 pos = lineJoin(prevPosition, currPosition, nextPosition);\\n    gl_Position = project_common_position_to_clipspace(vec4(pos, 1.0));\\n  }\\n}\\n\");\n//# sourceMappingURL=path-layer-vertex.glsl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3BhdGgtbGF5ZXIvcGF0aC1sYXllci12ZXJ0ZXguZ2xzbC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vcGF0aC1sYXllci9wYXRoLWxheWVyLXZlcnRleC5nbHNsLmpzPzY5YTAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCIjZGVmaW5lIFNIQURFUl9OQU1FIHBhdGgtbGF5ZXItdmVydGV4LXNoYWRlclxcblxcbmF0dHJpYnV0ZSB2ZWMzIHBvc2l0aW9ucztcXG5cXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVN0YXJ0UG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlRW5kUG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlU3RhcnRFbmRQb3NpdGlvbnM2NHh5TG93O1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlTGVmdFBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVJpZ2h0UG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlTmVpZ2hib3JQb3NpdGlvbnM2NHh5TG93O1xcbmF0dHJpYnV0ZSBmbG9hdCBpbnN0YW5jZVN0cm9rZVdpZHRocztcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUNvbG9ycztcXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBpY2tpbmdDb2xvcnM7XFxuYXR0cmlidXRlIHZlYzIgaW5zdGFuY2VEYXNoQXJyYXlzO1xcblxcbnVuaWZvcm0gZmxvYXQgd2lkdGhTY2FsZTtcXG51bmlmb3JtIGZsb2F0IHdpZHRoTWluUGl4ZWxzO1xcbnVuaWZvcm0gZmxvYXQgd2lkdGhNYXhQaXhlbHM7XFxudW5pZm9ybSBmbG9hdCBqb2ludFR5cGU7XFxudW5pZm9ybSBmbG9hdCBtaXRlckxpbWl0O1xcbnVuaWZvcm0gYm9vbCBiaWxsYm9hcmQ7XFxuXFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxudmFyeWluZyB2ZWMyIHZDb3JuZXJPZmZzZXQ7XFxudmFyeWluZyBmbG9hdCB2TWl0ZXJMZW5ndGg7XFxudmFyeWluZyB2ZWMyIHZEYXNoQXJyYXk7XFxudmFyeWluZyB2ZWMyIHZQYXRoUG9zaXRpb247XFxudmFyeWluZyBmbG9hdCB2UGF0aExlbmd0aDtcXG5cXG5jb25zdCBmbG9hdCBFUFNJTE9OID0gMC4wMDE7XFxuY29uc3QgdmVjMyBaRVJPX09GRlNFVCA9IHZlYzMoMC4wKTtcXG5cXG5mbG9hdCBmbGlwSWZUcnVlKGJvb2wgZmxhZykge1xcbiAgcmV0dXJuIC0oZmxvYXQoZmxhZykgKiAyLiAtIDEuKTtcXG59XFxudmVjMyBsaW5lSm9pbihcXG4gIHZlYzMgcHJldlBvaW50LCB2ZWMzIGN1cnJQb2ludCwgdmVjMyBuZXh0UG9pbnQsXFxuICBmbG9hdCByZWxhdGl2ZVBvc2l0aW9uLCBib29sIGlzRW5kLCBib29sIGlzSm9pbnQsXFxuICB2ZWMyIHdpZHRoXFxuKSB7XFxuICB2ZWMyIGRlbHRhQSA9IChjdXJyUG9pbnQueHkgLSBwcmV2UG9pbnQueHkpIC8gd2lkdGg7XFxuICB2ZWMyIGRlbHRhQiA9IChuZXh0UG9pbnQueHkgLSBjdXJyUG9pbnQueHkpIC8gd2lkdGg7XFxuXFxuICBmbG9hdCBsZW5BID0gbGVuZ3RoKGRlbHRhQSk7XFxuICBmbG9hdCBsZW5CID0gbGVuZ3RoKGRlbHRhQik7XFxuICBsZW5BID0gbGVuQSA+IEVQU0lMT04gPyBsZW5BIDogMC4wO1xcbiAgbGVuQiA9IGxlbkIgPiBFUFNJTE9OID8gbGVuQiA6IDAuMDtcXG5cXG4gIHZlYzIgZGlyQSA9IGxlbkEgPiAwLiA/IG5vcm1hbGl6ZShkZWx0YUEpIDogdmVjMigwLjAsIDAuMCk7XFxuICB2ZWMyIGRpckIgPSBsZW5CID4gMC4gPyBub3JtYWxpemUoZGVsdGFCKSA6IHZlYzIoMC4wLCAwLjApO1xcblxcbiAgdmVjMiBwZXJwQSA9IHZlYzIoLWRpckEueSwgZGlyQS54KTtcXG4gIHZlYzIgcGVycEIgPSB2ZWMyKC1kaXJCLnksIGRpckIueCk7XFxuICB2ZWMyIHRhbmdlbnQgPSB2ZWMyKGRpckEgKyBkaXJCKTtcXG4gIHRhbmdlbnQgPSBsZW5ndGgodGFuZ2VudCkgPiAwLiA/IG5vcm1hbGl6ZSh0YW5nZW50KSA6IHBlcnBBO1xcbiAgdmVjMiBtaXRlclZlYyA9IHZlYzIoLXRhbmdlbnQueSwgdGFuZ2VudC54KTtcXG4gIHZlYzIgcGVycCA9IGlzRW5kID8gcGVycEEgOiBwZXJwQjtcXG4gIGZsb2F0IEwgPSBpc0VuZCA/IGxlbkEgOiBsZW5CO1xcbiAgZmxvYXQgc2luSGFsZkEgPSBhYnMoZG90KG1pdGVyVmVjLCBwZXJwKSk7XFxuICBmbG9hdCBjb3NIYWxmQSA9IGFicyhkb3QoZGlyQSwgbWl0ZXJWZWMpKTtcXG5cXG4gIGJvb2wgdHVybnNSaWdodCA9IGRpckEueCAqIGRpckIueSA+IGRpckEueSAqIGRpckIueDtcXG5cXG4gIGZsb2F0IG9mZnNldFNjYWxlID0gMS4wIC8gbWF4KHNpbkhhbGZBLCBFUFNJTE9OKTtcXG5cXG4gIGZsb2F0IGNvcm5lclBvc2l0aW9uID0gaXNKb2ludCA/XFxuICAgIDAuMCA6XFxuICAgIGZsaXBJZlRydWUodHVybnNSaWdodCA9PSAocmVsYXRpdmVQb3NpdGlvbiA+IDAuMCkpO1xcbiAgY29ybmVyUG9zaXRpb24gKj1cXG4gICAgZmxvYXQoY29ybmVyUG9zaXRpb24gPD0gMC4wIHx8IHNpbkhhbGZBIDwgbWluKGxlbkEsIGxlbkIpICogY29zSGFsZkEpO1xcbiAgaWYgKGNvcm5lclBvc2l0aW9uIDwgMC4wKSB7XFxuICAgIG9mZnNldFNjYWxlID0gbWluKG9mZnNldFNjYWxlLCBMIC8gbWF4KGNvc0hhbGZBLCBFUFNJTE9OKSk7XFxuICB9XFxuXFxuICB2TWl0ZXJMZW5ndGggPSBjb3JuZXJQb3NpdGlvbiA+PSAwLjAgP1xcbiAgICBtaXgob2Zmc2V0U2NhbGUsIDAuMCwgY29ybmVyUG9zaXRpb24pIDpcXG4gICAgb2Zmc2V0U2NhbGUgKiBjb3JuZXJQb3NpdGlvbjtcXG4gIHZNaXRlckxlbmd0aCAtPSBzaW5IYWxmQSAqIGpvaW50VHlwZTtcXG5cXG4gIGZsb2F0IG9mZnNldERpcmVjdGlvbiA9IG1peChcXG4gICAgcG9zaXRpb25zLnksXFxuICAgIG1peChcXG4gICAgICBmbGlwSWZUcnVlKHR1cm5zUmlnaHQpLFxcbiAgICAgIHBvc2l0aW9ucy55ICogZmxpcElmVHJ1ZSh0dXJuc1JpZ2h0ID09IChwb3NpdGlvbnMueCA9PSAxLikpLFxcbiAgICAgIGNvcm5lclBvc2l0aW9uXFxuICAgICksXFxuICAgIHN0ZXAoMC4wLCBjb3JuZXJQb3NpdGlvbilcXG4gICk7XFxuXFxuICB2ZWMyIG9mZnNldFZlYyA9IG1peChtaXRlclZlYywgLXRhbmdlbnQsIHN0ZXAoMC41LCBjb3JuZXJQb3NpdGlvbikpO1xcbiAgb2Zmc2V0U2NhbGUgPSBtaXgob2Zmc2V0U2NhbGUsIDEuMCAvIG1heChjb3NIYWxmQSwgMC4wMDEpLCBzdGVwKDAuNSwgY29ybmVyUG9zaXRpb24pKTtcXG4gIGJvb2wgaXNTdGFydENhcCA9IHN0ZXAoMC4wLCAtbGVuQSkgPiAwLjU7XFxuICBib29sIGlzRW5kQ2FwID0gc3RlcCgwLjAsIC1sZW5CKSA+IDAuNTtcXG4gIGJvb2wgaXNDYXAgPSBpc1N0YXJ0Q2FwIHx8IGlzRW5kQ2FwO1xcbiAgY29ybmVyUG9zaXRpb24gPSBpc0NhcCA/ICgxLjAgLSBwb3NpdGlvbnMueikgOiAwLjtcXG4gIGlmIChpc1N0YXJ0Q2FwKSB7XFxuICAgIG9mZnNldFZlYyA9IG1peChkaXJCLCBwZXJwQiwgY29ybmVyUG9zaXRpb24pO1xcbiAgfVxcbiAgaWYgKGlzRW5kQ2FwKSB7XFxuICAgIG9mZnNldFZlYyA9IG1peChkaXJBLCBwZXJwQSwgY29ybmVyUG9zaXRpb24pO1xcbiAgfVxcbiAgaWYgKGlzQ2FwKSB7XFxuICAgIG9mZnNldFNjYWxlID0gbWl4KDQuMCAqIGpvaW50VHlwZSwgMS4wLCBjb3JuZXJQb3NpdGlvbik7XFxuICAgIHZNaXRlckxlbmd0aCA9IDEuMCAtIGNvcm5lclBvc2l0aW9uO1xcbiAgICBvZmZzZXREaXJlY3Rpb24gPSBtaXgoZmxpcElmVHJ1ZShpc1N0YXJ0Q2FwKSwgcG9zaXRpb25zLnksIGNvcm5lclBvc2l0aW9uKTtcXG4gIH1cXG5cXG4gIHZDb3JuZXJPZmZzZXQgPSBvZmZzZXRWZWMgKiBvZmZzZXREaXJlY3Rpb24gKiBvZmZzZXRTY2FsZTtcXG4gIHZEYXNoQXJyYXkgPSBpbnN0YW5jZURhc2hBcnJheXM7XFxuICB2UGF0aExlbmd0aCA9IEw7XFxuICB2ZWMyIG9mZnNldEZyb21TdGFydE9mUGF0aCA9IHZDb3JuZXJPZmZzZXQ7XFxuICBpZiAoaXNFbmQpIHtcXG4gICAgb2Zmc2V0RnJvbVN0YXJ0T2ZQYXRoICs9IGRlbHRhQTtcXG4gIH1cXG4gIHZlYzIgZGlyID0gaXNFbmQgPyBkaXJBIDogZGlyQjtcXG4gIHZQYXRoUG9zaXRpb24gPSB2ZWMyKFxcbiAgICBwb3NpdGlvbnMueSArIHBvc2l0aW9ucy56ICogb2Zmc2V0RGlyZWN0aW9uLFxcbiAgICBkb3Qob2Zmc2V0RnJvbVN0YXJ0T2ZQYXRoLCBkaXIpXFxuICApO1xcblxcbiAgcmV0dXJuIGN1cnJQb2ludCArIHZlYzModkNvcm5lck9mZnNldCAqIHdpZHRoLCAwLjApO1xcbn1cXG52ZWMzIGxpbmVKb2luKHZlYzMgcHJldlBvaW50LCB2ZWMzIGN1cnJQb2ludCwgdmVjMyBuZXh0UG9pbnQpIHtcXG5cXG4gIGZsb2F0IHJlbGF0aXZlUG9zaXRpb24gPSBwb3NpdGlvbnMueTtcXG4gIGJvb2wgaXNFbmQgPSBwb3NpdGlvbnMueCA+IEVQU0lMT047XFxuICBib29sIGlzSm9pbnQgPSBwb3NpdGlvbnMueiA+IEVQU0lMT047XFxuXFxuICB2ZWMyIHdpZHRoUGl4ZWxzID0gdmVjMihjbGFtcChwcm9qZWN0X3NpemVfdG9fcGl4ZWwoaW5zdGFuY2VTdHJva2VXaWR0aHMgKiB3aWR0aFNjYWxlKSxcXG4gICAgd2lkdGhNaW5QaXhlbHMsIHdpZHRoTWF4UGl4ZWxzKSAvIDIuMCk7XFxuXFxuICByZXR1cm4gbGluZUpvaW4oXFxuICAgIHByZXZQb2ludCwgY3VyclBvaW50LCBuZXh0UG9pbnQsXFxuICAgIHJlbGF0aXZlUG9zaXRpb24sIGlzRW5kLCBpc0pvaW50LFxcbiAgICBiaWxsYm9hcmQgPyBwcm9qZWN0X3BpeGVsX3NpemVfdG9fY2xpcHNwYWNlKHdpZHRoUGl4ZWxzKSA6IHByb2plY3RfcGl4ZWxfc2l6ZSh3aWR0aFBpeGVscylcXG4gICk7XFxufVxcbnZvaWQgY2xpcExpbmUoaW5vdXQgdmVjNCBwb3NpdGlvbiwgdmVjNCByZWZQb3NpdGlvbikge1xcbiAgaWYgKHBvc2l0aW9uLncgPCBFUFNJTE9OKSB7XFxuICAgIGZsb2F0IHIgPSAoRVBTSUxPTiAtIHJlZlBvc2l0aW9uLncpIC8gKHBvc2l0aW9uLncgLSByZWZQb3NpdGlvbi53KTtcXG4gICAgcG9zaXRpb24gPSByZWZQb3NpdGlvbiArIChwb3NpdGlvbiAtIHJlZlBvc2l0aW9uKSAqIHI7XFxuICB9XFxufVxcblxcbnZvaWQgbWFpbigpIHtcXG4gIHZDb2xvciA9IHZlYzQoaW5zdGFuY2VDb2xvcnMucmdiLCBpbnN0YW5jZUNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuO1xcbiAgcGlja2luZ19zZXRQaWNraW5nQ29sb3IoaW5zdGFuY2VQaWNraW5nQ29sb3JzKTtcXG5cXG4gIGZsb2F0IGlzRW5kID0gcG9zaXRpb25zLng7XFxuXFxuICB2ZWMzIHByZXZQb3NpdGlvbiA9IG1peChpbnN0YW5jZUxlZnRQb3NpdGlvbnMsIGluc3RhbmNlU3RhcnRQb3NpdGlvbnMsIGlzRW5kKTtcXG4gIHZlYzIgcHJldlBvc2l0aW9uNjR4eUxvdyA9IG1peChpbnN0YW5jZU5laWdoYm9yUG9zaXRpb25zNjR4eUxvdy54eSwgaW5zdGFuY2VTdGFydEVuZFBvc2l0aW9uczY0eHlMb3cueHksIGlzRW5kKTtcXG5cXG4gIHZlYzMgY3VyclBvc2l0aW9uID0gbWl4KGluc3RhbmNlU3RhcnRQb3NpdGlvbnMsIGluc3RhbmNlRW5kUG9zaXRpb25zLCBpc0VuZCk7XFxuICB2ZWMyIGN1cnJQb3NpdGlvbjY0eHlMb3cgPSBtaXgoaW5zdGFuY2VTdGFydEVuZFBvc2l0aW9uczY0eHlMb3cueHksIGluc3RhbmNlU3RhcnRFbmRQb3NpdGlvbnM2NHh5TG93Lnp3LCBpc0VuZCk7XFxuXFxuICB2ZWMzIG5leHRQb3NpdGlvbiA9IG1peChpbnN0YW5jZUVuZFBvc2l0aW9ucywgaW5zdGFuY2VSaWdodFBvc2l0aW9ucywgaXNFbmQpO1xcbiAgdmVjMiBuZXh0UG9zaXRpb242NHh5TG93ID0gbWl4KGluc3RhbmNlU3RhcnRFbmRQb3NpdGlvbnM2NHh5TG93Lnp3LCBpbnN0YW5jZU5laWdoYm9yUG9zaXRpb25zNjR4eUxvdy56dywgaXNFbmQpO1xcblxcbiAgaWYgKGJpbGxib2FyZCkge1xcbiAgICB2ZWM0IHByZXZQb3NpdGlvblNjcmVlbiA9IHByb2plY3RfcG9zaXRpb25fdG9fY2xpcHNwYWNlKHByZXZQb3NpdGlvbiwgcHJldlBvc2l0aW9uNjR4eUxvdywgWkVST19PRkZTRVQpO1xcbiAgICB2ZWM0IGN1cnJQb3NpdGlvblNjcmVlbiA9IHByb2plY3RfcG9zaXRpb25fdG9fY2xpcHNwYWNlKGN1cnJQb3NpdGlvbiwgY3VyclBvc2l0aW9uNjR4eUxvdywgWkVST19PRkZTRVQpO1xcbiAgICB2ZWM0IG5leHRQb3NpdGlvblNjcmVlbiA9IHByb2plY3RfcG9zaXRpb25fdG9fY2xpcHNwYWNlKG5leHRQb3NpdGlvbiwgbmV4dFBvc2l0aW9uNjR4eUxvdywgWkVST19PRkZTRVQpO1xcblxcbiAgICBjbGlwTGluZShwcmV2UG9zaXRpb25TY3JlZW4sIGN1cnJQb3NpdGlvblNjcmVlbik7XFxuICAgIGNsaXBMaW5lKG5leHRQb3NpdGlvblNjcmVlbiwgY3VyclBvc2l0aW9uU2NyZWVuKTtcXG4gICAgY2xpcExpbmUoY3VyclBvc2l0aW9uU2NyZWVuLCBtaXgobmV4dFBvc2l0aW9uU2NyZWVuLCBwcmV2UG9zaXRpb25TY3JlZW4sIGlzRW5kKSk7XFxuXFxuICAgIHZlYzMgcG9zID0gbGluZUpvaW4oXFxuICAgICAgcHJldlBvc2l0aW9uU2NyZWVuLnh5eiAvIHByZXZQb3NpdGlvblNjcmVlbi53LFxcbiAgICAgIGN1cnJQb3NpdGlvblNjcmVlbi54eXogLyBjdXJyUG9zaXRpb25TY3JlZW4udyxcXG4gICAgICBuZXh0UG9zaXRpb25TY3JlZW4ueHl6IC8gbmV4dFBvc2l0aW9uU2NyZWVuLndcXG4gICAgKTtcXG5cXG4gICAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvcyAqIGN1cnJQb3NpdGlvblNjcmVlbi53LCBjdXJyUG9zaXRpb25TY3JlZW4udyk7XFxuICB9IGVsc2Uge1xcbiAgICBwcmV2UG9zaXRpb24gPSBwcm9qZWN0X3Bvc2l0aW9uKHByZXZQb3NpdGlvbiwgcHJldlBvc2l0aW9uNjR4eUxvdyk7XFxuICAgIGN1cnJQb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb24oY3VyclBvc2l0aW9uLCBjdXJyUG9zaXRpb242NHh5TG93KTtcXG4gICAgbmV4dFBvc2l0aW9uID0gcHJvamVjdF9wb3NpdGlvbihuZXh0UG9zaXRpb24sIG5leHRQb3NpdGlvbjY0eHlMb3cpO1xcblxcbiAgICB2ZWMzIHBvcyA9IGxpbmVKb2luKHByZXZQb3NpdGlvbiwgY3VyclBvc2l0aW9uLCBuZXh0UG9zaXRpb24pO1xcbiAgICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfY29tbW9uX3Bvc2l0aW9uX3RvX2NsaXBzcGFjZSh2ZWM0KHBvcywgMS4wKSk7XFxuICB9XFxufVxcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGF0aC1sYXllci12ZXJ0ZXguZ2xzbC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js":
/*!************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js ***!
  \************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PathLayer; });\n/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_get__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/get */ \"./node_modules/@babel/runtime/helpers/esm/get.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @deck.gl/core */ \"./node_modules/@deck.gl/core/dist/esm/lib/layer.js\");\n/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @luma.gl/core */ \"./node_modules/@luma.gl/core/dist/esm/lib/model.js\");\n/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @luma.gl/core */ \"./node_modules/@luma.gl/core/dist/esm/geometry/geometry.js\");\n/* harmony import */ var _path_tesselator__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./path-tesselator */ \"./node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js\");\n/* harmony import */ var _path_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./path-layer-vertex.glsl */ \"./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js\");\n/* harmony import */ var _path_layer_vertex_64_glsl__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./path-layer-vertex-64.glsl */ \"./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex-64.glsl.js\");\n/* harmony import */ var _path_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./path-layer-fragment.glsl */ \"./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar defaultProps = {\n  widthUnits: 'meters',\n  widthScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  widthMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  widthMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  rounded: false,\n  miterLimit: {\n    type: 'number',\n    min: 0,\n    value: 4\n  },\n  fp64: false,\n  dashJustified: false,\n  billboard: false,\n  getPath: {\n    type: 'accessor',\n    value: function value(object) {\n      return object.path;\n    }\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  getDashArray: {\n    type: 'accessor',\n    value: [0, 0]\n  }\n};\nvar ATTRIBUTE_TRANSITION = {\n  enter: function enter(value, chunk) {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\nvar PathLayer = function (_Layer) {\n  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(PathLayer, _Layer);\n\n  function PathLayer() {\n    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, PathLayer);\n\n    return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(PathLayer).apply(this, arguments));\n  }\n\n  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(PathLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return this.use64bitProjection() ? {\n        vs: _path_layer_vertex_64_glsl__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n        fs: _path_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_12__[\"default\"],\n        modules: ['project64', 'picking']\n      } : {\n        vs: _path_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_10__[\"default\"],\n        fs: _path_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_12__[\"default\"],\n        modules: ['project32', 'picking']\n      };\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _this = this;\n\n      var noAlloc = true;\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        instanceStartPositions: {\n          size: 3,\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getPath',\n          update: this.calculateStartPositions,\n          noAlloc: noAlloc\n        },\n        instanceEndPositions: {\n          size: 3,\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getPath',\n          update: this.calculateEndPositions,\n          noAlloc: noAlloc\n        },\n        instanceStartEndPositions64xyLow: {\n          size: 4,\n          update: this.calculateInstanceStartEndPositions64xyLow,\n          noAlloc: noAlloc\n        },\n        instanceLeftPositions: {\n          size: 3,\n          accessor: 'getPath',\n          update: this.calculateLeftPositions,\n          noAlloc: noAlloc\n        },\n        instanceRightPositions: {\n          size: 3,\n          accessor: 'getPath',\n          update: this.calculateRightPositions,\n          noAlloc: noAlloc\n        },\n        instanceNeighborPositions64xyLow: {\n          size: 4,\n          update: this.calculateInstanceNeighborPositions64xyLow,\n          noAlloc: noAlloc\n        },\n        instanceStrokeWidths: {\n          size: 1,\n          accessor: 'getWidth',\n          transition: ATTRIBUTE_TRANSITION,\n          defaultValue: 1\n        },\n        instanceDashArrays: {\n          size: 2,\n          accessor: 'getDashArray'\n        },\n        instanceColors: {\n          size: 4,\n          type: 5121,\n          accessor: 'getColor',\n          transition: ATTRIBUTE_TRANSITION,\n          defaultValue: DEFAULT_COLOR\n        },\n        instancePickingColors: {\n          size: 3,\n          type: 5121,\n          accessor: function accessor(object, _ref) {\n            var index = _ref.index,\n                value = _ref.target;\n            return _this.encodePickingColor(index, value);\n          }\n        }\n      });\n      this.setState({\n        pathTesselator: new _path_tesselator__WEBPACK_IMPORTED_MODULE_9__[\"default\"]({})\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var oldProps = _ref2.oldProps,\n          props = _ref2.props,\n          changeFlags = _ref2.changeFlags;\n\n      Object(_babel_runtime_helpers_esm_get__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(PathLayer.prototype), \"updateState\", this).call(this, {\n        props: props,\n        oldProps: oldProps,\n        changeFlags: changeFlags\n      });\n\n      var attributeManager = this.getAttributeManager();\n      var geometryChanged = changeFlags.dataChanged || props.fp64 !== oldProps.fp64 || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);\n\n      if (geometryChanged) {\n        var pathTesselator = this.state.pathTesselator;\n        pathTesselator.updateGeometry({\n          data: props.data,\n          getGeometry: props.getPath,\n          positionFormat: props.positionFormat,\n          fp64: this.use64bitPositions()\n        });\n        this.setState({\n          numInstances: pathTesselator.instanceCount,\n          bufferLayout: pathTesselator.bufferLayout\n        });\n        attributeManager.invalidateAll();\n      }\n\n      if (props.fp64 !== oldProps.fp64) {\n        var gl = this.context.gl;\n\n        if (this.state.model) {\n          this.state.model.delete();\n        }\n\n        this.setState({\n          model: this._getModel(gl)\n        });\n        attributeManager.invalidateAll();\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref3) {\n      var uniforms = _ref3.uniforms;\n      var viewport = this.context.viewport;\n      var _this$props = this.props,\n          rounded = _this$props.rounded,\n          billboard = _this$props.billboard,\n          miterLimit = _this$props.miterLimit,\n          widthUnits = _this$props.widthUnits,\n          widthScale = _this$props.widthScale,\n          widthMinPixels = _this$props.widthMinPixels,\n          widthMaxPixels = _this$props.widthMaxPixels,\n          dashJustified = _this$props.dashJustified;\n      var widthMultiplier = widthUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1;\n      this.state.model.setUniforms(Object.assign({}, uniforms, {\n        jointType: Number(rounded),\n        billboard: billboard,\n        alignMode: Number(dashJustified),\n        widthScale: widthScale * widthMultiplier,\n        miterLimit: miterLimit,\n        widthMinPixels: widthMinPixels,\n        widthMaxPixels: widthMaxPixels\n      })).draw();\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      var SEGMENT_INDICES = [0, 2, 1, 1, 2, 4, 1, 4, 3, 3, 4, 5];\n      var SEGMENT_POSITIONS = [0, 0, 1, 0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0, 1, 0, 1];\n      return new _luma_gl_core__WEBPACK_IMPORTED_MODULE_7__[\"default\"](gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new _luma_gl_core__WEBPACK_IMPORTED_MODULE_8__[\"default\"]({\n          drawMode: 4,\n          attributes: {\n            indices: new Uint16Array(SEGMENT_INDICES),\n            positions: new Float32Array(SEGMENT_POSITIONS)\n          }\n        }),\n        isInstanced: true,\n        shaderCache: this.context.shaderCache\n      }));\n    }\n  }, {\n    key: \"calculateStartPositions\",\n    value: function calculateStartPositions(attribute) {\n      var pathTesselator = this.state.pathTesselator;\n      attribute.bufferLayout = pathTesselator.bufferLayout;\n      attribute.value = pathTesselator.get('startPositions');\n    }\n  }, {\n    key: \"calculateEndPositions\",\n    value: function calculateEndPositions(attribute) {\n      var pathTesselator = this.state.pathTesselator;\n      attribute.bufferLayout = pathTesselator.bufferLayout;\n      attribute.value = pathTesselator.get('endPositions');\n    }\n  }, {\n    key: \"calculateInstanceStartEndPositions64xyLow\",\n    value: function calculateInstanceStartEndPositions64xyLow(attribute) {\n      var isFP64 = this.use64bitPositions();\n      attribute.constant = !isFP64;\n\n      if (isFP64) {\n        attribute.value = this.state.pathTesselator.get('startEndPositions64XyLow');\n      } else {\n        attribute.value = new Float32Array(4);\n      }\n    }\n  }, {\n    key: \"calculateLeftPositions\",\n    value: function calculateLeftPositions(attribute) {\n      var pathTesselator = this.state.pathTesselator;\n      attribute.value = pathTesselator.get('leftPositions');\n    }\n  }, {\n    key: \"calculateRightPositions\",\n    value: function calculateRightPositions(attribute) {\n      var pathTesselator = this.state.pathTesselator;\n      attribute.value = pathTesselator.get('rightPositions');\n    }\n  }, {\n    key: \"calculateInstanceNeighborPositions64xyLow\",\n    value: function calculateInstanceNeighborPositions64xyLow(attribute) {\n      var isFP64 = this.use64bitPositions();\n      attribute.constant = !isFP64;\n\n      if (isFP64) {\n        attribute.value = this.state.pathTesselator.get('neighborPositions64XyLow');\n      } else {\n        attribute.value = new Float32Array(4);\n      }\n    }\n  }, {\n    key: \"clearPickingColor\",\n    value: function clearPickingColor(color) {\n      var pickedPathIndex = this.decodePickingColor(color);\n      var bufferLayout = this.state.pathTesselator.bufferLayout;\n      var numVertices = bufferLayout[pickedPathIndex];\n      var startInstanceIndex = 0;\n\n      for (var pathIndex = 0; pathIndex < pickedPathIndex; pathIndex++) {\n        startInstanceIndex += bufferLayout[pathIndex];\n      }\n\n      var instancePickingColors = this.getAttributeManager().attributes.instancePickingColors;\n      var value = instancePickingColors.value;\n      var endInstanceIndex = startInstanceIndex + numVertices;\n      value.fill(0, startInstanceIndex * 3, endInstanceIndex * 3);\n      instancePickingColors.update({\n        value: value\n      });\n    }\n  }]);\n\n  return PathLayer;\n}(_deck_gl_core__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n\n\nPathLayer.layerName = 'PathLayer';\nPathLayer.defaultProps = defaultProps;\n//# sourceMappingURL=path-layer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3BhdGgtbGF5ZXIvcGF0aC1sYXllci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vcGF0aC1sYXllci9wYXRoLWxheWVyLmpzPzcyZGIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjtcbmltcG9ydCBfZ2V0UHJvdG90eXBlT2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mXCI7XG5pbXBvcnQgX2dldCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0XCI7XG5pbXBvcnQgX2luaGVyaXRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c1wiO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICdAZGVjay5nbC9jb3JlJztcbmltcG9ydCB7IE1vZGVsLCBHZW9tZXRyeSB9IGZyb20gJ0BsdW1hLmdsL2NvcmUnO1xuaW1wb3J0IFBhdGhUZXNzZWxhdG9yIGZyb20gJy4vcGF0aC10ZXNzZWxhdG9yJztcbmltcG9ydCB2cyBmcm9tICcuL3BhdGgtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IHZzNjQgZnJvbSAnLi9wYXRoLWxheWVyLXZlcnRleC02NC5nbHNsJztcbmltcG9ydCBmcyBmcm9tICcuL3BhdGgtbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG52YXIgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAwLCAyNTVdO1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgd2lkdGhVbml0czogJ21ldGVycycsXG4gIHdpZHRoU2NhbGU6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBtaW46IDAsXG4gICAgdmFsdWU6IDFcbiAgfSxcbiAgd2lkdGhNaW5QaXhlbHM6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBtaW46IDAsXG4gICAgdmFsdWU6IDBcbiAgfSxcbiAgd2lkdGhNYXhQaXhlbHM6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBtaW46IDAsXG4gICAgdmFsdWU6IE51bWJlci5NQVhfU0FGRV9JTlRFR0VSXG4gIH0sXG4gIHJvdW5kZWQ6IGZhbHNlLFxuICBtaXRlckxpbWl0OiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgbWluOiAwLFxuICAgIHZhbHVlOiA0XG4gIH0sXG4gIGZwNjQ6IGZhbHNlLFxuICBkYXNoSnVzdGlmaWVkOiBmYWxzZSxcbiAgYmlsbGJvYXJkOiBmYWxzZSxcbiAgZ2V0UGF0aDoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdC5wYXRoO1xuICAgIH1cbiAgfSxcbiAgZ2V0Q29sb3I6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBERUZBVUxUX0NPTE9SXG4gIH0sXG4gIGdldFdpZHRoOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogMVxuICB9LFxuICBnZXREYXNoQXJyYXk6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBbMCwgMF1cbiAgfVxufTtcbnZhciBBVFRSSUJVVEVfVFJBTlNJVElPTiA9IHtcbiAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyKHZhbHVlLCBjaHVuaykge1xuICAgIHJldHVybiBjaHVuay5sZW5ndGggPyBjaHVuay5zdWJhcnJheShjaHVuay5sZW5ndGggLSB2YWx1ZS5sZW5ndGgpIDogdmFsdWU7XG4gIH1cbn07XG5cbnZhciBQYXRoTGF5ZXIgPSBmdW5jdGlvbiAoX0xheWVyKSB7XG4gIF9pbmhlcml0cyhQYXRoTGF5ZXIsIF9MYXllcik7XG5cbiAgZnVuY3Rpb24gUGF0aExheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQYXRoTGF5ZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihQYXRoTGF5ZXIpLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhdGhMYXllciwgW3tcbiAgICBrZXk6IFwiZ2V0U2hhZGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaGFkZXJzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudXNlNjRiaXRQcm9qZWN0aW9uKCkgPyB7XG4gICAgICAgIHZzOiB2czY0LFxuICAgICAgICBmczogZnMsXG4gICAgICAgIG1vZHVsZXM6IFsncHJvamVjdDY0JywgJ3BpY2tpbmcnXVxuICAgICAgfSA6IHtcbiAgICAgICAgdnM6IHZzLFxuICAgICAgICBmczogZnMsXG4gICAgICAgIG1vZHVsZXM6IFsncHJvamVjdDMyJywgJ3BpY2tpbmcnXVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRpYWxpemVTdGF0ZSgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgIHZhciBub0FsbG9jID0gdHJ1ZTtcbiAgICAgIHZhciBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCk7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZEluc3RhbmNlZCh7XG4gICAgICAgIGluc3RhbmNlU3RhcnRQb3NpdGlvbnM6IHtcbiAgICAgICAgICBzaXplOiAzLFxuICAgICAgICAgIHRyYW5zaXRpb246IEFUVFJJQlVURV9UUkFOU0lUSU9OLFxuICAgICAgICAgIGFjY2Vzc29yOiAnZ2V0UGF0aCcsXG4gICAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVN0YXJ0UG9zaXRpb25zLFxuICAgICAgICAgIG5vQWxsb2M6IG5vQWxsb2NcbiAgICAgICAgfSxcbiAgICAgICAgaW5zdGFuY2VFbmRQb3NpdGlvbnM6IHtcbiAgICAgICAgICBzaXplOiAzLFxuICAgICAgICAgIHRyYW5zaXRpb246IEFUVFJJQlVURV9UUkFOU0lUSU9OLFxuICAgICAgICAgIGFjY2Vzc29yOiAnZ2V0UGF0aCcsXG4gICAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUVuZFBvc2l0aW9ucyxcbiAgICAgICAgICBub0FsbG9jOiBub0FsbG9jXG4gICAgICAgIH0sXG4gICAgICAgIGluc3RhbmNlU3RhcnRFbmRQb3NpdGlvbnM2NHh5TG93OiB7XG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VTdGFydEVuZFBvc2l0aW9uczY0eHlMb3csXG4gICAgICAgICAgbm9BbGxvYzogbm9BbGxvY1xuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZUxlZnRQb3NpdGlvbnM6IHtcbiAgICAgICAgICBzaXplOiAzLFxuICAgICAgICAgIGFjY2Vzc29yOiAnZ2V0UGF0aCcsXG4gICAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZUxlZnRQb3NpdGlvbnMsXG4gICAgICAgICAgbm9BbGxvYzogbm9BbGxvY1xuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZVJpZ2h0UG9zaXRpb25zOiB7XG4gICAgICAgICAgc2l6ZTogMyxcbiAgICAgICAgICBhY2Nlc3NvcjogJ2dldFBhdGgnLFxuICAgICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVSaWdodFBvc2l0aW9ucyxcbiAgICAgICAgICBub0FsbG9jOiBub0FsbG9jXG4gICAgICAgIH0sXG4gICAgICAgIGluc3RhbmNlTmVpZ2hib3JQb3NpdGlvbnM2NHh5TG93OiB7XG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5zdGFuY2VOZWlnaGJvclBvc2l0aW9uczY0eHlMb3csXG4gICAgICAgICAgbm9BbGxvYzogbm9BbGxvY1xuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZVN0cm9rZVdpZHRoczoge1xuICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgYWNjZXNzb3I6ICdnZXRXaWR0aCcsXG4gICAgICAgICAgdHJhbnNpdGlvbjogQVRUUklCVVRFX1RSQU5TSVRJT04sXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiAxXG4gICAgICAgIH0sXG4gICAgICAgIGluc3RhbmNlRGFzaEFycmF5czoge1xuICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgYWNjZXNzb3I6ICdnZXREYXNoQXJyYXknXG4gICAgICAgIH0sXG4gICAgICAgIGluc3RhbmNlQ29sb3JzOiB7XG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiA1MTIxLFxuICAgICAgICAgIGFjY2Vzc29yOiAnZ2V0Q29sb3InLFxuICAgICAgICAgIHRyYW5zaXRpb246IEFUVFJJQlVURV9UUkFOU0lUSU9OLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogREVGQVVMVF9DT0xPUlxuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZVBpY2tpbmdDb2xvcnM6IHtcbiAgICAgICAgICBzaXplOiAzLFxuICAgICAgICAgIHR5cGU6IDUxMjEsXG4gICAgICAgICAgYWNjZXNzb3I6IGZ1bmN0aW9uIGFjY2Vzc29yKG9iamVjdCwgX3JlZikge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gX3JlZi5pbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF9yZWYudGFyZ2V0O1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVuY29kZVBpY2tpbmdDb2xvcihpbmRleCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcGF0aFRlc3NlbGF0b3I6IG5ldyBQYXRoVGVzc2VsYXRvcih7fSlcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTdGF0ZShfcmVmMikge1xuICAgICAgdmFyIG9sZFByb3BzID0gX3JlZjIub2xkUHJvcHMsXG4gICAgICAgICAgcHJvcHMgPSBfcmVmMi5wcm9wcyxcbiAgICAgICAgICBjaGFuZ2VGbGFncyA9IF9yZWYyLmNoYW5nZUZsYWdzO1xuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihQYXRoTGF5ZXIucHJvdG90eXBlKSwgXCJ1cGRhdGVTdGF0ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIHtcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBvbGRQcm9wczogb2xkUHJvcHMsXG4gICAgICAgIGNoYW5nZUZsYWdzOiBjaGFuZ2VGbGFnc1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCk7XG4gICAgICB2YXIgZ2VvbWV0cnlDaGFuZ2VkID0gY2hhbmdlRmxhZ3MuZGF0YUNoYW5nZWQgfHwgcHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCB8fCBjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQgJiYgKGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZC5hbGwgfHwgY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkLmdldFBhdGgpO1xuXG4gICAgICBpZiAoZ2VvbWV0cnlDaGFuZ2VkKSB7XG4gICAgICAgIHZhciBwYXRoVGVzc2VsYXRvciA9IHRoaXMuc3RhdGUucGF0aFRlc3NlbGF0b3I7XG4gICAgICAgIHBhdGhUZXNzZWxhdG9yLnVwZGF0ZUdlb21ldHJ5KHtcbiAgICAgICAgICBkYXRhOiBwcm9wcy5kYXRhLFxuICAgICAgICAgIGdldEdlb21ldHJ5OiBwcm9wcy5nZXRQYXRoLFxuICAgICAgICAgIHBvc2l0aW9uRm9ybWF0OiBwcm9wcy5wb3NpdGlvbkZvcm1hdCxcbiAgICAgICAgICBmcDY0OiB0aGlzLnVzZTY0Yml0UG9zaXRpb25zKClcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgIG51bUluc3RhbmNlczogcGF0aFRlc3NlbGF0b3IuaW5zdGFuY2VDb3VudCxcbiAgICAgICAgICBidWZmZXJMYXlvdXQ6IHBhdGhUZXNzZWxhdG9yLmJ1ZmZlckxheW91dFxuICAgICAgICB9KTtcbiAgICAgICAgYXR0cmlidXRlTWFuYWdlci5pbnZhbGlkYXRlQWxsKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChwcm9wcy5mcDY0ICE9PSBvbGRQcm9wcy5mcDY0KSB7XG4gICAgICAgIHZhciBnbCA9IHRoaXMuY29udGV4dC5nbDtcblxuICAgICAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbCkge1xuICAgICAgICAgIHRoaXMuc3RhdGUubW9kZWwuZGVsZXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBtb2RlbDogdGhpcy5fZ2V0TW9kZWwoZ2wpXG4gICAgICAgIH0pO1xuICAgICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmludmFsaWRhdGVBbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmF3KF9yZWYzKSB7XG4gICAgICB2YXIgdW5pZm9ybXMgPSBfcmVmMy51bmlmb3JtcztcbiAgICAgIHZhciB2aWV3cG9ydCA9IHRoaXMuY29udGV4dC52aWV3cG9ydDtcbiAgICAgIHZhciBfdGhpcyRwcm9wcyA9IHRoaXMucHJvcHMsXG4gICAgICAgICAgcm91bmRlZCA9IF90aGlzJHByb3BzLnJvdW5kZWQsXG4gICAgICAgICAgYmlsbGJvYXJkID0gX3RoaXMkcHJvcHMuYmlsbGJvYXJkLFxuICAgICAgICAgIG1pdGVyTGltaXQgPSBfdGhpcyRwcm9wcy5taXRlckxpbWl0LFxuICAgICAgICAgIHdpZHRoVW5pdHMgPSBfdGhpcyRwcm9wcy53aWR0aFVuaXRzLFxuICAgICAgICAgIHdpZHRoU2NhbGUgPSBfdGhpcyRwcm9wcy53aWR0aFNjYWxlLFxuICAgICAgICAgIHdpZHRoTWluUGl4ZWxzID0gX3RoaXMkcHJvcHMud2lkdGhNaW5QaXhlbHMsXG4gICAgICAgICAgd2lkdGhNYXhQaXhlbHMgPSBfdGhpcyRwcm9wcy53aWR0aE1heFBpeGVscyxcbiAgICAgICAgICBkYXNoSnVzdGlmaWVkID0gX3RoaXMkcHJvcHMuZGFzaEp1c3RpZmllZDtcbiAgICAgIHZhciB3aWR0aE11bHRpcGxpZXIgPSB3aWR0aFVuaXRzID09PSAncGl4ZWxzJyA/IHZpZXdwb3J0LmRpc3RhbmNlU2NhbGVzLm1ldGVyc1BlclBpeGVsWzJdIDogMTtcbiAgICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VW5pZm9ybXMoT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHtcbiAgICAgICAgam9pbnRUeXBlOiBOdW1iZXIocm91bmRlZCksXG4gICAgICAgIGJpbGxib2FyZDogYmlsbGJvYXJkLFxuICAgICAgICBhbGlnbk1vZGU6IE51bWJlcihkYXNoSnVzdGlmaWVkKSxcbiAgICAgICAgd2lkdGhTY2FsZTogd2lkdGhTY2FsZSAqIHdpZHRoTXVsdGlwbGllcixcbiAgICAgICAgbWl0ZXJMaW1pdDogbWl0ZXJMaW1pdCxcbiAgICAgICAgd2lkdGhNaW5QaXhlbHM6IHdpZHRoTWluUGl4ZWxzLFxuICAgICAgICB3aWR0aE1heFBpeGVsczogd2lkdGhNYXhQaXhlbHNcbiAgICAgIH0pKS5kcmF3KCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRNb2RlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TW9kZWwoZ2wpIHtcbiAgICAgIHZhciBTRUdNRU5UX0lORElDRVMgPSBbMCwgMiwgMSwgMSwgMiwgNCwgMSwgNCwgMywgMywgNCwgNV07XG4gICAgICB2YXIgU0VHTUVOVF9QT1NJVElPTlMgPSBbMCwgMCwgMSwgMCwgLTEsIDAsIDAsIDEsIDAsIDEsIC0xLCAwLCAxLCAxLCAwLCAxLCAwLCAxXTtcbiAgICAgIHJldHVybiBuZXcgTW9kZWwoZ2wsIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZ2V0U2hhZGVycygpLCB7XG4gICAgICAgIGlkOiB0aGlzLnByb3BzLmlkLFxuICAgICAgICBnZW9tZXRyeTogbmV3IEdlb21ldHJ5KHtcbiAgICAgICAgICBkcmF3TW9kZTogNCxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBpbmRpY2VzOiBuZXcgVWludDE2QXJyYXkoU0VHTUVOVF9JTkRJQ0VTKSxcbiAgICAgICAgICAgIHBvc2l0aW9uczogbmV3IEZsb2F0MzJBcnJheShTRUdNRU5UX1BPU0lUSU9OUylcbiAgICAgICAgICB9XG4gICAgICAgIH0pLFxuICAgICAgICBpc0luc3RhbmNlZDogdHJ1ZSxcbiAgICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVTdGFydFBvc2l0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVTdGFydFBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBwYXRoVGVzc2VsYXRvciA9IHRoaXMuc3RhdGUucGF0aFRlc3NlbGF0b3I7XG4gICAgICBhdHRyaWJ1dGUuYnVmZmVyTGF5b3V0ID0gcGF0aFRlc3NlbGF0b3IuYnVmZmVyTGF5b3V0O1xuICAgICAgYXR0cmlidXRlLnZhbHVlID0gcGF0aFRlc3NlbGF0b3IuZ2V0KCdzdGFydFBvc2l0aW9ucycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVFbmRQb3NpdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlRW5kUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIHBhdGhUZXNzZWxhdG9yID0gdGhpcy5zdGF0ZS5wYXRoVGVzc2VsYXRvcjtcbiAgICAgIGF0dHJpYnV0ZS5idWZmZXJMYXlvdXQgPSBwYXRoVGVzc2VsYXRvci5idWZmZXJMYXlvdXQ7XG4gICAgICBhdHRyaWJ1dGUudmFsdWUgPSBwYXRoVGVzc2VsYXRvci5nZXQoJ2VuZFBvc2l0aW9ucycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVJbnN0YW5jZVN0YXJ0RW5kUG9zaXRpb25zNjR4eUxvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVJbnN0YW5jZVN0YXJ0RW5kUG9zaXRpb25zNjR4eUxvdyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBpc0ZQNjQgPSB0aGlzLnVzZTY0Yml0UG9zaXRpb25zKCk7XG4gICAgICBhdHRyaWJ1dGUuY29uc3RhbnQgPSAhaXNGUDY0O1xuXG4gICAgICBpZiAoaXNGUDY0KSB7XG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucGF0aFRlc3NlbGF0b3IuZ2V0KCdzdGFydEVuZFBvc2l0aW9uczY0WHlMb3cnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNhbGN1bGF0ZUxlZnRQb3NpdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlTGVmdFBvc2l0aW9ucyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBwYXRoVGVzc2VsYXRvciA9IHRoaXMuc3RhdGUucGF0aFRlc3NlbGF0b3I7XG4gICAgICBhdHRyaWJ1dGUudmFsdWUgPSBwYXRoVGVzc2VsYXRvci5nZXQoJ2xlZnRQb3NpdGlvbnMnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlUmlnaHRQb3NpdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlUmlnaHRQb3NpdGlvbnMoYXR0cmlidXRlKSB7XG4gICAgICB2YXIgcGF0aFRlc3NlbGF0b3IgPSB0aGlzLnN0YXRlLnBhdGhUZXNzZWxhdG9yO1xuICAgICAgYXR0cmlidXRlLnZhbHVlID0gcGF0aFRlc3NlbGF0b3IuZ2V0KCdyaWdodFBvc2l0aW9ucycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVJbnN0YW5jZU5laWdoYm9yUG9zaXRpb25zNjR4eUxvd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVJbnN0YW5jZU5laWdoYm9yUG9zaXRpb25zNjR4eUxvdyhhdHRyaWJ1dGUpIHtcbiAgICAgIHZhciBpc0ZQNjQgPSB0aGlzLnVzZTY0Yml0UG9zaXRpb25zKCk7XG4gICAgICBhdHRyaWJ1dGUuY29uc3RhbnQgPSAhaXNGUDY0O1xuXG4gICAgICBpZiAoaXNGUDY0KSB7XG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHRoaXMuc3RhdGUucGF0aFRlc3NlbGF0b3IuZ2V0KCduZWlnaGJvclBvc2l0aW9uczY0WHlMb3cnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkoNCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyUGlja2luZ0NvbG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyUGlja2luZ0NvbG9yKGNvbG9yKSB7XG4gICAgICB2YXIgcGlja2VkUGF0aEluZGV4ID0gdGhpcy5kZWNvZGVQaWNraW5nQ29sb3IoY29sb3IpO1xuICAgICAgdmFyIGJ1ZmZlckxheW91dCA9IHRoaXMuc3RhdGUucGF0aFRlc3NlbGF0b3IuYnVmZmVyTGF5b3V0O1xuICAgICAgdmFyIG51bVZlcnRpY2VzID0gYnVmZmVyTGF5b3V0W3BpY2tlZFBhdGhJbmRleF07XG4gICAgICB2YXIgc3RhcnRJbnN0YW5jZUluZGV4ID0gMDtcblxuICAgICAgZm9yICh2YXIgcGF0aEluZGV4ID0gMDsgcGF0aEluZGV4IDwgcGlja2VkUGF0aEluZGV4OyBwYXRoSW5kZXgrKykge1xuICAgICAgICBzdGFydEluc3RhbmNlSW5kZXggKz0gYnVmZmVyTGF5b3V0W3BhdGhJbmRleF07XG4gICAgICB9XG5cbiAgICAgIHZhciBpbnN0YW5jZVBpY2tpbmdDb2xvcnMgPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKS5hdHRyaWJ1dGVzLmluc3RhbmNlUGlja2luZ0NvbG9ycztcbiAgICAgIHZhciB2YWx1ZSA9IGluc3RhbmNlUGlja2luZ0NvbG9ycy52YWx1ZTtcbiAgICAgIHZhciBlbmRJbnN0YW5jZUluZGV4ID0gc3RhcnRJbnN0YW5jZUluZGV4ICsgbnVtVmVydGljZXM7XG4gICAgICB2YWx1ZS5maWxsKDAsIHN0YXJ0SW5zdGFuY2VJbmRleCAqIDMsIGVuZEluc3RhbmNlSW5kZXggKiAzKTtcbiAgICAgIGluc3RhbmNlUGlja2luZ0NvbG9ycy51cGRhdGUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYXRoTGF5ZXI7XG59KExheWVyKTtcblxuZXhwb3J0IHsgUGF0aExheWVyIGFzIGRlZmF1bHQgfTtcblBhdGhMYXllci5sYXllck5hbWUgPSAnUGF0aExheWVyJztcblBhdGhMYXllci5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXRoLWxheWVyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js ***!
  \*****************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PathTesselator; });\n/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @deck.gl/core */ \"./node_modules/@deck.gl/core/dist/esm/index.js\");\n/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @luma.gl/core */ \"./node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js\");\n\n\n\n\n\n\nvar Tesselator = _deck_gl_core__WEBPACK_IMPORTED_MODULE_5__[\"experimental\"].Tesselator;\n\nvar fp64LowPart = _luma_gl_core__WEBPACK_IMPORTED_MODULE_6__[\"default\"].fp64LowPart;\n\nvar PathTesselator = function (_Tesselator) {\n  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(PathTesselator, _Tesselator);\n\n  function PathTesselator(_ref) {\n    var data = _ref.data,\n        getGeometry = _ref.getGeometry,\n        positionFormat = _ref.positionFormat,\n        fp64 = _ref.fp64;\n\n    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, PathTesselator);\n\n    return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(PathTesselator).call(this, {\n      data: data,\n      getGeometry: getGeometry,\n      fp64: fp64,\n      positionFormat: positionFormat,\n      attributes: {\n        startPositions: {\n          size: 3\n        },\n        endPositions: {\n          size: 3\n        },\n        leftPositions: {\n          size: 3\n        },\n        rightPositions: {\n          size: 3\n        },\n        startEndPositions64XyLow: {\n          size: 4,\n          fp64Only: true\n        },\n        neighborPositions64XyLow: {\n          size: 4,\n          fp64Only: true\n        }\n      }\n    }));\n  }\n\n  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(PathTesselator, [{\n    key: \"get\",\n    value: function get(attributeName) {\n      return this.attributes[attributeName];\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(path) {\n      return Math.max(0, this.getPathLength(path) - 1);\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(path, context) {\n      var _this$attributes = this.attributes,\n          startPositions = _this$attributes.startPositions,\n          endPositions = _this$attributes.endPositions,\n          leftPositions = _this$attributes.leftPositions,\n          rightPositions = _this$attributes.rightPositions,\n          startEndPositions64XyLow = _this$attributes.startEndPositions64XyLow,\n          neighborPositions64XyLow = _this$attributes.neighborPositions64XyLow,\n          fp64 = this.fp64;\n      var numPoints = context.geometrySize + 1;\n\n      if (numPoints < 2) {\n        return;\n      }\n\n      var isPathClosed = this.isClosed(path);\n      var startPoint = this.getPointOnPath(path, 0);\n      var endPoint = this.getPointOnPath(path, 1);\n      var prevPoint = isPathClosed ? this.getPointOnPath(path, numPoints - 2) : startPoint;\n      var nextPoint;\n\n      for (var i = context.vertexStart, ptIndex = 1; ptIndex < numPoints; i++, ptIndex++) {\n        if (ptIndex + 1 < numPoints) {\n          nextPoint = this.getPointOnPath(path, ptIndex + 1);\n        } else {\n          nextPoint = isPathClosed ? this.getPointOnPath(path, 1) : endPoint;\n        }\n\n        startPositions[i * 3] = startPoint[0];\n        startPositions[i * 3 + 1] = startPoint[1];\n        startPositions[i * 3 + 2] = startPoint[2] || 0;\n        endPositions[i * 3] = endPoint[0];\n        endPositions[i * 3 + 1] = endPoint[1];\n        endPositions[i * 3 + 2] = endPoint[2] || 0;\n        leftPositions[i * 3] = prevPoint[0];\n        leftPositions[i * 3 + 1] = prevPoint[1];\n        leftPositions[i * 3 + 2] = prevPoint[2] || 0;\n        rightPositions[i * 3] = nextPoint[0];\n        rightPositions[i * 3 + 1] = nextPoint[1];\n        rightPositions[i * 3 + 2] = nextPoint[2] || 0;\n\n        if (fp64) {\n          startEndPositions64XyLow[i * 4] = fp64LowPart(startPoint[0]);\n          startEndPositions64XyLow[i * 4 + 1] = fp64LowPart(startPoint[1]);\n          startEndPositions64XyLow[i * 4 + 2] = fp64LowPart(endPoint[0]);\n          startEndPositions64XyLow[i * 4 + 3] = fp64LowPart(endPoint[1]);\n          neighborPositions64XyLow[i * 4] = fp64LowPart(prevPoint[0]);\n          neighborPositions64XyLow[i * 4 + 1] = fp64LowPart(prevPoint[1]);\n          neighborPositions64XyLow[i * 4 + 2] = fp64LowPart(nextPoint[0]);\n          neighborPositions64XyLow[i * 4 + 3] = fp64LowPart(nextPoint[1]);\n        }\n\n        prevPoint = startPoint;\n        startPoint = endPoint;\n        endPoint = nextPoint;\n      }\n    }\n  }, {\n    key: \"getPathLength\",\n    value: function getPathLength(path) {\n      if (Number.isFinite(path[0])) {\n        return path.length / this.positionSize;\n      }\n\n      return path.length;\n    }\n  }, {\n    key: \"getPointOnPath\",\n    value: function getPointOnPath(path, index) {\n      if (Number.isFinite(path[0])) {\n        var positionSize = this.positionSize;\n        return [path[index * positionSize], path[index * positionSize + 1], positionSize === 3 ? path[index * positionSize + 2] : 0];\n      }\n\n      return path[index];\n    }\n  }, {\n    key: \"isClosed\",\n    value: function isClosed(path) {\n      var numPoints = this.getPathLength(path);\n      var firstPoint = this.getPointOnPath(path, 0);\n      var lastPoint = this.getPointOnPath(path, numPoints - 1);\n      return firstPoint[0] === lastPoint[0] && firstPoint[1] === lastPoint[1] && firstPoint[2] === lastPoint[2];\n    }\n  }]);\n\n  return PathTesselator;\n}(Tesselator);\n\n\n//# sourceMappingURL=path-tesselator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3BhdGgtbGF5ZXIvcGF0aC10ZXNzZWxhdG9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS9wYXRoLWxheWVyL3BhdGgtdGVzc2VsYXRvci5qcz8zNmMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI7XG5pbXBvcnQgX2dldFByb3RvdHlwZU9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZlwiO1xuaW1wb3J0IF9pbmhlcml0cyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNcIjtcbmltcG9ydCB7IGV4cGVyaW1lbnRhbCB9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xudmFyIFRlc3NlbGF0b3IgPSBleHBlcmltZW50YWwuVGVzc2VsYXRvcjtcbmltcG9ydCB7IGZwNjQgYXMgZnA2NE1vZHVsZSB9IGZyb20gJ0BsdW1hLmdsL2NvcmUnO1xudmFyIGZwNjRMb3dQYXJ0ID0gZnA2NE1vZHVsZS5mcDY0TG93UGFydDtcblxudmFyIFBhdGhUZXNzZWxhdG9yID0gZnVuY3Rpb24gKF9UZXNzZWxhdG9yKSB7XG4gIF9pbmhlcml0cyhQYXRoVGVzc2VsYXRvciwgX1Rlc3NlbGF0b3IpO1xuXG4gIGZ1bmN0aW9uIFBhdGhUZXNzZWxhdG9yKF9yZWYpIHtcbiAgICB2YXIgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgZ2V0R2VvbWV0cnkgPSBfcmVmLmdldEdlb21ldHJ5LFxuICAgICAgICBwb3NpdGlvbkZvcm1hdCA9IF9yZWYucG9zaXRpb25Gb3JtYXQsXG4gICAgICAgIGZwNjQgPSBfcmVmLmZwNjQ7XG5cbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUGF0aFRlc3NlbGF0b3IpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihQYXRoVGVzc2VsYXRvcikuY2FsbCh0aGlzLCB7XG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgZ2V0R2VvbWV0cnk6IGdldEdlb21ldHJ5LFxuICAgICAgZnA2NDogZnA2NCxcbiAgICAgIHBvc2l0aW9uRm9ybWF0OiBwb3NpdGlvbkZvcm1hdCxcbiAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgc3RhcnRQb3NpdGlvbnM6IHtcbiAgICAgICAgICBzaXplOiAzXG4gICAgICAgIH0sXG4gICAgICAgIGVuZFBvc2l0aW9uczoge1xuICAgICAgICAgIHNpemU6IDNcbiAgICAgICAgfSxcbiAgICAgICAgbGVmdFBvc2l0aW9uczoge1xuICAgICAgICAgIHNpemU6IDNcbiAgICAgICAgfSxcbiAgICAgICAgcmlnaHRQb3NpdGlvbnM6IHtcbiAgICAgICAgICBzaXplOiAzXG4gICAgICAgIH0sXG4gICAgICAgIHN0YXJ0RW5kUG9zaXRpb25zNjRYeUxvdzoge1xuICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgZnA2NE9ubHk6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgbmVpZ2hib3JQb3NpdGlvbnM2NFh5TG93OiB7XG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICBmcDY0T25seTogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBhdGhUZXNzZWxhdG9yLCBbe1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNbYXR0cmlidXRlTmFtZV07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEdlb21ldHJ5U2l6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHZW9tZXRyeVNpemUocGF0aCkge1xuICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIHRoaXMuZ2V0UGF0aExlbmd0aChwYXRoKSAtIDEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVHZW9tZXRyeUF0dHJpYnV0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlR2VvbWV0cnlBdHRyaWJ1dGVzKHBhdGgsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpcyRhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLFxuICAgICAgICAgIHN0YXJ0UG9zaXRpb25zID0gX3RoaXMkYXR0cmlidXRlcy5zdGFydFBvc2l0aW9ucyxcbiAgICAgICAgICBlbmRQb3NpdGlvbnMgPSBfdGhpcyRhdHRyaWJ1dGVzLmVuZFBvc2l0aW9ucyxcbiAgICAgICAgICBsZWZ0UG9zaXRpb25zID0gX3RoaXMkYXR0cmlidXRlcy5sZWZ0UG9zaXRpb25zLFxuICAgICAgICAgIHJpZ2h0UG9zaXRpb25zID0gX3RoaXMkYXR0cmlidXRlcy5yaWdodFBvc2l0aW9ucyxcbiAgICAgICAgICBzdGFydEVuZFBvc2l0aW9uczY0WHlMb3cgPSBfdGhpcyRhdHRyaWJ1dGVzLnN0YXJ0RW5kUG9zaXRpb25zNjRYeUxvdyxcbiAgICAgICAgICBuZWlnaGJvclBvc2l0aW9uczY0WHlMb3cgPSBfdGhpcyRhdHRyaWJ1dGVzLm5laWdoYm9yUG9zaXRpb25zNjRYeUxvdyxcbiAgICAgICAgICBmcDY0ID0gdGhpcy5mcDY0O1xuICAgICAgdmFyIG51bVBvaW50cyA9IGNvbnRleHQuZ2VvbWV0cnlTaXplICsgMTtcblxuICAgICAgaWYgKG51bVBvaW50cyA8IDIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNQYXRoQ2xvc2VkID0gdGhpcy5pc0Nsb3NlZChwYXRoKTtcbiAgICAgIHZhciBzdGFydFBvaW50ID0gdGhpcy5nZXRQb2ludE9uUGF0aChwYXRoLCAwKTtcbiAgICAgIHZhciBlbmRQb2ludCA9IHRoaXMuZ2V0UG9pbnRPblBhdGgocGF0aCwgMSk7XG4gICAgICB2YXIgcHJldlBvaW50ID0gaXNQYXRoQ2xvc2VkID8gdGhpcy5nZXRQb2ludE9uUGF0aChwYXRoLCBudW1Qb2ludHMgLSAyKSA6IHN0YXJ0UG9pbnQ7XG4gICAgICB2YXIgbmV4dFBvaW50O1xuXG4gICAgICBmb3IgKHZhciBpID0gY29udGV4dC52ZXJ0ZXhTdGFydCwgcHRJbmRleCA9IDE7IHB0SW5kZXggPCBudW1Qb2ludHM7IGkrKywgcHRJbmRleCsrKSB7XG4gICAgICAgIGlmIChwdEluZGV4ICsgMSA8IG51bVBvaW50cykge1xuICAgICAgICAgIG5leHRQb2ludCA9IHRoaXMuZ2V0UG9pbnRPblBhdGgocGF0aCwgcHRJbmRleCArIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRQb2ludCA9IGlzUGF0aENsb3NlZCA/IHRoaXMuZ2V0UG9pbnRPblBhdGgocGF0aCwgMSkgOiBlbmRQb2ludDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0UG9zaXRpb25zW2kgKiAzXSA9IHN0YXJ0UG9pbnRbMF07XG4gICAgICAgIHN0YXJ0UG9zaXRpb25zW2kgKiAzICsgMV0gPSBzdGFydFBvaW50WzFdO1xuICAgICAgICBzdGFydFBvc2l0aW9uc1tpICogMyArIDJdID0gc3RhcnRQb2ludFsyXSB8fCAwO1xuICAgICAgICBlbmRQb3NpdGlvbnNbaSAqIDNdID0gZW5kUG9pbnRbMF07XG4gICAgICAgIGVuZFBvc2l0aW9uc1tpICogMyArIDFdID0gZW5kUG9pbnRbMV07XG4gICAgICAgIGVuZFBvc2l0aW9uc1tpICogMyArIDJdID0gZW5kUG9pbnRbMl0gfHwgMDtcbiAgICAgICAgbGVmdFBvc2l0aW9uc1tpICogM10gPSBwcmV2UG9pbnRbMF07XG4gICAgICAgIGxlZnRQb3NpdGlvbnNbaSAqIDMgKyAxXSA9IHByZXZQb2ludFsxXTtcbiAgICAgICAgbGVmdFBvc2l0aW9uc1tpICogMyArIDJdID0gcHJldlBvaW50WzJdIHx8IDA7XG4gICAgICAgIHJpZ2h0UG9zaXRpb25zW2kgKiAzXSA9IG5leHRQb2ludFswXTtcbiAgICAgICAgcmlnaHRQb3NpdGlvbnNbaSAqIDMgKyAxXSA9IG5leHRQb2ludFsxXTtcbiAgICAgICAgcmlnaHRQb3NpdGlvbnNbaSAqIDMgKyAyXSA9IG5leHRQb2ludFsyXSB8fCAwO1xuXG4gICAgICAgIGlmIChmcDY0KSB7XG4gICAgICAgICAgc3RhcnRFbmRQb3NpdGlvbnM2NFh5TG93W2kgKiA0XSA9IGZwNjRMb3dQYXJ0KHN0YXJ0UG9pbnRbMF0pO1xuICAgICAgICAgIHN0YXJ0RW5kUG9zaXRpb25zNjRYeUxvd1tpICogNCArIDFdID0gZnA2NExvd1BhcnQoc3RhcnRQb2ludFsxXSk7XG4gICAgICAgICAgc3RhcnRFbmRQb3NpdGlvbnM2NFh5TG93W2kgKiA0ICsgMl0gPSBmcDY0TG93UGFydChlbmRQb2ludFswXSk7XG4gICAgICAgICAgc3RhcnRFbmRQb3NpdGlvbnM2NFh5TG93W2kgKiA0ICsgM10gPSBmcDY0TG93UGFydChlbmRQb2ludFsxXSk7XG4gICAgICAgICAgbmVpZ2hib3JQb3NpdGlvbnM2NFh5TG93W2kgKiA0XSA9IGZwNjRMb3dQYXJ0KHByZXZQb2ludFswXSk7XG4gICAgICAgICAgbmVpZ2hib3JQb3NpdGlvbnM2NFh5TG93W2kgKiA0ICsgMV0gPSBmcDY0TG93UGFydChwcmV2UG9pbnRbMV0pO1xuICAgICAgICAgIG5laWdoYm9yUG9zaXRpb25zNjRYeUxvd1tpICogNCArIDJdID0gZnA2NExvd1BhcnQobmV4dFBvaW50WzBdKTtcbiAgICAgICAgICBuZWlnaGJvclBvc2l0aW9uczY0WHlMb3dbaSAqIDQgKyAzXSA9IGZwNjRMb3dQYXJ0KG5leHRQb2ludFsxXSk7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2UG9pbnQgPSBzdGFydFBvaW50O1xuICAgICAgICBzdGFydFBvaW50ID0gZW5kUG9pbnQ7XG4gICAgICAgIGVuZFBvaW50ID0gbmV4dFBvaW50O1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYXRoTGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBhdGhMZW5ndGgocGF0aCkge1xuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShwYXRoWzBdKSkge1xuICAgICAgICByZXR1cm4gcGF0aC5sZW5ndGggLyB0aGlzLnBvc2l0aW9uU2l6ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBhdGgubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRQb2ludE9uUGF0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb2ludE9uUGF0aChwYXRoLCBpbmRleCkge1xuICAgICAgaWYgKE51bWJlci5pc0Zpbml0ZShwYXRoWzBdKSkge1xuICAgICAgICB2YXIgcG9zaXRpb25TaXplID0gdGhpcy5wb3NpdGlvblNpemU7XG4gICAgICAgIHJldHVybiBbcGF0aFtpbmRleCAqIHBvc2l0aW9uU2l6ZV0sIHBhdGhbaW5kZXggKiBwb3NpdGlvblNpemUgKyAxXSwgcG9zaXRpb25TaXplID09PSAzID8gcGF0aFtpbmRleCAqIHBvc2l0aW9uU2l6ZSArIDJdIDogMF07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBwYXRoW2luZGV4XTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNDbG9zZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNDbG9zZWQocGF0aCkge1xuICAgICAgdmFyIG51bVBvaW50cyA9IHRoaXMuZ2V0UGF0aExlbmd0aChwYXRoKTtcbiAgICAgIHZhciBmaXJzdFBvaW50ID0gdGhpcy5nZXRQb2ludE9uUGF0aChwYXRoLCAwKTtcbiAgICAgIHZhciBsYXN0UG9pbnQgPSB0aGlzLmdldFBvaW50T25QYXRoKHBhdGgsIG51bVBvaW50cyAtIDEpO1xuICAgICAgcmV0dXJuIGZpcnN0UG9pbnRbMF0gPT09IGxhc3RQb2ludFswXSAmJiBmaXJzdFBvaW50WzFdID09PSBsYXN0UG9pbnRbMV0gJiYgZmlyc3RQb2ludFsyXSA9PT0gbGFzdFBvaW50WzJdO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBQYXRoVGVzc2VsYXRvcjtcbn0oVGVzc2VsYXRvcik7XG5cbmV4cG9ydCB7IFBhdGhUZXNzZWxhdG9yIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhdGgtdGVzc2VsYXRvci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js ***!
  \****************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"#define SHADER_NAME scatterplot-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform bool filled;\\n\\nvarying vec4 vFillColor;\\nvarying vec4 vLineColor;\\nvarying vec2 unitPosition;\\nvarying float innerUnitRadius;\\n\\nvoid main(void) {\\n\\n  float distToCenter = length(unitPosition);\\n\\n  if (distToCenter > 1.0) {\\n    discard;\\n  } \\n  if (distToCenter > innerUnitRadius) {\\n    gl_FragColor = vLineColor;\\n  } else if (filled) {\\n    gl_FragColor = vFillColor;\\n  } else {\\n    discard;\\n  }\\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\\n}\\n\");\n//# sourceMappingURL=scatterplot-layer-fragment.glsl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NjYXR0ZXJwbG90LWxheWVyL3NjYXR0ZXJwbG90LWxheWVyLWZyYWdtZW50Lmdsc2wuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NjYXR0ZXJwbG90LWxheWVyL3NjYXR0ZXJwbG90LWxheWVyLWZyYWdtZW50Lmdsc2wuanM/YWY4MSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIiNkZWZpbmUgU0hBREVSX05BTUUgc2NhdHRlcnBsb3QtbGF5ZXItZnJhZ21lbnQtc2hhZGVyXFxuXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbnVuaWZvcm0gYm9vbCBmaWxsZWQ7XFxuXFxudmFyeWluZyB2ZWM0IHZGaWxsQ29sb3I7XFxudmFyeWluZyB2ZWM0IHZMaW5lQ29sb3I7XFxudmFyeWluZyB2ZWMyIHVuaXRQb3NpdGlvbjtcXG52YXJ5aW5nIGZsb2F0IGlubmVyVW5pdFJhZGl1cztcXG5cXG52b2lkIG1haW4odm9pZCkge1xcblxcbiAgZmxvYXQgZGlzdFRvQ2VudGVyID0gbGVuZ3RoKHVuaXRQb3NpdGlvbik7XFxuXFxuICBpZiAoZGlzdFRvQ2VudGVyID4gMS4wKSB7XFxuICAgIGRpc2NhcmQ7XFxuICB9IFxcbiAgaWYgKGRpc3RUb0NlbnRlciA+IGlubmVyVW5pdFJhZGl1cykge1xcbiAgICBnbF9GcmFnQ29sb3IgPSB2TGluZUNvbG9yO1xcbiAgfSBlbHNlIGlmIChmaWxsZWQpIHtcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdkZpbGxDb2xvcjtcXG4gIH0gZWxzZSB7XFxuICAgIGRpc2NhcmQ7XFxuICB9XFxuICBnbF9GcmFnQ29sb3IgPSBwaWNraW5nX2ZpbHRlckhpZ2hsaWdodENvbG9yKGdsX0ZyYWdDb2xvcik7XFxuICBnbF9GcmFnQ29sb3IgPSBwaWNraW5nX2ZpbHRlclBpY2tpbmdDb2xvcihnbF9GcmFnQ29sb3IpO1xcbn1cXG5cIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjYXR0ZXJwbG90LWxheWVyLWZyYWdtZW50Lmdsc2wuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js ***!
  \**************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"#define SHADER_NAME scatterplot-layer-vertex-shader\\n\\nattribute vec3 positions;\\n\\nattribute vec3 instancePositions;\\nattribute vec2 instancePositions64xyLow;\\nattribute float instanceRadius;\\nattribute float instanceLineWidths;\\nattribute vec4 instanceFillColors;\\nattribute vec4 instanceLineColors;\\nattribute vec3 instancePickingColors;\\n\\nuniform float opacity;\\nuniform float radiusScale;\\nuniform float radiusMinPixels;\\nuniform float radiusMaxPixels;\\nuniform float lineWidthScale;\\nuniform float lineWidthMinPixels;\\nuniform float lineWidthMaxPixels;\\nuniform float stroked;\\nuniform bool filled;\\n\\nvarying vec4 vFillColor;\\nvarying vec4 vLineColor;\\nvarying vec2 unitPosition;\\nvarying float innerUnitRadius;\\n\\nvoid main(void) {\\n  float outerRadiusPixels = clamp(\\n    project_size_to_pixel(radiusScale * instanceRadius),\\n    radiusMinPixels, radiusMaxPixels\\n  );\\n  float lineWidthPixels = clamp(\\n    project_size_to_pixel(lineWidthScale * instanceLineWidths),\\n    lineWidthMinPixels, lineWidthMaxPixels\\n  );\\n  outerRadiusPixels += stroked * lineWidthPixels / 2.0;\\n  unitPosition = positions.xy;\\n\\n  innerUnitRadius = 1.0 - stroked * lineWidthPixels / outerRadiusPixels;\\n  \\n  vec3 offset = positions * project_pixel_size(outerRadiusPixels);\\n  gl_Position = project_position_to_clipspace(instancePositions, instancePositions64xyLow, offset);\\n  vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * opacity) / 255.;\\n  vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * opacity) / 255.;\\n  picking_setPickingColor(instancePickingColors);\\n}\\n\");\n//# sourceMappingURL=scatterplot-layer-vertex.glsl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NjYXR0ZXJwbG90LWxheWVyL3NjYXR0ZXJwbG90LWxheWVyLXZlcnRleC5nbHNsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS9zY2F0dGVycGxvdC1sYXllci9zY2F0dGVycGxvdC1sYXllci12ZXJ0ZXguZ2xzbC5qcz8yM2MxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBTSEFERVJfTkFNRSBzY2F0dGVycGxvdC1sYXllci12ZXJ0ZXgtc2hhZGVyXFxuXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xcblxcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWMyIGluc3RhbmNlUG9zaXRpb25zNjR4eUxvdztcXG5hdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VSYWRpdXM7XFxuYXR0cmlidXRlIGZsb2F0IGluc3RhbmNlTGluZVdpZHRocztcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUZpbGxDb2xvcnM7XFxuYXR0cmlidXRlIHZlYzQgaW5zdGFuY2VMaW5lQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIGluc3RhbmNlUGlja2luZ0NvbG9ycztcXG5cXG51bmlmb3JtIGZsb2F0IG9wYWNpdHk7XFxudW5pZm9ybSBmbG9hdCByYWRpdXNTY2FsZTtcXG51bmlmb3JtIGZsb2F0IHJhZGl1c01pblBpeGVscztcXG51bmlmb3JtIGZsb2F0IHJhZGl1c01heFBpeGVscztcXG51bmlmb3JtIGZsb2F0IGxpbmVXaWR0aFNjYWxlO1xcbnVuaWZvcm0gZmxvYXQgbGluZVdpZHRoTWluUGl4ZWxzO1xcbnVuaWZvcm0gZmxvYXQgbGluZVdpZHRoTWF4UGl4ZWxzO1xcbnVuaWZvcm0gZmxvYXQgc3Ryb2tlZDtcXG51bmlmb3JtIGJvb2wgZmlsbGVkO1xcblxcbnZhcnlpbmcgdmVjNCB2RmlsbENvbG9yO1xcbnZhcnlpbmcgdmVjNCB2TGluZUNvbG9yO1xcbnZhcnlpbmcgdmVjMiB1bml0UG9zaXRpb247XFxudmFyeWluZyBmbG9hdCBpbm5lclVuaXRSYWRpdXM7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGZsb2F0IG91dGVyUmFkaXVzUGl4ZWxzID0gY2xhbXAoXFxuICAgIHByb2plY3Rfc2l6ZV90b19waXhlbChyYWRpdXNTY2FsZSAqIGluc3RhbmNlUmFkaXVzKSxcXG4gICAgcmFkaXVzTWluUGl4ZWxzLCByYWRpdXNNYXhQaXhlbHNcXG4gICk7XFxuICBmbG9hdCBsaW5lV2lkdGhQaXhlbHMgPSBjbGFtcChcXG4gICAgcHJvamVjdF9zaXplX3RvX3BpeGVsKGxpbmVXaWR0aFNjYWxlICogaW5zdGFuY2VMaW5lV2lkdGhzKSxcXG4gICAgbGluZVdpZHRoTWluUGl4ZWxzLCBsaW5lV2lkdGhNYXhQaXhlbHNcXG4gICk7XFxuICBvdXRlclJhZGl1c1BpeGVscyArPSBzdHJva2VkICogbGluZVdpZHRoUGl4ZWxzIC8gMi4wO1xcbiAgdW5pdFBvc2l0aW9uID0gcG9zaXRpb25zLnh5O1xcblxcbiAgaW5uZXJVbml0UmFkaXVzID0gMS4wIC0gc3Ryb2tlZCAqIGxpbmVXaWR0aFBpeGVscyAvIG91dGVyUmFkaXVzUGl4ZWxzO1xcbiAgXFxuICB2ZWMzIG9mZnNldCA9IHBvc2l0aW9ucyAqIHByb2plY3RfcGl4ZWxfc2l6ZShvdXRlclJhZGl1c1BpeGVscyk7XFxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb25fdG9fY2xpcHNwYWNlKGluc3RhbmNlUG9zaXRpb25zLCBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3csIG9mZnNldCk7XFxuICB2RmlsbENvbG9yID0gdmVjNChpbnN0YW5jZUZpbGxDb2xvcnMucmdiLCBpbnN0YW5jZUZpbGxDb2xvcnMuYSAqIG9wYWNpdHkpIC8gMjU1LjtcXG4gIHZMaW5lQ29sb3IgPSB2ZWM0KGluc3RhbmNlTGluZUNvbG9ycy5yZ2IsIGluc3RhbmNlTGluZUNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuO1xcbiAgcGlja2luZ19zZXRQaWNraW5nQ29sb3IoaW5zdGFuY2VQaWNraW5nQ29sb3JzKTtcXG59XFxuXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY2F0dGVycGxvdC1sYXllci12ZXJ0ZXguZ2xzbC5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js ***!
  \**************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return ScatterplotLayer; });\n/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_get__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/get */ \"./node_modules/@babel/runtime/helpers/esm/get.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @deck.gl/core */ \"./node_modules/@deck.gl/core/dist/esm/utils/iterable-utils.js\");\n/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @deck.gl/core */ \"./node_modules/@deck.gl/core/dist/esm/lib/layer.js\");\n/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @luma.gl/core */ \"./node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js\");\n/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @luma.gl/core */ \"./node_modules/@luma.gl/core/dist/esm/lib/model.js\");\n/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @luma.gl/core */ \"./node_modules/@luma.gl/core/dist/esm/geometry/geometry.js\");\n/* harmony import */ var _scatterplot_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./scatterplot-layer-vertex.glsl */ \"./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-vertex.glsl.js\");\n/* harmony import */ var _scatterplot_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./scatterplot-layer-fragment.glsl */ \"./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer-fragment.glsl.js\");\n\n\n\n\n\n\n\n\nvar fp64LowPart = _luma_gl_core__WEBPACK_IMPORTED_MODULE_8__[\"default\"].fp64LowPart;\n\n\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar defaultProps = {\n  radiusScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  radiusMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  radiusMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  lineWidthUnits: 'meters',\n  lineWidthScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  lineWidthMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  lineWidthMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  stroked: false,\n  fp64: false,\n  filled: true,\n  getPosition: {\n    type: 'accessor',\n    value: function value(x) {\n      return x.position;\n    }\n  },\n  getRadius: {\n    type: 'accessor',\n    value: 1\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  strokeWidth: {\n    deprecatedFor: 'getLineWidth'\n  },\n  outline: {\n    deprecatedFor: 'stroked'\n  },\n  getColor: {\n    deprecatedFor: ['getFillColor', 'getLineColor']\n  }\n};\n\nvar ScatterplotLayer = function (_Layer) {\n  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(ScatterplotLayer, _Layer);\n\n  function ScatterplotLayer() {\n    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, ScatterplotLayer);\n\n    return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(ScatterplotLayer).apply(this, arguments));\n  }\n\n  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(ScatterplotLayer, [{\n    key: \"getShaders\",\n    value: function getShaders(id) {\n      var projectModule = this.use64bitProjection() ? 'project64' : 'project32';\n      return {\n        vs: _scatterplot_layer_vertex_glsl__WEBPACK_IMPORTED_MODULE_11__[\"default\"],\n        fs: _scatterplot_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_12__[\"default\"],\n        modules: [projectModule, 'picking']\n      };\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      this.getAttributeManager().addInstanced({\n        instancePositions: {\n          size: 3,\n          transition: true,\n          accessor: 'getPosition'\n        },\n        instancePositions64xyLow: {\n          size: 2,\n          accessor: 'getPosition',\n          update: this.calculateInstancePositions64xyLow\n        },\n        instanceRadius: {\n          size: 1,\n          transition: true,\n          accessor: 'getRadius',\n          defaultValue: 1\n        },\n        instanceFillColors: {\n          size: 4,\n          transition: true,\n          type: 5121,\n          accessor: 'getFillColor',\n          defaultValue: [0, 0, 0, 255]\n        },\n        instanceLineColors: {\n          size: 4,\n          transition: true,\n          type: 5121,\n          accessor: 'getLineColor',\n          defaultValue: [0, 0, 0, 255]\n        },\n        instanceLineWidths: {\n          size: 1,\n          transition: true,\n          accessor: 'getLineWidth',\n          defaultValue: 1\n        }\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref) {\n      var props = _ref.props,\n          oldProps = _ref.oldProps,\n          changeFlags = _ref.changeFlags;\n\n      Object(_babel_runtime_helpers_esm_get__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(ScatterplotLayer.prototype), \"updateState\", this).call(this, {\n        props: props,\n        oldProps: oldProps,\n        changeFlags: changeFlags\n      });\n\n      if (props.fp64 !== oldProps.fp64) {\n        var gl = this.context.gl;\n\n        if (this.state.model) {\n          this.state.model.delete();\n        }\n\n        this.setState({\n          model: this._getModel(gl)\n        });\n        this.getAttributeManager().invalidateAll();\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n      var viewport = this.context.viewport;\n      var _this$props = this.props,\n          radiusScale = _this$props.radiusScale,\n          radiusMinPixels = _this$props.radiusMinPixels,\n          radiusMaxPixels = _this$props.radiusMaxPixels,\n          stroked = _this$props.stroked,\n          filled = _this$props.filled,\n          lineWidthUnits = _this$props.lineWidthUnits,\n          lineWidthScale = _this$props.lineWidthScale,\n          lineWidthMinPixels = _this$props.lineWidthMinPixels,\n          lineWidthMaxPixels = _this$props.lineWidthMaxPixels;\n      var widthMultiplier = lineWidthUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1;\n      this.state.model.setUniforms(Object.assign({}, uniforms, {\n        stroked: stroked ? 1 : 0,\n        filled: filled,\n        radiusScale: radiusScale,\n        radiusMinPixels: radiusMinPixels,\n        radiusMaxPixels: radiusMaxPixels,\n        lineWidthScale: lineWidthScale * widthMultiplier,\n        lineWidthMinPixels: lineWidthMinPixels,\n        lineWidthMaxPixels: lineWidthMaxPixels\n      })).draw();\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      var positions = [-1, -1, 0, -1, 1, 0, 1, 1, 0, 1, -1, 0];\n      return new _luma_gl_core__WEBPACK_IMPORTED_MODULE_9__[\"default\"](gl, Object.assign(this.getShaders(), {\n        id: this.props.id,\n        geometry: new _luma_gl_core__WEBPACK_IMPORTED_MODULE_10__[\"default\"]({\n          drawMode: 6,\n          vertexCount: 4,\n          attributes: {\n            positions: {\n              size: 3,\n              value: new Float32Array(positions)\n            }\n          }\n        }),\n        isInstanced: true,\n        shaderCache: this.context.shaderCache\n      }));\n    }\n  }, {\n    key: \"calculateInstancePositions64xyLow\",\n    value: function calculateInstancePositions64xyLow(attribute, _ref3) {\n      var startRow = _ref3.startRow,\n          endRow = _ref3.endRow;\n      var isFP64 = this.use64bitPositions();\n      attribute.constant = !isFP64;\n\n      if (!isFP64) {\n        attribute.value = new Float32Array(2);\n        return;\n      }\n\n      var _this$props2 = this.props,\n          data = _this$props2.data,\n          getPosition = _this$props2.getPosition;\n      var value = attribute.value,\n          size = attribute.size;\n      var i = startRow * size;\n\n      var _createIterable = Object(_deck_gl_core__WEBPACK_IMPORTED_MODULE_6__[\"createIterable\"])(data, startRow, endRow),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = iterable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var object = _step.value;\n          objectInfo.index++;\n          var position = getPosition(object, objectInfo);\n          value[i++] = fp64LowPart(position[0]);\n          value[i++] = fp64LowPart(position[1]);\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }]);\n\n  return ScatterplotLayer;\n}(_deck_gl_core__WEBPACK_IMPORTED_MODULE_7__[\"default\"]);\n\n\nScatterplotLayer.layerName = 'ScatterplotLayer';\nScatterplotLayer.defaultProps = defaultProps;\n//# sourceMappingURL=scatterplot-layer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NjYXR0ZXJwbG90LWxheWVyL3NjYXR0ZXJwbG90LWxheWVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS9zY2F0dGVycGxvdC1sYXllci9zY2F0dGVycGxvdC1sYXllci5qcz9mYmJiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI7XG5pbXBvcnQgX2dldFByb3RvdHlwZU9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZlwiO1xuaW1wb3J0IF9nZXQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFwiO1xuaW1wb3J0IF9pbmhlcml0cyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNcIjtcbmltcG9ydCB7IExheWVyLCBjcmVhdGVJdGVyYWJsZSB9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xuaW1wb3J0IHsgTW9kZWwsIEdlb21ldHJ5LCBmcDY0IH0gZnJvbSAnQGx1bWEuZ2wvY29yZSc7XG52YXIgZnA2NExvd1BhcnQgPSBmcDY0LmZwNjRMb3dQYXJ0O1xuaW1wb3J0IHZzIGZyb20gJy4vc2NhdHRlcnBsb3QtbGF5ZXItdmVydGV4Lmdsc2wnO1xuaW1wb3J0IGZzIGZyb20gJy4vc2NhdHRlcnBsb3QtbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG52YXIgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAwLCAyNTVdO1xudmFyIGRlZmF1bHRQcm9wcyA9IHtcbiAgcmFkaXVzU2NhbGU6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBtaW46IDAsXG4gICAgdmFsdWU6IDFcbiAgfSxcbiAgcmFkaXVzTWluUGl4ZWxzOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgbWluOiAwLFxuICAgIHZhbHVlOiAwXG4gIH0sXG4gIHJhZGl1c01heFBpeGVsczoge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIG1pbjogMCxcbiAgICB2YWx1ZTogTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgfSxcbiAgbGluZVdpZHRoVW5pdHM6ICdtZXRlcnMnLFxuICBsaW5lV2lkdGhTY2FsZToge1xuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIG1pbjogMCxcbiAgICB2YWx1ZTogMVxuICB9LFxuICBsaW5lV2lkdGhNaW5QaXhlbHM6IHtcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBtaW46IDAsXG4gICAgdmFsdWU6IDBcbiAgfSxcbiAgbGluZVdpZHRoTWF4UGl4ZWxzOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgbWluOiAwLFxuICAgIHZhbHVlOiBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUlxuICB9LFxuICBzdHJva2VkOiBmYWxzZSxcbiAgZnA2NDogZmFsc2UsXG4gIGZpbGxlZDogdHJ1ZSxcbiAgZ2V0UG9zaXRpb246IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh4KSB7XG4gICAgICByZXR1cm4geC5wb3NpdGlvbjtcbiAgICB9XG4gIH0sXG4gIGdldFJhZGl1czoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IDFcbiAgfSxcbiAgZ2V0RmlsbENvbG9yOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogREVGQVVMVF9DT0xPUlxuICB9LFxuICBnZXRMaW5lQ29sb3I6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBERUZBVUxUX0NPTE9SXG4gIH0sXG4gIGdldExpbmVXaWR0aDoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IDFcbiAgfSxcbiAgc3Ryb2tlV2lkdGg6IHtcbiAgICBkZXByZWNhdGVkRm9yOiAnZ2V0TGluZVdpZHRoJ1xuICB9LFxuICBvdXRsaW5lOiB7XG4gICAgZGVwcmVjYXRlZEZvcjogJ3N0cm9rZWQnXG4gIH0sXG4gIGdldENvbG9yOiB7XG4gICAgZGVwcmVjYXRlZEZvcjogWydnZXRGaWxsQ29sb3InLCAnZ2V0TGluZUNvbG9yJ11cbiAgfVxufTtcblxudmFyIFNjYXR0ZXJwbG90TGF5ZXIgPSBmdW5jdGlvbiAoX0xheWVyKSB7XG4gIF9pbmhlcml0cyhTY2F0dGVycGxvdExheWVyLCBfTGF5ZXIpO1xuXG4gIGZ1bmN0aW9uIFNjYXR0ZXJwbG90TGF5ZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFNjYXR0ZXJwbG90TGF5ZXIpO1xuXG4gICAgcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIF9nZXRQcm90b3R5cGVPZihTY2F0dGVycGxvdExheWVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTY2F0dGVycGxvdExheWVyLCBbe1xuICAgIGtleTogXCJnZXRTaGFkZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNoYWRlcnMoaWQpIHtcbiAgICAgIHZhciBwcm9qZWN0TW9kdWxlID0gdGhpcy51c2U2NGJpdFByb2plY3Rpb24oKSA/ICdwcm9qZWN0NjQnIDogJ3Byb2plY3QzMic7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2czogdnMsXG4gICAgICAgIGZzOiBmcyxcbiAgICAgICAgbW9kdWxlczogW3Byb2plY3RNb2R1bGUsICdwaWNraW5nJ11cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImluaXRpYWxpemVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpbml0aWFsaXplU3RhdGUoKSB7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKS5hZGRJbnN0YW5jZWQoe1xuICAgICAgICBpbnN0YW5jZVBvc2l0aW9uczoge1xuICAgICAgICAgIHNpemU6IDMsXG4gICAgICAgICAgdHJhbnNpdGlvbjogdHJ1ZSxcbiAgICAgICAgICBhY2Nlc3NvcjogJ2dldFBvc2l0aW9uJ1xuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3c6IHtcbiAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIGFjY2Vzc29yOiAnZ2V0UG9zaXRpb24nLFxuICAgICAgICAgIHVwZGF0ZTogdGhpcy5jYWxjdWxhdGVJbnN0YW5jZVBvc2l0aW9uczY0eHlMb3dcbiAgICAgICAgfSxcbiAgICAgICAgaW5zdGFuY2VSYWRpdXM6IHtcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgICAgICAgYWNjZXNzb3I6ICdnZXRSYWRpdXMnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMVxuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZUZpbGxDb2xvcnM6IHtcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgICAgICAgdHlwZTogNTEyMSxcbiAgICAgICAgICBhY2Nlc3NvcjogJ2dldEZpbGxDb2xvcicsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBbMCwgMCwgMCwgMjU1XVxuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZUxpbmVDb2xvcnM6IHtcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgICAgICAgdHlwZTogNTEyMSxcbiAgICAgICAgICBhY2Nlc3NvcjogJ2dldExpbmVDb2xvcicsXG4gICAgICAgICAgZGVmYXVsdFZhbHVlOiBbMCwgMCwgMCwgMjU1XVxuICAgICAgICB9LFxuICAgICAgICBpbnN0YW5jZUxpbmVXaWR0aHM6IHtcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIHRyYW5zaXRpb246IHRydWUsXG4gICAgICAgICAgYWNjZXNzb3I6ICdnZXRMaW5lV2lkdGgnLFxuICAgICAgICAgIGRlZmF1bHRWYWx1ZTogMVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlU3RhdGUoX3JlZikge1xuICAgICAgdmFyIHByb3BzID0gX3JlZi5wcm9wcyxcbiAgICAgICAgICBvbGRQcm9wcyA9IF9yZWYub2xkUHJvcHMsXG4gICAgICAgICAgY2hhbmdlRmxhZ3MgPSBfcmVmLmNoYW5nZUZsYWdzO1xuXG4gICAgICBfZ2V0KF9nZXRQcm90b3R5cGVPZihTY2F0dGVycGxvdExheWVyLnByb3RvdHlwZSksIFwidXBkYXRlU3RhdGVcIiwgdGhpcykuY2FsbCh0aGlzLCB7XG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgb2xkUHJvcHM6IG9sZFByb3BzLFxuICAgICAgICBjaGFuZ2VGbGFnczogY2hhbmdlRmxhZ3NcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocHJvcHMuZnA2NCAhPT0gb2xkUHJvcHMuZnA2NCkge1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLmNvbnRleHQuZ2w7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUubW9kZWwpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLm1vZGVsLmRlbGV0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgbW9kZWw6IHRoaXMuX2dldE1vZGVsKGdsKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCkuaW52YWxpZGF0ZUFsbCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoX3JlZjIpIHtcbiAgICAgIHZhciB1bmlmb3JtcyA9IF9yZWYyLnVuaWZvcm1zO1xuICAgICAgdmFyIHZpZXdwb3J0ID0gdGhpcy5jb250ZXh0LnZpZXdwb3J0O1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICByYWRpdXNTY2FsZSA9IF90aGlzJHByb3BzLnJhZGl1c1NjYWxlLFxuICAgICAgICAgIHJhZGl1c01pblBpeGVscyA9IF90aGlzJHByb3BzLnJhZGl1c01pblBpeGVscyxcbiAgICAgICAgICByYWRpdXNNYXhQaXhlbHMgPSBfdGhpcyRwcm9wcy5yYWRpdXNNYXhQaXhlbHMsXG4gICAgICAgICAgc3Ryb2tlZCA9IF90aGlzJHByb3BzLnN0cm9rZWQsXG4gICAgICAgICAgZmlsbGVkID0gX3RoaXMkcHJvcHMuZmlsbGVkLFxuICAgICAgICAgIGxpbmVXaWR0aFVuaXRzID0gX3RoaXMkcHJvcHMubGluZVdpZHRoVW5pdHMsXG4gICAgICAgICAgbGluZVdpZHRoU2NhbGUgPSBfdGhpcyRwcm9wcy5saW5lV2lkdGhTY2FsZSxcbiAgICAgICAgICBsaW5lV2lkdGhNaW5QaXhlbHMgPSBfdGhpcyRwcm9wcy5saW5lV2lkdGhNaW5QaXhlbHMsXG4gICAgICAgICAgbGluZVdpZHRoTWF4UGl4ZWxzID0gX3RoaXMkcHJvcHMubGluZVdpZHRoTWF4UGl4ZWxzO1xuICAgICAgdmFyIHdpZHRoTXVsdGlwbGllciA9IGxpbmVXaWR0aFVuaXRzID09PSAncGl4ZWxzJyA/IHZpZXdwb3J0LmRpc3RhbmNlU2NhbGVzLm1ldGVyc1BlclBpeGVsWzJdIDogMTtcbiAgICAgIHRoaXMuc3RhdGUubW9kZWwuc2V0VW5pZm9ybXMoT2JqZWN0LmFzc2lnbih7fSwgdW5pZm9ybXMsIHtcbiAgICAgICAgc3Ryb2tlZDogc3Ryb2tlZCA/IDEgOiAwLFxuICAgICAgICBmaWxsZWQ6IGZpbGxlZCxcbiAgICAgICAgcmFkaXVzU2NhbGU6IHJhZGl1c1NjYWxlLFxuICAgICAgICByYWRpdXNNaW5QaXhlbHM6IHJhZGl1c01pblBpeGVscyxcbiAgICAgICAgcmFkaXVzTWF4UGl4ZWxzOiByYWRpdXNNYXhQaXhlbHMsXG4gICAgICAgIGxpbmVXaWR0aFNjYWxlOiBsaW5lV2lkdGhTY2FsZSAqIHdpZHRoTXVsdGlwbGllcixcbiAgICAgICAgbGluZVdpZHRoTWluUGl4ZWxzOiBsaW5lV2lkdGhNaW5QaXhlbHMsXG4gICAgICAgIGxpbmVXaWR0aE1heFBpeGVsczogbGluZVdpZHRoTWF4UGl4ZWxzXG4gICAgICB9KSkuZHJhdygpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0TW9kZWxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldE1vZGVsKGdsKSB7XG4gICAgICB2YXIgcG9zaXRpb25zID0gWy0xLCAtMSwgMCwgLTEsIDEsIDAsIDEsIDEsIDAsIDEsIC0xLCAwXTtcbiAgICAgIHJldHVybiBuZXcgTW9kZWwoZ2wsIE9iamVjdC5hc3NpZ24odGhpcy5nZXRTaGFkZXJzKCksIHtcbiAgICAgICAgaWQ6IHRoaXMucHJvcHMuaWQsXG4gICAgICAgIGdlb21ldHJ5OiBuZXcgR2VvbWV0cnkoe1xuICAgICAgICAgIGRyYXdNb2RlOiA2LFxuICAgICAgICAgIHZlcnRleENvdW50OiA0LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uczoge1xuICAgICAgICAgICAgICBzaXplOiAzLFxuICAgICAgICAgICAgICB2YWx1ZTogbmV3IEZsb2F0MzJBcnJheShwb3NpdGlvbnMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KSxcbiAgICAgICAgaXNJbnN0YW5jZWQ6IHRydWUsXG4gICAgICAgIHNoYWRlckNhY2hlOiB0aGlzLmNvbnRleHQuc2hhZGVyQ2FjaGVcbiAgICAgIH0pKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlSW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGN1bGF0ZUluc3RhbmNlUG9zaXRpb25zNjR4eUxvdyhhdHRyaWJ1dGUsIF9yZWYzKSB7XG4gICAgICB2YXIgc3RhcnRSb3cgPSBfcmVmMy5zdGFydFJvdyxcbiAgICAgICAgICBlbmRSb3cgPSBfcmVmMy5lbmRSb3c7XG4gICAgICB2YXIgaXNGUDY0ID0gdGhpcy51c2U2NGJpdFBvc2l0aW9ucygpO1xuICAgICAgYXR0cmlidXRlLmNvbnN0YW50ID0gIWlzRlA2NDtcblxuICAgICAgaWYgKCFpc0ZQNjQpIHtcbiAgICAgICAgYXR0cmlidXRlLnZhbHVlID0gbmV3IEZsb2F0MzJBcnJheSgyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBkYXRhID0gX3RoaXMkcHJvcHMyLmRhdGEsXG4gICAgICAgICAgZ2V0UG9zaXRpb24gPSBfdGhpcyRwcm9wczIuZ2V0UG9zaXRpb247XG4gICAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGUudmFsdWUsXG4gICAgICAgICAgc2l6ZSA9IGF0dHJpYnV0ZS5zaXplO1xuICAgICAgdmFyIGkgPSBzdGFydFJvdyAqIHNpemU7XG5cbiAgICAgIHZhciBfY3JlYXRlSXRlcmFibGUgPSBjcmVhdGVJdGVyYWJsZShkYXRhLCBzdGFydFJvdywgZW5kUm93KSxcbiAgICAgICAgICBpdGVyYWJsZSA9IF9jcmVhdGVJdGVyYWJsZS5pdGVyYWJsZSxcbiAgICAgICAgICBvYmplY3RJbmZvID0gX2NyZWF0ZUl0ZXJhYmxlLm9iamVjdEluZm87XG5cbiAgICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICAgIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBpdGVyYWJsZVtTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgICB2YXIgb2JqZWN0ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgb2JqZWN0SW5mby5pbmRleCsrO1xuICAgICAgICAgIHZhciBwb3NpdGlvbiA9IGdldFBvc2l0aW9uKG9iamVjdCwgb2JqZWN0SW5mbyk7XG4gICAgICAgICAgdmFsdWVbaSsrXSA9IGZwNjRMb3dQYXJ0KHBvc2l0aW9uWzBdKTtcbiAgICAgICAgICB2YWx1ZVtpKytdID0gZnA2NExvd1BhcnQocG9zaXRpb25bMV0pO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgICBfaXRlcmF0b3JFcnJvciA9IGVycjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uICYmIF9pdGVyYXRvci5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yLnJldHVybigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAoX2RpZEl0ZXJhdG9yRXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTY2F0dGVycGxvdExheWVyO1xufShMYXllcik7XG5cbmV4cG9ydCB7IFNjYXR0ZXJwbG90TGF5ZXIgYXMgZGVmYXVsdCB9O1xuU2NhdHRlcnBsb3RMYXllci5sYXllck5hbWUgPSAnU2NhdHRlcnBsb3RMYXllcic7XG5TY2F0dGVycGxvdExheWVyLmRlZmF1bHRQcm9wcyA9IGRlZmF1bHRQcm9wcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNjYXR0ZXJwbG90LWxheWVyLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/scatterplot-layer/scatterplot-layer.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js ***!
  \*****************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PolygonTesselator; });\n/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var _polygon__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./polygon */ \"./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js\");\n/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @deck.gl/core */ \"./node_modules/@deck.gl/core/dist/esm/index.js\");\n/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @luma.gl/core */ \"./node_modules/@luma.gl/shadertools/dist/esm/modules/fp64/fp64.js\");\n\n\n\n\n\n\n\nvar Tesselator = _deck_gl_core__WEBPACK_IMPORTED_MODULE_6__[\"experimental\"].Tesselator;\n\nvar fp64LowPart = _luma_gl_core__WEBPACK_IMPORTED_MODULE_7__[\"default\"].fp64LowPart;\n\nvar PolygonTesselator = function (_Tesselator) {\n  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(PolygonTesselator, _Tesselator);\n\n  function PolygonTesselator(_ref) {\n    var data = _ref.data,\n        getGeometry = _ref.getGeometry,\n        fp64 = _ref.fp64,\n        positionFormat = _ref.positionFormat,\n        _ref$IndexType = _ref.IndexType,\n        IndexType = _ref$IndexType === void 0 ? Uint32Array : _ref$IndexType;\n\n    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, PolygonTesselator);\n\n    return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(PolygonTesselator).call(this, {\n      data: data,\n      getGeometry: getGeometry,\n      fp64: fp64,\n      positionFormat: positionFormat,\n      attributes: {\n        positions: {\n          size: 3\n        },\n        positions64xyLow: {\n          size: 2,\n          fp64Only: true\n        },\n        vertexValid: {\n          type: Uint8ClampedArray,\n          size: 1\n        },\n        indices: {\n          type: IndexType,\n          size: 1\n        }\n      }\n    }));\n  }\n\n  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(PolygonTesselator, [{\n    key: \"get\",\n    value: function get(attributeName) {\n      if (attributeName === 'indices') {\n        return this.attributes.indices.subarray(0, this.vertexCount);\n      }\n\n      return this.attributes[attributeName];\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(polygon) {\n      return _polygon__WEBPACK_IMPORTED_MODULE_5__[\"getVertexCount\"](polygon, this.positionSize);\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(polygon, context) {\n      polygon = _polygon__WEBPACK_IMPORTED_MODULE_5__[\"normalize\"](polygon, this.positionSize, context.geometrySize);\n\n      this._updateIndices(polygon, context);\n\n      this._updatePositions(polygon, context);\n    }\n  }, {\n    key: \"_updateIndices\",\n    value: function _updateIndices(polygon, _ref2) {\n      var geometryIndex = _ref2.geometryIndex,\n          offset = _ref2.vertexStart,\n          indexStart = _ref2.indexStart;\n      var attributes = this.attributes,\n          indexLayout = this.indexLayout,\n          typedArrayManager = this.typedArrayManager;\n      var target = attributes.indices;\n      var currentLength = target.length;\n      var i = indexStart;\n      var indices = _polygon__WEBPACK_IMPORTED_MODULE_5__[\"getSurfaceIndices\"](polygon, this.positionSize);\n\n      if (currentLength < i + indices.length) {\n        currentLength = (i + indices.length) * 2;\n        target = typedArrayManager.allocate(target, currentLength, {\n          type: target.constructor,\n          size: 1,\n          copy: true\n        });\n      }\n\n      for (var j = 0; j < indices.length; j++) {\n        target[i++] = indices[j] + offset;\n      }\n\n      indexLayout[geometryIndex] = indices.length;\n      attributes.indices = target;\n    }\n  }, {\n    key: \"_updatePositions\",\n    value: function _updatePositions(polygon, _ref3) {\n      var vertexStart = _ref3.vertexStart,\n          geometrySize = _ref3.geometrySize;\n      var _this$attributes = this.attributes,\n          positions = _this$attributes.positions,\n          positions64xyLow = _this$attributes.positions64xyLow,\n          vertexValid = _this$attributes.vertexValid,\n          fp64 = this.fp64,\n          positionSize = this.positionSize;\n      var i = vertexStart;\n      var polygonPositions = polygon.positions,\n          holeIndices = polygon.holeIndices;\n\n      for (var j = 0; j < geometrySize; j++) {\n        var x = polygonPositions[j * positionSize];\n        var y = polygonPositions[j * positionSize + 1];\n        var z = positionSize > 2 ? polygonPositions[j * positionSize + 2] : 0;\n        positions[i * 3] = x;\n        positions[i * 3 + 1] = y;\n        positions[i * 3 + 2] = z;\n\n        if (fp64) {\n          positions64xyLow[i * 2] = fp64LowPart(x);\n          positions64xyLow[i * 2 + 1] = fp64LowPart(y);\n        }\n\n        vertexValid[i] = 1;\n        i++;\n      }\n\n      if (holeIndices) {\n        for (var _j = 0; _j < holeIndices.length; _j++) {\n          vertexValid[vertexStart + holeIndices[_j] / positionSize - 1] = 0;\n        }\n      }\n\n      vertexValid[vertexStart + geometrySize - 1] = 0;\n    }\n  }]);\n\n  return PolygonTesselator;\n}(Tesselator);\n\n\n//# sourceMappingURL=polygon-tesselator.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NvbGlkLXBvbHlnb24tbGF5ZXIvcG9seWdvbi10ZXNzZWxhdG9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS9zb2xpZC1wb2x5Z29uLWxheWVyL3BvbHlnb24tdGVzc2VsYXRvci5qcz9lNDU5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfY2xhc3NDYWxsQ2hlY2sgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrXCI7XG5pbXBvcnQgX2NyZWF0ZUNsYXNzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jcmVhdGVDbGFzc1wiO1xuaW1wb3J0IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI7XG5pbXBvcnQgX2dldFByb3RvdHlwZU9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZlwiO1xuaW1wb3J0IF9pbmhlcml0cyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNcIjtcbmltcG9ydCAqIGFzIFBvbHlnb24gZnJvbSAnLi9wb2x5Z29uJztcbmltcG9ydCB7IGV4cGVyaW1lbnRhbCB9IGZyb20gJ0BkZWNrLmdsL2NvcmUnO1xudmFyIFRlc3NlbGF0b3IgPSBleHBlcmltZW50YWwuVGVzc2VsYXRvcjtcbmltcG9ydCB7IGZwNjQgYXMgZnA2NE1vZHVsZSB9IGZyb20gJ0BsdW1hLmdsL2NvcmUnO1xudmFyIGZwNjRMb3dQYXJ0ID0gZnA2NE1vZHVsZS5mcDY0TG93UGFydDtcblxudmFyIFBvbHlnb25UZXNzZWxhdG9yID0gZnVuY3Rpb24gKF9UZXNzZWxhdG9yKSB7XG4gIF9pbmhlcml0cyhQb2x5Z29uVGVzc2VsYXRvciwgX1Rlc3NlbGF0b3IpO1xuXG4gIGZ1bmN0aW9uIFBvbHlnb25UZXNzZWxhdG9yKF9yZWYpIHtcbiAgICB2YXIgZGF0YSA9IF9yZWYuZGF0YSxcbiAgICAgICAgZ2V0R2VvbWV0cnkgPSBfcmVmLmdldEdlb21ldHJ5LFxuICAgICAgICBmcDY0ID0gX3JlZi5mcDY0LFxuICAgICAgICBwb3NpdGlvbkZvcm1hdCA9IF9yZWYucG9zaXRpb25Gb3JtYXQsXG4gICAgICAgIF9yZWYkSW5kZXhUeXBlID0gX3JlZi5JbmRleFR5cGUsXG4gICAgICAgIEluZGV4VHlwZSA9IF9yZWYkSW5kZXhUeXBlID09PSB2b2lkIDAgPyBVaW50MzJBcnJheSA6IF9yZWYkSW5kZXhUeXBlO1xuXG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBvbHlnb25UZXNzZWxhdG9yKTtcblxuICAgIHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCBfZ2V0UHJvdG90eXBlT2YoUG9seWdvblRlc3NlbGF0b3IpLmNhbGwodGhpcywge1xuICAgICAgZGF0YTogZGF0YSxcbiAgICAgIGdldEdlb21ldHJ5OiBnZXRHZW9tZXRyeSxcbiAgICAgIGZwNjQ6IGZwNjQsXG4gICAgICBwb3NpdGlvbkZvcm1hdDogcG9zaXRpb25Gb3JtYXQsXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIHBvc2l0aW9uczoge1xuICAgICAgICAgIHNpemU6IDNcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb25zNjR4eUxvdzoge1xuICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgZnA2NE9ubHk6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgdmVydGV4VmFsaWQ6IHtcbiAgICAgICAgICB0eXBlOiBVaW50OENsYW1wZWRBcnJheSxcbiAgICAgICAgICBzaXplOiAxXG4gICAgICAgIH0sXG4gICAgICAgIGluZGljZXM6IHtcbiAgICAgICAgICB0eXBlOiBJbmRleFR5cGUsXG4gICAgICAgICAgc2l6ZTogMVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG5cbiAgX2NyZWF0ZUNsYXNzKFBvbHlnb25UZXNzZWxhdG9yLCBbe1xuICAgIGtleTogXCJnZXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0KGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgIGlmIChhdHRyaWJ1dGVOYW1lID09PSAnaW5kaWNlcycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlcy5pbmRpY2VzLnN1YmFycmF5KDAsIHRoaXMudmVydGV4Q291bnQpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2F0dHJpYnV0ZU5hbWVdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRHZW9tZXRyeVNpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0R2VvbWV0cnlTaXplKHBvbHlnb24pIHtcbiAgICAgIHJldHVybiBQb2x5Z29uLmdldFZlcnRleENvdW50KHBvbHlnb24sIHRoaXMucG9zaXRpb25TaXplKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlR2VvbWV0cnlBdHRyaWJ1dGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZUdlb21ldHJ5QXR0cmlidXRlcyhwb2x5Z29uLCBjb250ZXh0KSB7XG4gICAgICBwb2x5Z29uID0gUG9seWdvbi5ub3JtYWxpemUocG9seWdvbiwgdGhpcy5wb3NpdGlvblNpemUsIGNvbnRleHQuZ2VvbWV0cnlTaXplKTtcblxuICAgICAgdGhpcy5fdXBkYXRlSW5kaWNlcyhwb2x5Z29uLCBjb250ZXh0KTtcblxuICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb25zKHBvbHlnb24sIGNvbnRleHQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlSW5kaWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlSW5kaWNlcyhwb2x5Z29uLCBfcmVmMikge1xuICAgICAgdmFyIGdlb21ldHJ5SW5kZXggPSBfcmVmMi5nZW9tZXRyeUluZGV4LFxuICAgICAgICAgIG9mZnNldCA9IF9yZWYyLnZlcnRleFN0YXJ0LFxuICAgICAgICAgIGluZGV4U3RhcnQgPSBfcmVmMi5pbmRleFN0YXJ0O1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB0aGlzLmF0dHJpYnV0ZXMsXG4gICAgICAgICAgaW5kZXhMYXlvdXQgPSB0aGlzLmluZGV4TGF5b3V0LFxuICAgICAgICAgIHR5cGVkQXJyYXlNYW5hZ2VyID0gdGhpcy50eXBlZEFycmF5TWFuYWdlcjtcbiAgICAgIHZhciB0YXJnZXQgPSBhdHRyaWJ1dGVzLmluZGljZXM7XG4gICAgICB2YXIgY3VycmVudExlbmd0aCA9IHRhcmdldC5sZW5ndGg7XG4gICAgICB2YXIgaSA9IGluZGV4U3RhcnQ7XG4gICAgICB2YXIgaW5kaWNlcyA9IFBvbHlnb24uZ2V0U3VyZmFjZUluZGljZXMocG9seWdvbiwgdGhpcy5wb3NpdGlvblNpemUpO1xuXG4gICAgICBpZiAoY3VycmVudExlbmd0aCA8IGkgKyBpbmRpY2VzLmxlbmd0aCkge1xuICAgICAgICBjdXJyZW50TGVuZ3RoID0gKGkgKyBpbmRpY2VzLmxlbmd0aCkgKiAyO1xuICAgICAgICB0YXJnZXQgPSB0eXBlZEFycmF5TWFuYWdlci5hbGxvY2F0ZSh0YXJnZXQsIGN1cnJlbnRMZW5ndGgsIHtcbiAgICAgICAgICB0eXBlOiB0YXJnZXQuY29uc3RydWN0b3IsXG4gICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICBjb3B5OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGluZGljZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgdGFyZ2V0W2krK10gPSBpbmRpY2VzW2pdICsgb2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpbmRleExheW91dFtnZW9tZXRyeUluZGV4XSA9IGluZGljZXMubGVuZ3RoO1xuICAgICAgYXR0cmlidXRlcy5pbmRpY2VzID0gdGFyZ2V0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJfdXBkYXRlUG9zaXRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVQb3NpdGlvbnMocG9seWdvbiwgX3JlZjMpIHtcbiAgICAgIHZhciB2ZXJ0ZXhTdGFydCA9IF9yZWYzLnZlcnRleFN0YXJ0LFxuICAgICAgICAgIGdlb21ldHJ5U2l6ZSA9IF9yZWYzLmdlb21ldHJ5U2l6ZTtcbiAgICAgIHZhciBfdGhpcyRhdHRyaWJ1dGVzID0gdGhpcy5hdHRyaWJ1dGVzLFxuICAgICAgICAgIHBvc2l0aW9ucyA9IF90aGlzJGF0dHJpYnV0ZXMucG9zaXRpb25zLFxuICAgICAgICAgIHBvc2l0aW9uczY0eHlMb3cgPSBfdGhpcyRhdHRyaWJ1dGVzLnBvc2l0aW9uczY0eHlMb3csXG4gICAgICAgICAgdmVydGV4VmFsaWQgPSBfdGhpcyRhdHRyaWJ1dGVzLnZlcnRleFZhbGlkLFxuICAgICAgICAgIGZwNjQgPSB0aGlzLmZwNjQsXG4gICAgICAgICAgcG9zaXRpb25TaXplID0gdGhpcy5wb3NpdGlvblNpemU7XG4gICAgICB2YXIgaSA9IHZlcnRleFN0YXJ0O1xuICAgICAgdmFyIHBvbHlnb25Qb3NpdGlvbnMgPSBwb2x5Z29uLnBvc2l0aW9ucyxcbiAgICAgICAgICBob2xlSW5kaWNlcyA9IHBvbHlnb24uaG9sZUluZGljZXM7XG5cbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2VvbWV0cnlTaXplOyBqKyspIHtcbiAgICAgICAgdmFyIHggPSBwb2x5Z29uUG9zaXRpb25zW2ogKiBwb3NpdGlvblNpemVdO1xuICAgICAgICB2YXIgeSA9IHBvbHlnb25Qb3NpdGlvbnNbaiAqIHBvc2l0aW9uU2l6ZSArIDFdO1xuICAgICAgICB2YXIgeiA9IHBvc2l0aW9uU2l6ZSA+IDIgPyBwb2x5Z29uUG9zaXRpb25zW2ogKiBwb3NpdGlvblNpemUgKyAyXSA6IDA7XG4gICAgICAgIHBvc2l0aW9uc1tpICogM10gPSB4O1xuICAgICAgICBwb3NpdGlvbnNbaSAqIDMgKyAxXSA9IHk7XG4gICAgICAgIHBvc2l0aW9uc1tpICogMyArIDJdID0gejtcblxuICAgICAgICBpZiAoZnA2NCkge1xuICAgICAgICAgIHBvc2l0aW9uczY0eHlMb3dbaSAqIDJdID0gZnA2NExvd1BhcnQoeCk7XG4gICAgICAgICAgcG9zaXRpb25zNjR4eUxvd1tpICogMiArIDFdID0gZnA2NExvd1BhcnQoeSk7XG4gICAgICAgIH1cblxuICAgICAgICB2ZXJ0ZXhWYWxpZFtpXSA9IDE7XG4gICAgICAgIGkrKztcbiAgICAgIH1cblxuICAgICAgaWYgKGhvbGVJbmRpY2VzKSB7XG4gICAgICAgIGZvciAodmFyIF9qID0gMDsgX2ogPCBob2xlSW5kaWNlcy5sZW5ndGg7IF9qKyspIHtcbiAgICAgICAgICB2ZXJ0ZXhWYWxpZFt2ZXJ0ZXhTdGFydCArIGhvbGVJbmRpY2VzW19qXSAvIHBvc2l0aW9uU2l6ZSAtIDFdID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2ZXJ0ZXhWYWxpZFt2ZXJ0ZXhTdGFydCArIGdlb21ldHJ5U2l6ZSAtIDFdID0gMDtcbiAgICB9XG4gIH1dKTtcblxuICByZXR1cm4gUG9seWdvblRlc3NlbGF0b3I7XG59KFRlc3NlbGF0b3IpO1xuXG5leHBvcnQgeyBQb2x5Z29uVGVzc2VsYXRvciBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2x5Z29uLXRlc3NlbGF0b3IuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js ***!
  \******************************************************************************/
/*! exports provided: getVertexCount, normalize, getSurfaceIndices */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getVertexCount\", function() { return getVertexCount; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"normalize\", function() { return normalize; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSurfaceIndices\", function() { return getSurfaceIndices; });\n/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! earcut */ \"./node_modules/earcut/src/earcut.js\");\n/* harmony import */ var earcut__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(earcut__WEBPACK_IMPORTED_MODULE_0__);\n\n\nfunction validate(polygon) {\n  polygon = polygon && polygon.positions || polygon;\n\n  if (!Array.isArray(polygon) && !ArrayBuffer.isView(polygon)) {\n    throw new Error('invalid polygon');\n  }\n}\n\nfunction isSimple(polygon) {\n  return polygon.length >= 1 && polygon[0].length >= 2 && Number.isFinite(polygon[0][0]);\n}\n\nfunction isNestedRingClosed(simplePolygon) {\n  var p0 = simplePolygon[0];\n  var p1 = simplePolygon[simplePolygon.length - 1];\n  return p0[0] === p1[0] && p0[1] === p1[1] && p0[2] === p1[2];\n}\n\nfunction isFlatRingClosed(positions, size, startIndex, endIndex) {\n  for (var i = 0; i < size; i++) {\n    if (positions[startIndex + i] !== positions[endIndex - size + i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction copyNestedRing(target, targetStartIndex, simplePolygon, size) {\n  var targetIndex = targetStartIndex;\n  var len = simplePolygon.length;\n\n  for (var i = 0; i < len; i++) {\n    for (var j = 0; j < size; j++) {\n      target[targetIndex++] = simplePolygon[i][j] || 0;\n    }\n  }\n\n  if (!isNestedRingClosed(simplePolygon)) {\n    for (var _j = 0; _j < size; _j++) {\n      target[targetIndex++] = simplePolygon[0][_j] || 0;\n    }\n  }\n\n  return targetIndex;\n}\n\nfunction copyFlatRing(target, targetStartIndex, positions, size) {\n  var srcStartIndex = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  var srcEndIndex = arguments.length > 5 ? arguments[5] : undefined;\n  srcEndIndex = srcEndIndex || positions.length;\n  var srcLength = srcEndIndex - srcStartIndex;\n\n  if (srcLength <= 0) {\n    return targetStartIndex;\n  }\n\n  var targetIndex = targetStartIndex;\n\n  for (var i = 0; i < srcLength; i++) {\n    target[targetIndex++] = positions[srcStartIndex + i];\n  }\n\n  if (!isFlatRingClosed(positions, size, srcStartIndex, srcEndIndex)) {\n    for (var _i = 0; _i < size; _i++) {\n      target[targetIndex++] = positions[srcStartIndex + _i];\n    }\n  }\n\n  return targetIndex;\n}\n\nfunction getNestedVertexCount(simplePolygon) {\n  return (isNestedRingClosed(simplePolygon) ? 0 : 1) + simplePolygon.length;\n}\n\nfunction getFlatVertexCount(positions, size) {\n  var startIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var endIndex = arguments.length > 3 ? arguments[3] : undefined;\n  endIndex = endIndex || positions.length;\n\n  if (startIndex >= endIndex) {\n    return 0;\n  }\n\n  return (isFlatRingClosed(positions, size, startIndex, endIndex) ? 0 : 1) + (endIndex - startIndex) / size;\n}\n\nfunction getVertexCount(polygon, positionSize) {\n  validate(polygon);\n\n  if (polygon.positions) {\n    var _polygon = polygon,\n        positions = _polygon.positions,\n        holeIndices = _polygon.holeIndices;\n\n    if (holeIndices) {\n      var vertexCount = 0;\n\n      for (var i = 0; i <= holeIndices.length; i++) {\n        vertexCount += getFlatVertexCount(polygon.positions, positionSize, holeIndices[i - 1], holeIndices[i]);\n      }\n\n      return vertexCount;\n    }\n\n    polygon = positions;\n  }\n\n  if (Number.isFinite(polygon[0])) {\n    return getFlatVertexCount(polygon, positionSize);\n  }\n\n  if (!isSimple(polygon)) {\n    var _vertexCount = 0;\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = polygon[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var simplePolygon = _step.value;\n        _vertexCount += getNestedVertexCount(simplePolygon);\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return != null) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return _vertexCount;\n  }\n\n  return getNestedVertexCount(polygon);\n}\nfunction normalize(polygon, positionSize, vertexCount) {\n  validate(polygon);\n  vertexCount = vertexCount || getVertexCount(polygon, positionSize);\n  var positions = new Float64Array(vertexCount * positionSize);\n  var holeIndices = [];\n\n  if (polygon.positions) {\n    var _polygon2 = polygon,\n        srcPositions = _polygon2.positions,\n        srcHoleIndices = _polygon2.holeIndices;\n\n    if (srcHoleIndices) {\n      var targetIndex = 0;\n\n      for (var i = 0; i <= srcHoleIndices.length; i++) {\n        targetIndex = copyFlatRing(positions, targetIndex, srcPositions, positionSize, srcHoleIndices[i - 1], srcHoleIndices[i]);\n        holeIndices.push(targetIndex);\n      }\n\n      holeIndices.pop();\n      return {\n        positions: positions,\n        holeIndices: holeIndices\n      };\n    }\n\n    polygon = srcPositions;\n  }\n\n  if (Number.isFinite(polygon[0])) {\n    copyFlatRing(positions, 0, polygon, positionSize);\n    return {\n      positions: positions,\n      holeIndices: null\n    };\n  }\n\n  if (!isSimple(polygon)) {\n    var _targetIndex = 0;\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = polygon[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var simplePolygon = _step2.value;\n        _targetIndex = copyNestedRing(positions, _targetIndex, simplePolygon, positionSize);\n        holeIndices.push(_targetIndex);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n\n    holeIndices.pop();\n    return {\n      positions: positions,\n      holeIndices: holeIndices\n    };\n  }\n\n  copyNestedRing(positions, 0, polygon, positionSize);\n  return {\n    positions: positions,\n    holeIndices: null\n  };\n}\nfunction getSurfaceIndices(normalizedPolygon, positionSize) {\n  var holeIndices = null;\n\n  if (normalizedPolygon.holeIndices) {\n    holeIndices = normalizedPolygon.holeIndices.map(function (positionIndex) {\n      return positionIndex / positionSize;\n    });\n  }\n\n  return earcut__WEBPACK_IMPORTED_MODULE_0___default()(normalizedPolygon.positions, holeIndices, positionSize);\n}\n//# sourceMappingURL=polygon.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NvbGlkLXBvbHlnb24tbGF5ZXIvcG9seWdvbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vc29saWQtcG9seWdvbi1sYXllci9wb2x5Z29uLmpzP2RjM2EiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGVhcmN1dCBmcm9tICdlYXJjdXQnO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZShwb2x5Z29uKSB7XG4gIHBvbHlnb24gPSBwb2x5Z29uICYmIHBvbHlnb24ucG9zaXRpb25zIHx8IHBvbHlnb247XG5cbiAgaWYgKCFBcnJheS5pc0FycmF5KHBvbHlnb24pICYmICFBcnJheUJ1ZmZlci5pc1ZpZXcocG9seWdvbikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9seWdvbicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2ltcGxlKHBvbHlnb24pIHtcbiAgcmV0dXJuIHBvbHlnb24ubGVuZ3RoID49IDEgJiYgcG9seWdvblswXS5sZW5ndGggPj0gMiAmJiBOdW1iZXIuaXNGaW5pdGUocG9seWdvblswXVswXSk7XG59XG5cbmZ1bmN0aW9uIGlzTmVzdGVkUmluZ0Nsb3NlZChzaW1wbGVQb2x5Z29uKSB7XG4gIHZhciBwMCA9IHNpbXBsZVBvbHlnb25bMF07XG4gIHZhciBwMSA9IHNpbXBsZVBvbHlnb25bc2ltcGxlUG9seWdvbi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIHAwWzBdID09PSBwMVswXSAmJiBwMFsxXSA9PT0gcDFbMV0gJiYgcDBbMl0gPT09IHAxWzJdO1xufVxuXG5mdW5jdGlvbiBpc0ZsYXRSaW5nQ2xvc2VkKHBvc2l0aW9ucywgc2l6ZSwgc3RhcnRJbmRleCwgZW5kSW5kZXgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICBpZiAocG9zaXRpb25zW3N0YXJ0SW5kZXggKyBpXSAhPT0gcG9zaXRpb25zW2VuZEluZGV4IC0gc2l6ZSArIGldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvcHlOZXN0ZWRSaW5nKHRhcmdldCwgdGFyZ2V0U3RhcnRJbmRleCwgc2ltcGxlUG9seWdvbiwgc2l6ZSkge1xuICB2YXIgdGFyZ2V0SW5kZXggPSB0YXJnZXRTdGFydEluZGV4O1xuICB2YXIgbGVuID0gc2ltcGxlUG9seWdvbi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgc2l6ZTsgaisrKSB7XG4gICAgICB0YXJnZXRbdGFyZ2V0SW5kZXgrK10gPSBzaW1wbGVQb2x5Z29uW2ldW2pdIHx8IDA7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFpc05lc3RlZFJpbmdDbG9zZWQoc2ltcGxlUG9seWdvbikpIHtcbiAgICBmb3IgKHZhciBfaiA9IDA7IF9qIDwgc2l6ZTsgX2orKykge1xuICAgICAgdGFyZ2V0W3RhcmdldEluZGV4KytdID0gc2ltcGxlUG9seWdvblswXVtfal0gfHwgMDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0SW5kZXg7XG59XG5cbmZ1bmN0aW9uIGNvcHlGbGF0UmluZyh0YXJnZXQsIHRhcmdldFN0YXJ0SW5kZXgsIHBvc2l0aW9ucywgc2l6ZSkge1xuICB2YXIgc3JjU3RhcnRJbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ICYmIGFyZ3VtZW50c1s0XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzRdIDogMDtcbiAgdmFyIHNyY0VuZEluZGV4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgPyBhcmd1bWVudHNbNV0gOiB1bmRlZmluZWQ7XG4gIHNyY0VuZEluZGV4ID0gc3JjRW5kSW5kZXggfHwgcG9zaXRpb25zLmxlbmd0aDtcbiAgdmFyIHNyY0xlbmd0aCA9IHNyY0VuZEluZGV4IC0gc3JjU3RhcnRJbmRleDtcblxuICBpZiAoc3JjTGVuZ3RoIDw9IDApIHtcbiAgICByZXR1cm4gdGFyZ2V0U3RhcnRJbmRleDtcbiAgfVxuXG4gIHZhciB0YXJnZXRJbmRleCA9IHRhcmdldFN0YXJ0SW5kZXg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzcmNMZW5ndGg7IGkrKykge1xuICAgIHRhcmdldFt0YXJnZXRJbmRleCsrXSA9IHBvc2l0aW9uc1tzcmNTdGFydEluZGV4ICsgaV07XG4gIH1cblxuICBpZiAoIWlzRmxhdFJpbmdDbG9zZWQocG9zaXRpb25zLCBzaXplLCBzcmNTdGFydEluZGV4LCBzcmNFbmRJbmRleCkpIHtcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgc2l6ZTsgX2krKykge1xuICAgICAgdGFyZ2V0W3RhcmdldEluZGV4KytdID0gcG9zaXRpb25zW3NyY1N0YXJ0SW5kZXggKyBfaV07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldEluZGV4O1xufVxuXG5mdW5jdGlvbiBnZXROZXN0ZWRWZXJ0ZXhDb3VudChzaW1wbGVQb2x5Z29uKSB7XG4gIHJldHVybiAoaXNOZXN0ZWRSaW5nQ2xvc2VkKHNpbXBsZVBvbHlnb24pID8gMCA6IDEpICsgc2ltcGxlUG9seWdvbi5sZW5ndGg7XG59XG5cbmZ1bmN0aW9uIGdldEZsYXRWZXJ0ZXhDb3VudChwb3NpdGlvbnMsIHNpemUpIHtcbiAgdmFyIHN0YXJ0SW5kZXggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gIHZhciBlbmRJbmRleCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICBlbmRJbmRleCA9IGVuZEluZGV4IHx8IHBvc2l0aW9ucy5sZW5ndGg7XG5cbiAgaWYgKHN0YXJ0SW5kZXggPj0gZW5kSW5kZXgpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiAoaXNGbGF0UmluZ0Nsb3NlZChwb3NpdGlvbnMsIHNpemUsIHN0YXJ0SW5kZXgsIGVuZEluZGV4KSA/IDAgOiAxKSArIChlbmRJbmRleCAtIHN0YXJ0SW5kZXgpIC8gc2l6ZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFZlcnRleENvdW50KHBvbHlnb24sIHBvc2l0aW9uU2l6ZSkge1xuICB2YWxpZGF0ZShwb2x5Z29uKTtcblxuICBpZiAocG9seWdvbi5wb3NpdGlvbnMpIHtcbiAgICB2YXIgX3BvbHlnb24gPSBwb2x5Z29uLFxuICAgICAgICBwb3NpdGlvbnMgPSBfcG9seWdvbi5wb3NpdGlvbnMsXG4gICAgICAgIGhvbGVJbmRpY2VzID0gX3BvbHlnb24uaG9sZUluZGljZXM7XG5cbiAgICBpZiAoaG9sZUluZGljZXMpIHtcbiAgICAgIHZhciB2ZXJ0ZXhDb3VudCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZlcnRleENvdW50ICs9IGdldEZsYXRWZXJ0ZXhDb3VudChwb2x5Z29uLnBvc2l0aW9ucywgcG9zaXRpb25TaXplLCBob2xlSW5kaWNlc1tpIC0gMV0sIGhvbGVJbmRpY2VzW2ldKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHZlcnRleENvdW50O1xuICAgIH1cblxuICAgIHBvbHlnb24gPSBwb3NpdGlvbnM7XG4gIH1cblxuICBpZiAoTnVtYmVyLmlzRmluaXRlKHBvbHlnb25bMF0pKSB7XG4gICAgcmV0dXJuIGdldEZsYXRWZXJ0ZXhDb3VudChwb2x5Z29uLCBwb3NpdGlvblNpemUpO1xuICB9XG5cbiAgaWYgKCFpc1NpbXBsZShwb2x5Z29uKSkge1xuICAgIHZhciBfdmVydGV4Q291bnQgPSAwO1xuICAgIHZhciBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZTtcbiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgICB0cnkge1xuICAgICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gcG9seWdvbltTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwOyAhKF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSAoX3N0ZXAgPSBfaXRlcmF0b3IubmV4dCgpKS5kb25lKTsgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWUpIHtcbiAgICAgICAgdmFyIHNpbXBsZVBvbHlnb24gPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgX3ZlcnRleENvdW50ICs9IGdldE5lc3RlZFZlcnRleENvdW50KHNpbXBsZVBvbHlnb24pO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3IucmV0dXJuICE9IG51bGwpIHtcbiAgICAgICAgICBfaXRlcmF0b3IucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF92ZXJ0ZXhDb3VudDtcbiAgfVxuXG4gIHJldHVybiBnZXROZXN0ZWRWZXJ0ZXhDb3VudChwb2x5Z29uKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemUocG9seWdvbiwgcG9zaXRpb25TaXplLCB2ZXJ0ZXhDb3VudCkge1xuICB2YWxpZGF0ZShwb2x5Z29uKTtcbiAgdmVydGV4Q291bnQgPSB2ZXJ0ZXhDb3VudCB8fCBnZXRWZXJ0ZXhDb3VudChwb2x5Z29uLCBwb3NpdGlvblNpemUpO1xuICB2YXIgcG9zaXRpb25zID0gbmV3IEZsb2F0NjRBcnJheSh2ZXJ0ZXhDb3VudCAqIHBvc2l0aW9uU2l6ZSk7XG4gIHZhciBob2xlSW5kaWNlcyA9IFtdO1xuXG4gIGlmIChwb2x5Z29uLnBvc2l0aW9ucykge1xuICAgIHZhciBfcG9seWdvbjIgPSBwb2x5Z29uLFxuICAgICAgICBzcmNQb3NpdGlvbnMgPSBfcG9seWdvbjIucG9zaXRpb25zLFxuICAgICAgICBzcmNIb2xlSW5kaWNlcyA9IF9wb2x5Z29uMi5ob2xlSW5kaWNlcztcblxuICAgIGlmIChzcmNIb2xlSW5kaWNlcykge1xuICAgICAgdmFyIHRhcmdldEluZGV4ID0gMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gc3JjSG9sZUluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGFyZ2V0SW5kZXggPSBjb3B5RmxhdFJpbmcocG9zaXRpb25zLCB0YXJnZXRJbmRleCwgc3JjUG9zaXRpb25zLCBwb3NpdGlvblNpemUsIHNyY0hvbGVJbmRpY2VzW2kgLSAxXSwgc3JjSG9sZUluZGljZXNbaV0pO1xuICAgICAgICBob2xlSW5kaWNlcy5wdXNoKHRhcmdldEluZGV4KTtcbiAgICAgIH1cblxuICAgICAgaG9sZUluZGljZXMucG9wKCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbnM6IHBvc2l0aW9ucyxcbiAgICAgICAgaG9sZUluZGljZXM6IGhvbGVJbmRpY2VzXG4gICAgICB9O1xuICAgIH1cblxuICAgIHBvbHlnb24gPSBzcmNQb3NpdGlvbnM7XG4gIH1cblxuICBpZiAoTnVtYmVyLmlzRmluaXRlKHBvbHlnb25bMF0pKSB7XG4gICAgY29weUZsYXRSaW5nKHBvc2l0aW9ucywgMCwgcG9seWdvbiwgcG9zaXRpb25TaXplKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb25zOiBwb3NpdGlvbnMsXG4gICAgICBob2xlSW5kaWNlczogbnVsbFxuICAgIH07XG4gIH1cblxuICBpZiAoIWlzU2ltcGxlKHBvbHlnb24pKSB7XG4gICAgdmFyIF90YXJnZXRJbmRleCA9IDA7XG4gICAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZTtcbiAgICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IyID0gZmFsc2U7XG4gICAgdmFyIF9pdGVyYXRvckVycm9yMiA9IHVuZGVmaW5lZDtcblxuICAgIHRyeSB7XG4gICAgICBmb3IgKHZhciBfaXRlcmF0b3IyID0gcG9seWdvbltTeW1ib2wuaXRlcmF0b3JdKCksIF9zdGVwMjsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uMiA9IChfc3RlcDIgPSBfaXRlcmF0b3IyLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24yID0gdHJ1ZSkge1xuICAgICAgICB2YXIgc2ltcGxlUG9seWdvbiA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgX3RhcmdldEluZGV4ID0gY29weU5lc3RlZFJpbmcocG9zaXRpb25zLCBfdGFyZ2V0SW5kZXgsIHNpbXBsZVBvbHlnb24sIHBvc2l0aW9uU2l6ZSk7XG4gICAgICAgIGhvbGVJbmRpY2VzLnB1c2goX3RhcmdldEluZGV4KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kaWRJdGVyYXRvckVycm9yMiA9IHRydWU7XG4gICAgICBfaXRlcmF0b3JFcnJvcjIgPSBlcnI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbjIgJiYgX2l0ZXJhdG9yMi5yZXR1cm4gIT0gbnVsbCkge1xuICAgICAgICAgIF9pdGVyYXRvcjIucmV0dXJuKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcjIpIHtcbiAgICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBob2xlSW5kaWNlcy5wb3AoKTtcbiAgICByZXR1cm4ge1xuICAgICAgcG9zaXRpb25zOiBwb3NpdGlvbnMsXG4gICAgICBob2xlSW5kaWNlczogaG9sZUluZGljZXNcbiAgICB9O1xuICB9XG5cbiAgY29weU5lc3RlZFJpbmcocG9zaXRpb25zLCAwLCBwb2x5Z29uLCBwb3NpdGlvblNpemUpO1xuICByZXR1cm4ge1xuICAgIHBvc2l0aW9uczogcG9zaXRpb25zLFxuICAgIGhvbGVJbmRpY2VzOiBudWxsXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U3VyZmFjZUluZGljZXMobm9ybWFsaXplZFBvbHlnb24sIHBvc2l0aW9uU2l6ZSkge1xuICB2YXIgaG9sZUluZGljZXMgPSBudWxsO1xuXG4gIGlmIChub3JtYWxpemVkUG9seWdvbi5ob2xlSW5kaWNlcykge1xuICAgIGhvbGVJbmRpY2VzID0gbm9ybWFsaXplZFBvbHlnb24uaG9sZUluZGljZXMubWFwKGZ1bmN0aW9uIChwb3NpdGlvbkluZGV4KSB7XG4gICAgICByZXR1cm4gcG9zaXRpb25JbmRleCAvIHBvc2l0aW9uU2l6ZTtcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlYXJjdXQobm9ybWFsaXplZFBvbHlnb24ucG9zaXRpb25zLCBob2xlSW5kaWNlcywgcG9zaXRpb25TaXplKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvbHlnb24uanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js ***!
  \********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"#define SHADER_NAME solid-polygon-layer-fragment-shader\\n\\nprecision highp float;\\n\\nvarying vec4 vColor;\\nvarying float isValid;\\n\\nvoid main(void) {\\n  if (isValid < 0.5) {\\n    discard;\\n  }\\n\\n  gl_FragColor = vColor;\\n  gl_FragColor = picking_filterHighlightColor(gl_FragColor);\\n  gl_FragColor = picking_filterPickingColor(gl_FragColor);\\n}\\n\");\n//# sourceMappingURL=solid-polygon-layer-fragment.glsl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NvbGlkLXBvbHlnb24tbGF5ZXIvc29saWQtcG9seWdvbi1sYXllci1mcmFnbWVudC5nbHNsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS9zb2xpZC1wb2x5Z29uLWxheWVyL3NvbGlkLXBvbHlnb24tbGF5ZXItZnJhZ21lbnQuZ2xzbC5qcz9iZGM4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBTSEFERVJfTkFNRSBzb2xpZC1wb2x5Z29uLWxheWVyLWZyYWdtZW50LXNoYWRlclxcblxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzQgdkNvbG9yO1xcbnZhcnlpbmcgZmxvYXQgaXNWYWxpZDtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgaWYgKGlzVmFsaWQgPCAwLjUpIHtcXG4gICAgZGlzY2FyZDtcXG4gIH1cXG5cXG4gIGdsX0ZyYWdDb2xvciA9IHZDb2xvcjtcXG4gIGdsX0ZyYWdDb2xvciA9IHBpY2tpbmdfZmlsdGVySGlnaGxpZ2h0Q29sb3IoZ2xfRnJhZ0NvbG9yKTtcXG4gIGdsX0ZyYWdDb2xvciA9IHBpY2tpbmdfZmlsdGVyUGlja2luZ0NvbG9yKGdsX0ZyYWdDb2xvcik7XFxufVxcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29saWQtcG9seWdvbi1sYXllci1mcmFnbWVudC5nbHNsLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js ***!
  \***********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"\\nattribute vec2 vertexPositions;\\nattribute float vertexValid;\\n\\nuniform bool extruded;\\nuniform bool isWireframe;\\nuniform float elevationScale;\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\nvarying float isValid;\\n\\nstruct PolygonProps {\\n  vec4 fillColors;\\n  vec4 lineColors;\\n  vec3 positions;\\n  vec3 nextPositions;\\n  vec3 pickingColors;\\n  vec2 positions64xyLow;\\n  vec2 nextPositions64xyLow;\\n  float elevations;\\n};\\n\\nvec3 project_offset_normal(vec3 vector) {\\n  if (project_uCoordinateSystem == COORDINATE_SYSTEM_LNG_LAT ||\\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSETS ||\\n    project_uCoordinateSystem == COORDINATE_SYSTEM_LNGLAT_AUTO_OFFSET) {\\n    return normalize(vector * project_uCommonUnitsPerWorldUnit);\\n  }\\n  return project_normal(vector);\\n}\\n\\nvoid calculatePosition(PolygonProps props) {\\n  vec3 pos;\\n  vec2 pos64xyLow;\\n  vec3 normal;\\n  vec4 colors = isWireframe ? props.lineColors : props.fillColors;\\n\\n#ifdef IS_SIDE_VERTEX\\n  pos = mix(props.positions, props.nextPositions, vertexPositions.x);\\n  pos64xyLow = mix(props.positions64xyLow, props.nextPositions64xyLow, vertexPositions.x);\\n  isValid = vertexValid;\\n#else\\n  pos = props.positions;\\n  pos64xyLow = props.positions64xyLow;\\n  isValid = 1.0;\\n#endif\\n\\n  if (extruded) {\\n    pos.z += props.elevations * vertexPositions.y * elevationScale;\\n  }\\n\\n  vec4 position_commonspace;\\n  gl_Position = project_position_to_clipspace(pos, pos64xyLow, vec3(0.), position_commonspace);\\n\\n  if (extruded) {\\n#ifdef IS_SIDE_VERTEX\\n    normal = vec3(props.positions.y - props.nextPositions.y, props.nextPositions.x - props.positions.x, 0.0);\\n    normal = project_offset_normal(normal);\\n#else\\n    normal = vec3(0.0, 0.0, 1.0);\\n#endif\\n\\n    vec3 lightColor = lighting_getLightColor(colors.rgb, project_uCameraPosition, position_commonspace.xyz, normal);\\n    vColor = vec4(lightColor, colors.a * opacity) / 255.0;\\n  } else {\\n    vColor = vec4(colors.rgb, colors.a * opacity) / 255.0;\\n  }\\n  picking_setPickingColor(props.pickingColors);\\n}\\n\");\n//# sourceMappingURL=solid-polygon-layer-vertex-main.glsl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NvbGlkLXBvbHlnb24tbGF5ZXIvc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtbWFpbi5nbHNsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS9zb2xpZC1wb2x5Z29uLWxheWVyL3NvbGlkLXBvbHlnb24tbGF5ZXItdmVydGV4LW1haW4uZ2xzbC5qcz9mYjlhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiXFxuYXR0cmlidXRlIHZlYzIgdmVydGV4UG9zaXRpb25zO1xcbmF0dHJpYnV0ZSBmbG9hdCB2ZXJ0ZXhWYWxpZDtcXG5cXG51bmlmb3JtIGJvb2wgZXh0cnVkZWQ7XFxudW5pZm9ybSBib29sIGlzV2lyZWZyYW1lO1xcbnVuaWZvcm0gZmxvYXQgZWxldmF0aW9uU2NhbGU7XFxudW5pZm9ybSBmbG9hdCBvcGFjaXR5O1xcblxcbnZhcnlpbmcgdmVjNCB2Q29sb3I7XFxudmFyeWluZyBmbG9hdCBpc1ZhbGlkO1xcblxcbnN0cnVjdCBQb2x5Z29uUHJvcHMge1xcbiAgdmVjNCBmaWxsQ29sb3JzO1xcbiAgdmVjNCBsaW5lQ29sb3JzO1xcbiAgdmVjMyBwb3NpdGlvbnM7XFxuICB2ZWMzIG5leHRQb3NpdGlvbnM7XFxuICB2ZWMzIHBpY2tpbmdDb2xvcnM7XFxuICB2ZWMyIHBvc2l0aW9uczY0eHlMb3c7XFxuICB2ZWMyIG5leHRQb3NpdGlvbnM2NHh5TG93O1xcbiAgZmxvYXQgZWxldmF0aW9ucztcXG59O1xcblxcbnZlYzMgcHJvamVjdF9vZmZzZXRfbm9ybWFsKHZlYzMgdmVjdG9yKSB7XFxuICBpZiAocHJvamVjdF91Q29vcmRpbmF0ZVN5c3RlbSA9PSBDT09SRElOQVRFX1NZU1RFTV9MTkdfTEFUIHx8XFxuICAgIHByb2plY3RfdUNvb3JkaW5hdGVTeXN0ZW0gPT0gQ09PUkRJTkFURV9TWVNURU1fTE5HTEFUX09GRlNFVFMgfHxcXG4gICAgcHJvamVjdF91Q29vcmRpbmF0ZVN5c3RlbSA9PSBDT09SRElOQVRFX1NZU1RFTV9MTkdMQVRfQVVUT19PRkZTRVQpIHtcXG4gICAgcmV0dXJuIG5vcm1hbGl6ZSh2ZWN0b3IgKiBwcm9qZWN0X3VDb21tb25Vbml0c1BlcldvcmxkVW5pdCk7XFxuICB9XFxuICByZXR1cm4gcHJvamVjdF9ub3JtYWwodmVjdG9yKTtcXG59XFxuXFxudm9pZCBjYWxjdWxhdGVQb3NpdGlvbihQb2x5Z29uUHJvcHMgcHJvcHMpIHtcXG4gIHZlYzMgcG9zO1xcbiAgdmVjMiBwb3M2NHh5TG93O1xcbiAgdmVjMyBub3JtYWw7XFxuICB2ZWM0IGNvbG9ycyA9IGlzV2lyZWZyYW1lID8gcHJvcHMubGluZUNvbG9ycyA6IHByb3BzLmZpbGxDb2xvcnM7XFxuXFxuI2lmZGVmIElTX1NJREVfVkVSVEVYXFxuICBwb3MgPSBtaXgocHJvcHMucG9zaXRpb25zLCBwcm9wcy5uZXh0UG9zaXRpb25zLCB2ZXJ0ZXhQb3NpdGlvbnMueCk7XFxuICBwb3M2NHh5TG93ID0gbWl4KHByb3BzLnBvc2l0aW9uczY0eHlMb3csIHByb3BzLm5leHRQb3NpdGlvbnM2NHh5TG93LCB2ZXJ0ZXhQb3NpdGlvbnMueCk7XFxuICBpc1ZhbGlkID0gdmVydGV4VmFsaWQ7XFxuI2Vsc2VcXG4gIHBvcyA9IHByb3BzLnBvc2l0aW9ucztcXG4gIHBvczY0eHlMb3cgPSBwcm9wcy5wb3NpdGlvbnM2NHh5TG93O1xcbiAgaXNWYWxpZCA9IDEuMDtcXG4jZW5kaWZcXG5cXG4gIGlmIChleHRydWRlZCkge1xcbiAgICBwb3MueiArPSBwcm9wcy5lbGV2YXRpb25zICogdmVydGV4UG9zaXRpb25zLnkgKiBlbGV2YXRpb25TY2FsZTtcXG4gIH1cXG5cXG4gIHZlYzQgcG9zaXRpb25fY29tbW9uc3BhY2U7XFxuICBnbF9Qb3NpdGlvbiA9IHByb2plY3RfcG9zaXRpb25fdG9fY2xpcHNwYWNlKHBvcywgcG9zNjR4eUxvdywgdmVjMygwLiksIHBvc2l0aW9uX2NvbW1vbnNwYWNlKTtcXG5cXG4gIGlmIChleHRydWRlZCkge1xcbiNpZmRlZiBJU19TSURFX1ZFUlRFWFxcbiAgICBub3JtYWwgPSB2ZWMzKHByb3BzLnBvc2l0aW9ucy55IC0gcHJvcHMubmV4dFBvc2l0aW9ucy55LCBwcm9wcy5uZXh0UG9zaXRpb25zLnggLSBwcm9wcy5wb3NpdGlvbnMueCwgMC4wKTtcXG4gICAgbm9ybWFsID0gcHJvamVjdF9vZmZzZXRfbm9ybWFsKG5vcm1hbCk7XFxuI2Vsc2VcXG4gICAgbm9ybWFsID0gdmVjMygwLjAsIDAuMCwgMS4wKTtcXG4jZW5kaWZcXG5cXG4gICAgdmVjMyBsaWdodENvbG9yID0gbGlnaHRpbmdfZ2V0TGlnaHRDb2xvcihjb2xvcnMucmdiLCBwcm9qZWN0X3VDYW1lcmFQb3NpdGlvbiwgcG9zaXRpb25fY29tbW9uc3BhY2UueHl6LCBub3JtYWwpO1xcbiAgICB2Q29sb3IgPSB2ZWM0KGxpZ2h0Q29sb3IsIGNvbG9ycy5hICogb3BhY2l0eSkgLyAyNTUuMDtcXG4gIH0gZWxzZSB7XFxuICAgIHZDb2xvciA9IHZlYzQoY29sb3JzLnJnYiwgY29sb3JzLmEgKiBvcGFjaXR5KSAvIDI1NS4wO1xcbiAgfVxcbiAgcGlja2luZ19zZXRQaWNraW5nQ29sb3IocHJvcHMucGlja2luZ0NvbG9ycyk7XFxufVxcblwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtbWFpbi5nbHNsLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js ***!
  \***********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _solid_polygon_layer_vertex_main_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./solid-polygon-layer-vertex-main.glsl */ \"./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"#define SHADER_NAME solid-polygon-layer-vertex-shader-side\\n#define IS_SIDE_VERTEX\\n\\n\\nattribute vec3 instancePositions;\\nattribute vec2 instancePositions64xyLow;\\nattribute vec3 nextPositions;\\nattribute vec2 nextPositions64xyLow;\\nattribute float instanceElevations;\\nattribute vec4 instanceFillColors;\\nattribute vec4 instanceLineColors;\\nattribute vec3 instancePickingColors;\\n\\n\".concat(_solid_polygon_layer_vertex_main_glsl__WEBPACK_IMPORTED_MODULE_0__[\"default\"], \"\\n\\nvoid main(void) {\\n  PolygonProps props;\\n\\n  props.positions = instancePositions;\\n  props.positions64xyLow = instancePositions64xyLow;\\n  props.elevations = instanceElevations;\\n  props.fillColors = instanceFillColors;\\n  props.lineColors = instanceLineColors;\\n  props.pickingColors = instancePickingColors;\\n  props.nextPositions = nextPositions;\\n  props.nextPositions64xyLow = nextPositions64xyLow;\\n\\n  calculatePosition(props);\\n}\\n\"));\n//# sourceMappingURL=solid-polygon-layer-vertex-side.glsl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NvbGlkLXBvbHlnb24tbGF5ZXIvc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtc2lkZS5nbHNsLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BkZWNrLmdsL2xheWVycy9kaXN0L2VzbS9zb2xpZC1wb2x5Z29uLWxheWVyL3NvbGlkLXBvbHlnb24tbGF5ZXItdmVydGV4LXNpZGUuZ2xzbC5qcz9kM2JlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtYWluIGZyb20gJy4vc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtbWFpbi5nbHNsJztcbmV4cG9ydCBkZWZhdWx0IFwiI2RlZmluZSBTSEFERVJfTkFNRSBzb2xpZC1wb2x5Z29uLWxheWVyLXZlcnRleC1zaGFkZXItc2lkZVxcbiNkZWZpbmUgSVNfU0lERV9WRVJURVhcXG5cXG5cXG5hdHRyaWJ1dGUgdmVjMyBpbnN0YW5jZVBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMiBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3c7XFxuYXR0cmlidXRlIHZlYzMgbmV4dFBvc2l0aW9ucztcXG5hdHRyaWJ1dGUgdmVjMiBuZXh0UG9zaXRpb25zNjR4eUxvdztcXG5hdHRyaWJ1dGUgZmxvYXQgaW5zdGFuY2VFbGV2YXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWM0IGluc3RhbmNlRmlsbENvbG9ycztcXG5hdHRyaWJ1dGUgdmVjNCBpbnN0YW5jZUxpbmVDb2xvcnM7XFxuYXR0cmlidXRlIHZlYzMgaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xcblxcblwiLmNvbmNhdChtYWluLCBcIlxcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBQb2x5Z29uUHJvcHMgcHJvcHM7XFxuXFxuICBwcm9wcy5wb3NpdGlvbnMgPSBpbnN0YW5jZVBvc2l0aW9ucztcXG4gIHByb3BzLnBvc2l0aW9uczY0eHlMb3cgPSBpbnN0YW5jZVBvc2l0aW9uczY0eHlMb3c7XFxuICBwcm9wcy5lbGV2YXRpb25zID0gaW5zdGFuY2VFbGV2YXRpb25zO1xcbiAgcHJvcHMuZmlsbENvbG9ycyA9IGluc3RhbmNlRmlsbENvbG9ycztcXG4gIHByb3BzLmxpbmVDb2xvcnMgPSBpbnN0YW5jZUxpbmVDb2xvcnM7XFxuICBwcm9wcy5waWNraW5nQ29sb3JzID0gaW5zdGFuY2VQaWNraW5nQ29sb3JzO1xcbiAgcHJvcHMubmV4dFBvc2l0aW9ucyA9IG5leHRQb3NpdGlvbnM7XFxuICBwcm9wcy5uZXh0UG9zaXRpb25zNjR4eUxvdyA9IG5leHRQb3NpdGlvbnM2NHh5TG93O1xcblxcbiAgY2FsY3VsYXRlUG9zaXRpb24ocHJvcHMpO1xcbn1cXG5cIik7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zb2xpZC1wb2x5Z29uLWxheWVyLXZlcnRleC1zaWRlLmdsc2wuanMubWFwIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js ***!
  \**********************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _solid_polygon_layer_vertex_main_glsl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./solid-polygon-layer-vertex-main.glsl */ \"./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-main.glsl.js\");\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"#define SHADER_NAME solid-polygon-layer-vertex-shader\\n\\nattribute vec3 positions;\\nattribute vec2 positions64xyLow;\\nattribute float elevations;\\nattribute vec4 fillColors;\\nattribute vec4 lineColors;\\nattribute vec3 pickingColors;\\n\\n\".concat(_solid_polygon_layer_vertex_main_glsl__WEBPACK_IMPORTED_MODULE_0__[\"default\"], \"\\n\\nvoid main(void) {\\n  PolygonProps props;\\n\\n  props.positions = positions;\\n  props.positions64xyLow = positions64xyLow;\\n  props.elevations = elevations;\\n  props.fillColors = fillColors;\\n  props.lineColors = lineColors;\\n  props.pickingColors = pickingColors;\\n\\n  calculatePosition(props);\\n}\\n\"));\n//# sourceMappingURL=solid-polygon-layer-vertex-top.glsl.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NvbGlkLXBvbHlnb24tbGF5ZXIvc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtdG9wLmdsc2wuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NvbGlkLXBvbHlnb24tbGF5ZXIvc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtdG9wLmdsc2wuanM/MTM1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbWFpbiBmcm9tICcuL3NvbGlkLXBvbHlnb24tbGF5ZXItdmVydGV4LW1haW4uZ2xzbCc7XG5leHBvcnQgZGVmYXVsdCBcIiNkZWZpbmUgU0hBREVSX05BTUUgc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtc2hhZGVyXFxuXFxuYXR0cmlidXRlIHZlYzMgcG9zaXRpb25zO1xcbmF0dHJpYnV0ZSB2ZWMyIHBvc2l0aW9uczY0eHlMb3c7XFxuYXR0cmlidXRlIGZsb2F0IGVsZXZhdGlvbnM7XFxuYXR0cmlidXRlIHZlYzQgZmlsbENvbG9ycztcXG5hdHRyaWJ1dGUgdmVjNCBsaW5lQ29sb3JzO1xcbmF0dHJpYnV0ZSB2ZWMzIHBpY2tpbmdDb2xvcnM7XFxuXFxuXCIuY29uY2F0KG1haW4sIFwiXFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIFBvbHlnb25Qcm9wcyBwcm9wcztcXG5cXG4gIHByb3BzLnBvc2l0aW9ucyA9IHBvc2l0aW9ucztcXG4gIHByb3BzLnBvc2l0aW9uczY0eHlMb3cgPSBwb3NpdGlvbnM2NHh5TG93O1xcbiAgcHJvcHMuZWxldmF0aW9ucyA9IGVsZXZhdGlvbnM7XFxuICBwcm9wcy5maWxsQ29sb3JzID0gZmlsbENvbG9ycztcXG4gIHByb3BzLmxpbmVDb2xvcnMgPSBsaW5lQ29sb3JzO1xcbiAgcHJvcHMucGlja2luZ0NvbG9ycyA9IHBpY2tpbmdDb2xvcnM7XFxuXFxuICBjYWxjdWxhdGVQb3NpdGlvbihwcm9wcyk7XFxufVxcblwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNvbGlkLXBvbHlnb24tbGF5ZXItdmVydGV4LXRvcC5nbHNsLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js\n");

/***/ }),

/***/ "./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js ***!
  \******************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return SolidPolygonLayer; });\n/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_get__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/get */ \"./node_modules/@babel/runtime/helpers/esm/get.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var _deck_gl_core__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @deck.gl/core */ \"./node_modules/@deck.gl/core/dist/esm/lib/layer.js\");\n/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @luma.gl/core */ \"./node_modules/@luma.gl/core/dist/esm/materials/phong-material.js\");\n/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @luma.gl/core */ \"./node_modules/@luma.gl/webgl/dist/esm/features/features.js\");\n/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @luma.gl/core */ \"./node_modules/@luma.gl/webgl/dist/esm/features/webgl-features-table.js\");\n/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @luma.gl/core */ \"./node_modules/@luma.gl/core/dist/esm/lib/model.js\");\n/* harmony import */ var _luma_gl_core__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @luma.gl/core */ \"./node_modules/@luma.gl/core/dist/esm/geometry/geometry.js\");\n/* harmony import */ var _polygon_tesselator__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./polygon-tesselator */ \"./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/polygon-tesselator.js\");\n/* harmony import */ var _solid_polygon_layer_vertex_top_glsl__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./solid-polygon-layer-vertex-top.glsl */ \"./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-top.glsl.js\");\n/* harmony import */ var _solid_polygon_layer_vertex_side_glsl__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./solid-polygon-layer-vertex-side.glsl */ \"./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-vertex-side.glsl.js\");\n/* harmony import */ var _solid_polygon_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./solid-polygon-layer-fragment.glsl */ \"./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer-fragment.glsl.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar defaultMaterial = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_7__[\"default\"]();\nvar defaultProps = {\n  filled: true,\n  extruded: false,\n  wireframe: false,\n  fp64: false,\n  elevationScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  getPolygon: {\n    type: 'accessor',\n    value: function value(f) {\n      return f.polygon;\n    }\n  },\n  getElevation: {\n    type: 'accessor',\n    value: 1000\n  },\n  getFillColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getLineColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  material: defaultMaterial\n};\nvar ATTRIBUTE_TRANSITION = {\n  enter: function enter(value, chunk) {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\nvar SolidPolygonLayer = function (_Layer) {\n  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(SolidPolygonLayer, _Layer);\n\n  function SolidPolygonLayer() {\n    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, SolidPolygonLayer);\n\n    return Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(SolidPolygonLayer).apply(this, arguments));\n  }\n\n  Object(_babel_runtime_helpers_esm_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(SolidPolygonLayer, [{\n    key: \"getShaders\",\n    value: function getShaders(vs) {\n      var projectModule = this.use64bitProjection() ? 'project64' : 'project32';\n      return {\n        vs: vs,\n        fs: _solid_polygon_layer_fragment_glsl__WEBPACK_IMPORTED_MODULE_15__[\"default\"],\n        defines: {},\n        modules: [projectModule, 'gouraud-lighting', 'picking']\n      };\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _this = this;\n\n      var gl = this.context.gl;\n      this.setState({\n        numInstances: 0,\n        polygonTesselator: new _polygon_tesselator__WEBPACK_IMPORTED_MODULE_12__[\"default\"]({\n          IndexType: !gl || Object(_luma_gl_core__WEBPACK_IMPORTED_MODULE_8__[\"hasFeature\"])(gl, _luma_gl_core__WEBPACK_IMPORTED_MODULE_9__[\"FEATURES\"].ELEMENT_INDEX_UINT32) ? Uint32Array : Uint16Array\n        })\n      });\n      var attributeManager = this.getAttributeManager();\n      var noAlloc = true;\n      attributeManager.remove(['instancePickingColors']);\n      attributeManager.add({\n        indices: {\n          size: 1,\n          isIndexed: true,\n          update: this.calculateIndices,\n          noAlloc: noAlloc\n        },\n        positions: {\n          size: 3,\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getPolygon',\n          update: this.calculatePositions,\n          noAlloc: noAlloc,\n          shaderAttributes: {\n            positions: {\n              offset: 0,\n              divisor: 0\n            },\n            instancePositions: {\n              offset: 0,\n              divisor: 1\n            },\n            nextPositions: {\n              offset: 12,\n              divisor: 1\n            }\n          }\n        },\n        positions64xyLow: {\n          size: 2,\n          update: this.calculatePositionsLow,\n          noAlloc: noAlloc,\n          shaderAttributes: {\n            positions64xyLow: {\n              offset: 0,\n              divisor: 0\n            },\n            instancePositions64xyLow: {\n              offset: 0,\n              divisor: 1\n            },\n            nextPositions64xyLow: {\n              offset: 8,\n              divisor: 1\n            }\n          }\n        },\n        vertexValid: {\n          size: 1,\n          divisor: 1,\n          type: 5121,\n          update: this.calculateVertexValid,\n          noAlloc: noAlloc\n        },\n        elevations: {\n          size: 1,\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getElevation',\n          shaderAttributes: {\n            elevations: {\n              divisor: 0\n            },\n            instanceElevations: {\n              divisor: 1\n            }\n          }\n        },\n        fillColors: {\n          alias: 'colors',\n          size: 4,\n          type: 5121,\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getFillColor',\n          defaultValue: DEFAULT_COLOR,\n          shaderAttributes: {\n            fillColors: {\n              divisor: 0\n            },\n            instanceFillColors: {\n              divisor: 1\n            }\n          }\n        },\n        lineColors: {\n          alias: 'colors',\n          size: 4,\n          type: 5121,\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getLineColor',\n          defaultValue: DEFAULT_COLOR,\n          shaderAttributes: {\n            lineColors: {\n              divisor: 0\n            },\n            instanceLineColors: {\n              divisor: 1\n            }\n          }\n        },\n        pickingColors: {\n          size: 3,\n          type: 5121,\n          accessor: function accessor(object, _ref) {\n            var index = _ref.index,\n                value = _ref.target;\n            return _this.encodePickingColor(index, value);\n          },\n          shaderAttributes: {\n            pickingColors: {\n              divisor: 0\n            },\n            instancePickingColors: {\n              divisor: 1\n            }\n          }\n        }\n      });\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref2) {\n      var uniforms = _ref2.uniforms;\n      var _this$props = this.props,\n          extruded = _this$props.extruded,\n          filled = _this$props.filled,\n          wireframe = _this$props.wireframe,\n          elevationScale = _this$props.elevationScale;\n      var _this$state = this.state,\n          topModel = _this$state.topModel,\n          sideModel = _this$state.sideModel,\n          polygonTesselator = _this$state.polygonTesselator;\n      var renderUniforms = Object.assign({}, uniforms, {\n        extruded: Boolean(extruded),\n        elevationScale: elevationScale\n      });\n\n      if (sideModel) {\n        sideModel.setInstanceCount(polygonTesselator.instanceCount - 1);\n        sideModel.setUniforms(renderUniforms);\n\n        if (wireframe) {\n          sideModel.setDrawMode(3);\n          sideModel.setUniforms({\n            isWireframe: true\n          }).draw();\n        }\n\n        if (filled) {\n          sideModel.setDrawMode(6);\n          sideModel.setUniforms({\n            isWireframe: false\n          }).draw();\n        }\n      }\n\n      if (topModel) {\n        topModel.setVertexCount(polygonTesselator.get('indices').length);\n        topModel.setUniforms(renderUniforms).draw();\n      }\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(updateParams) {\n      Object(_babel_runtime_helpers_esm_get__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(SolidPolygonLayer.prototype), \"updateState\", this).call(this, updateParams);\n\n      this.updateGeometry(updateParams);\n      var props = updateParams.props,\n          oldProps = updateParams.oldProps;\n      var attributeManager = this.getAttributeManager();\n      var regenerateModels = props.fp64 !== oldProps.fp64 || props.filled !== oldProps.filled || props.extruded !== oldProps.extruded;\n\n      if (regenerateModels) {\n        if (this.state.models) {\n          this.state.models.forEach(function (model) {\n            return model.delete();\n          });\n        }\n\n        this.setState(this._getModels(this.context.gl));\n        attributeManager.invalidateAll();\n      }\n    }\n  }, {\n    key: \"updateGeometry\",\n    value: function updateGeometry(_ref3) {\n      var props = _ref3.props,\n          oldProps = _ref3.oldProps,\n          changeFlags = _ref3.changeFlags;\n      var geometryConfigChanged = changeFlags.dataChanged || props.fp64 !== oldProps.fp64 || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPolygon);\n\n      if (geometryConfigChanged) {\n        var polygonTesselator = this.state.polygonTesselator;\n        polygonTesselator.updateGeometry({\n          data: props.data,\n          getGeometry: props.getPolygon,\n          positionFormat: props.positionFormat,\n          fp64: this.use64bitPositions()\n        });\n        this.setState({\n          numInstances: polygonTesselator.instanceCount,\n          bufferLayout: polygonTesselator.bufferLayout\n        });\n        this.getAttributeManager().invalidateAll();\n      }\n    }\n  }, {\n    key: \"_getModels\",\n    value: function _getModels(gl) {\n      var _this$props2 = this.props,\n          id = _this$props2.id,\n          filled = _this$props2.filled,\n          extruded = _this$props2.extruded;\n      var topModel;\n      var sideModel;\n\n      if (filled) {\n        var shaders = this.getShaders(_solid_polygon_layer_vertex_top_glsl__WEBPACK_IMPORTED_MODULE_13__[\"default\"]);\n        shaders.defines.NON_INSTANCED_MODEL = 1;\n        topModel = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_10__[\"default\"](gl, Object.assign({}, shaders, {\n          id: \"\".concat(id, \"-top\"),\n          drawMode: 4,\n          attributes: {\n            vertexPositions: new Float32Array([0, 1])\n          },\n          uniforms: {\n            isWireframe: false,\n            isSideVertex: false\n          },\n          vertexCount: 0,\n          isIndexed: true,\n          shaderCache: this.context.shaderCache\n        }));\n      }\n\n      if (extruded) {\n        sideModel = new _luma_gl_core__WEBPACK_IMPORTED_MODULE_10__[\"default\"](gl, Object.assign({}, this.getShaders(_solid_polygon_layer_vertex_side_glsl__WEBPACK_IMPORTED_MODULE_14__[\"default\"]), {\n          id: \"\".concat(id, \"-side\"),\n          geometry: new _luma_gl_core__WEBPACK_IMPORTED_MODULE_11__[\"default\"]({\n            drawMode: 1,\n            vertexCount: 4,\n            attributes: {\n              vertexPositions: {\n                size: 2,\n                value: new Float32Array([1, 1, 0, 1, 0, 0, 1, 0])\n              }\n            }\n          }),\n          instanceCount: 0,\n          isInstanced: 1,\n          shaderCache: this.context.shaderCache\n        }));\n        sideModel.userData.excludeAttributes = {\n          indices: true\n        };\n      }\n\n      return {\n        models: [sideModel, topModel].filter(Boolean),\n        topModel: topModel,\n        sideModel: sideModel\n      };\n    }\n  }, {\n    key: \"calculateIndices\",\n    value: function calculateIndices(attribute) {\n      var polygonTesselator = this.state.polygonTesselator;\n      attribute.bufferLayout = polygonTesselator.indexLayout;\n      attribute.value = polygonTesselator.get('indices');\n    }\n  }, {\n    key: \"calculatePositions\",\n    value: function calculatePositions(attribute) {\n      var polygonTesselator = this.state.polygonTesselator;\n      attribute.bufferLayout = polygonTesselator.bufferLayout;\n      attribute.value = polygonTesselator.get('positions');\n    }\n  }, {\n    key: \"calculatePositionsLow\",\n    value: function calculatePositionsLow(attribute) {\n      var isFP64 = this.use64bitPositions();\n      attribute.constant = !isFP64;\n\n      if (!isFP64) {\n        attribute.value = new Float32Array(2);\n        return;\n      }\n\n      attribute.value = this.state.polygonTesselator.get('positions64xyLow');\n    }\n  }, {\n    key: \"calculateVertexValid\",\n    value: function calculateVertexValid(attribute) {\n      attribute.value = this.state.polygonTesselator.get('vertexValid');\n    }\n  }, {\n    key: \"clearPickingColor\",\n    value: function clearPickingColor(color) {\n      var pickedPolygonIndex = this.decodePickingColor(color);\n      var bufferLayout = this.state.polygonTesselator.bufferLayout;\n      var numVertices = bufferLayout[pickedPolygonIndex];\n      var startInstanceIndex = 0;\n\n      for (var polygonIndex = 0; polygonIndex < pickedPolygonIndex; polygonIndex++) {\n        startInstanceIndex += bufferLayout[polygonIndex];\n      }\n\n      var pickingColors = this.getAttributeManager().attributes.pickingColors;\n      var value = pickingColors.value;\n      var endInstanceIndex = startInstanceIndex + numVertices;\n      value.fill(0, startInstanceIndex * 3, endInstanceIndex * 3);\n      pickingColors.update({\n        value: value\n      });\n    }\n  }]);\n\n  return SolidPolygonLayer;\n}(_deck_gl_core__WEBPACK_IMPORTED_MODULE_6__[\"default\"]);\n\n\nSolidPolygonLayer.layerName = 'SolidPolygonLayer';\nSolidPolygonLayer.defaultProps = defaultProps;\n//# sourceMappingURL=solid-polygon-layer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGRlY2suZ2wvbGF5ZXJzL2Rpc3QvZXNtL3NvbGlkLXBvbHlnb24tbGF5ZXIvc29saWQtcG9seWdvbi1sYXllci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZGVjay5nbC9sYXllcnMvZGlzdC9lc20vc29saWQtcG9seWdvbi1sYXllci9zb2xpZC1wb2x5Z29uLWxheWVyLmpzPzI4NzMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9jbGFzc0NhbGxDaGVjayBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2tcIjtcbmltcG9ydCBfY3JlYXRlQ2xhc3MgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzXCI7XG5pbXBvcnQgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4gZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm5cIjtcbmltcG9ydCBfZ2V0UHJvdG90eXBlT2YgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2dldFByb3RvdHlwZU9mXCI7XG5pbXBvcnQgX2dldCBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0XCI7XG5pbXBvcnQgX2luaGVyaXRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pbmhlcml0c1wiO1xuaW1wb3J0IHsgTGF5ZXIgfSBmcm9tICdAZGVjay5nbC9jb3JlJztcbmltcG9ydCB7IE1vZGVsLCBHZW9tZXRyeSwgaGFzRmVhdHVyZSwgRkVBVFVSRVMsIFBob25nTWF0ZXJpYWwgfSBmcm9tICdAbHVtYS5nbC9jb3JlJztcbmltcG9ydCBQb2x5Z29uVGVzc2VsYXRvciBmcm9tICcuL3BvbHlnb24tdGVzc2VsYXRvcic7XG5pbXBvcnQgdnNUb3AgZnJvbSAnLi9zb2xpZC1wb2x5Z29uLWxheWVyLXZlcnRleC10b3AuZ2xzbCc7XG5pbXBvcnQgdnNTaWRlIGZyb20gJy4vc29saWQtcG9seWdvbi1sYXllci12ZXJ0ZXgtc2lkZS5nbHNsJztcbmltcG9ydCBmcyBmcm9tICcuL3NvbGlkLXBvbHlnb24tbGF5ZXItZnJhZ21lbnQuZ2xzbCc7XG52YXIgREVGQVVMVF9DT0xPUiA9IFswLCAwLCAwLCAyNTVdO1xudmFyIGRlZmF1bHRNYXRlcmlhbCA9IG5ldyBQaG9uZ01hdGVyaWFsKCk7XG52YXIgZGVmYXVsdFByb3BzID0ge1xuICBmaWxsZWQ6IHRydWUsXG4gIGV4dHJ1ZGVkOiBmYWxzZSxcbiAgd2lyZWZyYW1lOiBmYWxzZSxcbiAgZnA2NDogZmFsc2UsXG4gIGVsZXZhdGlvblNjYWxlOiB7XG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgbWluOiAwLFxuICAgIHZhbHVlOiAxXG4gIH0sXG4gIGdldFBvbHlnb246IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShmKSB7XG4gICAgICByZXR1cm4gZi5wb2x5Z29uO1xuICAgIH1cbiAgfSxcbiAgZ2V0RWxldmF0aW9uOiB7XG4gICAgdHlwZTogJ2FjY2Vzc29yJyxcbiAgICB2YWx1ZTogMTAwMFxuICB9LFxuICBnZXRGaWxsQ29sb3I6IHtcbiAgICB0eXBlOiAnYWNjZXNzb3InLFxuICAgIHZhbHVlOiBERUZBVUxUX0NPTE9SXG4gIH0sXG4gIGdldExpbmVDb2xvcjoge1xuICAgIHR5cGU6ICdhY2Nlc3NvcicsXG4gICAgdmFsdWU6IERFRkFVTFRfQ09MT1JcbiAgfSxcbiAgbWF0ZXJpYWw6IGRlZmF1bHRNYXRlcmlhbFxufTtcbnZhciBBVFRSSUJVVEVfVFJBTlNJVElPTiA9IHtcbiAgZW50ZXI6IGZ1bmN0aW9uIGVudGVyKHZhbHVlLCBjaHVuaykge1xuICAgIHJldHVybiBjaHVuay5sZW5ndGggPyBjaHVuay5zdWJhcnJheShjaHVuay5sZW5ndGggLSB2YWx1ZS5sZW5ndGgpIDogdmFsdWU7XG4gIH1cbn07XG5cbnZhciBTb2xpZFBvbHlnb25MYXllciA9IGZ1bmN0aW9uIChfTGF5ZXIpIHtcbiAgX2luaGVyaXRzKFNvbGlkUG9seWdvbkxheWVyLCBfTGF5ZXIpO1xuXG4gIGZ1bmN0aW9uIFNvbGlkUG9seWdvbkxheWVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTb2xpZFBvbHlnb25MYXllcik7XG5cbiAgICByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFNvbGlkUG9seWdvbkxheWVyKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhTb2xpZFBvbHlnb25MYXllciwgW3tcbiAgICBrZXk6IFwiZ2V0U2hhZGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTaGFkZXJzKHZzKSB7XG4gICAgICB2YXIgcHJvamVjdE1vZHVsZSA9IHRoaXMudXNlNjRiaXRQcm9qZWN0aW9uKCkgPyAncHJvamVjdDY0JyA6ICdwcm9qZWN0MzInO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdnM6IHZzLFxuICAgICAgICBmczogZnMsXG4gICAgICAgIGRlZmluZXM6IHt9LFxuICAgICAgICBtb2R1bGVzOiBbcHJvamVjdE1vZHVsZSwgJ2dvdXJhdWQtbGlnaHRpbmcnLCAncGlja2luZyddXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpbml0aWFsaXplU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaW5pdGlhbGl6ZVN0YXRlKCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGdsID0gdGhpcy5jb250ZXh0LmdsO1xuICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIG51bUluc3RhbmNlczogMCxcbiAgICAgICAgcG9seWdvblRlc3NlbGF0b3I6IG5ldyBQb2x5Z29uVGVzc2VsYXRvcih7XG4gICAgICAgICAgSW5kZXhUeXBlOiAhZ2wgfHwgaGFzRmVhdHVyZShnbCwgRkVBVFVSRVMuRUxFTUVOVF9JTkRFWF9VSU5UMzIpID8gVWludDMyQXJyYXkgOiBVaW50MTZBcnJheVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICB2YXIgYXR0cmlidXRlTWFuYWdlciA9IHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpO1xuICAgICAgdmFyIG5vQWxsb2MgPSB0cnVlO1xuICAgICAgYXR0cmlidXRlTWFuYWdlci5yZW1vdmUoWydpbnN0YW5jZVBpY2tpbmdDb2xvcnMnXSk7XG4gICAgICBhdHRyaWJ1dGVNYW5hZ2VyLmFkZCh7XG4gICAgICAgIGluZGljZXM6IHtcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIGlzSW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlSW5kaWNlcyxcbiAgICAgICAgICBub0FsbG9jOiBub0FsbG9jXG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uczoge1xuICAgICAgICAgIHNpemU6IDMsXG4gICAgICAgICAgdHJhbnNpdGlvbjogQVRUUklCVVRFX1RSQU5TSVRJT04sXG4gICAgICAgICAgYWNjZXNzb3I6ICdnZXRQb2x5Z29uJyxcbiAgICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlUG9zaXRpb25zLFxuICAgICAgICAgIG5vQWxsb2M6IG5vQWxsb2MsXG4gICAgICAgICAgc2hhZGVyQXR0cmlidXRlczoge1xuICAgICAgICAgICAgcG9zaXRpb25zOiB7XG4gICAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgICAgZGl2aXNvcjogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc3RhbmNlUG9zaXRpb25zOiB7XG4gICAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgICAgZGl2aXNvcjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHRQb3NpdGlvbnM6IHtcbiAgICAgICAgICAgICAgb2Zmc2V0OiAxMixcbiAgICAgICAgICAgICAgZGl2aXNvcjogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb25zNjR4eUxvdzoge1xuICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgdXBkYXRlOiB0aGlzLmNhbGN1bGF0ZVBvc2l0aW9uc0xvdyxcbiAgICAgICAgICBub0FsbG9jOiBub0FsbG9jLFxuICAgICAgICAgIHNoYWRlckF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIHBvc2l0aW9uczY0eHlMb3c6IHtcbiAgICAgICAgICAgICAgb2Zmc2V0OiAwLFxuICAgICAgICAgICAgICBkaXZpc29yOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5zdGFuY2VQb3NpdGlvbnM2NHh5TG93OiB7XG4gICAgICAgICAgICAgIG9mZnNldDogMCxcbiAgICAgICAgICAgICAgZGl2aXNvcjogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHRQb3NpdGlvbnM2NHh5TG93OiB7XG4gICAgICAgICAgICAgIG9mZnNldDogOCxcbiAgICAgICAgICAgICAgZGl2aXNvcjogMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmVydGV4VmFsaWQ6IHtcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIGRpdmlzb3I6IDEsXG4gICAgICAgICAgdHlwZTogNTEyMSxcbiAgICAgICAgICB1cGRhdGU6IHRoaXMuY2FsY3VsYXRlVmVydGV4VmFsaWQsXG4gICAgICAgICAgbm9BbGxvYzogbm9BbGxvY1xuICAgICAgICB9LFxuICAgICAgICBlbGV2YXRpb25zOiB7XG4gICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICB0cmFuc2l0aW9uOiBBVFRSSUJVVEVfVFJBTlNJVElPTixcbiAgICAgICAgICBhY2Nlc3NvcjogJ2dldEVsZXZhdGlvbicsXG4gICAgICAgICAgc2hhZGVyQXR0cmlidXRlczoge1xuICAgICAgICAgICAgZWxldmF0aW9uczoge1xuICAgICAgICAgICAgICBkaXZpc29yOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5zdGFuY2VFbGV2YXRpb25zOiB7XG4gICAgICAgICAgICAgIGRpdmlzb3I6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGxDb2xvcnM6IHtcbiAgICAgICAgICBhbGlhczogJ2NvbG9ycycsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiA1MTIxLFxuICAgICAgICAgIHRyYW5zaXRpb246IEFUVFJJQlVURV9UUkFOU0lUSU9OLFxuICAgICAgICAgIGFjY2Vzc29yOiAnZ2V0RmlsbENvbG9yJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IERFRkFVTFRfQ09MT1IsXG4gICAgICAgICAgc2hhZGVyQXR0cmlidXRlczoge1xuICAgICAgICAgICAgZmlsbENvbG9yczoge1xuICAgICAgICAgICAgICBkaXZpc29yOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5zdGFuY2VGaWxsQ29sb3JzOiB7XG4gICAgICAgICAgICAgIGRpdmlzb3I6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGxpbmVDb2xvcnM6IHtcbiAgICAgICAgICBhbGlhczogJ2NvbG9ycycsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiA1MTIxLFxuICAgICAgICAgIHRyYW5zaXRpb246IEFUVFJJQlVURV9UUkFOU0lUSU9OLFxuICAgICAgICAgIGFjY2Vzc29yOiAnZ2V0TGluZUNvbG9yJyxcbiAgICAgICAgICBkZWZhdWx0VmFsdWU6IERFRkFVTFRfQ09MT1IsXG4gICAgICAgICAgc2hhZGVyQXR0cmlidXRlczoge1xuICAgICAgICAgICAgbGluZUNvbG9yczoge1xuICAgICAgICAgICAgICBkaXZpc29yOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5zdGFuY2VMaW5lQ29sb3JzOiB7XG4gICAgICAgICAgICAgIGRpdmlzb3I6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBpY2tpbmdDb2xvcnM6IHtcbiAgICAgICAgICBzaXplOiAzLFxuICAgICAgICAgIHR5cGU6IDUxMjEsXG4gICAgICAgICAgYWNjZXNzb3I6IGZ1bmN0aW9uIGFjY2Vzc29yKG9iamVjdCwgX3JlZikge1xuICAgICAgICAgICAgdmFyIGluZGV4ID0gX3JlZi5pbmRleCxcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF9yZWYudGFyZ2V0O1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzLmVuY29kZVBpY2tpbmdDb2xvcihpbmRleCwgdmFsdWUpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgc2hhZGVyQXR0cmlidXRlczoge1xuICAgICAgICAgICAgcGlja2luZ0NvbG9yczoge1xuICAgICAgICAgICAgICBkaXZpc29yOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5zdGFuY2VQaWNraW5nQ29sb3JzOiB7XG4gICAgICAgICAgICAgIGRpdmlzb3I6IDFcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXcoX3JlZjIpIHtcbiAgICAgIHZhciB1bmlmb3JtcyA9IF9yZWYyLnVuaWZvcm1zO1xuICAgICAgdmFyIF90aGlzJHByb3BzID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBleHRydWRlZCA9IF90aGlzJHByb3BzLmV4dHJ1ZGVkLFxuICAgICAgICAgIGZpbGxlZCA9IF90aGlzJHByb3BzLmZpbGxlZCxcbiAgICAgICAgICB3aXJlZnJhbWUgPSBfdGhpcyRwcm9wcy53aXJlZnJhbWUsXG4gICAgICAgICAgZWxldmF0aW9uU2NhbGUgPSBfdGhpcyRwcm9wcy5lbGV2YXRpb25TY2FsZTtcbiAgICAgIHZhciBfdGhpcyRzdGF0ZSA9IHRoaXMuc3RhdGUsXG4gICAgICAgICAgdG9wTW9kZWwgPSBfdGhpcyRzdGF0ZS50b3BNb2RlbCxcbiAgICAgICAgICBzaWRlTW9kZWwgPSBfdGhpcyRzdGF0ZS5zaWRlTW9kZWwsXG4gICAgICAgICAgcG9seWdvblRlc3NlbGF0b3IgPSBfdGhpcyRzdGF0ZS5wb2x5Z29uVGVzc2VsYXRvcjtcbiAgICAgIHZhciByZW5kZXJVbmlmb3JtcyA9IE9iamVjdC5hc3NpZ24oe30sIHVuaWZvcm1zLCB7XG4gICAgICAgIGV4dHJ1ZGVkOiBCb29sZWFuKGV4dHJ1ZGVkKSxcbiAgICAgICAgZWxldmF0aW9uU2NhbGU6IGVsZXZhdGlvblNjYWxlXG4gICAgICB9KTtcblxuICAgICAgaWYgKHNpZGVNb2RlbCkge1xuICAgICAgICBzaWRlTW9kZWwuc2V0SW5zdGFuY2VDb3VudChwb2x5Z29uVGVzc2VsYXRvci5pbnN0YW5jZUNvdW50IC0gMSk7XG4gICAgICAgIHNpZGVNb2RlbC5zZXRVbmlmb3JtcyhyZW5kZXJVbmlmb3Jtcyk7XG5cbiAgICAgICAgaWYgKHdpcmVmcmFtZSkge1xuICAgICAgICAgIHNpZGVNb2RlbC5zZXREcmF3TW9kZSgzKTtcbiAgICAgICAgICBzaWRlTW9kZWwuc2V0VW5pZm9ybXMoe1xuICAgICAgICAgICAgaXNXaXJlZnJhbWU6IHRydWVcbiAgICAgICAgICB9KS5kcmF3KCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmlsbGVkKSB7XG4gICAgICAgICAgc2lkZU1vZGVsLnNldERyYXdNb2RlKDYpO1xuICAgICAgICAgIHNpZGVNb2RlbC5zZXRVbmlmb3Jtcyh7XG4gICAgICAgICAgICBpc1dpcmVmcmFtZTogZmFsc2VcbiAgICAgICAgICB9KS5kcmF3KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRvcE1vZGVsKSB7XG4gICAgICAgIHRvcE1vZGVsLnNldFZlcnRleENvdW50KHBvbHlnb25UZXNzZWxhdG9yLmdldCgnaW5kaWNlcycpLmxlbmd0aCk7XG4gICAgICAgIHRvcE1vZGVsLnNldFVuaWZvcm1zKHJlbmRlclVuaWZvcm1zKS5kcmF3KCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZVN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKHVwZGF0ZVBhcmFtcykge1xuICAgICAgX2dldChfZ2V0UHJvdG90eXBlT2YoU29saWRQb2x5Z29uTGF5ZXIucHJvdG90eXBlKSwgXCJ1cGRhdGVTdGF0ZVwiLCB0aGlzKS5jYWxsKHRoaXMsIHVwZGF0ZVBhcmFtcyk7XG5cbiAgICAgIHRoaXMudXBkYXRlR2VvbWV0cnkodXBkYXRlUGFyYW1zKTtcbiAgICAgIHZhciBwcm9wcyA9IHVwZGF0ZVBhcmFtcy5wcm9wcyxcbiAgICAgICAgICBvbGRQcm9wcyA9IHVwZGF0ZVBhcmFtcy5vbGRQcm9wcztcbiAgICAgIHZhciBhdHRyaWJ1dGVNYW5hZ2VyID0gdGhpcy5nZXRBdHRyaWJ1dGVNYW5hZ2VyKCk7XG4gICAgICB2YXIgcmVnZW5lcmF0ZU1vZGVscyA9IHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQgfHwgcHJvcHMuZmlsbGVkICE9PSBvbGRQcm9wcy5maWxsZWQgfHwgcHJvcHMuZXh0cnVkZWQgIT09IG9sZFByb3BzLmV4dHJ1ZGVkO1xuXG4gICAgICBpZiAocmVnZW5lcmF0ZU1vZGVscykge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5tb2RlbHMpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlLm1vZGVscy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZGVsLmRlbGV0ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLl9nZXRNb2RlbHModGhpcy5jb250ZXh0LmdsKSk7XG4gICAgICAgIGF0dHJpYnV0ZU1hbmFnZXIuaW52YWxpZGF0ZUFsbCgpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVHZW9tZXRyeVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVHZW9tZXRyeShfcmVmMykge1xuICAgICAgdmFyIHByb3BzID0gX3JlZjMucHJvcHMsXG4gICAgICAgICAgb2xkUHJvcHMgPSBfcmVmMy5vbGRQcm9wcyxcbiAgICAgICAgICBjaGFuZ2VGbGFncyA9IF9yZWYzLmNoYW5nZUZsYWdzO1xuICAgICAgdmFyIGdlb21ldHJ5Q29uZmlnQ2hhbmdlZCA9IGNoYW5nZUZsYWdzLmRhdGFDaGFuZ2VkIHx8IHByb3BzLmZwNjQgIT09IG9sZFByb3BzLmZwNjQgfHwgY2hhbmdlRmxhZ3MudXBkYXRlVHJpZ2dlcnNDaGFuZ2VkICYmIChjaGFuZ2VGbGFncy51cGRhdGVUcmlnZ2Vyc0NoYW5nZWQuYWxsIHx8IGNoYW5nZUZsYWdzLnVwZGF0ZVRyaWdnZXJzQ2hhbmdlZC5nZXRQb2x5Z29uKTtcblxuICAgICAgaWYgKGdlb21ldHJ5Q29uZmlnQ2hhbmdlZCkge1xuICAgICAgICB2YXIgcG9seWdvblRlc3NlbGF0b3IgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yO1xuICAgICAgICBwb2x5Z29uVGVzc2VsYXRvci51cGRhdGVHZW9tZXRyeSh7XG4gICAgICAgICAgZGF0YTogcHJvcHMuZGF0YSxcbiAgICAgICAgICBnZXRHZW9tZXRyeTogcHJvcHMuZ2V0UG9seWdvbixcbiAgICAgICAgICBwb3NpdGlvbkZvcm1hdDogcHJvcHMucG9zaXRpb25Gb3JtYXQsXG4gICAgICAgICAgZnA2NDogdGhpcy51c2U2NGJpdFBvc2l0aW9ucygpXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBudW1JbnN0YW5jZXM6IHBvbHlnb25UZXNzZWxhdG9yLmluc3RhbmNlQ291bnQsXG4gICAgICAgICAgYnVmZmVyTGF5b3V0OiBwb2x5Z29uVGVzc2VsYXRvci5idWZmZXJMYXlvdXRcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlTWFuYWdlcigpLmludmFsaWRhdGVBbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldE1vZGVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TW9kZWxzKGdsKSB7XG4gICAgICB2YXIgX3RoaXMkcHJvcHMyID0gdGhpcy5wcm9wcyxcbiAgICAgICAgICBpZCA9IF90aGlzJHByb3BzMi5pZCxcbiAgICAgICAgICBmaWxsZWQgPSBfdGhpcyRwcm9wczIuZmlsbGVkLFxuICAgICAgICAgIGV4dHJ1ZGVkID0gX3RoaXMkcHJvcHMyLmV4dHJ1ZGVkO1xuICAgICAgdmFyIHRvcE1vZGVsO1xuICAgICAgdmFyIHNpZGVNb2RlbDtcblxuICAgICAgaWYgKGZpbGxlZCkge1xuICAgICAgICB2YXIgc2hhZGVycyA9IHRoaXMuZ2V0U2hhZGVycyh2c1RvcCk7XG4gICAgICAgIHNoYWRlcnMuZGVmaW5lcy5OT05fSU5TVEFOQ0VEX01PREVMID0gMTtcbiAgICAgICAgdG9wTW9kZWwgPSBuZXcgTW9kZWwoZ2wsIE9iamVjdC5hc3NpZ24oe30sIHNoYWRlcnMsIHtcbiAgICAgICAgICBpZDogXCJcIi5jb25jYXQoaWQsIFwiLXRvcFwiKSxcbiAgICAgICAgICBkcmF3TW9kZTogNCxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICB2ZXJ0ZXhQb3NpdGlvbnM6IG5ldyBGbG9hdDMyQXJyYXkoWzAsIDFdKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgdW5pZm9ybXM6IHtcbiAgICAgICAgICAgIGlzV2lyZWZyYW1lOiBmYWxzZSxcbiAgICAgICAgICAgIGlzU2lkZVZlcnRleDogZmFsc2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIHZlcnRleENvdW50OiAwLFxuICAgICAgICAgIGlzSW5kZXhlZDogdHJ1ZSxcbiAgICAgICAgICBzaGFkZXJDYWNoZTogdGhpcy5jb250ZXh0LnNoYWRlckNhY2hlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGV4dHJ1ZGVkKSB7XG4gICAgICAgIHNpZGVNb2RlbCA9IG5ldyBNb2RlbChnbCwgT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5nZXRTaGFkZXJzKHZzU2lkZSksIHtcbiAgICAgICAgICBpZDogXCJcIi5jb25jYXQoaWQsIFwiLXNpZGVcIiksXG4gICAgICAgICAgZ2VvbWV0cnk6IG5ldyBHZW9tZXRyeSh7XG4gICAgICAgICAgICBkcmF3TW9kZTogMSxcbiAgICAgICAgICAgIHZlcnRleENvdW50OiA0LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICB2ZXJ0ZXhQb3NpdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAxLCAwLCAxLCAwLCAwLCAxLCAwXSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGluc3RhbmNlQ291bnQ6IDAsXG4gICAgICAgICAgaXNJbnN0YW5jZWQ6IDEsXG4gICAgICAgICAgc2hhZGVyQ2FjaGU6IHRoaXMuY29udGV4dC5zaGFkZXJDYWNoZVxuICAgICAgICB9KSk7XG4gICAgICAgIHNpZGVNb2RlbC51c2VyRGF0YS5leGNsdWRlQXR0cmlidXRlcyA9IHtcbiAgICAgICAgICBpbmRpY2VzOiB0cnVlXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1vZGVsczogW3NpZGVNb2RlbCwgdG9wTW9kZWxdLmZpbHRlcihCb29sZWFuKSxcbiAgICAgICAgdG9wTW9kZWw6IHRvcE1vZGVsLFxuICAgICAgICBzaWRlTW9kZWw6IHNpZGVNb2RlbFxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlSW5kaWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxjdWxhdGVJbmRpY2VzKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIHBvbHlnb25UZXNzZWxhdG9yID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvcjtcbiAgICAgIGF0dHJpYnV0ZS5idWZmZXJMYXlvdXQgPSBwb2x5Z29uVGVzc2VsYXRvci5pbmRleExheW91dDtcbiAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IHBvbHlnb25UZXNzZWxhdG9yLmdldCgnaW5kaWNlcycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVQb3NpdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25zKGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIHBvbHlnb25UZXNzZWxhdG9yID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvcjtcbiAgICAgIGF0dHJpYnV0ZS5idWZmZXJMYXlvdXQgPSBwb2x5Z29uVGVzc2VsYXRvci5idWZmZXJMYXlvdXQ7XG4gICAgICBhdHRyaWJ1dGUudmFsdWUgPSBwb2x5Z29uVGVzc2VsYXRvci5nZXQoJ3Bvc2l0aW9ucycpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjYWxjdWxhdGVQb3NpdGlvbnNMb3dcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlUG9zaXRpb25zTG93KGF0dHJpYnV0ZSkge1xuICAgICAgdmFyIGlzRlA2NCA9IHRoaXMudXNlNjRiaXRQb3NpdGlvbnMoKTtcbiAgICAgIGF0dHJpYnV0ZS5jb25zdGFudCA9ICFpc0ZQNjQ7XG5cbiAgICAgIGlmICghaXNGUDY0KSB7XG4gICAgICAgIGF0dHJpYnV0ZS52YWx1ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlLnZhbHVlID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5nZXQoJ3Bvc2l0aW9uczY0eHlMb3cnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsY3VsYXRlVmVydGV4VmFsaWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2FsY3VsYXRlVmVydGV4VmFsaWQoYXR0cmlidXRlKSB7XG4gICAgICBhdHRyaWJ1dGUudmFsdWUgPSB0aGlzLnN0YXRlLnBvbHlnb25UZXNzZWxhdG9yLmdldCgndmVydGV4VmFsaWQnKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJQaWNraW5nQ29sb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJQaWNraW5nQ29sb3IoY29sb3IpIHtcbiAgICAgIHZhciBwaWNrZWRQb2x5Z29uSW5kZXggPSB0aGlzLmRlY29kZVBpY2tpbmdDb2xvcihjb2xvcik7XG4gICAgICB2YXIgYnVmZmVyTGF5b3V0ID0gdGhpcy5zdGF0ZS5wb2x5Z29uVGVzc2VsYXRvci5idWZmZXJMYXlvdXQ7XG4gICAgICB2YXIgbnVtVmVydGljZXMgPSBidWZmZXJMYXlvdXRbcGlja2VkUG9seWdvbkluZGV4XTtcbiAgICAgIHZhciBzdGFydEluc3RhbmNlSW5kZXggPSAwO1xuXG4gICAgICBmb3IgKHZhciBwb2x5Z29uSW5kZXggPSAwOyBwb2x5Z29uSW5kZXggPCBwaWNrZWRQb2x5Z29uSW5kZXg7IHBvbHlnb25JbmRleCsrKSB7XG4gICAgICAgIHN0YXJ0SW5zdGFuY2VJbmRleCArPSBidWZmZXJMYXlvdXRbcG9seWdvbkluZGV4XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHBpY2tpbmdDb2xvcnMgPSB0aGlzLmdldEF0dHJpYnV0ZU1hbmFnZXIoKS5hdHRyaWJ1dGVzLnBpY2tpbmdDb2xvcnM7XG4gICAgICB2YXIgdmFsdWUgPSBwaWNraW5nQ29sb3JzLnZhbHVlO1xuICAgICAgdmFyIGVuZEluc3RhbmNlSW5kZXggPSBzdGFydEluc3RhbmNlSW5kZXggKyBudW1WZXJ0aWNlcztcbiAgICAgIHZhbHVlLmZpbGwoMCwgc3RhcnRJbnN0YW5jZUluZGV4ICogMywgZW5kSW5zdGFuY2VJbmRleCAqIDMpO1xuICAgICAgcGlja2luZ0NvbG9ycy51cGRhdGUoe1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBTb2xpZFBvbHlnb25MYXllcjtcbn0oTGF5ZXIpO1xuXG5leHBvcnQgeyBTb2xpZFBvbHlnb25MYXllciBhcyBkZWZhdWx0IH07XG5Tb2xpZFBvbHlnb25MYXllci5sYXllck5hbWUgPSAnU29saWRQb2x5Z29uTGF5ZXInO1xuU29saWRQb2x5Z29uTGF5ZXIuZGVmYXVsdFByb3BzID0gZGVmYXVsdFByb3BzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c29saWQtcG9seWdvbi1sYXllci5qcy5tYXAiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@deck.gl/layers/dist/esm/solid-polygon-layer/solid-polygon-layer.js\n");

/***/ }),

/***/ "./node_modules/@luma.gl/core/dist/esm/materials/material.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@luma.gl/core/dist/esm/materials/material.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return Material; });\n/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n\n\nvar Material = function Material() {\n  Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Material);\n};\n\n\n//# sourceMappingURL=material.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvY29yZS9kaXN0L2VzbS9tYXRlcmlhbHMvbWF0ZXJpYWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvY29yZS9kaXN0L2VzbS9tYXRlcmlhbHMvbWF0ZXJpYWwuanM/NDg0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuXG52YXIgTWF0ZXJpYWwgPSBmdW5jdGlvbiBNYXRlcmlhbCgpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE1hdGVyaWFsKTtcbn07XG5cbmV4cG9ydCB7IE1hdGVyaWFsIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1hdGVyaWFsLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@luma.gl/core/dist/esm/materials/material.js\n");

/***/ }),

/***/ "./node_modules/@luma.gl/core/dist/esm/materials/phong-material.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@luma.gl/core/dist/esm/materials/phong-material.js ***!
  \*************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PhongMaterial; });\n/* harmony import */ var _babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @babel/runtime/helpers/esm/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @babel/runtime/helpers/esm/assertThisInitialized */ \"./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/esm/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var _material__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./material */ \"./node_modules/@luma.gl/core/dist/esm/materials/material.js\");\n\n\n\n\n\n\nvar defaultProps = {\n  ambient: 0.35,\n  diffuse: 0.6,\n  shininess: 32,\n  specularColor: [30, 30, 30]\n};\n\nvar PhongMaterial = function (_Material) {\n  Object(_babel_runtime_helpers_esm_inherits__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(PhongMaterial, _Material);\n\n  function PhongMaterial(props) {\n    var _this;\n\n    Object(_babel_runtime_helpers_esm_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, PhongMaterial);\n\n    _this = Object(_babel_runtime_helpers_esm_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(this, Object(_babel_runtime_helpers_esm_getPrototypeOf__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(PhongMaterial).call(this, props));\n    props = Object.assign({}, defaultProps, props);\n    Object.assign(Object(_babel_runtime_helpers_esm_assertThisInitialized__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(_this), props);\n    return _this;\n  }\n\n  return PhongMaterial;\n}(_material__WEBPACK_IMPORTED_MODULE_5__[\"default\"]);\n\n\n//# sourceMappingURL=phong-material.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvY29yZS9kaXN0L2VzbS9tYXRlcmlhbHMvcGhvbmctbWF0ZXJpYWwuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGx1bWEuZ2wvY29yZS9kaXN0L2VzbS9tYXRlcmlhbHMvcGhvbmctbWF0ZXJpYWwuanM/ZGFkNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9jbGFzc0NhbGxDaGVja1wiO1xuaW1wb3J0IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCI7XG5pbXBvcnQgX2dldFByb3RvdHlwZU9mIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9nZXRQcm90b3R5cGVPZlwiO1xuaW1wb3J0IF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZFwiO1xuaW1wb3J0IF9pbmhlcml0cyBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHNcIjtcbmltcG9ydCBNYXRlcmlhbCBmcm9tICcuL21hdGVyaWFsJztcbnZhciBkZWZhdWx0UHJvcHMgPSB7XG4gIGFtYmllbnQ6IDAuMzUsXG4gIGRpZmZ1c2U6IDAuNixcbiAgc2hpbmluZXNzOiAzMixcbiAgc3BlY3VsYXJDb2xvcjogWzMwLCAzMCwgMzBdXG59O1xuXG52YXIgUGhvbmdNYXRlcmlhbCA9IGZ1bmN0aW9uIChfTWF0ZXJpYWwpIHtcbiAgX2luaGVyaXRzKFBob25nTWF0ZXJpYWwsIF9NYXRlcmlhbCk7XG5cbiAgZnVuY3Rpb24gUGhvbmdNYXRlcmlhbChwcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQaG9uZ01hdGVyaWFsKTtcblxuICAgIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgX2dldFByb3RvdHlwZU9mKFBob25nTWF0ZXJpYWwpLmNhbGwodGhpcywgcHJvcHMpKTtcbiAgICBwcm9wcyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQcm9wcywgcHJvcHMpO1xuICAgIE9iamVjdC5hc3NpZ24oX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIHByb3BzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cblxuICByZXR1cm4gUGhvbmdNYXRlcmlhbDtcbn0oTWF0ZXJpYWwpO1xuXG5leHBvcnQgeyBQaG9uZ01hdGVyaWFsIGFzIGRlZmF1bHQgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBob25nLW1hdGVyaWFsLmpzLm1hcCJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@luma.gl/core/dist/esm/materials/phong-material.js\n");

/***/ }),

/***/ "./node_modules/@superset-ui/legacy-preset-chart-deckgl/esm/layers/Geojson/Geojson.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@superset-ui/legacy-preset-chart-deckgl/esm/layers/Geojson/Geojson.js ***!
  \********************************************************************************************/
/*! exports provided: getLayer, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getLayer\", function() { return getLayer; });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! prop-types */ \"./node_modules/prop-types/index.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var deck_gl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! deck.gl */ \"./node_modules/@deck.gl/layers/dist/esm/geojson-layer/geojson-layer.js\");\n/* harmony import */ var _DeckGLContainer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../DeckGLContainer */ \"./node_modules/@superset-ui/legacy-preset-chart-deckgl/esm/DeckGLContainer.js\");\n/* harmony import */ var _utils_colors__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/colors */ \"./node_modules/@superset-ui/legacy-preset-chart-deckgl/esm/utils/colors.js\");\n/* harmony import */ var _utils_sandbox__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/sandbox */ \"./node_modules/@superset-ui/legacy-preset-chart-deckgl/esm/utils/sandbox.js\");\n/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../common */ \"./node_modules/@superset-ui/legacy-preset-chart-deckgl/esm/layers/common.js\");\n/* harmony import */ var _TooltipRow__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../TooltipRow */ \"./node_modules/@superset-ui/legacy-preset-chart-deckgl/esm/TooltipRow.js\");\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\n/* eslint-disable react/no-array-index-key */\n\n/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n\n // TODO import geojsonExtent from 'geojson-extent';\n\n\n\n\n\n\nconst propertyMap = {\n  fillColor: 'fillColor',\n  color: 'fillColor',\n  fill: 'fillColor',\n  'fill-color': 'fillColor',\n  strokeColor: 'strokeColor',\n  'stroke-color': 'strokeColor',\n  'stroke-width': 'strokeWidth'\n};\n\nconst alterProps = (props, propOverrides) => {\n  const newProps = {};\n  Object.keys(props).forEach(k => {\n    if (k in propertyMap) {\n      newProps[propertyMap[k]] = props[k];\n    } else {\n      newProps[k] = props[k];\n    }\n  });\n\n  if (typeof props.fillColor === 'string') {\n    newProps.fillColor = Object(_utils_colors__WEBPACK_IMPORTED_MODULE_4__[\"hexToRGB\"])(props.fillColor);\n  }\n\n  if (typeof props.strokeColor === 'string') {\n    newProps.strokeColor = Object(_utils_colors__WEBPACK_IMPORTED_MODULE_4__[\"hexToRGB\"])(props.strokeColor);\n  }\n\n  return _extends({}, newProps, {}, propOverrides);\n};\n\nlet features;\n\nconst recurseGeoJson = (node, propOverrides, extraProps) => {\n  if (node && node.features) {\n    node.features.forEach(obj => {\n      recurseGeoJson(obj, propOverrides, node.extraProps || extraProps);\n    });\n  }\n\n  if (node && node.geometry) {\n    const newNode = _extends({}, node, {\n      properties: alterProps(node.properties, propOverrides)\n    });\n\n    if (!newNode.extraProps) {\n      newNode.extraProps = extraProps;\n    }\n\n    features.push(newNode);\n  }\n};\n\nfunction setTooltipContent(o) {\n  return o.object.extraProps && react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(\"div\", {\n    className: \"deckgl-tooltip\"\n  }, Object.keys(o.object.extraProps).map((prop, index) => react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_TooltipRow__WEBPACK_IMPORTED_MODULE_7__[\"default\"], {\n    key: \"prop-\" + index,\n    label: prop + \": \",\n    value: \"\" + o.object.extraProps[prop]\n  })));\n}\n\nfunction getLayer(formData, payload, onAddFilter, setTooltip) {\n  const fd = formData;\n  const fc = fd.fill_color_picker;\n  const sc = fd.stroke_color_picker;\n  const fillColor = [fc.r, fc.g, fc.b, 255 * fc.a];\n  const strokeColor = [sc.r, sc.g, sc.b, 255 * sc.a];\n  const propOverrides = {};\n\n  if (fillColor[3] > 0) {\n    propOverrides.fillColor = fillColor;\n  }\n\n  if (strokeColor[3] > 0) {\n    propOverrides.strokeColor = strokeColor;\n  }\n\n  features = [];\n  recurseGeoJson(payload.data, propOverrides);\n  let jsFnMutator;\n\n  if (fd.js_data_mutator) {\n    // Applying user defined data mutator if defined\n    jsFnMutator = Object(_utils_sandbox__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(fd.js_data_mutator);\n    features = jsFnMutator(features);\n  }\n\n  return new deck_gl__WEBPACK_IMPORTED_MODULE_2__[\"default\"](_extends({\n    id: \"geojson-layer-\" + fd.slice_id,\n    filled: fd.filled,\n    data: features,\n    stroked: fd.stroked,\n    extruded: fd.extruded,\n    pointRadiusScale: fd.point_radius_scale\n  }, Object(_common__WEBPACK_IMPORTED_MODULE_6__[\"commonLayerProps\"])(fd, setTooltip, setTooltipContent)));\n}\nconst propTypes = {\n  formData: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object.isRequired,\n  payload: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object.isRequired,\n  setControlValue: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func.isRequired,\n  viewport: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.object.isRequired,\n  onAddFilter: prop_types__WEBPACK_IMPORTED_MODULE_1___default.a.func\n};\nconst defaultProps = {\n  onAddFilter() {}\n\n};\n\nclass DeckGLGeoJson extends react__WEBPACK_IMPORTED_MODULE_0___default.a.Component {\n  constructor() {\n    super(...arguments);\n\n    _defineProperty(this, \"containerRef\", react__WEBPACK_IMPORTED_MODULE_0___default.a.createRef());\n\n    _defineProperty(this, \"setTooltip\", tooltip => {\n      const {\n        current\n      } = this.containerRef;\n\n      if (current) {\n        current.setTooltip(tooltip);\n      }\n    });\n  }\n\n  render() {\n    const {\n      formData,\n      payload,\n      setControlValue,\n      onAddFilter,\n      viewport\n    } = this.props; // TODO get this to work\n    // if (formData.autozoom) {\n    //   viewport = common.fitViewport(viewport, geojsonExtent(payload.data.features));\n    // }\n\n    const layer = getLayer(formData, payload, onAddFilter, this.setTooltip);\n    return react__WEBPACK_IMPORTED_MODULE_0___default.a.createElement(_DeckGLContainer__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {\n      ref: this.containerRef,\n      mapboxApiAccessToken: payload.data.mapboxApiKey,\n      viewport: viewport,\n      layers: [layer],\n      mapStyle: formData.mapbox_style,\n      setControlValue: setControlValue\n    });\n  }\n\n}\n\nDeckGLGeoJson.propTypes = propTypes;\nDeckGLGeoJson.defaultProps = defaultProps;\n/* harmony default export */ __webpack_exports__[\"default\"] = (DeckGLGeoJson);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGVyc2V0LXVpL2xlZ2FjeS1wcmVzZXQtY2hhcnQtZGVja2dsL2VzbS9sYXllcnMvR2VvanNvbi9HZW9qc29uLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzdXBlcnNldC11aS9sZWdhY3ktcHJlc2V0LWNoYXJ0LWRlY2tnbC9lc20vbGF5ZXJzL0dlb2pzb24vR2VvanNvbi5qcz9iNmIxIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkgeyBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07IHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlYWN0L25vLWFycmF5LWluZGV4LWtleSAqL1xuXG4vKipcbiAqIExpY2Vuc2VkIHRvIHRoZSBBcGFjaGUgU29mdHdhcmUgRm91bmRhdGlvbiAoQVNGKSB1bmRlciBvbmVcbiAqIG9yIG1vcmUgY29udHJpYnV0b3IgbGljZW5zZSBhZ3JlZW1lbnRzLiAgU2VlIHRoZSBOT1RJQ0UgZmlsZVxuICogZGlzdHJpYnV0ZWQgd2l0aCB0aGlzIHdvcmsgZm9yIGFkZGl0aW9uYWwgaW5mb3JtYXRpb25cbiAqIHJlZ2FyZGluZyBjb3B5cmlnaHQgb3duZXJzaGlwLiAgVGhlIEFTRiBsaWNlbnNlcyB0aGlzIGZpbGVcbiAqIHRvIHlvdSB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGVcbiAqIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZVxuICogd2l0aCB0aGUgTGljZW5zZS4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLFxuICogc29mdHdhcmUgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW5cbiAqIFwiQVMgSVNcIiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXG4gKiBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGVcbiAqIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmQgbGltaXRhdGlvbnNcbiAqIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCB7IEdlb0pzb25MYXllciB9IGZyb20gJ2RlY2suZ2wnOyAvLyBUT0RPIGltcG9ydCBnZW9qc29uRXh0ZW50IGZyb20gJ2dlb2pzb24tZXh0ZW50JztcblxuaW1wb3J0IERlY2tHTENvbnRhaW5lciBmcm9tICcuLi8uLi9EZWNrR0xDb250YWluZXInO1xuaW1wb3J0IHsgaGV4VG9SR0IgfSBmcm9tICcuLi8uLi91dGlscy9jb2xvcnMnO1xuaW1wb3J0IHNhbmRib3hlZEV2YWwgZnJvbSAnLi4vLi4vdXRpbHMvc2FuZGJveCc7XG5pbXBvcnQgeyBjb21tb25MYXllclByb3BzIH0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCBUb29sdGlwUm93IGZyb20gJy4uLy4uL1Rvb2x0aXBSb3cnO1xuY29uc3QgcHJvcGVydHlNYXAgPSB7XG4gIGZpbGxDb2xvcjogJ2ZpbGxDb2xvcicsXG4gIGNvbG9yOiAnZmlsbENvbG9yJyxcbiAgZmlsbDogJ2ZpbGxDb2xvcicsXG4gICdmaWxsLWNvbG9yJzogJ2ZpbGxDb2xvcicsXG4gIHN0cm9rZUNvbG9yOiAnc3Ryb2tlQ29sb3InLFxuICAnc3Ryb2tlLWNvbG9yJzogJ3N0cm9rZUNvbG9yJyxcbiAgJ3N0cm9rZS13aWR0aCc6ICdzdHJva2VXaWR0aCdcbn07XG5cbmNvbnN0IGFsdGVyUHJvcHMgPSAocHJvcHMsIHByb3BPdmVycmlkZXMpID0+IHtcbiAgY29uc3QgbmV3UHJvcHMgPSB7fTtcbiAgT2JqZWN0LmtleXMocHJvcHMpLmZvckVhY2goayA9PiB7XG4gICAgaWYgKGsgaW4gcHJvcGVydHlNYXApIHtcbiAgICAgIG5ld1Byb3BzW3Byb3BlcnR5TWFwW2tdXSA9IHByb3BzW2tdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQcm9wc1trXSA9IHByb3BzW2tdO1xuICAgIH1cbiAgfSk7XG5cbiAgaWYgKHR5cGVvZiBwcm9wcy5maWxsQ29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgbmV3UHJvcHMuZmlsbENvbG9yID0gaGV4VG9SR0IocHJvcHMuZmlsbENvbG9yKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgcHJvcHMuc3Ryb2tlQ29sb3IgPT09ICdzdHJpbmcnKSB7XG4gICAgbmV3UHJvcHMuc3Ryb2tlQ29sb3IgPSBoZXhUb1JHQihwcm9wcy5zdHJva2VDb2xvcik7XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIG5ld1Byb3BzLCB7fSwgcHJvcE92ZXJyaWRlcyk7XG59O1xuXG5sZXQgZmVhdHVyZXM7XG5cbmNvbnN0IHJlY3Vyc2VHZW9Kc29uID0gKG5vZGUsIHByb3BPdmVycmlkZXMsIGV4dHJhUHJvcHMpID0+IHtcbiAgaWYgKG5vZGUgJiYgbm9kZS5mZWF0dXJlcykge1xuICAgIG5vZGUuZmVhdHVyZXMuZm9yRWFjaChvYmogPT4ge1xuICAgICAgcmVjdXJzZUdlb0pzb24ob2JqLCBwcm9wT3ZlcnJpZGVzLCBub2RlLmV4dHJhUHJvcHMgfHwgZXh0cmFQcm9wcyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAobm9kZSAmJiBub2RlLmdlb21ldHJ5KSB7XG4gICAgY29uc3QgbmV3Tm9kZSA9IF9leHRlbmRzKHt9LCBub2RlLCB7XG4gICAgICBwcm9wZXJ0aWVzOiBhbHRlclByb3BzKG5vZGUucHJvcGVydGllcywgcHJvcE92ZXJyaWRlcylcbiAgICB9KTtcblxuICAgIGlmICghbmV3Tm9kZS5leHRyYVByb3BzKSB7XG4gICAgICBuZXdOb2RlLmV4dHJhUHJvcHMgPSBleHRyYVByb3BzO1xuICAgIH1cblxuICAgIGZlYXR1cmVzLnB1c2gobmV3Tm9kZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldFRvb2x0aXBDb250ZW50KG8pIHtcbiAgcmV0dXJuIG8ub2JqZWN0LmV4dHJhUHJvcHMgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7XG4gICAgY2xhc3NOYW1lOiBcImRlY2tnbC10b29sdGlwXCJcbiAgfSwgT2JqZWN0LmtleXMoby5vYmplY3QuZXh0cmFQcm9wcykubWFwKChwcm9wLCBpbmRleCkgPT4gUmVhY3QuY3JlYXRlRWxlbWVudChUb29sdGlwUm93LCB7XG4gICAga2V5OiBcInByb3AtXCIgKyBpbmRleCxcbiAgICBsYWJlbDogcHJvcCArIFwiOiBcIixcbiAgICB2YWx1ZTogXCJcIiArIG8ub2JqZWN0LmV4dHJhUHJvcHNbcHJvcF1cbiAgfSkpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldExheWVyKGZvcm1EYXRhLCBwYXlsb2FkLCBvbkFkZEZpbHRlciwgc2V0VG9vbHRpcCkge1xuICBjb25zdCBmZCA9IGZvcm1EYXRhO1xuICBjb25zdCBmYyA9IGZkLmZpbGxfY29sb3JfcGlja2VyO1xuICBjb25zdCBzYyA9IGZkLnN0cm9rZV9jb2xvcl9waWNrZXI7XG4gIGNvbnN0IGZpbGxDb2xvciA9IFtmYy5yLCBmYy5nLCBmYy5iLCAyNTUgKiBmYy5hXTtcbiAgY29uc3Qgc3Ryb2tlQ29sb3IgPSBbc2Muciwgc2MuZywgc2MuYiwgMjU1ICogc2MuYV07XG4gIGNvbnN0IHByb3BPdmVycmlkZXMgPSB7fTtcblxuICBpZiAoZmlsbENvbG9yWzNdID4gMCkge1xuICAgIHByb3BPdmVycmlkZXMuZmlsbENvbG9yID0gZmlsbENvbG9yO1xuICB9XG5cbiAgaWYgKHN0cm9rZUNvbG9yWzNdID4gMCkge1xuICAgIHByb3BPdmVycmlkZXMuc3Ryb2tlQ29sb3IgPSBzdHJva2VDb2xvcjtcbiAgfVxuXG4gIGZlYXR1cmVzID0gW107XG4gIHJlY3Vyc2VHZW9Kc29uKHBheWxvYWQuZGF0YSwgcHJvcE92ZXJyaWRlcyk7XG4gIGxldCBqc0ZuTXV0YXRvcjtcblxuICBpZiAoZmQuanNfZGF0YV9tdXRhdG9yKSB7XG4gICAgLy8gQXBwbHlpbmcgdXNlciBkZWZpbmVkIGRhdGEgbXV0YXRvciBpZiBkZWZpbmVkXG4gICAganNGbk11dGF0b3IgPSBzYW5kYm94ZWRFdmFsKGZkLmpzX2RhdGFfbXV0YXRvcik7XG4gICAgZmVhdHVyZXMgPSBqc0ZuTXV0YXRvcihmZWF0dXJlcyk7XG4gIH1cblxuICByZXR1cm4gbmV3IEdlb0pzb25MYXllcihfZXh0ZW5kcyh7XG4gICAgaWQ6IFwiZ2VvanNvbi1sYXllci1cIiArIGZkLnNsaWNlX2lkLFxuICAgIGZpbGxlZDogZmQuZmlsbGVkLFxuICAgIGRhdGE6IGZlYXR1cmVzLFxuICAgIHN0cm9rZWQ6IGZkLnN0cm9rZWQsXG4gICAgZXh0cnVkZWQ6IGZkLmV4dHJ1ZGVkLFxuICAgIHBvaW50UmFkaXVzU2NhbGU6IGZkLnBvaW50X3JhZGl1c19zY2FsZVxuICB9LCBjb21tb25MYXllclByb3BzKGZkLCBzZXRUb29sdGlwLCBzZXRUb29sdGlwQ29udGVudCkpKTtcbn1cbmNvbnN0IHByb3BUeXBlcyA9IHtcbiAgZm9ybURhdGE6IFByb3BUeXBlcy5vYmplY3QuaXNSZXF1aXJlZCxcbiAgcGF5bG9hZDogUHJvcFR5cGVzLm9iamVjdC5pc1JlcXVpcmVkLFxuICBzZXRDb250cm9sVmFsdWU6IFByb3BUeXBlcy5mdW5jLmlzUmVxdWlyZWQsXG4gIHZpZXdwb3J0OiBQcm9wVHlwZXMub2JqZWN0LmlzUmVxdWlyZWQsXG4gIG9uQWRkRmlsdGVyOiBQcm9wVHlwZXMuZnVuY1xufTtcbmNvbnN0IGRlZmF1bHRQcm9wcyA9IHtcbiAgb25BZGRGaWx0ZXIoKSB7fVxuXG59O1xuXG5jbGFzcyBEZWNrR0xHZW9Kc29uIGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcblxuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnRhaW5lclJlZlwiLCBSZWFjdC5jcmVhdGVSZWYoKSk7XG5cbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJzZXRUb29sdGlwXCIsIHRvb2x0aXAgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBjdXJyZW50XG4gICAgICB9ID0gdGhpcy5jb250YWluZXJSZWY7XG5cbiAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgIGN1cnJlbnQuc2V0VG9vbHRpcCh0b29sdGlwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7XG4gICAgICBmb3JtRGF0YSxcbiAgICAgIHBheWxvYWQsXG4gICAgICBzZXRDb250cm9sVmFsdWUsXG4gICAgICBvbkFkZEZpbHRlcixcbiAgICAgIHZpZXdwb3J0XG4gICAgfSA9IHRoaXMucHJvcHM7IC8vIFRPRE8gZ2V0IHRoaXMgdG8gd29ya1xuICAgIC8vIGlmIChmb3JtRGF0YS5hdXRvem9vbSkge1xuICAgIC8vICAgdmlld3BvcnQgPSBjb21tb24uZml0Vmlld3BvcnQodmlld3BvcnQsIGdlb2pzb25FeHRlbnQocGF5bG9hZC5kYXRhLmZlYXR1cmVzKSk7XG4gICAgLy8gfVxuXG4gICAgY29uc3QgbGF5ZXIgPSBnZXRMYXllcihmb3JtRGF0YSwgcGF5bG9hZCwgb25BZGRGaWx0ZXIsIHRoaXMuc2V0VG9vbHRpcCk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoRGVja0dMQ29udGFpbmVyLCB7XG4gICAgICByZWY6IHRoaXMuY29udGFpbmVyUmVmLFxuICAgICAgbWFwYm94QXBpQWNjZXNzVG9rZW46IHBheWxvYWQuZGF0YS5tYXBib3hBcGlLZXksXG4gICAgICB2aWV3cG9ydDogdmlld3BvcnQsXG4gICAgICBsYXllcnM6IFtsYXllcl0sXG4gICAgICBtYXBTdHlsZTogZm9ybURhdGEubWFwYm94X3N0eWxlLFxuICAgICAgc2V0Q29udHJvbFZhbHVlOiBzZXRDb250cm9sVmFsdWVcbiAgICB9KTtcbiAgfVxuXG59XG5cbkRlY2tHTEdlb0pzb24ucHJvcFR5cGVzID0gcHJvcFR5cGVzO1xuRGVja0dMR2VvSnNvbi5kZWZhdWx0UHJvcHMgPSBkZWZhdWx0UHJvcHM7XG5leHBvcnQgZGVmYXVsdCBEZWNrR0xHZW9Kc29uOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@superset-ui/legacy-preset-chart-deckgl/esm/layers/Geojson/Geojson.js\n");

/***/ }),

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = earcut;\nmodule.exports.default = earcut;\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n\n        // filter collinear points around the cuts\n        filterPoints(outerNode, outerNode.next);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n           (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZWFyY3V0L3NyYy9lYXJjdXQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZWFyY3V0L3NyYy9lYXJjdXQuanM/NTY2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZWFyY3V0O1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGVhcmN1dDtcblxuZnVuY3Rpb24gZWFyY3V0KGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0pIHtcblxuICAgIGRpbSA9IGRpbSB8fCAyO1xuXG4gICAgdmFyIGhhc0hvbGVzID0gaG9sZUluZGljZXMgJiYgaG9sZUluZGljZXMubGVuZ3RoLFxuICAgICAgICBvdXRlckxlbiA9IGhhc0hvbGVzID8gaG9sZUluZGljZXNbMF0gKiBkaW0gOiBkYXRhLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJOb2RlID0gbGlua2VkTGlzdChkYXRhLCAwLCBvdXRlckxlbiwgZGltLCB0cnVlKSxcbiAgICAgICAgdHJpYW5nbGVzID0gW107XG5cbiAgICBpZiAoIW91dGVyTm9kZSB8fCBvdXRlck5vZGUubmV4dCA9PT0gb3V0ZXJOb2RlLnByZXYpIHJldHVybiB0cmlhbmdsZXM7XG5cbiAgICB2YXIgbWluWCwgbWluWSwgbWF4WCwgbWF4WSwgeCwgeSwgaW52U2l6ZTtcblxuICAgIGlmIChoYXNIb2xlcykgb3V0ZXJOb2RlID0gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKTtcblxuICAgIC8vIGlmIHRoZSBzaGFwZSBpcyBub3QgdG9vIHNpbXBsZSwgd2UnbGwgdXNlIHotb3JkZXIgY3VydmUgaGFzaCBsYXRlcjsgY2FsY3VsYXRlIHBvbHlnb24gYmJveFxuICAgIGlmIChkYXRhLmxlbmd0aCA+IDgwICogZGltKSB7XG4gICAgICAgIG1pblggPSBtYXhYID0gZGF0YVswXTtcbiAgICAgICAgbWluWSA9IG1heFkgPSBkYXRhWzFdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSBkaW07IGkgPCBvdXRlckxlbjsgaSArPSBkaW0pIHtcbiAgICAgICAgICAgIHggPSBkYXRhW2ldO1xuICAgICAgICAgICAgeSA9IGRhdGFbaSArIDFdO1xuICAgICAgICAgICAgaWYgKHggPCBtaW5YKSBtaW5YID0geDtcbiAgICAgICAgICAgIGlmICh5IDwgbWluWSkgbWluWSA9IHk7XG4gICAgICAgICAgICBpZiAoeCA+IG1heFgpIG1heFggPSB4O1xuICAgICAgICAgICAgaWYgKHkgPiBtYXhZKSBtYXhZID0geTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1pblgsIG1pblkgYW5kIGludlNpemUgYXJlIGxhdGVyIHVzZWQgdG8gdHJhbnNmb3JtIGNvb3JkcyBpbnRvIGludGVnZXJzIGZvciB6LW9yZGVyIGNhbGN1bGF0aW9uXG4gICAgICAgIGludlNpemUgPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgICAgICBpbnZTaXplID0gaW52U2l6ZSAhPT0gMCA/IDEgLyBpbnZTaXplIDogMDtcbiAgICB9XG5cbiAgICBlYXJjdXRMaW5rZWQob3V0ZXJOb2RlLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuXG4vLyBjcmVhdGUgYSBjaXJjdWxhciBkb3VibHkgbGlua2VkIGxpc3QgZnJvbSBwb2x5Z29uIHBvaW50cyBpbiB0aGUgc3BlY2lmaWVkIHdpbmRpbmcgb3JkZXJcbmZ1bmN0aW9uIGxpbmtlZExpc3QoZGF0YSwgc3RhcnQsIGVuZCwgZGltLCBjbG9ja3dpc2UpIHtcbiAgICB2YXIgaSwgbGFzdDtcblxuICAgIGlmIChjbG9ja3dpc2UgPT09IChzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkgPiAwKSkge1xuICAgICAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSBkaW0pIGxhc3QgPSBpbnNlcnROb2RlKGksIGRhdGFbaV0sIGRhdGFbaSArIDFdLCBsYXN0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSBlbmQgLSBkaW07IGkgPj0gc3RhcnQ7IGkgLT0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfVxuXG4gICAgaWYgKGxhc3QgJiYgZXF1YWxzKGxhc3QsIGxhc3QubmV4dCkpIHtcbiAgICAgICAgcmVtb3ZlTm9kZShsYXN0KTtcbiAgICAgICAgbGFzdCA9IGxhc3QubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGFzdDtcbn1cblxuLy8gZWxpbWluYXRlIGNvbGluZWFyIG9yIGR1cGxpY2F0ZSBwb2ludHNcbmZ1bmN0aW9uIGZpbHRlclBvaW50cyhzdGFydCwgZW5kKSB7XG4gICAgaWYgKCFzdGFydCkgcmV0dXJuIHN0YXJ0O1xuICAgIGlmICghZW5kKSBlbmQgPSBzdGFydDtcblxuICAgIHZhciBwID0gc3RhcnQsXG4gICAgICAgIGFnYWluO1xuICAgIGRvIHtcbiAgICAgICAgYWdhaW4gPSBmYWxzZTtcblxuICAgICAgICBpZiAoIXAuc3RlaW5lciAmJiAoZXF1YWxzKHAsIHAubmV4dCkgfHwgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPT09IDApKSB7XG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcCA9IGVuZCA9IHAucHJldjtcbiAgICAgICAgICAgIGlmIChwID09PSBwLm5leHQpIGJyZWFrO1xuICAgICAgICAgICAgYWdhaW4gPSB0cnVlO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgICB9XG4gICAgfSB3aGlsZSAoYWdhaW4gfHwgcCAhPT0gZW5kKTtcblxuICAgIHJldHVybiBlbmQ7XG59XG5cbi8vIG1haW4gZWFyIHNsaWNpbmcgbG9vcCB3aGljaCB0cmlhbmd1bGF0ZXMgYSBwb2x5Z29uIChnaXZlbiBhcyBhIGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIHBhc3MpIHtcbiAgICBpZiAoIWVhcikgcmV0dXJuO1xuXG4gICAgLy8gaW50ZXJsaW5rIHBvbHlnb24gbm9kZXMgaW4gei1vcmRlclxuICAgIGlmICghcGFzcyAmJiBpbnZTaXplKSBpbmRleEN1cnZlKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cbiAgICB2YXIgc3RvcCA9IGVhcixcbiAgICAgICAgcHJldiwgbmV4dDtcblxuICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBlYXJzLCBzbGljaW5nIHRoZW0gb25lIGJ5IG9uZVxuICAgIHdoaWxlIChlYXIucHJldiAhPT0gZWFyLm5leHQpIHtcbiAgICAgICAgcHJldiA9IGVhci5wcmV2O1xuICAgICAgICBuZXh0ID0gZWFyLm5leHQ7XG5cbiAgICAgICAgaWYgKGludlNpemUgPyBpc0Vhckhhc2hlZChlYXIsIG1pblgsIG1pblksIGludlNpemUpIDogaXNFYXIoZWFyKSkge1xuICAgICAgICAgICAgLy8gY3V0IG9mZiB0aGUgdHJpYW5nbGVcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHByZXYuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChlYXIuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChuZXh0LmkgLyBkaW0pO1xuXG4gICAgICAgICAgICByZW1vdmVOb2RlKGVhcik7XG5cbiAgICAgICAgICAgIC8vIHNraXBwaW5nIHRoZSBuZXh0IHZlcnRleCBsZWFkcyB0byBsZXNzIHNsaXZlciB0cmlhbmdsZXNcbiAgICAgICAgICAgIGVhciA9IG5leHQubmV4dDtcbiAgICAgICAgICAgIHN0b3AgPSBuZXh0Lm5leHQ7XG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZWFyID0gbmV4dDtcblxuICAgICAgICAvLyBpZiB3ZSBsb29wZWQgdGhyb3VnaCB0aGUgd2hvbGUgcmVtYWluaW5nIHBvbHlnb24gYW5kIGNhbid0IGZpbmQgYW55IG1vcmUgZWFyc1xuICAgICAgICBpZiAoZWFyID09PSBzdG9wKSB7XG4gICAgICAgICAgICAvLyB0cnkgZmlsdGVyaW5nIHBvaW50cyBhbmQgc2xpY2luZyBhZ2FpblxuICAgICAgICAgICAgaWYgKCFwYXNzKSB7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMSk7XG5cbiAgICAgICAgICAgIC8vIGlmIHRoaXMgZGlkbid0IHdvcmssIHRyeSBjdXJpbmcgYWxsIHNtYWxsIHNlbGYtaW50ZXJzZWN0aW9ucyBsb2NhbGx5XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBlYXIgPSBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKGZpbHRlclBvaW50cyhlYXIpLCB0cmlhbmdsZXMsIGRpbSk7XG4gICAgICAgICAgICAgICAgZWFyY3V0TGlua2VkKGVhciwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDIpO1xuXG4gICAgICAgICAgICAvLyBhcyBhIGxhc3QgcmVzb3J0LCB0cnkgc3BsaXR0aW5nIHRoZSByZW1haW5pbmcgcG9seWdvbiBpbnRvIHR3b1xuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAyKSB7XG4gICAgICAgICAgICAgICAgc3BsaXRFYXJjdXQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBjaGVjayB3aGV0aGVyIGEgcG9seWdvbiBub2RlIGZvcm1zIGEgdmFsaWQgZWFyIHdpdGggYWRqYWNlbnQgbm9kZXNcbmZ1bmN0aW9uIGlzRWFyKGVhcikge1xuICAgIHZhciBhID0gZWFyLnByZXYsXG4gICAgICAgIGIgPSBlYXIsXG4gICAgICAgIGMgPSBlYXIubmV4dDtcblxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIC8vIG5vdyBtYWtlIHN1cmUgd2UgZG9uJ3QgaGF2ZSBvdGhlciBwb2ludHMgaW5zaWRlIHRoZSBwb3RlbnRpYWwgZWFyXG4gICAgdmFyIHAgPSBlYXIubmV4dC5uZXh0O1xuXG4gICAgd2hpbGUgKHAgIT09IGVhci5wcmV2KSB7XG4gICAgICAgIGlmIChwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGlzRWFySGFzaGVkKGVhciwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIHZhciBhID0gZWFyLnByZXYsXG4gICAgICAgIGIgPSBlYXIsXG4gICAgICAgIGMgPSBlYXIubmV4dDtcblxuICAgIGlmIChhcmVhKGEsIGIsIGMpID49IDApIHJldHVybiBmYWxzZTsgLy8gcmVmbGV4LCBjYW4ndCBiZSBhbiBlYXJcblxuICAgIC8vIHRyaWFuZ2xlIGJib3g7IG1pbiAmIG1heCBhcmUgY2FsY3VsYXRlZCBsaWtlIHRoaXMgZm9yIHNwZWVkXG4gICAgdmFyIG1pblRYID0gYS54IDwgYi54ID8gKGEueCA8IGMueCA/IGEueCA6IGMueCkgOiAoYi54IDwgYy54ID8gYi54IDogYy54KSxcbiAgICAgICAgbWluVFkgPSBhLnkgPCBiLnkgPyAoYS55IDwgYy55ID8gYS55IDogYy55KSA6IChiLnkgPCBjLnkgPyBiLnkgOiBjLnkpLFxuICAgICAgICBtYXhUWCA9IGEueCA+IGIueCA/IChhLnggPiBjLnggPyBhLnggOiBjLngpIDogKGIueCA+IGMueCA/IGIueCA6IGMueCksXG4gICAgICAgIG1heFRZID0gYS55ID4gYi55ID8gKGEueSA+IGMueSA/IGEueSA6IGMueSkgOiAoYi55ID4gYy55ID8gYi55IDogYy55KTtcblxuICAgIC8vIHotb3JkZXIgcmFuZ2UgZm9yIHRoZSBjdXJyZW50IHRyaWFuZ2xlIGJib3g7XG4gICAgdmFyIG1pblogPSB6T3JkZXIobWluVFgsIG1pblRZLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSxcbiAgICAgICAgbWF4WiA9IHpPcmRlcihtYXhUWCwgbWF4VFksIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgdmFyIHAgPSBlYXIucHJldlosXG4gICAgICAgIG4gPSBlYXIubmV4dFo7XG5cbiAgICAvLyBsb29rIGZvciBwb2ludHMgaW5zaWRlIHRoZSB0cmlhbmdsZSBpbiBib3RoIGRpcmVjdGlvbnNcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWiAmJiBuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcblxuICAgICAgICBpZiAobiAhPT0gZWFyLnByZXYgJiYgbiAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBuLngsIG4ueSkgJiZcbiAgICAgICAgICAgIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBkZWNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAocCAmJiBwLnogPj0gbWluWikge1xuICAgICAgICBpZiAocCAhPT0gZWFyLnByZXYgJiYgcCAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAucHJldlo7XG4gICAgfVxuXG4gICAgLy8gbG9vayBmb3IgcmVtYWluaW5nIHBvaW50cyBpbiBpbmNyZWFzaW5nIHotb3JkZXJcbiAgICB3aGlsZSAobiAmJiBuLnogPD0gbWF4Wikge1xuICAgICAgICBpZiAobiAhPT0gZWFyLnByZXYgJiYgbiAhPT0gZWFyLm5leHQgJiZcbiAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBuLngsIG4ueSkgJiZcbiAgICAgICAgICAgIGFyZWEobi5wcmV2LCBuLCBuLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgbiA9IG4ubmV4dFo7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGdvIHRocm91Z2ggYWxsIHBvbHlnb24gbm9kZXMgYW5kIGN1cmUgc21hbGwgbG9jYWwgc2VsZi1pbnRlcnNlY3Rpb25zXG5mdW5jdGlvbiBjdXJlTG9jYWxJbnRlcnNlY3Rpb25zKHN0YXJ0LCB0cmlhbmdsZXMsIGRpbSkge1xuICAgIHZhciBwID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYSA9IHAucHJldixcbiAgICAgICAgICAgIGIgPSBwLm5leHQubmV4dDtcblxuICAgICAgICBpZiAoIWVxdWFscyhhLCBiKSAmJiBpbnRlcnNlY3RzKGEsIHAsIHAubmV4dCwgYikgJiYgbG9jYWxseUluc2lkZShhLCBiKSAmJiBsb2NhbGx5SW5zaWRlKGIsIGEpKSB7XG5cbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKGEuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYi5pIC8gZGltKTtcblxuICAgICAgICAgICAgLy8gcmVtb3ZlIHR3byBub2RlcyBpbnZvbHZlZFxuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHJlbW92ZU5vZGUocC5uZXh0KTtcblxuICAgICAgICAgICAgcCA9IHN0YXJ0ID0gYjtcbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBmaWx0ZXJQb2ludHMocCk7XG59XG5cbi8vIHRyeSBzcGxpdHRpbmcgcG9seWdvbiBpbnRvIHR3byBhbmQgdHJpYW5ndWxhdGUgdGhlbSBpbmRlcGVuZGVudGx5XG5mdW5jdGlvbiBzcGxpdEVhcmN1dChzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBsb29rIGZvciBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xuICAgIHZhciBhID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYiA9IGEubmV4dC5uZXh0O1xuICAgICAgICB3aGlsZSAoYiAhPT0gYS5wcmV2KSB7XG4gICAgICAgICAgICBpZiAoYS5pICE9PSBiLmkgJiYgaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxuICAgICAgICAgICAgICAgIHZhciBjID0gc3BsaXRQb2x5Z29uKGEsIGIpO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcbiAgICAgICAgICAgICAgICBhID0gZmlsdGVyUG9pbnRzKGEsIGEubmV4dCk7XG4gICAgICAgICAgICAgICAgYyA9IGZpbHRlclBvaW50cyhjLCBjLm5leHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IGIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBhID0gYS5uZXh0O1xuICAgIH0gd2hpbGUgKGEgIT09IHN0YXJ0KTtcbn1cblxuLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xuZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKSB7XG4gICAgdmFyIHF1ZXVlID0gW10sXG4gICAgICAgIGksIGxlbiwgc3RhcnQsIGVuZCwgbGlzdDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGxpc3QgPSBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UpO1xuICAgICAgICBpZiAobGlzdCA9PT0gbGlzdC5uZXh0KSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuICAgICAgICBxdWV1ZS5wdXNoKGdldExlZnRtb3N0KGxpc3QpKTtcbiAgICB9XG5cbiAgICBxdWV1ZS5zb3J0KGNvbXBhcmVYKTtcblxuICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgZm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsaW1pbmF0ZUhvbGUocXVldWVbaV0sIG91dGVyTm9kZSk7XG4gICAgICAgIG91dGVyTm9kZSA9IGZpbHRlclBvaW50cyhvdXRlck5vZGUsIG91dGVyTm9kZS5uZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0ZXJOb2RlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlWChhLCBiKSB7XG4gICAgcmV0dXJuIGEueCAtIGIueDtcbn1cblxuLy8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGFuZCBsaW5rIGl0XG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIG91dGVyTm9kZSA9IGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSk7XG4gICAgaWYgKG91dGVyTm9kZSkge1xuICAgICAgICB2YXIgYiA9IHNwbGl0UG9seWdvbihvdXRlck5vZGUsIGhvbGUpO1xuXG4gICAgICAgIC8vIGZpbHRlciBjb2xsaW5lYXIgcG9pbnRzIGFyb3VuZCB0aGUgY3V0c1xuICAgICAgICBmaWx0ZXJQb2ludHMob3V0ZXJOb2RlLCBvdXRlck5vZGUubmV4dCk7XG4gICAgICAgIGZpbHRlclBvaW50cyhiLCBiLm5leHQpO1xuICAgIH1cbn1cblxuLy8gRGF2aWQgRWJlcmx5J3MgYWxnb3JpdGhtIGZvciBmaW5kaW5nIGEgYnJpZGdlIGJldHdlZW4gaG9sZSBhbmQgb3V0ZXIgcG9seWdvblxuZnVuY3Rpb24gZmluZEhvbGVCcmlkZ2UoaG9sZSwgb3V0ZXJOb2RlKSB7XG4gICAgdmFyIHAgPSBvdXRlck5vZGUsXG4gICAgICAgIGh4ID0gaG9sZS54LFxuICAgICAgICBoeSA9IGhvbGUueSxcbiAgICAgICAgcXggPSAtSW5maW5pdHksXG4gICAgICAgIG07XG5cbiAgICAvLyBmaW5kIGEgc2VnbWVudCBpbnRlcnNlY3RlZCBieSBhIHJheSBmcm9tIHRoZSBob2xlJ3MgbGVmdG1vc3QgcG9pbnQgdG8gdGhlIGxlZnQ7XG4gICAgLy8gc2VnbWVudCdzIGVuZHBvaW50IHdpdGggbGVzc2VyIHggd2lsbCBiZSBwb3RlbnRpYWwgY29ubmVjdGlvbiBwb2ludFxuICAgIGRvIHtcbiAgICAgICAgaWYgKGh5IDw9IHAueSAmJiBoeSA+PSBwLm5leHQueSAmJiBwLm5leHQueSAhPT0gcC55KSB7XG4gICAgICAgICAgICB2YXIgeCA9IHAueCArIChoeSAtIHAueSkgKiAocC5uZXh0LnggLSBwLngpIC8gKHAubmV4dC55IC0gcC55KTtcbiAgICAgICAgICAgIGlmICh4IDw9IGh4ICYmIHggPiBxeCkge1xuICAgICAgICAgICAgICAgIHF4ID0geDtcbiAgICAgICAgICAgICAgICBpZiAoeCA9PT0gaHgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh5ID09PSBwLnkpIHJldHVybiBwO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaHkgPT09IHAubmV4dC55KSByZXR1cm4gcC5uZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtID0gcC54IDwgcC5uZXh0LnggPyBwIDogcC5uZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gb3V0ZXJOb2RlKTtcblxuICAgIGlmICghbSkgcmV0dXJuIG51bGw7XG5cbiAgICBpZiAoaHggPT09IHF4KSByZXR1cm4gbTsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbGVmdG1vc3QgZW5kcG9pbnRcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcbiAgICAvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG4gICAgdmFyIHN0b3AgPSBtLFxuICAgICAgICBteCA9IG0ueCxcbiAgICAgICAgbXkgPSBtLnksXG4gICAgICAgIHRhbk1pbiA9IEluZmluaXR5LFxuICAgICAgICB0YW47XG5cbiAgICBwID0gbTtcblxuICAgIGRvIHtcbiAgICAgICAgaWYgKGh4ID49IHAueCAmJiBwLnggPj0gbXggJiYgaHggIT09IHAueCAmJlxuICAgICAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSkpIHtcblxuICAgICAgICAgICAgdGFuID0gTWF0aC5hYnMoaHkgLSBwLnkpIC8gKGh4IC0gcC54KTsgLy8gdGFuZ2VudGlhbFxuXG4gICAgICAgICAgICBpZiAobG9jYWxseUluc2lkZShwLCBob2xlKSAmJlxuICAgICAgICAgICAgICAgICh0YW4gPCB0YW5NaW4gfHwgKHRhbiA9PT0gdGFuTWluICYmIChwLnggPiBtLnggfHwgKHAueCA9PT0gbS54ICYmIHNlY3RvckNvbnRhaW5zU2VjdG9yKG0sIHApKSkpKSkge1xuICAgICAgICAgICAgICAgIG0gPSBwO1xuICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RvcCk7XG5cbiAgICByZXR1cm4gbTtcbn1cblxuLy8gd2hldGhlciBzZWN0b3IgaW4gdmVydGV4IG0gY29udGFpbnMgc2VjdG9yIGluIHZlcnRleCBwIGluIHRoZSBzYW1lIGNvb3JkaW5hdGVzXG5mdW5jdGlvbiBzZWN0b3JDb250YWluc1NlY3RvcihtLCBwKSB7XG4gICAgcmV0dXJuIGFyZWEobS5wcmV2LCBtLCBwLnByZXYpIDwgMCAmJiBhcmVhKHAubmV4dCwgbSwgbS5uZXh0KSA8IDA7XG59XG5cbi8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbmZ1bmN0aW9uIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueiA9PT0gbnVsbCkgcC56ID0gek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgcC5wcmV2WiA9IHAucHJldjtcbiAgICAgICAgcC5uZXh0WiA9IHAubmV4dDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICBwLnByZXZaLm5leHRaID0gbnVsbDtcbiAgICBwLnByZXZaID0gbnVsbDtcblxuICAgIHNvcnRMaW5rZWQocCk7XG59XG5cbi8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXG4vLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxuZnVuY3Rpb24gc29ydExpbmtlZChsaXN0KSB7XG4gICAgdmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLFxuICAgICAgICBpblNpemUgPSAxO1xuXG4gICAgZG8ge1xuICAgICAgICBwID0gbGlzdDtcbiAgICAgICAgbGlzdCA9IG51bGw7XG4gICAgICAgIHRhaWwgPSBudWxsO1xuICAgICAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBudW1NZXJnZXMrKztcbiAgICAgICAgICAgIHEgPSBwO1xuICAgICAgICAgICAgcFNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFNpemUrKztcbiAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICBpZiAoIXEpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcVNpemUgPSBpblNpemU7XG5cbiAgICAgICAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgKHFTaXplID4gMCAmJiBxKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBTaXplICE9PSAwICYmIChxU2l6ZSA9PT0gMCB8fCAhcSB8fCBwLnogPD0gcS56KSkge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtcbiAgICAgICAgICAgICAgICBlbHNlIGxpc3QgPSBlO1xuXG4gICAgICAgICAgICAgICAgZS5wcmV2WiA9IHRhaWw7XG4gICAgICAgICAgICAgICAgdGFpbCA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFpbC5uZXh0WiA9IG51bGw7XG4gICAgICAgIGluU2l6ZSAqPSAyO1xuXG4gICAgfSB3aGlsZSAobnVtTWVyZ2VzID4gMSk7XG5cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XG5mdW5jdGlvbiB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcbiAgICB4ID0gMzI3NjcgKiAoeCAtIG1pblgpICogaW52U2l6ZTtcbiAgICB5ID0gMzI3NjcgKiAoeSAtIG1pblkpICogaW52U2l6ZTtcblxuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBsZWZ0bW9zdCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueCA8IGxlZnRtb3N0LnggfHwgKHAueCA9PT0gbGVmdG1vc3QueCAmJiBwLnkgPCBsZWZ0bW9zdC55KSkgbGVmdG1vc3QgPSBwO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBsZWZ0bW9zdDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xuICAgIHJldHVybiAoY3ggLSBweCkgKiAoYXkgLSBweSkgLSAoYXggLSBweCkgKiAoY3kgLSBweSkgPj0gMCAmJlxuICAgICAgICAgICAoYXggLSBweCkgKiAoYnkgLSBweSkgLSAoYnggLSBweCkgKiAoYXkgLSBweSkgPj0gMCAmJlxuICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgLSAoY3ggLSBweCkgKiAoYnkgLSBweSkgPj0gMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXG5mdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikge1xuICAgIHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgIWludGVyc2VjdHNQb2x5Z29uKGEsIGIpICYmIC8vIGRvbmVzJ3QgaW50ZXJzZWN0IG90aGVyIGVkZ2VzXG4gICAgICAgICAgIChsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkgJiYgbWlkZGxlSW5zaWRlKGEsIGIpICYmIC8vIGxvY2FsbHkgdmlzaWJsZVxuICAgICAgICAgICAgKGFyZWEoYS5wcmV2LCBhLCBiLnByZXYpIHx8IGFyZWEoYSwgYi5wcmV2LCBiKSkgfHwgLy8gZG9lcyBub3QgY3JlYXRlIG9wcG9zaXRlLWZhY2luZyBzZWN0b3JzXG4gICAgICAgICAgICBlcXVhbHMoYSwgYikgJiYgYXJlYShhLnByZXYsIGEsIGEubmV4dCkgPiAwICYmIGFyZWEoYi5wcmV2LCBiLCBiLm5leHQpID4gMCk7IC8vIHNwZWNpYWwgemVyby1sZW5ndGggY2FzZVxufVxuXG4vLyBzaWduZWQgYXJlYSBvZiBhIHRyaWFuZ2xlXG5mdW5jdGlvbiBhcmVhKHAsIHEsIHIpIHtcbiAgICByZXR1cm4gKHEueSAtIHAueSkgKiAoci54IC0gcS54KSAtIChxLnggLSBwLngpICogKHIueSAtIHEueSk7XG59XG5cbi8vIGNoZWNrIGlmIHR3byBwb2ludHMgYXJlIGVxdWFsXG5mdW5jdGlvbiBlcXVhbHMocDEsIHAyKSB7XG4gICAgcmV0dXJuIHAxLnggPT09IHAyLnggJiYgcDEueSA9PT0gcDIueTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHNlZ21lbnRzIGludGVyc2VjdFxuZnVuY3Rpb24gaW50ZXJzZWN0cyhwMSwgcTEsIHAyLCBxMikge1xuICAgIHZhciBvMSA9IHNpZ24oYXJlYShwMSwgcTEsIHAyKSk7XG4gICAgdmFyIG8yID0gc2lnbihhcmVhKHAxLCBxMSwgcTIpKTtcbiAgICB2YXIgbzMgPSBzaWduKGFyZWEocDIsIHEyLCBwMSkpO1xuICAgIHZhciBvNCA9IHNpZ24oYXJlYShwMiwgcTIsIHExKSk7XG5cbiAgICBpZiAobzEgIT09IG8yICYmIG8zICE9PSBvNCkgcmV0dXJuIHRydWU7IC8vIGdlbmVyYWwgY2FzZVxuXG4gICAgaWYgKG8xID09PSAwICYmIG9uU2VnbWVudChwMSwgcDIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcDIgYXJlIGNvbGxpbmVhciBhbmQgcDIgbGllcyBvbiBwMXExXG4gICAgaWYgKG8yID09PSAwICYmIG9uU2VnbWVudChwMSwgcTIsIHExKSkgcmV0dXJuIHRydWU7IC8vIHAxLCBxMSBhbmQgcTIgYXJlIGNvbGxpbmVhciBhbmQgcTIgbGllcyBvbiBwMXExXG4gICAgaWYgKG8zID09PSAwICYmIG9uU2VnbWVudChwMiwgcDEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcDEgYXJlIGNvbGxpbmVhciBhbmQgcDEgbGllcyBvbiBwMnEyXG4gICAgaWYgKG80ID09PSAwICYmIG9uU2VnbWVudChwMiwgcTEsIHEyKSkgcmV0dXJuIHRydWU7IC8vIHAyLCBxMiBhbmQgcTEgYXJlIGNvbGxpbmVhciBhbmQgcTEgbGllcyBvbiBwMnEyXG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGZvciBjb2xsaW5lYXIgcG9pbnRzIHAsIHEsIHIsIGNoZWNrIGlmIHBvaW50IHEgbGllcyBvbiBzZWdtZW50IHByXG5mdW5jdGlvbiBvblNlZ21lbnQocCwgcSwgcikge1xuICAgIHJldHVybiBxLnggPD0gTWF0aC5tYXgocC54LCByLngpICYmIHEueCA+PSBNYXRoLm1pbihwLngsIHIueCkgJiYgcS55IDw9IE1hdGgubWF4KHAueSwgci55KSAmJiBxLnkgPj0gTWF0aC5taW4ocC55LCByLnkpO1xufVxuXG5mdW5jdGlvbiBzaWduKG51bSkge1xuICAgIHJldHVybiBudW0gPiAwID8gMSA6IG51bSA8IDAgPyAtMSA6IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XG4gICAgdmFyIHAgPSBhO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMocCwgcC5uZXh0LCBhLCBiKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/XG4gICAgICAgIGFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIGFyZWEoYSwgYS5wcmV2LCBiKSA+PSAwIDpcbiAgICAgICAgYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBhcmVhKGEsIGEubmV4dCwgYikgPCAwO1xufVxuXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIG1pZGRsZUluc2lkZShhLCBiKSB7XG4gICAgdmFyIHAgPSBhLFxuICAgICAgICBpbnNpZGUgPSBmYWxzZSxcbiAgICAgICAgcHggPSAoYS54ICsgYi54KSAvIDIsXG4gICAgICAgIHB5ID0gKGEueSArIGIueSkgLyAyO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCgocC55ID4gcHkpICE9PSAocC5uZXh0LnkgPiBweSkpICYmIHAubmV4dC55ICE9PSBwLnkgJiZcbiAgICAgICAgICAgICAgICAocHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpKVxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBpbnNpZGU7XG59XG5cbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSxcbiAgICAgICAgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSxcbiAgICAgICAgYW4gPSBhLm5leHQsXG4gICAgICAgIGJwID0gYi5wcmV2O1xuXG4gICAgYS5uZXh0ID0gYjtcbiAgICBiLnByZXYgPSBhO1xuXG4gICAgYTIubmV4dCA9IGFuO1xuICAgIGFuLnByZXYgPSBhMjtcblxuICAgIGIyLm5leHQgPSBhMjtcbiAgICBhMi5wcmV2ID0gYjI7XG5cbiAgICBicC5uZXh0ID0gYjI7XG4gICAgYjIucHJldiA9IGJwO1xuXG4gICAgcmV0dXJuIGIyO1xufVxuXG4vLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShpLCB4LCB5LCBsYXN0KSB7XG4gICAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcblxuICAgIGlmICghbGFzdCkge1xuICAgICAgICBwLnByZXYgPSBwO1xuICAgICAgICBwLm5leHQgPSBwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xuICAgICAgICBwLnByZXYgPSBsYXN0O1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IHA7XG4gICAgICAgIGxhc3QubmV4dCA9IHA7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcbiAgICBwLm5leHQucHJldiA9IHAucHJldjtcbiAgICBwLnByZXYubmV4dCA9IHAubmV4dDtcblxuICAgIGlmIChwLnByZXZaKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcbiAgICBpZiAocC5uZXh0WikgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XG59XG5cbmZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xuICAgIC8vIHZlcnRleCBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuICAgIHRoaXMuaSA9IGk7XG5cbiAgICAvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0ZXggbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcbiAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG5cbiAgICAvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXG4gICAgdGhpcy56ID0gbnVsbDtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IG5vZGVzIGluIHotb3JkZXJcbiAgICB0aGlzLnByZXZaID0gbnVsbDtcbiAgICB0aGlzLm5leHRaID0gbnVsbDtcblxuICAgIC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XG4gICAgdGhpcy5zdGVpbmVyID0gZmFsc2U7XG59XG5cbi8vIHJldHVybiBhIHBlcmNlbnRhZ2UgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwb2x5Z29uIGFyZWEgYW5kIGl0cyB0cmlhbmd1bGF0aW9uIGFyZWE7XG4vLyB1c2VkIHRvIHZlcmlmeSBjb3JyZWN0bmVzcyBvZiB0cmlhbmd1bGF0aW9uXG5lYXJjdXQuZGV2aWF0aW9uID0gZnVuY3Rpb24gKGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0sIHRyaWFuZ2xlcykge1xuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcbiAgICB2YXIgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGg7XG5cbiAgICB2YXIgcG9seWdvbkFyZWEgPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIDAsIG91dGVyTGVuLCBkaW0pKTtcbiAgICBpZiAoaGFzSG9sZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgcG9seWdvbkFyZWEgLT0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmlhbmdsZXNBcmVhID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciBhID0gdHJpYW5nbGVzW2ldICogZGltO1xuICAgICAgICB2YXIgYiA9IHRyaWFuZ2xlc1tpICsgMV0gKiBkaW07XG4gICAgICAgIHZhciBjID0gdHJpYW5nbGVzW2kgKyAyXSAqIGRpbTtcbiAgICAgICAgdHJpYW5nbGVzQXJlYSArPSBNYXRoLmFicyhcbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtjXSkgKiAoZGF0YVtiICsgMV0gLSBkYXRhW2EgKyAxXSkgLVxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2JdKSAqIChkYXRhW2MgKyAxXSAtIGRhdGFbYSArIDFdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvbHlnb25BcmVhID09PSAwICYmIHRyaWFuZ2xlc0FyZWEgPT09IDAgPyAwIDpcbiAgICAgICAgTWF0aC5hYnMoKHRyaWFuZ2xlc0FyZWEgLSBwb2x5Z29uQXJlYSkgLyBwb2x5Z29uQXJlYSk7XG59O1xuXG5mdW5jdGlvbiBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0pIHtcbiAgICAgICAgc3VtICs9IChkYXRhW2pdIC0gZGF0YVtpXSkgKiAoZGF0YVtpICsgMV0gKyBkYXRhW2ogKyAxXSk7XG4gICAgICAgIGogPSBpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG4vLyB0dXJuIGEgcG9seWdvbiBpbiBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IGZvcm0gKGUuZy4gYXMgaW4gR2VvSlNPTikgaW50byBhIGZvcm0gRWFyY3V0IGFjY2VwdHNcbmVhcmN1dC5mbGF0dGVuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZGltID0gZGF0YVswXVswXS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IHt2ZXJ0aWNlczogW10sIGhvbGVzOiBbXSwgZGltZW5zaW9uczogZGltfSxcbiAgICAgICAgaG9sZUluZGV4ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGltOyBkKyspIHJlc3VsdC52ZXJ0aWNlcy5wdXNoKGRhdGFbaV1bal1bZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaG9sZUluZGV4ICs9IGRhdGFbaSAtIDFdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdC5ob2xlcy5wdXNoKGhvbGVJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/earcut/src/earcut.js\n");

/***/ })

}]);